{"title":"系统与应用异常定位诊断","slug":"系统运维/Linux/常用命令/诊断异常类命令/系统与应用异常定位诊断","date":"2020-01-27T05:34:30.000Z","updated":"2022-03-29T05:39:06.306Z","url":"2020/1-27-182.html","path":"api/articles/2020/1-27-182.html.json","covers":["https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2020/1/20200726144348.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2020/1/20200726150726.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"前言简述\"><a href=\"#前言简述\" class=\"headerlink\" title=\"前言简述\"></a>前言简述</h4><p>在运维的日常工作中，故障处理和问题诊断是个主要的内容，也是必备的技能</p>\n<h4 id=\"0x00-系统诊断\"><a href=\"#0x00-系统诊断\" class=\"headerlink\" title=\"0x00 系统诊断\"></a>0x00 系统诊断</h4><h5 id=\"strace-命令-可用于诊断、调试和教学的Linux用户空间跟踪器\"><a href=\"#strace-命令-可用于诊断、调试和教学的Linux用户空间跟踪器\" class=\"headerlink\" title=\"strace 命令 - 可用于诊断、调试和教学的Linux用户空间跟踪器\"></a>strace 命令 - 可用于诊断、调试和教学的Linux用户空间跟踪器</h5><p>描述:官方介绍 strace是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来<code>监控用户空间进程和内核的交互</code>，比如系统调用、信号传递、进程状态变更等。其底层的实现方式是<code>基于ptrace特性</code>;</p>\n<p>Q:strace究竟能做什么呢?</p>\n<blockquote>\n<p>它作为一种动态跟踪工具，能够帮助运维高效地定位进程和服务故障。它像是一个侦探，通过系统调用的蛛丝马迹，告诉你异常的真相。<br>它能够打开应用进程的这个黑盒，通过系统调用的线索告诉你进程大概在干嘛。</p>\n</blockquote>\n<p>Q:在进入strace使用的主题之前，我们的先理解什么是系统调用?</p>\n<blockquote>\n<p>按维基百科中的解释，在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。<br>系统调用提供用户程序与操作系统之间的接口,在Linux系统上应用代码<code>通过glibc库封装的函数</code>间接使用系统调用。</p>\n</blockquote>\n<p>操作系统的进程空间分为用户空间和内核空间：</p>\n<ul>\n<li>1.操作系统内核直接运行在硬件上，提供设备管理、内存管理、任务调度等功能。</li>\n<li>2.用户空间通过API请求内核空间的服务来完成其功能——内核提供给用户空间的这些API, 就是系统调用。</li>\n</ul>\n<p>Linux内核目前有300多个系统调用，详细的列表以通过syscalls手册页查看,系统调用主要分为几类：</p>\n<ul>\n<li>文件和设备访问类 比如open/close/read/write/chmod等</li>\n<li>进程管理类 fork/clone/execve/exit/getpid等</li>\n<li>信号类 signal/sigaction/kill 等</li>\n<li>内存管理 brk/mmap/mlock等</li>\n<li>进程间通信IPC shmget/semget * 信号量，共享内存，消息队列等</li>\n<li>网络通信 socket/connect/sendto/sendmsg 等</li>\n</ul>\n<p>Syntax &amp; Parameter:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装</span></span><br><span class=\"line\">yum install -y strace</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数</span></span><br><span class=\"line\">strace [ -dffhiqrtttTvxx ] [ -acolumn ] [ -eexpr ] ... [ -ofile ] [-ppid ] ... [ -sstrsize ] [ -uusername ] [ -Evar=val ] ... [ -Evar ]... [ <span class=\"built_in\">command</span> [ arg ... ] ]</span><br><span class=\"line\">strace -c [ -eexpr ] ... [ -Ooverhead ] [ -Ssortby ] [ <span class=\"built_in\">command</span> [ arg... ] ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数:</span></span><br><span class=\"line\">-c 统计每一系统调用的所执行的时间,次数和出错的次数等. </span><br><span class=\"line\">-d 输出strace关于标准错误的调试信息. </span><br><span class=\"line\">-f 跟踪由fork调用所产生的子进程. </span><br><span class=\"line\">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. </span><br><span class=\"line\">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. </span><br><span class=\"line\">-h 输出简要的帮助信息. </span><br><span class=\"line\">-i 输出系统调用的入口指针. </span><br><span class=\"line\">-q 禁止输出关于脱离的消息. </span><br><span class=\"line\">-r 打印出相对时间关于,,每一个系统调用. </span><br><span class=\"line\">-t 在输出中的每一行前加上时间信息. </span><br><span class=\"line\">-tt 在输出中的每一行前加上时间信息,微秒级. </span><br><span class=\"line\">-ttt 微秒级输出,以秒了表示时间. </span><br><span class=\"line\">-T 显示每一调用所耗的时间. </span><br><span class=\"line\">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. </span><br><span class=\"line\">-V 输出strace的版本信息. </span><br><span class=\"line\">-x 以十六进制形式输出非标准字符串 </span><br><span class=\"line\">-xx 所有字符串以十六进制形式输出. </span><br><span class=\"line\">-a column 设置返回值的输出位置.默认 为40. </span><br><span class=\"line\">-e expr 指定一个表达式,用来控制如何跟踪.格式如下: [qualifier=][!]value1[,value2]... </span><br><span class=\"line\">  <span class=\"comment\">#qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.</span></span><br><span class=\"line\">  <span class=\"comment\">#例如: -eopen等价于-e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. </span></span><br><span class=\"line\">  <span class=\"comment\">#注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\.</span></span><br><span class=\"line\">-e trace=all  <span class=\"comment\">#只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. </span></span><br><span class=\"line\">-e trace=file <span class=\"comment\">#只跟踪有关文件操作的系统调用. </span></span><br><span class=\"line\">-e trace=process  <span class=\"comment\">#只跟踪有关进程控制的系统调用. 比如fork/exec/exit_group</span></span><br><span class=\"line\">-e trace=network  <span class=\"comment\">#跟踪与网络有关的所有系统调用. 比如socket/sendto/connect</span></span><br><span class=\"line\">-e trace=signal <span class=\"comment\">#跟踪所有与系统信号有关的系统调用. 比如kill/sigaction</span></span><br><span class=\"line\">-e trace=desc  <span class=\"comment\">#和文件描述符相关，比如write/read/select/epoll等</span></span><br><span class=\"line\">-e trace=ipc     <span class=\"comment\">#跟踪所有与进程通讯有关的系统调用 ，比如shmget等</span></span><br><span class=\"line\">-e execve   <span class=\"comment\">#跟踪某个脚本里面的执行程序</span></span><br><span class=\"line\">-e abbrev= <span class=\"comment\">#设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. </span></span><br><span class=\"line\">-e raw=   <span class=\"comment\">#将指定的系统调用的参数以十六进制显示. </span></span><br><span class=\"line\">-e signal= <span class=\"comment\">#指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. </span></span><br><span class=\"line\">-e <span class=\"built_in\">read</span>=  <span class=\"comment\">#输出从指定文件中读出 的数据</span></span><br><span class=\"line\">-e write= <span class=\"comment\">#输出写入到指定文件中的数据.</span></span><br><span class=\"line\">-o filename  <span class=\"comment\">#将strace的输出写入文件filename </span></span><br><span class=\"line\">-p pid  <span class=\"comment\">#跟踪指定的进程pid. (可跟踪多个进程PID)</span></span><br><span class=\"line\">-s strsize <span class=\"comment\">#指定输出的字符串的最大长度.默认为32.文件名一直全部输出. </span></span><br><span class=\"line\">-u username <span class=\"comment\">#以username 的UID和GID执行被跟踪的命令</span></span><br><span class=\"line\"></span><br><span class=\"line\">它的两种运行模式:</span><br><span class=\"line\">- 1.通过它启动要跟踪的进程(可以类似理解为沙箱进行程序运行分析) <span class=\"comment\">#strace ls -lh /var/log/messages</span></span><br><span class=\"line\">- 2.跟踪已经在运行的进程(在不中断进程执行的情况下理解它在干嘛) <span class=\"comment\">#strace -p &lt;pid&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>基础实例:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 0.简单的程序来演示strace的基本用法</span></span><br><span class=\"line\"><span class=\"variable\">$nano</span> hello.c</span><br><span class=\"line\"><span class=\"comment\">#include&lt;stdio.h&gt;</span></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int a=0;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"please input:\\n\"</span>);</span><br><span class=\"line\">  scanf(<span class=\"string\">\"%d\"</span>,&amp;a);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%9d\\n\"</span>,a);                                                      </span><br><span class=\"line\">  <span class=\"built_in\">return</span> 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$gcc</span> hello.c &amp;&amp;  ./a.out</span><br><span class=\"line\"><span class=\"comment\"># please input:</span></span><br><span class=\"line\"><span class=\"comment\"># 123</span></span><br><span class=\"line\"><span class=\"comment\">#       123</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$strace</span> -s 2049 ./a.out</span><br><span class=\"line\"><span class=\"comment\"># 从下图输出中可以得出系统首先调用execve开始一个新的进行，接着进行些环境的初始化操作，最后停顿在”read(0,\"上面,此时等待执行到了我们的scanf函数之中并且输入1024数字格式,在调用write函数将格式化后的数值\"1024″输出到屏幕，最后调用exit_group退出进行，完成整个程序的执行过程。</span></span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2020/1/20200726144348.png\" alt=\"WeiyiGeek.实例0\" title=\"\" class=\"\">\n                <p>WeiyiGeek.实例0</p>\n            </figure></p>\n<p><br/></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.跟踪nginx查看其启动时都访问了哪些文件</span></span><br><span class=\"line\">strace -tt -T -f -e trace=file -o /data/<span class=\"built_in\">log</span>/strace.log -s 1024 ./nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.跟踪已启动的nginx(pid=23489)进程</span></span><br><span class=\"line\">strace -tt -T -v -f -e trace=file -o /data/<span class=\"built_in\">log</span>/strace.log -s 1024 -p 23489</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.指定跟踪相关的系统调用这里监控所有的系统调用</span></span><br><span class=\"line\"><span class=\"comment\">#  跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</span></span><br><span class=\"line\">strace -o output.txt -T -tt -e trace=all -p 28979</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.跟踪信号传递（此处还是以上面的hello.c代码与a.out为例）指定进程的pid号</span></span><br><span class=\"line\">[root@terminal-1 ~]$ ./a.out  <span class=\"comment\">#终端1 执行</span></span><br><span class=\"line\"><span class=\"comment\"># please input:</span></span><br><span class=\"line\"><span class=\"comment\"># 已终止</span></span><br><span class=\"line\">[root@terminal-1 ~]$ strace -s 1024 -p 2225 <span class=\"comment\">#终端2 跟踪进程信号</span></span><br><span class=\"line\"><span class=\"comment\"># strace: Process 2225 attached</span></span><br><span class=\"line\"><span class=\"comment\"># read(0, 0x7f9b2ab43000, 1024)           = ? ERESTARTSYS (To be restarted if SA_RESTART is set)</span></span><br><span class=\"line\"><span class=\"comment\"># --- SIGTERM &#123;si_signo=SIGTERM, si_code=SI_USER, si_pid=2277, si_uid=0&#125; ---</span></span><br><span class=\"line\"><span class=\"comment\">#+++ killed by SIGTERM +++             #关键点 捕捉到终端停止信号</span></span><br><span class=\"line\">[root@terminal-1 ~]$ killall ./a.out  <span class=\"comment\">#终端3 kill掉./a.out进程</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.系统调用统计通过使用参数-c能将进程所有的系统调用做一个统计分析;</span></span><br><span class=\"line\">strace -c -o hello.txt ./a.out</span><br><span class=\"line\"><span class=\"comment\"># please input:</span></span><br><span class=\"line\"><span class=\"comment\"># 10247</span></span><br><span class=\"line\"><span class=\"comment\">#     10247</span></span><br><span class=\"line\">cat hello.txt </span><br><span class=\"line\">% time     seconds  usecs/call     calls    errors syscall</span><br><span class=\"line\">------ ----------- ----------- --------- --------- ----------------</span><br><span class=\"line\">  0.00    0.000000           0         2           <span class=\"built_in\">read</span></span><br><span class=\"line\">  0.00    0.000000           0         2           write</span><br><span class=\"line\">  0.00    0.000000           0         2           open</span><br><span class=\"line\">  0.00    0.000000           0         2           close</span><br><span class=\"line\">  0.00    0.000000           0         4           fstat</span><br><span class=\"line\">  0.00    0.000000           0         9           mmap</span><br><span class=\"line\">  0.00    0.000000           0         4           mprotect</span><br><span class=\"line\">  0.00    0.000000           0         1           munmap</span><br><span class=\"line\">  0.00    0.000000           0         1           brk</span><br><span class=\"line\">  0.00    0.000000           0         1         1 access</span><br><span class=\"line\">  0.00    0.000000           0         1           execve</span><br><span class=\"line\">  0.00    0.000000           0         1           arch_prctl</span><br><span class=\"line\">------ ----------- ----------- --------- --------- ----------------</span><br><span class=\"line\">100.00    0.000000                    30         1 total</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6. 截断输出长度设置与限制跟踪特定的系统调用</span></span><br><span class=\"line\">strace -f -s10 -o text.txt -e execve ./a.out &amp;&amp; cat text.txt</span><br><span class=\"line\"><span class=\"comment\"># please input:</span></span><br><span class=\"line\"><span class=\"comment\"># 1024</span></span><br><span class=\"line\"><span class=\"comment\">#      1024</span></span><br><span class=\"line\"><span class=\"comment\"># 2377  execve(\"./a.out\", [\"./a.out\"], 0x7fff80272970 /* 26 vars */) = 0</span></span><br><span class=\"line\"><span class=\"comment\"># 2377  +++ exited with 0 +++</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7. 系统调用计时，参数-T将每个系统所花费的时间打印出来</span></span><br><span class=\"line\">strace -T -tt -o hello1.txt ./a.out &amp;&amp; cat hello1.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 8. 查看进程打开的文件进行过滤</span></span><br><span class=\"line\">strace -e trace=file killall bt_uinfo_memcached 2&gt;&amp;1 | grep open | tail</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2020/1/20200726150726.png\" alt=\"WeiyiGeek.实例7系统调用计时\" title=\"\" class=\"\">\n                <p>WeiyiGeek.实例7系统调用计时</p>\n            </figure>\n<p><br/></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 8.strace实战定位共享内存异常</span></span><br><span class=\"line\"><span class=\"comment\"># 有个服务启动时报错,错误日志大概告诉我们是获取共享内存出错通过strace看下</span></span><br><span class=\"line\"><span class=\"comment\"># shmget 267264 30097568: Invalid argument Can not get shm...exit!</span></span><br><span class=\"line\">strace -tt -f -e trace=ipc ./a_mon_svr ../conf/a_mon_svr.conf <span class=\"comment\"># 只跟踪和进程通信相关的系统调用。</span></span><br><span class=\"line\"><span class=\"comment\"># 输出结果:</span></span><br><span class=\"line\"><span class=\"comment\"># 22:46:36.351798 shmget(0x5feb, 12000, 0666) = 0</span></span><br><span class=\"line\"><span class=\"comment\"># 22:46:36.351939 shmat(0, 0, 0)          = ?</span></span><br><span class=\"line\"><span class=\"comment\"># Process 21406 attached</span></span><br><span class=\"line\"><span class=\"comment\"># 22:46:36.355439 shmget(0x41400, 30097568, 0666) = -1 EINVAL (Invalid argument)</span></span><br><span class=\"line\"><span class=\"comment\"># shmget 267264 30097568: Invalid argument</span></span><br><span class=\"line\"><span class=\"comment\"># Can not get shm...exit!</span></span><br><span class=\"line\"></span><br><span class=\"line\">从strace输出我们知道是shmget系统调用出错了errno是EINVAL。同样查询下shmget手册页搜索EINVAL的错误码的说明:</span><br><span class=\"line\"><span class=\"comment\"># EINVAL A new segment was to be created and size &lt; SHMMIN or size &gt; SHMMAX, or no new segment was to be created, a segment with given key existed, but size is greater than the size of that segment</span></span><br><span class=\"line\">shmget设置EINVAL错误码的原因为下列之一：</span><br><span class=\"line\">* 要创建的共享内存段比 SHMMIN小 (一般是1个字节)</span><br><span class=\"line\">* 要创建的共享内存段比 SHMMAX 大 (内核参数kernel.shmmax配置)</span><br><span class=\"line\">* 指定key的共享内存段已存在，其大小和调用shmget时传递的值不同。</span><br><span class=\"line\"></span><br><span class=\"line\">从strace输出看我们要连的共享内存key 0x41400, 指定的大小是30097568字节，明显与第1、2种情况不匹配。</span><br><span class=\"line\">那只剩下第三种情况使用ipcs看下是否真的是大小不匹配,可以看到已经0x41400这个key已经存在，并且其大小为30095516字节，和我们调用参数中的30097568不匹配于是产生了这个错误。</span><br><span class=\"line\"><span class=\"comment\"># ipcs -m | grep 41400</span></span><br><span class=\"line\"><span class=\"comment\"># key        shmid      owner      perms      bytes      nattch     status    </span></span><br><span class=\"line\"><span class=\"comment\"># 0x00041400 1015822    root       666        30095516   1</span></span><br><span class=\"line\"></span><br><span class=\"line\">在我们这个案例里面导致共享内存大小不一致的原因是一组程序中，`其中一个编译为32位另外一个编译为64位`,代码里面使用了long这个变长int数据类型, 把两个程序都编译为64解决了这个问题。</span><br></pre></td></tr></table></figure>\n<p><strong>补充示例:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.使用 strace 追踪 sysctl 命令的系统调用可发现该命令最终是访问 `/proc/sys/vm/swappiness` 这个文件</span></span><br><span class=\"line\">sudo strace sysctl -w vm.swappiness = 0</span><br><span class=\"line\">cat /proc/sys/vm/swappiness</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure></p>\n<p><strong>总结</strong></p>\n<ul>\n<li>1.当发现进程或服务异常时我们可以通过strace命令进行快速定位异常原因;</li>\n<li>2.其可以让我们熟悉常用系统调用，能够更好地理解和使用strace命令;</li>\n<li>3.当目标进程卡死在用户态时strace没有输出，此时我们需要其他的跟踪手段，比如gdb/perf/SystemTap等。<ul>\n<li>3.1) perf原因kernel支持</li>\n<li>3.2) ftrace kernel支持可编程</li>\n<li>3.3) systemtap 功能强大RedHat系统支持，对用户态，内核态逻辑都能探查，使用范围更广;</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h4 id=\"0x01-应用诊断\"><a href=\"#0x01-应用诊断\" class=\"headerlink\" title=\"0x01 应用诊断\"></a>0x01 应用诊断</h4>","comments":true,"excerpt":"[TOC]","categories":[{"name":"Linux命令","path":"api/categories/Linux命令.json"},{"name":"SystemOperation","path":"api/categories/SystemOperation.json"}],"tags":[{"name":"Linux异常排查命令","path":"api/tags/Linux异常排查命令.json"}]}