{"title":"Linux系统入门学习基础知识","slug":"系统运维/Linux/系统学习/Linux系统入门学习基础知识","date":"2019-05-01T06:34:30.000Z","updated":"2022-12-27T01:22:49.678Z","url":"2019/5-1-214.html","path":"api/articles/2019/5-1-214.html.json","covers":["https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527092707.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527100324.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527104541.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527105833.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527103241.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527115212.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527141648.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0x00-Linux发展史\"><a href=\"#0x00-Linux发展史\" class=\"headerlink\" title=\"0x00 Linux发展史\"></a>0x00 Linux发展史</h4><h5 id=\"1-Linux前身Unix历史\"><a href=\"#1-Linux前身Unix历史\" class=\"headerlink\" title=\"1. Linux前身Unix历史\"></a>1. Linux前身Unix历史</h5><p>从unix中繁衍出了许多,现在大家耳熟能详的Linux发行版本：</p>\n<ul>\n<li>1969年以前，一个伟大的梦想Bell,MIT与GE的“Multics”系统。其目的是为了实现一台大型主机提供给300以上终端同时使用。由于缺乏资金Bell实验室退出了该计划。</li>\n<li>1969年，原“Multics”计划成员Ken Thomspon 根据“Multics”，以汇编语言写出了第一个Unix原型，因为相对”Multics“来说，简化了许多，所以当时朋友称这个系统为”Unics“（当时并不叫Unix）。他的这个系统有一个很重要的概念：所有的程序和系统装置都是文件。这个概念对后来Linux的发展有相当重要的影响！</li>\n<li>1973年，UNIX正式诞生,Richie等人以C语言写出第一个正式的UNIX内核</li>\n<li>1977年，重要的Unix分支-BSD诞生：伯克利大学的Bill Joy在Unix源码的基础上着手开发出来的系统，取名为Berkeley Software Distribution (BSD)。ps：Bill joy便是Sun公司的创办者。Freebsd便是由BSD发展而来。</li>\n<li>由于Unix的高度可移植性，很多商业公司开始了Unix的发展，包括IBM的AIX，惠普等公司。1979年AT&amp;T公司发布System V 第七版由于商业行为，AT&amp;T公司想收回版权，并限制不对学生提供源码</li>\n<li>1984年之一，x86架构的Minix操作系统诞生。谭宁邦教授为了教学需要编写了Minix这个Unix like操作系统。Minix不能从网上下载，只能通过磁碟购买。</li>\n<li>1984年之二，史托曼发起的GNU项目于FSF基金会，1985年发布GNU-GPL（通用公共许可证），这对后来的自由软件有着重大意义。所有的自由软件都需要遵循GPL协议。</li>\n<li>1988年，MIT的Xfree86计划，即：X window System +Free+x86</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527092707.png\" alt=\"WeiyiGeek.Unix家谱图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.Unix家谱图</p>\n            </figure>\n<p><br/></p>\n<h5 id=\"2-Linux介绍\"><a href=\"#2-Linux介绍\" class=\"headerlink\" title=\"2. Linux介绍\"></a>2. Linux介绍</h5><p>Linux操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间，以MINIX为模版）芬兰大学生 auther：Linus Torvalds，在BBS上发布了一则消息，他以bash/GCC等工具写了一个核心程序，这个程序可以在inter的386机器上面运作;</p>\n<ul>\n<li>1994年完成了Linux核心正式版 v1.0 ,并加入了对X Window System的支持。</li>\n<li>1996年发布Linux核心正式版v2.0版本 ,托瓦兹指定企鹅为吉祥物.</li>\n</ul>\n<p>Linux是一个开源的软件,这意味着我们可以可以任意的研究使用、散布、改良的自由;</p>\n<p><strong>主要特性:</strong></p>\n<ul>\n<li>基本思想</li>\n<li>完全免费</li>\n<li>完全兼容POSIX1.0标准</li>\n<li>多用户、多任务</li>\n<li>良好的界面</li>\n<li>支持多种平台</li>\n</ul>\n<p>Linux存在着许多不同的Linux版本，但它们都使用了Linux内核，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统</p>\n<p>The Linux Kernel Archives（官网）:<a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/</a></p>\n<p><em>Linux内核版本：</em> (注意：Linux版本指定的核心版本，而不是Linux distribution版本[他们拥有自己的版本号])</p>\n<ul>\n<li>2.6.18-4.9.24 (主版本.次版本.末版本)</li>\n</ul>\n<ul>\n<li>次版本为奇数：测试版</li>\n<li>次版本为偶数：稳定版</li>\n</ul>\n<p><em>Linux发型版本(Linux distribution)：</em><br>Q:什么是Linux发行版?<br>答:可以完全安装的Linux发布套件，由Kernel + Software + tools组成的这个可以完全安装的东东就叫Linux distribution；</p>\n<p>Linux的发行版本可以大体分为两类</p>\n<ul>\n<li>一类是商业公司维护的发行版本, 前者以著名的Redhat（RHEL）为代表它收购了Centos</li>\n<li>一类是社区组织维护的发行版本, 后者以Debian为代表（Ubuntu就是基于它）</li>\n</ul>\n<p>Linux发行版年表（大图链接：<a href=\"http://huaban.com/pins/363388579/）\" target=\"_blank\" rel=\"noopener\">http://huaban.com/pins/363388579/）</a></p>\n<p>常见Linux发行版：</p>\n<ul>\n<li>Redhat(Centos)、Ubuntu、Debian、Fedora、OpenSUSE、Torbolinux</li>\n</ul>\n<p>黑客或安全人员常使用的Linux系统： </p>\n<ul>\n<li>Kali、 BackBox 、Arch Linux、Parrot Security os、Tails 和 Qubes、网络安全工具包 (NST)</li>\n</ul>\n<p>Linux应用领域：</p>\n<ul>\n<li>基于企业级的服务器、嵌入式的系统开发（智能电视、智能设备、防火墙，路由器等）</li>\n<li>金融数据库、大型企业网管环境</li>\n<li>学术机构的高效能运算任务</li>\n</ul>\n<p>Linux中常常使用的应用软件：<br>由于GNU计划与Linux的GPL授权模式，让很多优秀的软件都在Linux上面发展，且这些在Linux上面的服务器软件几乎都是自由软件，开源软件的比例变化:netcraft.com</p>\n<ul>\n<li>Apache、Nginx（高并发，低运行内存）、Mysql、php、php、samba、MongoDB</li>\n</ul>\n<p><br></p>\n<h5 id=\"3-Linux与Windows的不同\"><a href=\"#3-Linux与Windows的不同\" class=\"headerlink\" title=\"3. Linux与Windows的不同\"></a>3. Linux与Windows的不同</h5><p>Liunx是一个终端（Terminal）也称终端字符设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入以及处理结果的输出等。 </p>\n<ul>\n<li>在早期计算机系统中，由于计算机主机昂贵，因此一个主机（IBM大型计算机）一般会配置多个终端，这些终端本身不具备计算能力，仅仅承担信息输入输出的工作，运算和处理均由主机来完成。 </li>\n<li>在个人计算机时代，个人计算机可以运行称为终端仿真器的程序来模仿一个终端的工作</li>\n</ul>\n<p><em>Linux与Windows比较：</em></p>\n<ul>\n<li>操作系统内核不同：windows 操作系统内核是NT,而linux 是 shell</li>\n<li>硬盘文件格式不同: windows 硬盘文件格式是fat32或NTSF, 而linux 需要的文件格式是xfs/ext4/ext3/ext2或ext</li>\n<li>用户界面不同：Windows是图形化界面为主,而Linux是字符化界面为主</li>\n<li>硬件配置要求不同：你的硬件如果太新或太旧建议你还是装Windows吧，因为Linus的软件/硬件兼容性还有待提高</li>\n</ul>\n<p><em>Linux特性：</em>(重要的核心思想：一切皆文件)<br>1.严格区分大小写<br>2.系统一切内容皆是文件包括硬件设备也是<br>3.不靠扩展名来区分文件类型<br>4.Windows下的程序不能直接在LInux上面运行,需要移植重新编译;<br>5.字符界面的优势：</p>\n<ul>\n<li>优点1：占用系统资源更少</li>\n<li>优点2：减少了出错，被攻击的可能性.</li>\n</ul>\n<hr/>\n\n<h4 id=\"0x01-Linux安装与分区\"><a href=\"#0x01-Linux安装与分区\" class=\"headerlink\" title=\"0x01 Linux安装与分区\"></a>0x01 Linux安装与分区</h4><h5 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h5><p>Linux安装我们常常采用虚拟机进行安装学习,当然您有服务器的搭建学习环境会更好;</p>\n<p><em>两种选择方式：</em><br>VMware官方网站：<a href=\"http://www.vmware.com\" target=\"_blank\" rel=\"noopener\">http://www.vmware.com</a>  #推荐<br>virtualbox官方网站：<a href=\"https://www.virtualbox.org/\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/</a></p>\n<ol>\n<li><p>主要特点：<br>（1）不需要分区或重新开机就能在同一台电脑上使用两种以上的操作系统。<br>（2）本机系统可以与虚拟机系统网络通信<br>（3）随时随地修改硬件环境,内存只能占物理机一半 ，包括硬盘<br>（4）快照：当时状态保持下来。随时随地恢复到快照状态</p>\n</li>\n<li><p>建议的VMware配置<br>（1）cpu : 主频 1GHz以上<br>（2）内存: 1GB以上(按照LInux+一倍)<br>（3）硬盘：建议分区空闲空间8GB以上<br>按照：不推荐安装到C盘，否则系统非常缓慢;虚拟机不需要更新也不用体验计划；按照的速度和电脑有关软件400M,装完后约2-3G</p>\n</li>\n</ol>\n<p><em>软件包选择(一般推荐最小安装)：</em></p>\n<ul>\n<li>Desktop （桌面安装-常用） </li>\n<li>Minimal Desktop ( 小化桌面-常用） </li>\n<li>Minimal (最小化安装-常用） </li>\n<li>Basic Server （基本服务器） </li>\n<li>Database Server （数据库服务器） </li>\n<li>Web Server （网页服务器） </li>\n<li>Virtual Host （虚拟主机） </li>\n<li>software development workstation （软件开发工作站）</li>\n</ul>\n<p><em>系统安完成后过程日志：</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/root/install.log ：存储了安装在系统中的软件包及其版本值息 </span><br><span class=\"line\">/root/install.log.syslog : 存储了安装过程中留下的事件记录</span><br><span class=\"line\">/root/anaconda-ks.cfg : 网络批量安装使用以Kickstart配置文件的格式记录安装过程;</span><br></pre></td></tr></table></figure><br><br></p>\n<h5 id=\"2-磁盘分区\"><a href=\"#2-磁盘分区\" class=\"headerlink\" title=\"2.磁盘分区\"></a>2.磁盘分区</h5><p>概念:硬盘分区是使用分区编辑器（partiton editor）,在磁盘上划几个逻辑分区，碟片一旦划分成数个分区(partition),不同分类的目录和文件可以存储进不同的分区.<br>分区规则,Win与Linux都必须遵循:</p>\n<ol>\n<li>硬盘主分区：最多只能有4个 (后面发展肯定没这个限制)</li>\n<li>扩展分区：最多只能有一个（主扩展分区最多有4个，不能写入数据,只能建立逻辑分区）</li>\n<li>逻辑分区：（按26个字母排列，逻辑分区在扩展分区内，主+扩展&lt;=4），逻辑必须从5开始</li>\n</ol>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527100324.png\" alt=\"WeiyiGeek.分区规则\" title=\"\" class=\"\">\n                <p>WeiyiGeek.分区规则</p>\n            </figure>\n<p>硬盘主分区：</p>\n<ul>\n<li>磁盘上的每个磁道被等分为若干个弧段，弧段便是磁盘的扇区</li>\n<li>每个扇区可以存放512个字节的信息，446记录启动信息，剩下的64个字节记录分区的，每16个字节表示一个分区，所以最多只能有4个分区。</li>\n<li>磁盘驱动器在向磁盘读取和写入数据时,要以扇区为单位且硬盘分成等大小的扇区，每个扇区512字节<br><br/><br>扩展分区：</li>\n<li>最多只能有一个,拿出一个主分区作为扩展分区</li>\n<li>扩展分区本身不能写数据，只能包含逻辑分区,逻辑分区【最多可以再划分23个】</li>\n</ul>\n<p><em>Q：什么是磁盘格式化？</em><br>答：不是为了清空数据的,只是附带清空数据和硬盘打隔断;格式化是为了写入文件系统(FAT16,FAT32、NTFS、EXT2、EXT3、EXT4等)，</p>\n<ul>\n<li>第一步:把分区分成等大小的block，每个数据块大小默认4kB，不一定连续存储；</li>\n<li>第二步:建立分区列表,用于存放文件分区列表、目录表等用于文件管理磁盘空间,记录ID字节号（文件的ID号）、I节点（Node）、修改时间、权限、文件保存地点，后续数据块号等等</li>\n</ul>\n<p>常使用的文件系统：</p>\n<ol>\n<li><p>Windows系统</p>\n<ul>\n<li>FAT16:最大只能支持2GB的分区</li>\n<li>FAT32:最大分区/磁盘容量不能超过2TB,且单个文件大小不超过4GB (有效地节约了硬盘空间)</li>\n<li>NTFS: 引导分区大小限于 7.8 GB，分区表大小限于 2 TB,动态卷最大16TB。</li>\n<li>GPT: 更大的分区和更大的单个文件大小</li>\n</ul>\n</li>\n<li><p>Linux系统</p>\n<ul>\n<li>EXT文件系统：EXT2 / EXT3 / 最新EXT4(提供更佳的性能和可靠性)</li>\n<li>xfs文件系统</li>\n<li>是 GNU/Linux 系统中标准的文件系统，其特点为存取文件的性能极好，对于中小型的文件更显示出优势，这主要得利于其簇快取层的优良设计</li>\n<li>其单一文件大小与文件系统本身的容量上限与文件系统本身的簇大小有关，</li>\n<li>在一般常见的 x86 电脑系统中簇最大为 4KB, 则单一文件大小上限为 2048GB, 而文件系统的容量上限为 16384GB</li>\n</ul>\n</li>\n</ol>\n<p><em>问：为什么CENTOS 7.0开始选择XFS作为默认的文件系统？XFS相比ext有什么优点？</em><br>答：XFS在很多方面确实做的比Ext4好,综下所述XFS 取代Ext4 已经成为必然。</p>\n<ul>\n<li>Ext4(Maintainer Ted受雇于google):受限制于磁盘结构和兼容问题/可扩展性和scalability确实不如XFS，作为传统的文件系统确实非常成熟稳定，但是随着存储需求的越来越大，Ext4 渐渐适应不了了<ul>\n<li>目录索引采用了Hash Index Tree但是依然限制高度为2,实际测试Ext4的单个目录文件超过200W个，性能下降的就比较厉害了。</li>\n<li>由于历史磁盘结构原因 Ext4 的inode 个数限制(32位数)最多只能有大概40多亿文件,而且Ext4的单个文件大小最大只能支持到16T(4K block size) 的话</li>\n</ul>\n</li>\n<li>XFS(Mainainer Dave Chineer受雇于Redhat)：锁的细化做得比较好，XFS使用64位管理空间，文件系统规模可以达到EB级别<ul>\n<li>XFS 是基于B+Ttree 管理元数据，即将支持reflink, dedupe等高级特性(Oracle 开发者已经开发了patch)。</li>\n</ul>\n</li>\n</ul>\n<p><em>分区专业术语：</em></p>\n<ul>\n<li>分区：把大硬盘分为小的逻辑分区</li>\n<li>格式化：确实是清楚了数据，目的是为写入文件系统</li>\n<li>分区设备文件名：给每个分区定义设备文件名（不是Windows的C、D、E）</li>\n<li>挂载：给每个分区分配挂载点</li>\n</ul>\n<p><em>挂载与盘符相似</em>：<br>常见的分区方法：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#必须分区</span></span><br><span class=\"line\">- / 根分区</span><br><span class=\"line\">- /swap swap分区：</span><br><span class=\"line\"><span class=\"comment\">#内存在4个G以内swap分为内存的两倍（建议不超过2G），内存大于4个G，swap分区可以分的和内存一样大</span></span><br><span class=\"line\">- /boot 启动分区：建议500MB~1GB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#建议分区：将home与data单独进行分区,重要业务数据可采用专门硬盘存放;</span></span><br><span class=\"line\">- /home</span><br></pre></td></tr></table></figure></p>\n<p>补充知识: <code>[2020年4月22日 10:47:59]</code><br><em>Q：什么是SWAP分区？它有什么作用?</em><br>答：<code>与Windows系统中的虚拟内存类似，Swap是在磁盘中分配出来的一块空间，物理内存被占满时使用</code>。假如VPS也不会自动创建交换分区，此时我们唯一的选择就是手动创建交换文件。</p>\n<ul>\n<li>当Linux系统中的物理内存耗尽时，不活动的页面会从内存移动到Swap。</li>\n<li>Swap可以采用专用的交换分区或交换文件的形式</li>\n</ul>\n<p>按照以下步骤在Linux系统中添加1GB的Swap空间：</p>\n<p>Linux创建Swap分区操作流程<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.创建一个将用于Swap空间的文件</span></span><br><span class=\"line\">sudo fallocate -l 1G /swapfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.如果你在执行上述命令时遇到了错误fallocate failed: Operation not supported，那么请使用以下命令重新创建Swap文件：</span></span><br><span class=\"line\">sudo dd <span class=\"keyword\">if</span>=/dev/zero of=/swapfile bs=1024 count=1048576  <span class=\"comment\">#注意不同发型版本的Mib / MB 单位 2,097,152 (2G)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.只有root用户才能写入和读取Swap文件，执行以下命令设置正确的权限类型：</span></span><br><span class=\"line\">sudo chmod 600 /swapfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4.使用mkswap命令将文件设置为Linux交换区：</span></span><br><span class=\"line\">sudo mkswap /swapfile</span><br><span class=\"line\">Setting up swapspace version 1, size = 2047996 KiB</span><br><span class=\"line\">no label, UUID=a4eab465-75d1-4830-b870-c222c7e2e87b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5.启用并激活交换文件：</span></span><br><span class=\"line\">sudo swapon /swapfile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#6.要使Swap永久生效，我们需要修改/etc/fstab文件：</span></span><br><span class=\"line\"><span class=\"comment\"># 使用vi打开/etc/fstab</span></span><br><span class=\"line\">vi /etc/fstab</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#7.将输入法切换为英文，按i键进入编辑模式，在文件最后附加以下内容</span></span><br><span class=\"line\">/swapfile swap swap defaults 0 0</span><br><span class=\"line\"><span class=\"comment\"># 按Esc键退出编辑模式，输入以下命令保存并退出</span></span><br><span class=\"line\">:wq</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#8.现在我们的Swap空间已经创建成功。接下来验证是否处于活动状态，可以使用swapon或free命令，如下所示：</span></span><br><span class=\"line\">sudo swapon --show</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">NAME      TYPE  SIZE   USED PRIO</span><br><span class=\"line\">/swapfile file 1024M 507.4M   -1</span><br><span class=\"line\"></span><br><span class=\"line\">sudo free -h</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:           488M        158M         83M        2.3M        246M        217M</span><br><span class=\"line\">Swap:          1.0G        506M        517M</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#9.调整swappiness</span></span><br><span class=\"line\"><span class=\"comment\">#Swappiness是一个Linux内核属性，用于定义Swap空间的使用频率，值在0~100之间。较低的值将使内核尽可能避免交换，较高的值将使内核更积极地使用Swap空间。你可以通过以下命令来查看当前的swappiness值：</span></span><br><span class=\"line\">cat /proc/sys/vm/swappiness</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">60</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#10.如上所述，桌面系统的swappiness值默认为60，但对于生产服务器，较低的值可能更合适。例如，我们将swappiness值设置为10：</span></span><br><span class=\"line\">sudo sysctl vm.swappiness=10</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#11.要使这个参数在系统重启后保持不变，我们需要修改/etc/sysctl.conf文件：</span></span><br><span class=\"line\"><span class=\"comment\"># 使用vi打开/etc/sysctl.conf</span></span><br><span class=\"line\">vi /etc/sysctl.conf</span><br><span class=\"line\"><span class=\"comment\"># 将输入法切换为英文，按i键进入编辑模式，在文件最后附加以下内容</span></span><br><span class=\"line\">vm.swappiness=10</span><br><span class=\"line\"><span class=\"comment\"># 按Esc键退出编辑模式，输入以下命令保存并退出</span></span><br><span class=\"line\">:wq</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#12.删除Swap文件</span></span><br><span class=\"line\"><span class=\"comment\">#如果你需要停用并删除Swap文件，请执行以下命令来停用Swap：</span></span><br><span class=\"line\">sudo swapoff -v /swapfile</span><br><span class=\"line\"><span class=\"comment\">#然后，删除/etc/fstab文件中的/swapfile swap swap defaults 0 0内容：</span></span><br><span class=\"line\"><span class=\"comment\">#最后，删除磁盘上的swapfile文件：</span></span><br><span class=\"line\">sudo rm /swapfile</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h4 id=\"0x02-Linux文件系统\"><a href=\"#0x02-Linux文件系统\" class=\"headerlink\" title=\"0x02 Linux文件系统\"></a>0x02 Linux文件系统</h4><p><em>Q:如何理解“万物皆文件”的说法？</em><br>答：Linux 和其它类 UNIX 系统的一个重要特征就是：万物皆文件（Everything is a file），Linux 的文件系统上有很多非常规的特殊文件（常规文件这里指的是存放在硬盘上的普通文件）,特殊文件可能位于伪文件系统或虚拟文件系统中，而这些特殊文件实际上是代表硬件设备、系统信息和其它乱七八糟的东西, 比如随机数生成器。</p>\n<p>还有尽管这些并不是文件，但它们在文件系统中却是可访问的-文件系统是一个通用的“命名空间”，在里面所有的东西都是可访问的，想要访问一个随机数生成器或者直接从设备上读取数据？<br>你只需要在文件系统中找到它们即可，而不需要其它形式的寻址操作。 </p>\n<p>当然，“万物皆文件”的说法也不是绝对的，比如说系统上正在运行的进程就不是文件系统的一部分；设计了这么一套逻辑，主要还是秉承着 UNIX 哲学一贯主张的 KISS 原则（Keep it simple, stupid），将所有的设备都隐藏起来，给用户统一的外在接口，操作起来简洁方便。</p>\n<p>说明实际上，更准确的说法是“万物皆字节流”（Everything is a stream of bytes），/dev/random 并不是一个文件，但它无疑是字节流。</p>\n<h5 id=\"1-文件系统目录结构\"><a href=\"#1-文件系统目录结构\" class=\"headerlink\" title=\"1. 文件系统目录结构\"></a>1. 文件系统目录结构</h5><p>Linux文件系统目录为“倒”的树形结构，所有的目录都是从”/”衍生而来，也称为Linux目录树</p>\n<p>Linux文件系统目录结构：<br><figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527104541.png\" alt=\"WeiyiGeek.系统目录结构\" title=\"\" class=\"\">\n                <p>WeiyiGeek.系统目录结构</p>\n            </figure></p>\n<p>Linx系统目录名的简要说明：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/root 系统管理员主目录</span><br><span class=\"line\">/home 用户主目录</span><br><span class=\"line\">/bin  二进制可执行命令：存放Linux系统常用命令如cat,chmod(修改权限), chown</span><br><span class=\"line\">/sbin 系统管理命令，存放的是系统管理员使用的命令或程序只有超级用户才能执行如fdisk, fsck, ifconfig, init, mkfs</span><br><span class=\"line\">/boot Linux的内核及引导系统程序所需要的文件目录：系统启动引导加载vmlinuz 、 grub</span><br><span class=\"line\">/etc  系统管理和服务应用配置文件:其中/etc/rc.d为启动配置文件和脚本</span><br><span class=\"line\">/opt  用户安装应用程序：有些软件包也会被安装在这里也就是自定义软件包(以前的系统常安装在/usr/<span class=\"built_in\">local</span>目录)</span><br><span class=\"line\">/usr  可共享的只读数据：系统存放程序的目录Linux的绝大多数服务和文件都存放在这个目录下</span><br><span class=\"line\">/var  应用于服务的数据文件：一般常用来存放各种服务的日志文件</span><br><span class=\"line\">/lib  标准程序设计库,应用程序编译使用的库文件存放目录</span><br><span class=\"line\">/dev  设备文件存储目录：比如声卡、磁盘</span><br><span class=\"line\">/tmp  公用的临时文件存储路径</span><br><span class=\"line\">/mnt  系统提供这个目录让用户挂载其他的文件系统</span><br><span class=\"line\">/lost+found  这个目录默认是空的，在ext2或ext3文件系统中，当系统意外崩溃或机器意外关机，当系统非正常关机的时候这个目录下会保留一些文件（可以并修复已经损坏的文件系统）</span><br><span class=\"line\">/proc 操作系统运行时进程信息及内核信息（比如cpu、硬盘分区、内存信息等）存放在这里。/proc目录伪装的文件系统proc的挂载目录，proc并不是真正的文件系统</span><br><span class=\"line\">/sys 目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯,并且同样不占硬盘容量</span><br><span class=\"line\">/srv  service的缩写是一些网路服务启动之后，这些服务所需要取用的资料目录(分发行版本)</span><br></pre></td></tr></table></figure></p>\n<p>目录缩写解释<br>缩写 | 全称 | 说明<br>— | — | — |<br>/bin | BINaries | 二进制可执行命令<br>/dev | DEVices | 特殊设备文件<br>/etc | ETCetera | 系统管理和配置文件<br>/etc/fstab | FileSystem TABle | 文件/etc/fstab包含了静态文件系统信息，定义了存储设备和分区整合到整个系统的方式。mount 命令会读取这个文件，确定设备和分区的挂载选项。<br>/lib | LIBraries | 库文件<br>/mnt | MouNT | 系统提供这个目录是让用户临时挂载其他的文件系统。<br>/opt | OPTion | 第三方软件放置的目录。如果你想自行安装额外的软件(非原本的 distribution 提供的)，那么也能够将你的软件安装到这里来。<br>/proc | PROCesses | 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/sbin | Super BINaries, Superuser BINaries | 系统管理命令，这里存放的是系统管理员使用的管理程序<br>/srv | SeRVices | 是一些网络服务启动后，这些服务所需要取用的数据目录。常见的服务例如 WWW，FTP 等。<br>/sys | SYStem | 虚拟文件系统，主要记录与内核相关的信息，包括目前已加载的内核模块与内核检测到的硬件设备信息，同样不占硬盘容量。<br>/tmp | TeMPorary | 公用的临时文件存储点<br>tty | teletypewriter | “电传打字机”，在类Unix里，键盘显示器，都是虚拟的teletypewriter<br>/usr | Unix System/Software/Shared Resources | “Unix 操作系统软件资源” 所放置的目录，不是用户数据。 FHS 建议所有的软件开发者应该将他们的数据合理的放置到这个目录下的子目录，而不是自行新建该软件自己独立的目录。<br>/var | VARiable | 某些大文件的溢出区，比方说各种服务的日志文件</p>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527105833.png\" alt=\"WeiyiGeek.系统目录名的简要\" title=\"\" class=\"\">\n                <p>WeiyiGeek.系统目录名的简要</p>\n            </figure>\n<p>FHS（Filesystem Hierarchy Standard ）机构诞生: <a href=\"http://www.pathname.com/fhs/\" target=\"_blank\" rel=\"noopener\">http://www.pathname.com/fhs/</a><br>描述：该机构是linux爱好者自发的组成的一个团体，主要是是对linux做一些基本的要求，不至于是操作者换一台主机就成了linux的‘文盲’。<br>产生原因：由于linux是开放源代码，各大公司和团体根据linux的核心代码做各自的操作、编程，造成在根下的目录的不同，及不能共用配置及文件在哪里，从而导致混乱不方便用户的使用。</p>\n<p>FHS依据文件系统使用的频繁与否与是否允许使用者随意更动而将目录定义<code>成为四种交互作用的形态</code>：</p>\n<table>\n<thead>\n<tr>\n<th>~</th>\n<th>可分享的(shareable)</th>\n<th>不可分享的(unshareable)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>不变的(static)</td>\n<td>/usr (软件放置处)</td>\n<td>/usr (软件放置处)</td>\n</tr>\n<tr>\n<td>不变的(static)</td>\n<td>/opt (第三方协力软件)</td>\n<td>/boot (开机与核心档)</td>\n</tr>\n<tr>\n<td>可变动的(variable)</td>\n<td>/var/mail (使用者邮件信箱)</td>\n<td>/var/mail (使用者邮件信箱)</td>\n</tr>\n<tr>\n<td>可变动的(variable)</td>\n<td>/var/spool/news (新闻组)</td>\n<td>/var/lock (程序相关)</td>\n</tr>\n</tbody>\n</table>\n<p><em>四中类型</em>:</p>\n<ul>\n<li>1.可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；</li>\n<li>2.不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</li>\n<li>3.不变的：有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等；</li>\n<li>4.可变动的：经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</li>\n</ul>\n<p><br/></p>\n<p><strong>1) /usr 的意义与内容</strong></p>\n<p>其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦<br>FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>应放置文件内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/usr/bin/</td>\n<td>绝大部分的用户可使用指令都放在这里，他与/bin的不同之处(是否与开机过程有关)</td>\n</tr>\n<tr>\n<td>/usr/sbin/</td>\n<td>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)</td>\n</tr>\n<tr>\n<td>/usr/src/</td>\n<td>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</td>\n</tr>\n<tr>\n<td>/usr/include/</td>\n<td>c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。</td>\n</tr>\n<tr>\n<td>/usr/lib/</td>\n<td>各应用软件的函式库文件、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。要注意的是，如果你使用的是X86_64的Linux系统,那可能会有/usr/lib64/目录产生</td>\n</tr>\n<tr>\n<td>/usr/local/</td>\n<td>系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录</td>\n</tr>\n<tr>\n<td>/usr/share/</td>\n<td>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件</td>\n</tr>\n<tr>\n<td>/usr/share/doc</td>\n<td>软件杂项的文件说明</td>\n</tr>\n<tr>\n<td>/usr/share/zoneinfo</td>\n<td>与时区有关的时区文件</td>\n</tr>\n<tr>\n<td>/usr/X11R6/</td>\n<td>X版本为第11版，且该版的第6次释出之意，为X Window System重要数据所放置的目录。</td>\n</tr>\n</tbody>\n</table>\n<p>补充：/usr/local 这个目录一般是用来存放用户自编译安装软件的存放目录,一般是通过源码包安装的软件，如果没有特别指定安装目录的话–prefix=，一般是安装在这个目录中。</p>\n<p><br></p>\n<p><strong>2) /var 的意义与内容</strong></p>\n<p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录；<br>主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等;</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>应放置文件内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/var/cache/</td>\n<td>应用程序本身运作过程中会产生的一些暂存档</td>\n</tr>\n<tr>\n<td>/var/lib/</td>\n<td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说MySQL的数据库放置到/var/lib/mysql/,而rpm的数据库则放到/var/lib/rpm去</td>\n</tr>\n<tr>\n<td>/var/lock/</td>\n<td>某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用</td>\n</tr>\n<tr>\n<td>/var/log/</td>\n<td>登录文件放置的目录以及服务日志目录,里面比较重要的文件如/var/log/messages(系统主日志), /var/log/wtmp(记录登入者的信息),/var/log/secure(认证/安全),/var/log/dmesg(系统启动相关)等。</td>\n</tr>\n<tr>\n<td>/var/mail/</td>\n<td>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。</td>\n</tr>\n<tr>\n<td>/var/run/</td>\n<td>某些程序或者是服务启动后，会将他们的PID放置在这个目录下</td>\n</tr>\n<tr>\n<td>/var/spool/</td>\n<td>打印机、邮件、代理服务器等假脱机目录,通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<p><strong>3）/dev  的意义与内容</strong></p>\n<p>/dev 是包含表示设备的特殊文件，硬件设备文件名(一切皆文件),将这些设备作为文件系统的一部分显示有这些好处。文件系统提供了一个一致的“命名空间”，所有应用程序都可以使用它来处理和访问设备。<br>常见的磁盘格式：</p>\n<ul>\n<li>SSD -&gt; 3.2GB/s</li>\n<li>SATA 3代 -&gt;500 MB/S</li>\n<li>IDE -&gt; 113 MB/S</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$lsblk</span>  <span class=\"comment\">#显示系统中磁盘</span></span><br><span class=\"line\">NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT</span><br><span class=\"line\">vda    253:0    0  40G  0 disk</span><br><span class=\"line\">└─vda1 253:1    0  40G  0 part /</span><br><span class=\"line\"></span><br><span class=\"line\">/dev/sda   <span class=\"comment\">#表示你的第一块硬盘；</span></span><br><span class=\"line\">/dev/sda1  <span class=\"comment\">#表示你的第一块硬盘的第一个分区。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#特殊设备</span></span><br><span class=\"line\"><span class=\"comment\">#例如，默认情况下 Linux 命令产生的输出消息（错误消息和其它标准输出）到标准输出设备（默认是终端），如果你想要运行命令但却不关心其输出，你可以将其（输出）重定向到 /dev/null</span></span><br><span class=\"line\">/dev/null   <span class=\"comment\">#丢弃所有写入它的数据库(类似于一个黑洞)</span></span><br><span class=\"line\"><span class=\"variable\">$ifconfig</span> &gt; /dev/null </span><br><span class=\"line\"><span class=\"comment\">#通过填充 0 来擦除硬盘上的内容，你不需要使用特殊的工具，使用 /dev/zero 即可实现</span></span><br><span class=\"line\">/dev/zero    <span class=\"comment\">#产生0,它会提供无限的空字符(NULL,NUL,0X00)</span></span><br><span class=\"line\"><span class=\"variable\">$dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/dev/sda1  <span class=\"comment\">#将擦除你的第一个分区的所有数据，只有当你想销毁数据的时候才运行它</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527103241.png\" alt=\"WeiyiGeek.磁盘硬件设备\" title=\"\" class=\"\">\n                <p>WeiyiGeek.磁盘硬件设备</p>\n            </figure>\n<p><em>/dev/random与/dev/urandom设备的区别：</em></p>\n<ul>\n<li><code>/dev/random</code> : 设备,存储着当前系统运行的环境实时数据，它可以看着系统某个时候的唯一数据可以用作随机元数据，我看可以通过文件读取的方式读得里面的数据`</li>\n<li><code>/dev/urandom</code>: 设备,设备数据与random里面一样,只是他是非阻塞的随机数发生器，读取操作不会产生阻塞的情况;</li>\n</ul>\n<p>补充：上面我们在特殊文件（/dev/zero 和 /dev/sda1）间使用 dd 命令，我们也可以使用 dd 命令来读写普通文件。相同的命令既可以直接操作设备，也可以处理普通文件，这就是“万物皆文件”的好处！</p>\n<p><br></p>\n<p><strong>4) /proc 的意义与内容</strong><br>存放系统运行一些硬件信息以及硬件使用情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/proc/cpuinfo —— 显示 可以在终端上打印你的 CPU 信息。</span><br><span class=\"line\">/proc/uptime —— 显示 Linux 内核的运行时间（即当前系统的运行时间）</span><br><span class=\"line\">/proc/version —— 显示 Linux 内核的版本号</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527115212.png\" alt=\"WeiyiGeek.cpu\" title=\"\" class=\"\">\n                <p>WeiyiGeek.cpu</p>\n            </figure></p>\n<p><br></p>\n<h5 id=\"2-文件类型\"><a href=\"#2-文件类型\" class=\"headerlink\" title=\"2. 文件类型\"></a>2. 文件类型</h5><p>Linux使用标准的目录结构，安装程序的同时已经创建了文件系统和完整的目录组成形式，并指定了每个目录的作用和其中的文件类型。<br>Linux最新的发行版默认都采用ext4格式作为默认文件系统，Linux上面的文件类型主要包含下面几类：</p>\n<ul>\n<li>普通文件：分为纯文本和二进制-rwxrwxrwx (777)</li>\n<li>目录文件：存储文件地方 drw-r–r– (744)</li>\n<li>链接文件：指向同一个文件或目录的文件  lrw-r–r–</li>\n<li>特殊文件：分为块设备和字符设备 /dev/null</li>\n<li>管道文件：提供进程间通信</li>\n<li>套接字文件：与网络通信有关</li>\n</ul>\n<p>LINUX有四种基本文件系统类型，普通文件、目录文件、连接文件和特殊文件，可用file命令来识别;<br>普通文件：如文本文件、C语言元代码、SHELL脚本、二进制的可执行文件等，可用cat、less、more、vi、emacs来察看内容，用mv来改名<br>目录文件：包括文件名、子目录名及其指针。它是LINUX储存文件名的唯一地方，可用ls列出目录文件<br>连接文件：是指向同一索引节点的那些目录条目。用ls来查看是，连接文件的标志用l开头，而文件面后以”-&gt;”指向所连接的文件<br>特殊文件：一些设备如磁盘、终端、打印机等都在文件系统中表示出来，则一类文件就是特殊文件，常放在/dev目录内例如，软驱A称为/dev/fd0,LINUX无C：的概念，而是用/dev/had来自第一硬盘。</p>\n<p>学过Windows运维或者web开发的一定知道路径(path)分,在Linux中访问上面的这些文件可以用绝对路径(absolute)与相对路径(relative)。 </p>\n<ul>\n<li>绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；</li>\n<li>相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 <a href=\"http://www.weiyi.geek/home/dmtsai/\" target=\"_blank\" rel=\"noopener\">http://www.weiyi.geek/home/dmtsai/</a> 等等。反正开头不是 / 就属于相对路径的写法</li>\n</ul>\n<hr/>\n\n<h4 id=\"0x03-Llinux启动流程\"><a href=\"#0x03-Llinux启动流程\" class=\"headerlink\" title=\"0x03 Llinux启动流程\"></a>0x03 Llinux启动流程</h4><p>linux系统的启动过程：</p>\n<ol>\n<li>开机自检（POST），初始化部分硬件</li>\n<li>搜素可用于引导的启动设备（如磁盘的MBR,Boot）</li>\n<li>读取并将控制权交给系统启动加载器（grub2）</li>\n<li>启动加载器加载器配置，显示可用配置菜单</li>\n<li>启动加载器加载内核及initramfs，置入内存</li>\n<li>启动加载器将控制权交给内核kernel</li>\n<li>由内核查找initramfs中的硬件驱动，作为PID=1从initramfs执行/sbin/init（在RHEL7中，为systemd，并包含udev守护进程）</li>\n<li>Systemd执行initrd.target的所有单元（包含将文件系统挂载到/sysroot）</li>\n<li>内核root文件系统从initramfsroot文件系统切换到/sysroot上的系统root文件系统</li>\n<li>Systemd查找默认目标（target），然后启动该target的所有单元</li>\n</ol>\n<p>其中以上第10步的”Systemd查找默认目标（target），然后启动该target的所有单元“中的target指的是如下启动加载单元：<br>INIT 3 启动级别使系统通过命令行登录</p>\n<table>\n<thead>\n<tr>\n<th>目录</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>graphcial.target</td>\n<td>系统支持多用户、图形和基于文件的登陆</td>\n</tr>\n<tr>\n<td>multi-user.target</td>\n<td>系统仅支持多用户、基于文本的登陆</td>\n</tr>\n<tr>\n<td>rescue.tar</td>\n<td>sulogin提示,表示基于功能初始化已完成</td>\n</tr>\n<tr>\n<td>emergency.target</td>\n<td>sulogin提示,表示initramfs回转完成,且系统root以只读形式挂载于 / </td>\n</tr>\n</tbody>\n</table>\n<p><em>Centos 6.0 系统服务启动流程顺序排序：</em></p>\n<ul>\n<li>查看字符界面启动服务的顺序,在<code>ls /etc/rc.d/rc3.d/ | grep ^S</code> ：防火墙在网络服务之前启动；<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527141648.png\" alt=\"WeiyiGeek.防火墙启动顺序\" title=\"\" class=\"\">\n                <p>WeiyiGeek.防火墙启动顺序</p>\n            </figure>\n</li>\n</ul>\n<p><em>补充：</em> 系统内核参数文件 ：/boot /grub/grub.conf</p>\n<p><br></p>\n<h4 id=\"0x04-补充知识\"><a href=\"#0x04-补充知识\" class=\"headerlink\" title=\"0x04 补充知识\"></a>0x04 补充知识</h4><p><strong>Q:什么是TLDP?</strong><br>答：Linux文档项目,即线性文献项目官网：<a href=\"http://www.tldp.org/\" target=\"_blank\" rel=\"noopener\">http://www.tldp.org/</a></p>\n<p><br></p>\n<p><strong>Q：EL6,EL7代表什么？</strong><br>答：EL是Red Hat Enterprise Linux（EL）的缩写。</p>\n<ul>\n<li>EL6是Red Hat 6.x，CentOS 6.x和CloudLinux 6.x的下载。</li>\n<li>EL5是Red Hat 5.x，CentOS 5.x和CloudLinux 5.x的下载。</li>\n<li>EL7是Red Hat 7.x，CentOS 7.x和CloudLinux 7.x的下载。</li>\n</ul>\n<p><strong>Q:通用查看系统发行版的方式</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /etc/issue </span><br><span class=\"line\">Ubuntu 16.04.5 LTS \\n \\l</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>Q:那哪些目录不可与根目录分开呢？</strong><br>答：有底下这些：这五个目录千万不可与根目录分开在不同的分区。请背下来啊。</p>\n<ul>\n<li>/etc：配置文件</li>\n<li>/bin：重要执行档</li>\n<li>/sbin：重要的系统执行文件</li>\n<li>/lib：执行档所需的函式库与核心所需的模块</li>\n<li>/dev：所需要的装置文件</li>\n</ul>\n<p><strong>Q：常常采用什么软件连接到Linux中？</strong><br>答：远程Linux管理常用软件：xSHELL,Putty,secure,Mobaxtem(推荐)</p>\n<p><strong>Q:glibc和libc到底有什么区别关系 ?</strong><br>A:libc的名字来源于历史，指C开发包的函数库，包括头文件和基本C库libc.a，最初的libc由发明C语言，后来随着C移植到不同平台，libc也有了多个版本，可能是为了兼容吧，很多头文件和libc.a的文件名都没有变（很好的传统）。<br>glibc和libc都是Linux下的C函数库，libc是Linux下的ANSI C的函数库；glibc是Linux下的GUN C的函数库；而现在用的最广功能最强的当然是GNU LibC，简称glibc各发行版Linux用的就是glibc。</p>\n<p>Glibc是gnu发布的libc库，也即c运行库；glibc是linux 系统中最底层的api（应用程序开发接口），几乎其它任何的运行库都会倚赖于glibc，glibc除了封装linux操作系统所提供的系统服务外，它本 身也提供了许多其它一些必要功能服务的实现，主要的如下：</p>\n<ul>\n<li>（1）string，字符串处理</li>\n<li>（2）signal，信号处理</li>\n<li>（3）dlfcn，管理共享库的动态加载</li>\n<li>（4）direct，文件目录操作</li>\n<li>（5）elf，共享库的动态加载器，也即interpreter</li>\n<li>（6）iconv，不同字符集的编码转换</li>\n<li>（7）inet，socket接口的实现</li>\n<li>（8）intl，国际化，也即gettext的实现</li>\n<li>（9）io</li>\n<li>（10）linuxthreads</li>\n<li>（11）locale，本地化</li>\n<li>（12）login，虚拟终端设备的管理，及系统的安全访问</li>\n<li>（13）malloc，动态内存的分配与管理</li>\n<li>（14）nis</li>\n<li>（15）stdlib，其它基本功能</li>\n</ul>\n<p>Linux查看glibc安装版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ldd</span> --version</span><br><span class=\"line\">ldd (GNU libc) 2.17</span><br><span class=\"line\">Copyright (C) 2012 Free Software Foundation, Inc.</span><br><span class=\"line\"></span><br><span class=\"line\">64bit：strings /lib64/libc.so.6 |grep GLIBC</span><br><span class=\"line\">32bit：strings /lib/libc.so.6 |grep GLIBC </span><br><span class=\"line\"><span class=\"comment\">#libc的动态库版本叫做是libc.so，通常是/usr/lib/libc.so，glibc的libc.so其实不是.so文件，而是一个ld Script，但gnu ld 会正确处理的。</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h5 id=\"1-Linux配置文件说明\"><a href=\"#1-Linux配置文件说明\" class=\"headerlink\" title=\"1.Linux配置文件说明\"></a>1.Linux配置文件说明</h5><p><strong>(1) /etc/inittab</strong><br>我们通过前面学习的Linux运行等级可以知道默认的6种运行等级，但是在inittab配置文件中可以配置自定义运行等级;针对于CentOS6及以下适用，<code>对于内核版本在使用systemd时配置该文件就没有任何效果</code>。</p>\n<p>复习runlevel定义本行适用的运行等级.一般如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0      |Halt,关闭系统.</span><br><span class=\"line\">1      |单用户,在grub启动时加上为kernel加上参single即可进入此运行等级(安全处理方法后面会讲到)</span><br><span class=\"line\">2      |无网络多用户模式.</span><br><span class=\"line\">3      |有网络多用户模式.</span><br><span class=\"line\">4      |有网络多用户模式.</span><br><span class=\"line\">5      |X模式</span><br><span class=\"line\">6      |reboot重启系统</span><br><span class=\"line\">S/s    |同运行等级1</span><br><span class=\"line\">a,b,c |自定义等级,通常不使用.</span><br></pre></td></tr></table></figure><br><br/></p>\n<p>CentOS 7 : inittab在使用systemd时不再使用。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># multi-user.target: analogous to runlevel 3</span></span><br><span class=\"line\"><span class=\"comment\"># graphical.target: analogous to runlevel 5</span></span><br><span class=\"line\"><span class=\"variable\">$systemctl</span> get-default</span><br><span class=\"line\">multi-user.target</span><br><span class=\"line\"><span class=\"comment\">#设置默认运行等级</span></span><br><span class=\"line\"><span class=\"variable\">$systemctl</span> <span class=\"built_in\">set</span>-default TARGET.target</span><br></pre></td></tr></table></figure></p>\n<p>语法格式解析:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id:runlevels:action:process [argument]</span><br><span class=\"line\"><span class=\"comment\">#id为标志字段，一般为2至4个字符．</span></span><br><span class=\"line\"><span class=\"comment\">#runlevel定义本行适用的运行等级.</span></span><br><span class=\"line\"><span class=\"comment\">#action定义采取的行动.</span></span><br><span class=\"line\"><span class=\"comment\">#   respawn   |只要进程一停止,该进程就重新启动.</span></span><br><span class=\"line\"><span class=\"comment\">#    wait     |进程只运行一次,init将一直等待它结束,再执行其它命令.</span></span><br><span class=\"line\"><span class=\"comment\">#    once     |进程只运行一次.</span></span><br><span class=\"line\"><span class=\"comment\">#    boot     |系统引导进程中,进程运行,init将忽略运行等级这段.</span></span><br><span class=\"line\"><span class=\"comment\">#   bootwait |系统引导过程中,进程运行,init将等待进程结束.</span></span><br><span class=\"line\"><span class=\"comment\">#    off     |不采取任何行动,功能相当于将这行用#注释掉.</span></span><br><span class=\"line\"><span class=\"comment\"># ondemand   |只要init调用a,b,c中的任何一种运行等级时,进程便运行.</span></span><br><span class=\"line\"><span class=\"comment\"># initdefault|系统设置默认运行级别.process字段被忽略.</span></span><br><span class=\"line\"><span class=\"comment\">#   sysinit   |只要系统引导,该进程便运行,优先于boot与bootwait.</span></span><br><span class=\"line\"><span class=\"comment\"># powerwait |当init接收到SIGPWR信号时进程开始运行,一般为电源故障时运行.</span></span><br><span class=\"line\"><span class=\"comment\"># powerfail |与powerwait相同,但init不会等待进程完成.</span></span><br><span class=\"line\"><span class=\"comment\"># powerokwait|当电源故障修复时运行.</span></span><br><span class=\"line\"><span class=\"comment\"># ctrialdel |当init收到SIGNT信号时(按下ctrl+alt+del)时,进程运行.</span></span><br><span class=\"line\"><span class=\"comment\"># kbrequest |当init收到键盘处理KeyboardSignal信号时,进程运行.</span></span><br><span class=\"line\"><span class=\"comment\">#process 定义需要执行的程序以及参数</span></span><br></pre></td></tr></table></figure></p>\n<p>基础示例:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#设置默认运行等级．init 首先读取这一行来确定运行级别．</span></span><br><span class=\"line\">id:3:initdefault:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在1-5运行等级中按下ctrl+alt+del时便重新启动系统.</span></span><br><span class=\"line\">cad:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果在用grub或lilo启动时,如果为kernel加上single参数时,会直接进入单用户模式,而无需密码.造成一定安全隐患.加上这一行即可解决问题.</span></span><br><span class=\"line\">su:S016:once:/sbin/sulogin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#设置tty控制台数量,一般为tty[1-6],X窗口系统一般运行在tty7</span></span><br><span class=\"line\">1:2345:respawn:/sbin/agetty -I <span class=\"string\">'\\033(K'</span> tty1 9600</span><br><span class=\"line\">2:2345:respawn:/sbin/agetty -I <span class=\"string\">'\\033(K'</span> tty2 9600</span><br><span class=\"line\">3:2345:respawn:/sbin/agetty -I <span class=\"string\">'\\033(K'</span> tty3 9600</span><br><span class=\"line\">4:2345:respawn:/sbin/agetty -I <span class=\"string\">'\\033(K'</span> tty4 9600</span><br><span class=\"line\">5:2345:respawn:/sbin/agetty -I <span class=\"string\">'\\033(K'</span> tty5 9600</span><br><span class=\"line\">6:2345:respawn:/sbin/agetty -I <span class=\"string\">'\\033(K'</span> tty6 9600</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h5 id=\"2-命令扩展\"><a href=\"#2-命令扩展\" class=\"headerlink\" title=\"2.命令扩展\"></a>2.命令扩展</h5><ul>\n<li><a href=\"https://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/linux/linux-command-manual.html</a></li>\n</ul>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"SystemOperation","path":"api/categories/SystemOperation.json"}],"tags":[{"name":"Linux","path":"api/tags/Linux.json"}]}