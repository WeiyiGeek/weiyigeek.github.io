{"title":"MySQL数据库编程基础入门4","slug":"数据存储/MySQL/MySQL数据库编程基础入门4","date":"2020-02-10T13:34:33.000Z","updated":"2023-01-31T02:29:07.993Z","url":"2020/2-10-46.html","path":"api/articles/2020/2-10-46.html.json","covers":["https://img.weiyigeek.top/2020/1/20200205200607.png","https://img.weiyigeek.top/2020/1/20200205200718.png","https://img.weiyigeek.top/2020/1/20200205200830.png","https://img.weiyigeek.top/2020/1/20200206130707.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"1-事务处理\"><a href=\"#1-事务处理\" class=\"headerlink\" title=\"1.事务处理\"></a>1.事务处理</h4><h5 id=\"1-并发控制\"><a href=\"#1-并发控制\" class=\"headerlink\" title=\"(1) 并发控制\"></a>(1) 并发控制</h5><p>描述：MySQL并发控制问题需要依赖<code>锁Lock机制</code>进行解决;</p>\n<p>比如:多事务的执行方法,当不止一个请求到来时候,前面都还没执行以及有许多工作需要完成这时候常常是<code>串行执行、交叉并发执行、同时并发执行</code>；</p>\n<ul>\n<li>1.串行执行:同一时间只有一个事务运行,将进程排列成为一个序列一个一个执行;<ul>\n<li>特点:最笨的方法执行效率最低,且无法充分利用资源,类比于银行的一个个服务窗口;</li>\n</ul>\n</li>\n<li>2.交叉并发执行:多事务交叉运行(非占用空闲时间可以处理其他任务),单处理器的并发方式;<ul>\n<li>特点:执行效率高,充分利用资源，类比于银行的一个个服务窗口但是可以在A填表时间可以处理B用户的业务;</li>\n</ul>\n</li>\n<li>3.同时并发执行:每个处理器处理一个事务,常常在多处理系统中使用;<ul>\n<li>特点:当前应用广泛的执行方式,类比于银行的多个服务窗口;</li>\n</ul>\n</li>\n</ul>\n<p>为什么要出现并发控制?<br>答:锁(Lock)保证对并发操作进行正确调度以及保证事务的隔离性和数据的一致性;但是并发执行会导致<code>同读同写</code>的问题,导致破坏事务隔离性和数据不一致;</p>\n<p>什么是数据不一致?</p>\n<ul>\n<li><p>丢失修改(Lost update):指事务1与事务2从数据库中读取同一数据并修改,事务2提交的结果破坏了事务1提交的结果,导致事务1的修改被丢失;</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2020/1/20200205200607.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n<li><p>不可重复读(non-repeatable read):不可重复读是指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果;</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2020/1/20200205200718.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n<li><p>读”脏”数据(Dirty Read):读脏数据是指事务2修改某一数据并写回,然后事1读取该数据。事务2是由于某种原因被撤销，数据恢复原值，导致事务1读取的数据为错误数据也就是脏数据;</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2020/1/20200205200830.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n</ul>\n<p>注意事项：</p>\n<ul>\n<li>多事物并发处理并非一定需要事物性引擎;</li>\n<li>事物性引擎可以先对数据进行修改然后还可以进行回滚撤回比如InnoDB中(Rollback,commit)<br><br></li>\n</ul>\n<h5 id=\"2-锁机制\"><a href=\"#2-锁机制\" class=\"headerlink\" title=\"(2) 锁机制\"></a>(2) 锁机制</h5><p>描述:为什么要有锁Lock?<br>答:因为为了避免多事物并发处理导致数据不一致，所以多事物之间要隔离;加锁后事物则对此数据对象具有一定的控制,在释放锁之前对其他事物不能更新此数据对象;</p>\n<p>操作流程:事物对某个数据对象操作前,先向系统发出请求对其加锁;</p>\n<p>基本锁分为两种类型:</p>\n<ul>\n<li>读锁(Read Lock):别名共享锁,可以多个事物对此数据对象进行加读锁,但是不能加写锁直到所有事物释放锁才行;</li>\n<li>写锁(Write Lock):别名排它锁,当且只能有一个事物对此数据对象进行加写锁,其他事物不能对此数据对象添加任何锁;</li>\n</ul>\n<p>悲观锁与乐观锁,本质上是对于锁机制的一种看待角度:</p>\n<ul>\n<li>悲观锁:对数据被外界(包括本系统当前的其他事务,以及来之外部系统的事务处理)修改保持保守态度,因此在整个数据处理过程中将数据处于锁定状态;</li>\n<li>乐观锁:假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新时候,才会正式对数据的冲突与否进行检测,如果发现冲突了则让返回用户错误的信息让用户决定如何去做;</li>\n</ul>\n<p>MySQL锁的实现是依赖于存储引擎,不同的存储引擎其实现方式是不一致的;</p>\n<hr/>\n\n<h4 id=\"2-存储引擎\"><a href=\"#2-存储引擎\" class=\"headerlink\" title=\"2.存储引擎\"></a>2.存储引擎</h4><h5 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"(1) 简介\"></a>(1) 简介</h5><p>描述:我们列出常用的MySQL数据库存储引擎;</p>\n<ul>\n<li>MYISAM</li>\n<li>InnoDB</li>\n<li>Memory</li>\n</ul>\n<p><br></p>\n<p><strong>1.MYISAM</strong><br>描述:在MySQL5.5版本之前默认的存储引擎;<br>特点:</p>\n<ul>\n<li>支持大文件存储最大256TB空间(受操作系统文件系统类型影响ext2/NTFS),每个MYISAM表最大索引64(可以通过编译修改进行改变);</li>\n<li>支持全文索引,以及BLOB和TEXT类型可以被索引;</li>\n<li>仅仅支持表锁;</li>\n<li>非事物性引擎;</li>\n<li>产生文件格式:FRM文件存储表定义,MYD数据文件,MYI索引文件;</li>\n<li>适合读多写少的应用场景;</li>\n</ul>\n<p><br></p>\n<p><strong>InnoDB</strong><br>描述:在MySQL5.5版本之后的默认存储引擎;<br>特点:</p>\n<ul>\n<li>事物性引擎为巨大数据量的最大性能设计;</li>\n<li>支持事物安全</li>\n<li>支持表、行锁和外键;</li>\n<li>产生文件格式:FRM文件存储表定义,idb数据文件,opt索引文件,(idbata1自动扩展数据文件,ib_logfile 0/1 日志文件);</li>\n<li>适合并发量大的大型网站</li>\n</ul>\n<p><br></p>\n<p><strong>Memory</strong><br>描述:将数据存储到内存中的存储引擎;<br>特点:</p>\n<ul>\n<li>IO效率高读写快,但注意内存是掉电不保存数据的特性;</li>\n<li>非事物性引擎,并且不支持BLOB和TEXT类型;</li>\n<li>适合对数据及时性要求比较强的应用,读写频繁场景比如Session值;</li>\n</ul>\n<p><br></p>\n<p><strong>Cluster</strong><br>描述:用于MySQL Cluster的集群的存储引擎,提供数据层面上的高可用性HA;</p>\n<p>例如:多表查询等复杂性查询性能相对不是优势;</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2020/1/20200206130707.png\" alt=\"WeiyiGeek.引擎对比\" title=\"\" class=\"\">\n                <p>WeiyiGeek.引擎对比</p>\n            </figure>\n<p><br></p>\n<p>基础示例：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建表指定数据存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> demo(</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> PRIMARY <span class=\"keyword\">KEY</span>,</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span> = MYISAM; <span class=\"comment\">-- 关键点:ENGINE 指定数据引擎;</span></span><br></pre></td></tr></table></figure></p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"Database","path":"api/categories/Database.json"}],"tags":[{"name":"MySQL","path":"api/tags/MySQL.json"}]}