{"title":"Git入门学习到进阶2","slug":"编程世界/开发必备/版本控制/GIT/Git入门学习到进阶2","date":"2019-03-08T14:44:26.000Z","updated":"2023-01-31T02:29:10.670Z","url":"2019/3-8-368.html","path":"api/articles/2019/3-8-368.html.json","covers":["https://img.weiyigeek.top/2019/20190717114202.png","https://img.weiyigeek.top/2019/20190716125410.png","https://img.weiyigeek.top/2019/20190716125703.png","https://img.weiyigeek.top/2019/20190716142332.png","https://img.weiyigeek.top/2019/20190716143018.png","https://img.weiyigeek.top/2019/20190716162836.png","https://img.weiyigeek.top/2019/20190716163120.png","https://img.weiyigeek.top/2019/20190716163901.png","https://img.weiyigeek.top/2019/20190716164122.png","https://img.weiyigeek.top/2019/20190716164215.png","https://img.weiyigeek.top/2019/20190716171147.png","https://img.weiyigeek.top/2019/20190716171612.png","https://img.weiyigeek.top/2019/20190716172854.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0x00-三步骤四个区五状态\"><a href=\"#0x00-三步骤四个区五状态\" class=\"headerlink\" title=\"0x00 三步骤四个区五状态\"></a>0x00 三步骤四个区五状态</h4><p>描述：下面所有讨论我们<code>都假设只使用一个分支，也就是主分支master的情况</code>，虽然这种作法并不符合git规范，但是现实情况中绝大部分用户是直接在master分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签tag的操作，只讲在最简单的主分支上如何回退。</p>\n<p>Git 是一个分布式的版本控制工具，因此远程和本地可以视为两个独立的 Git 仓库，下图是一张经典的 Git 中的数据流与存储级别的介绍，其中储存级别主要包含几部分：</p>\n<ul>\n<li>上图是一张经典的 Git 中的数据流与存储级别的介绍，其中储存级别主要包含几部分：<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190717114202.png\" alt=\"WeiyiGeek.工作流程\" title=\"\" class=\"\">\n                <p>WeiyiGeek.工作流程</p>\n            </figure>\n</li>\n</ul>\n<p><em>注意：</em></p>\n<ul>\n<li>工作区有一个隐藏目录.git，这个不算工作区而是Git的版本库（Repository）:。</li>\n</ul>\n<p>正常情况下我们的工作流就是<code>3个步骤</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .  <span class=\"comment\">#把所有文件从工作区放入暂存区</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"comment\"</span> <span class=\"comment\">#把所有文件从暂存区提交进本地仓库;(提交后工作区和暂存区都为空)</span></span><br><span class=\"line\">git push  <span class=\"comment\">#把所有文件从本地仓库推送进远程仓库。</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><code>四个区</code>和其他版本控制管理工具SVN的一个不同之处，多引入了一个暂存区(Stage)的概念</p>\n<ul>\n<li>工作区(Working Area) : <ul>\n<li>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区</li>\n</ul>\n</li>\n<li><p>暂存区(Stage) :</p>\n<ul>\n<li>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li>\n</ul>\n</li>\n<li><p>本地仓库(Local Repository)</p>\n</li>\n<li>远程仓库(Remote Repository)</li>\n</ul>\n<p><br></p>\n<p><code>五种状态</code>,以上4个区进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">未修改(Origin)   <span class=\"comment\">#默认</span></span><br><span class=\"line\">已修改(Modified) <span class=\"comment\">#常见</span></span><br><span class=\"line\">已暂存(Staged)</span><br><span class=\"line\">已提交(Committed)</span><br><span class=\"line\">已推送(Pushed)</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h5 id=\"检查状态与对比\"><a href=\"#检查状态与对比\" class=\"headerlink\" title=\"检查状态与对比\"></a>检查状态与对比</h5><p><em>如何查看我们进行到上面哪一个区，哪一个状态？</em><br>答:git status告诉我们，将要被提交的修改包括readme.txt，下一步就可以放心地提交了;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status <span class=\"comment\">#查看当前状态</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add distributed\"</span></span><br><span class=\"line\"><span class=\"comment\"># [master ea34578] add distributed</span></span><br><span class=\"line\"><span class=\"comment\"># 1 file changed, 1 insertion(+), 1 deletion(-)</span></span><br><span class=\"line\">$ git status  <span class=\"comment\">#提交后，我们再用git status命令看看仓库的当前状态：</span></span><br><span class=\"line\"><span class=\"comment\"># On branch master</span></span><br><span class=\"line\"><span class=\"comment\"># nothing to commit (working directory clean)</span></span><br><span class=\"line\"><span class=\"comment\">#Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。</span></span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716125410.png\" alt=\"WeiyiGeek.git status\" title=\"\" class=\"\">\n                <p>WeiyiGeek.git status</p>\n            </figure></p>\n<p><br/></p>\n<p>采用git diff可以查看不同区里面的提交的数据,告诉我们更改了什么内容，检查修改的二级命令都相同<code>都是diff，只是参数有所不同</code>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#已修改，未暂存 (ctrl+s保存 并未 git add .)</span></span><br><span class=\"line\">git diff           <span class=\"comment\">#看到本地目录文件和暂存区间的差异</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#已暂存，未提交 (git add .)</span></span><br><span class=\"line\">git diff --cached  <span class=\"comment\">#看到暂存区和本地仓库之间的差异</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#已提交，未推送 (git commit)</span></span><br><span class=\"line\">git diff master origin/master <span class=\"comment\">#master就是你的本地仓库，而origin/master就是你的远程仓库，master是主分支的意思，而后者代表了远程仓库主分支</span></span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716125703.png\" alt=\"WeiyiGeek.git diff\" title=\"\" class=\"\">\n                <p>WeiyiGeek.git diff</p>\n            </figure></p>\n<p><em>总结：</em></p>\n<ul>\n<li>要随时掌握工作区的状态，使用git status命令。git status告诉你有文件被修改过，用git diff可以查看修改内容。</li>\n</ul>\n<p><br></p>\n<h4 id=\"0x01-撤销与丢弃\"><a href=\"#0x01-撤销与丢弃\" class=\"headerlink\" title=\"0x01 撤销与丢弃\"></a>0x01 撤销与丢弃</h4><h5 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h5><p>了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(1)已修改，未暂存:只是在编辑器里修改了文件，但还没有执行git add .</span></span><br><span class=\"line\"><span class=\"comment\">#一对反义词 git add .的反义词是git checkout .。做完修改之后，</span></span><br><span class=\"line\">git checkout .  <span class=\"comment\">#在执行完git checkout .之后，修改已被撤销，git diff没有任何内容了。</span></span><br><span class=\"line\"><span class=\"comment\">#或者</span></span><br><span class=\"line\">git reset --hard </span><br><span class=\"line\"><span class=\"comment\"># 如果你想向前走一步，让修改进入暂存区，就执行git add .</span></span><br><span class=\"line\"><span class=\"comment\"># 如果你想向后退一步，撤销刚才的修改，就执行git checkout .</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(2)已暂存，未提交:已经执行了git add .，但还没有执行git commit -m \"comment\"</span></span><br><span class=\"line\">git reset <span class=\"comment\">#只是把修改退回到了git add .之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .</span></span><br><span class=\"line\">git checkout .</span><br><span class=\"line\"><span class=\"comment\">#或者 </span></span><br><span class=\"line\">git reset --hard</span><br><span class=\"line\"><span class=\"comment\">#以上两个步骤都可以用同一个命令git reset --hard来完成</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(3)已提交，未推送 : 执行了git add .，又执行了git commit</span></span><br><span class=\"line\">git reset --hard origin/master  <span class=\"comment\">#origin/master代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(4)已推送: 你既git add了又git commit了，并且还git push了这时你的代码已经进入远程仓库</span></span><br><span class=\"line\">git reset --hard HEAD^  <span class=\"comment\">#由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了：</span></span><br><span class=\"line\">git push -f</span><br></pre></td></tr></table></figure>\n<p>_总结_:</p>\n<ul>\n<li>以上4种状态的撤销我们都用到了同一个命令git reset –hard,前2种状态的用法甚至完全一样，所以只要掌握了git reset –hard这个命令的用法,从此你再也不用担心提交错误了。</li>\n</ul>\n<p><br></p>\n<h5 id=\"管理修改\"><a href=\"#管理修改\" class=\"headerlink\" title=\"管理修改\"></a>管理修改</h5><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。<br><em>你会问，什么是修改？</em><br>答：比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>\n<p>示例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"change 1 id\"</span> &gt; readme.txt <span class=\"comment\">#第一次修改</span></span><br><span class=\"line\">$ git add readme.txt  <span class=\"comment\">#然后添加到暂存区</span></span><br><span class=\"line\">$ git status  <span class=\"comment\">#查看工作区状态</span></span><br><span class=\"line\"><span class=\"comment\">#  modified:   readme.txt</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"change 2 id\"</span> &gt;&gt; readme.txt <span class=\"comment\">#第2次修改</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"git tracks changes\"</span> <span class=\"comment\">#提交后，再看看状态</span></span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># modified:   readme.txt</span></span><br></pre></td></tr></table></figure></p>\n<p>咦，怎么第二次的修改没有被提交？<br>答:我们回顾一下操作过程：<code>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</code>,Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是在工作区的第二次修改并没有放入暂存区，所以git commit只负责把暂存区的修改提交了，<code>也就是第一次的修改被提交了，第二次的修改不会被提交</code>。</p>\n<p><em>那怎么提交第二次修改呢？</em><br>你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#每次修改，如果不add到暂存区，那就不会加入到commit中提交到本地仓库</span></span><br><span class=\"line\">第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit -&gt; git status <span class=\"comment\">#这时候工作区便为空了</span></span><br></pre></td></tr></table></figure><br><br></p>\n<h5 id=\"丢弃修改\"><a href=\"#丢弃修改\" class=\"headerlink\" title=\"丢弃修改\"></a>丢弃修改</h5><p>比如：您在您的项目中修改了文件并添加文件到了暂存区，却发现错误需要进行更正;<br>既然错误发现得很及时，就可以很容易地纠正它,你可以删掉最后一行手动把文件恢复到上一个版本的状态。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#你也可以丢弃工作区的修改</span></span><br><span class=\"line\">git checkout -- file</span><br><span class=\"line\"></span><br><span class=\"line\">$ git checkout -- readme.txt   <span class=\"comment\">#把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</span></span><br><span class=\"line\">* 一种是readme.txt自修改后还没有被放到暂存区，现在撤销修改就回到和版本库一模一样的状态；</span><br><span class=\"line\">* 一种是readme.txt已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态（即没有更改）。</span><br></pre></td></tr></table></figure></p>\n<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br><code>git checkout -- file命令中的--很重要</code>，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#用命令git reset HEAD file也可以把暂存区的修改撤销掉（unstage），重新放回工作区</span></span><br><span class=\"line\">$ git reset HEAD readme.txt</span><br><span class=\"line\">Unstaged changes after reset:</span><br><span class=\"line\">M       readme.txt</span><br></pre></td></tr></table></figure>\n<p>_总结_：</p>\n<ul>\n<li>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</li>\n<li>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</li>\n<li>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>\n</ul>\n<p><br></p>\n<h5 id=\"时光机穿梭\"><a href=\"#时光机穿梭\" class=\"headerlink\" title=\"时光机穿梭\"></a>时光机穿梭</h5><p>描述：当然了在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。<br>版本控制系统肯定有某个命令可以告诉我们历史记录即提交说明执行<code>git log</code>，<code>你看到的一大串类似3628164...882e1e0的是commit id（版本号）</code>，和SVN不一样Git的commit id不是1，2，3……递增的数字，<code>而是一个SHA1计算出来的一个非常大的数字用十六进制表示</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git log --pretty&#x3D;oneline</span><br><span class=\"line\">c75b5b8afcff97b3c37c4d57d574b0bc868f6f2f (HEAD -&gt; master, origin&#x2F;master, origin&#x2F;HEAD) git study</span><br><span class=\"line\">c1ee2c4ec8f7d6a8e9b44f91b5fa59ea3aec13d8 all</span><br></pre></td></tr></table></figure></p>\n<p><em>为什么commit id需要用这么一大串数字表示呢？</em><br>答：因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>\n<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线;</p>\n<p><em>如果准备把readme.txt回退到上一个版本，也就是“distributed”的那个版本，怎么做呢？</em><br>首先，Git必须知道当前版本是哪个版本，在Git中用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），<code>上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来所以写成HEAD~100。</code><br>现在，我们要把当前版本“append GPL”回退到上一个版本“distributed”，就可以使用git reset命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(1)查看需要回退的版本 </span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> HEAD^  <span class=\"comment\">#上一个</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> HEAD^^ <span class=\"comment\">#上上个</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> HEAD^^^  <span class=\"comment\">#上三个版本等同于 </span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> HEAD~3</span><br><span class=\"line\"><span class=\"comment\"># commit ddbfbfbf4951747c80e87d980e439ccbd73ab245</span></span><br><span class=\"line\"><span class=\"comment\"># Author: WeiyiGeek  </span></span><br><span class=\"line\"><span class=\"comment\"># Date:   Mon Jul 15 21:23:05 2019 +0800</span></span><br><span class=\"line\"><span class=\"comment\">#     Initial commit</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(2)回退到上一个版本或者回退到指定版本</span></span><br><span class=\"line\">git reset --hard HEAD^    <span class=\"comment\">#同一提交的所有内容都会变回上一个Commit时的状态，这时候回到了以前 (可使用 HEAD~9)</span></span><br><span class=\"line\">HEAD is now at ea34578 add distributed  <span class=\"comment\"># distributed 英 [dɪˈstrɪbjuːtɪd] 分布式</span></span><br></pre></td></tr></table></figure><br>还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716142332.png\" alt=\"WeiyiGeek.gitlog回退版本查看\" title=\"\" class=\"\">\n                <p>WeiyiGeek.gitlog回退版本查看</p>\n            </figure></p>\n<p><br></p>\n<p><em>最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</em><br>答：在命令窗口没有关闭的情况下，往上查找 append GPL的commit id是3628164，于是就可以指定回到未来的某个版本<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(3)又回到了未来版本上</span></span><br><span class=\"line\">$ git reset --hard 3628164   <span class=\"comment\">#版本号没必要写全，前7位就可以了，Git会自动去找</span></span><br><span class=\"line\"><span class=\"comment\"># HEAD is now at 3628164 append GPL</span></span><br></pre></td></tr></table></figure></p>\n<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL，改为指向add distributed，然后顺便把工作区的文件更新了；<code>所以你让HEAD指向哪个版本号，你就把当前版本定位在哪</code>。<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716143018.png\" alt=\"WeiyiGeek.HEAD版本回退\" title=\"\" class=\"\">\n                <p>WeiyiGeek.HEAD版本回退</p>\n            </figure></p>\n<p><br></p>\n<p><em>现在你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</em></p>\n<p>答：当你用<code>$git reset --hard HEAD^</code>回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reflog</span><br><span class=\"line\">ea34578 HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class=\"line\">3628164 HEAD@&#123;1&#125;: commit: append GPL <span class=\"comment\">#第二行显示append GPL的commit id是3628164，现在你又可以乘坐时光机回到未来了。</span></span><br><span class=\"line\">ea34578 HEAD@&#123;2&#125;: commit: add distributed</span><br><span class=\"line\">cb926e7 HEAD@&#123;3&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure></p>\n<p>_总结_：</p>\n<ul>\n<li>HEAD指向的版本就是当前版本，因此Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li>\n<li><code>穿梭前用git log可以查看提交历史</code>，以便确定要回退到哪个版本，要重返未来用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li>\n</ul>\n<p><br></p>\n<h5 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h5><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add test.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add test.txt\"</span></span><br><span class=\"line\">[master 94cdc44] add test.txt</span><br><span class=\"line\"><span class=\"comment\">#一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了</span></span><br><span class=\"line\">$ rm test.txt</span><br><span class=\"line\"><span class=\"comment\">#Git知道你删除了文件，因此工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</span></span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\">#       deleted:    test.txt</span></span><br></pre></td></tr></table></figure></p>\n<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit，现在文件就从版本库中被删除了。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm test.txt  </span><br><span class=\"line\">rm <span class=\"string\">'test.txt'</span></span><br><span class=\"line\">$ git rm --cached test.txt  <span class=\"comment\">#只删除暂存区里的文件</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"remove test.txt\"</span></span><br></pre></td></tr></table></figure></p>\n<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”</span></span><br><span class=\"line\">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure></p>\n<p>利用文本过滤方式，这些脚本会在文件签出前（”smudge”）和提交到暂存区前（”clean”）被调用。这些过滤器能够做各种有趣的事。<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716162836.png\" alt=\"WeiyiGeek.checkout与add\" title=\"\" class=\"\">\n                <p>WeiyiGeek.checkout与add</p>\n            </figure></p>\n<hr>\n\n<h4 id=\"0x02-分支管理\"><a href=\"#0x02-分支管理\" class=\"headerlink\" title=\"0x02 分支管理\"></a>0x02 分支管理</h4><p>描述：分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>\n<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过在某个时间点，两个平行宇宙合并了，结果你既学会了Git又学会了SVN！<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716163120.png\" alt=\"WeiyiGeek.漫画图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.漫画图</p>\n            </figure></p>\n<p><em>分支在实际中有什么用呢？</em><br>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>\n<p>现在有了分支你就创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样既安全，又不影响别人工作。</p>\n<p>Git的分支是<code>与众不同的，无论创建、切换和删除分支</code>，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>\n<p><em>专有名词:</em></p>\n<ul>\n<li>跟踪分支：tracking branch</li>\n<li>远程跟踪分支： remote tracking branch</li>\n</ul>\n<p><br></p>\n<h5 id=\"创建与合并分支\"><a href=\"#创建与合并分支\" class=\"headerlink\" title=\"创建与合并分支\"></a>创建与合并分支</h5><p>在版本回退里，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。只有一条时间线，在Git里，这个分支叫<code>主分支即master分支</code>。</p>\n<p>HEAD严格来说不是指向提交，而是指向master才是指向提交的，所以HEAD指向的地址就是当前分支。</p>\n<ul>\n<li><p>(1) 一开始的时候 master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支以及当前分支的提交点，每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长</p>\n</li>\n<li><p>(2) 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上</p>\n<ul>\n<li>Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</li>\n</ul>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716163901.png\" alt=\"WeiyiGeek.创建分支\" title=\"\" class=\"\">\n                <p>WeiyiGeek.创建分支</p>\n            </figure>\n<ul>\n<li>(3) 不过从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</li>\n<li>(4) 假如我们在dev上的工作完成了，就可以把dev合并到master上。<ul>\n<li>Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并</li>\n</ul>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716164122.png\" alt=\"WeiyiGeek.分支合并\" title=\"\" class=\"\">\n                <p>WeiyiGeek.分支合并</p>\n            </figure>\n<ul>\n<li>(5) 所以Git合并分支也很快！就改改指针，工作区内容也不变！<ul>\n<li>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支</li>\n</ul>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716164215.png\" alt=\"WeiyiGeek.主分支\" title=\"\" class=\"\">\n                <p>WeiyiGeek.主分支</p>\n            </figure>\n<p><strong>开始实战演示</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1.首先，我们创建dev分支，然后切换到dev分支（Branch）</span></span><br><span class=\"line\">git checkout -b dev <span class=\"comment\">#相当于以下两条命令：</span></span><br><span class=\"line\">$ git branch dev   <span class=\"comment\">#创建分支</span></span><br><span class=\"line\">$ git checkout dev <span class=\"comment\">#切换分支</span></span><br><span class=\"line\"><span class=\"comment\">#Switched to a new branch 'dev'</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.查看当前分支指向情况</span></span><br><span class=\"line\">git branch </span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.然后我们就可以在dev分支上正常提交，比如对readme.txt做个修改然后提交</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"qweqwe\"</span> &gt; readme.txt</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"branch test\"</span></span><br><span class=\"line\"><span class=\"comment\"># [dev 50aad8f] branch test</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4.现在dev分支的工作完成，我们就可以切换回master分支，查看一个readme.txt文件，刚才添加的内容不见了！</span></span><br><span class=\"line\"><span class=\"comment\">#因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</span></span><br><span class=\"line\">$ git checkout master <span class=\"comment\">#或者将master换成 - </span></span><br><span class=\"line\"><span class=\"comment\">#Switched to branch 'master'</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5.现在我们把dev分支的工作成果合并到master分支上，合并后再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</span></span><br><span class=\"line\">git merge dev</span><br><span class=\"line\"><span class=\"comment\"># Updating 890adee..50aad8f</span></span><br><span class=\"line\"><span class=\"comment\"># Fast-forward   #Git告诉我们这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快</span></span><br><span class=\"line\"><span class=\"comment\">#  readme.txt | 1 +  #Non-fast-forword merge,三方合并把master和分支合并到第三方</span></span><br><span class=\"line\"><span class=\"comment\">#  1 file changed, 1 insertion(+)</span></span><br><span class=\"line\"><span class=\"comment\">#  create mode 100644 readme.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#6.合并完成后，就可以放心地删除dev分支了，删除后查看branch，就只剩下master分支了：</span></span><br><span class=\"line\">ubuntu@WeiyiGeek:/mnt/e/githubProject/<span class=\"built_in\">test</span>$ git branch -D dev</span><br><span class=\"line\">Deleted branch dev (was 50aad8f).</span><br><span class=\"line\">ubuntu@WeiyiGeek:/mnt/e/githubProject/<span class=\"built_in\">test</span>$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure><br>当然也不是<code>每次合并都能Fast-forward，</code>我们后面会讲其他方式的合并。</p>\n<p>因为创建、合并和删除分支非常快，所以Git鼓励你 <code>使用分支完成某个任务，合并后再删掉分支</code>，这和直接在master分支上工作效果是一样的，但过程更安全。</p>\n<hr>\n\n<h5 id=\"冲突解决\"><a href=\"#冲突解决\" class=\"headerlink\" title=\"冲突解决\"></a>冲突解决</h5><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>\n<p>实际案例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1.准备新的feature1分支，继续我们的新分支开发，修改readme.txt最后一行</span></span><br><span class=\"line\">$ git checkout -b feature1</span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"Creating a new branch is quick AND simple.\"</span> &gt;&gt; readme.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.在feature1分支上提交并且切换到master分支</span></span><br><span class=\"line\">$ git add readme.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"feature1 AND simple\"</span></span><br><span class=\"line\">$ git checkout master  <span class=\"comment\">#Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.这时在master分支上把readme.txt文件的最后一行改为下面，即master与feature1分支都更改readme.txt文件</span></span><br><span class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">\"Creating a new branch is quick &amp; simple.\"</span> &gt;&gt; readme.txt</span><br><span class=\"line\">$ git add readme.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"Master &amp; simple\"</span></span><br></pre></td></tr></table></figure><br>现在，master分支和feature1分支各自都分别有新的提交，变成了这样：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716171147.png\" alt=\"WeiyiGeek.无法快速合并\" title=\"\" class=\"\">\n                <p>WeiyiGeek.无法快速合并</p>\n            </figure></p>\n<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#4.尝试合并feature1</span></span><br><span class=\"line\">$ git merge feature1</span><br><span class=\"line\">Auto-merging readme.txt <span class=\"comment\">#Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。</span></span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> readme.txt </span><br><span class=\"line\">Automatic merge failed; fix conflicts and <span class=\"keyword\">then</span> commit the result. </span><br><span class=\"line\">$ git status <span class=\"comment\">#可以告诉我们冲突的文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5.可以直接查看readme.txt的内容修改后进行提交</span></span><br><span class=\"line\">Git tracks changes of files.</span><br><span class=\"line\">\\&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  <span class=\"comment\">#Master分支</span></span><br><span class=\"line\">Creating a new branch is quick &amp; simple.</span><br><span class=\"line\">=======</span><br><span class=\"line\">Creating a new branch is quick AND simple.</span><br><span class=\"line\">\\&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1  <span class=\"comment\">#建立的分支</span></span><br><span class=\"line\"><span class=\"comment\">#Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：</span></span><br><span class=\"line\"><span class=\"comment\"># Creating a new branch is quick AND simple.</span></span><br><span class=\"line\">$ git add readme.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"conflict fixed\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#6.最后，删除feature1分支工作完成。</span></span><br><span class=\"line\">$ git branch -d feature1</span><br><span class=\"line\">Deleted branch feature1 (was 75a857c).</span><br></pre></td></tr></table></figure><br>现在，master分支和feature1分支变成了下图所示：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190716171612.png\" alt=\"WeiyiGeek.主从分支更改同一文件合并冲突解决\" title=\"\" class=\"\">\n                <p>WeiyiGeek.主从分支更改同一文件合并冲突解决</p>\n            </figure></p>\n<p>用带参数的git log也可以看到分支的合并情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class=\"line\">*   59bc1cb conflict fixed   //冲突解决</span><br><span class=\"line\">|\\</span><br><span class=\"line\">| * 75a857c AND simple</span><br><span class=\"line\">* | 400b400 &amp; simple</span><br><span class=\"line\">|/</span><br><span class=\"line\">* fec145a branch <span class=\"built_in\">test</span></span><br><span class=\"line\">...</span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --oneline --decorate --graph</span><br></pre></td></tr></table></figure></p>\n<p><em>总结：</em></p>\n<ul>\n<li>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</li>\n</ul>\n<p><br></p>\n<h5 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h5><p>描述：通常合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果<code>要强制禁用Fast forward模式</code>，Git就会在merge时生成一个新的commit，这样从分支历史上就可以看出分支信息。</p>\n<p>实际案例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b dev</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#修改readme.txt文件，并提交一个新的commit</span></span><br><span class=\"line\">$ git add readme.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add merge\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#现在我们切换回master</span></span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward（快进）</span></span><br><span class=\"line\"><span class=\"comment\">#因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</span></span><br><span class=\"line\">$ git merge --no-ff -m <span class=\"string\">\"merge with no-ff\"</span> dev</span><br><span class=\"line\">Merge made by the <span class=\"string\">'recursive'</span> strategy.</span><br><span class=\"line\"> readme.txt |    1 +</span><br><span class=\"line\">1 file changed, 1 insertion(+)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#合并后，我们用git log看看分支历史：</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --graph --pretty=oneline --abbrev-commit <span class=\"comment\"># (abbr. 缩写 abbreviation )</span></span><br><span class=\"line\">*   7825a50 merge with no-ff</span><br><span class=\"line\">|\\</span><br><span class=\"line\">| * 6224937 add merge</span><br><span class=\"line\">|/</span><br><span class=\"line\">*   59bc1cb conflict fixed</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>分支策略在实际开发中，我们应该按照几个基本原则进行分支管理：</p>\n<ul>\n<li>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li>\n<li>那在哪干活呢？干活都在dev分支上，也就是说dev分支是不稳定的，到某个时候，比如1.0版本发布时再把dev分支合并到master上，再到master分支发布1.0版本；每个人都有自己的分支，时不时地往dev分支上合并就可以了。</li>\n</ul>\n<p><img src=\"https://img.weiyigeek.top/2019/20190716172854.png\" alt=\"WeiyiGeek.git团队合作\"></p>\n<p>_总结_：</p>\n<ul>\n<li>Git分支十分强大，在团队开发中应该充分应用。</li>\n<li>合并分支时<code>加上--no-ff参数就可以用普通模式合并</code>，<code>合并后的历史有分支能看出来曾经做过合并</code>，而fast forward合并就看不出来曾经做过合并。</li>\n</ul>\n<p><br></p>\n<h5 id=\"缺陷BUG分支\"><a href=\"#缺陷BUG分支\" class=\"headerlink\" title=\"缺陷BUG分支\"></a>缺陷BUG分支</h5><p>软件开发中bug就像家常便饭一样。有了bug就需要修复在Git中，由于分支是如此的强大，所以每个bug都可以通过一个新的临时分支来修复，修复后合并分支，然后将临时分支删除。</p>\n<p>当你接到一个修复一个代号101的bug的任务时很自然地，你想创建一个分支issue-101来修复它，但是等等，当前正在dev上进行的工作还没有提交：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch dev</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       new file:   hello.py</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       modified:   readme.txt</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br></pre></td></tr></table></figure><br>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>\n<p>幸好Git还<code>提供了一个stash功能</code>，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash</span><br><span class=\"line\">Saved working directory and index state WIP on dev: 6224937 add merge</span><br><span class=\"line\">HEAD is now at 6224937 add merge</span><br></pre></td></tr></table></figure><br>现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。<br>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch <span class=\"string\">'master'</span></span><br><span class=\"line\">Your branch is ahead of <span class=\"string\">'origin/master'</span> by 6 commits.</span><br><span class=\"line\"></span><br><span class=\"line\">$ git checkout -b issue-101  <span class=\"comment\">#临时分支</span></span><br><span class=\"line\">Switched to a new branch <span class=\"string\">'issue-101'</span></span><br></pre></td></tr></table></figure></p>\n<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add readme.txt</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"fix bug 101\"</span></span><br><span class=\"line\">[issue-101 cc17032] fix bug 101</span><br><span class=\"line\">1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</span></span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\"><span class=\"comment\"># Switched to branch 'master'</span></span><br><span class=\"line\"><span class=\"comment\"># Your branch is ahead of 'origin/master' by 2 commits.</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git merge --no-ff -m <span class=\"string\">\"merged bug fix 101\"</span> issue-101</span><br><span class=\"line\"><span class=\"comment\"># Merge made by the 'recursive' strategy.</span></span><br><span class=\"line\"><span class=\"comment\">#  readme.txt |    2 +-</span></span><br><span class=\"line\"><span class=\"comment\"># 1 file changed, 1 insertion(+), 1 deletion(-)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git branch -d issue-101</span><br><span class=\"line\"><span class=\"comment\"># Deleted branch issue-101 (was cc17032).</span></span><br></pre></td></tr></table></figure></p>\n<p>现在，是时候接着回到dev分支干活了！<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout dev</span><br><span class=\"line\">Switched to branch <span class=\"string\">'dev'</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch dev</span></span><br><span class=\"line\"><span class=\"comment\"># nothing to commit (working directory clean)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看前面保存的工作现场</span></span><br><span class=\"line\">$ git stash list</span><br><span class=\"line\">stash@&#123;0&#125;: WIP on dev: 6224937 add merge</span><br></pre></td></tr></table></figure></p>\n<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>\n<ul>\n<li>(1)用git stash apply恢复但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</li>\n<li>(2)用git stash pop，恢复的同时把stash内容也删了：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git stash pop</span><br><span class=\"line\"><span class=\"comment\"># On branch dev</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       new file:   hello.py</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Changes not staged for commit:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git add &lt;file&gt;...\" to update what will be committed)</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       modified:   readme.txt</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git stash list  <span class=\"comment\">#再用git stash list查看，就看不到任何stash内容了</span></span><br></pre></td></tr></table></figure>\n<p><em>总结：</em></p>\n<ul>\n<li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</li>\n<li>当手头工作没有完成时，先把工作现场git stash一下然后去修复bug，修复后，再git stash pop回到工作现场。</li>\n</ul>\n<p><br></p>\n<h5 id=\"未合并分支\"><a href=\"#未合并分支\" class=\"headerlink\" title=\"未合并分支\"></a>未合并分支</h5><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。<br>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以每添加一个新功能，最好新建一个feature分支，在上面开发，完成后合并，最后删除该feature分支。</p>\n<p>现在你终于接到了一个新任务，开发代号为Vulcan的新功能，于是准备开发：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b feature-vulcan</span><br><span class=\"line\">$ git add vulcan.py</span><br><span class=\"line\">$ git status</span><br><span class=\"line\"><span class=\"comment\"># On branch feature-vulcan</span></span><br><span class=\"line\"><span class=\"comment\"># Changes to be committed:</span></span><br><span class=\"line\"><span class=\"comment\">#   (use \"git reset HEAD &lt;file&gt;...\" to unstage)</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#       new file:   vulcan.py</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add feature vulcan\"</span></span><br><span class=\"line\"><span class=\"comment\"># [feature-vulcan 756d4af] add feature vulcan</span></span><br><span class=\"line\"><span class=\"comment\"># 1 file changed, 2 insertions(+)</span></span><br><span class=\"line\"><span class=\"comment\"># create mode 100644 vulcan.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#切回dev，准备合并;一切顺利的话，feature分支和bug分支是类似的，合并然后删除。</span></span><br><span class=\"line\">$ git checkout dev</span><br><span class=\"line\"><span class=\"comment\">#在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了但是这个分支还是必须就地销毁：</span></span><br><span class=\"line\">$ git branch -d feature-vulcan</span><br><span class=\"line\">error: The branch <span class=\"string\">'feature-vulcan'</span> is not fully merged. <span class=\"comment\">#销毁失败</span></span><br><span class=\"line\">If you are sure you want to delete it, run <span class=\"string\">'git branch -D feature-vulcan'</span>.</span><br><span class=\"line\"><span class=\"comment\">#Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。</span></span><br><span class=\"line\">$ git branch -D feature-vulcan  <span class=\"comment\">#强行删除</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"0x03-远程分支关联\"><a href=\"#0x03-远程分支关联\" class=\"headerlink\" title=\"0x03 远程分支关联\"></a>0x03 远程分支关联</h4><p><strong>多人协作分支</strong><br>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程仓库的默认名称是origin。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote <span class=\"comment\">#或者用git remote -v显示更详细的信息：</span></span><br><span class=\"line\">origin</span><br><span class=\"line\">$ git remote -v <span class=\"comment\">#显示了可以抓取和推送的origin的地址。</span></span><br><span class=\"line\"><span class=\"comment\">#如果没有推送权限，就看不到push的地址。</span></span><br><span class=\"line\">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class=\"line\">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><br>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br><span class=\"line\"><span class=\"comment\">#如果要推送其他分支，比如dev就改成：</span></span><br><span class=\"line\">$ git push origin dev   <span class=\"comment\">#远程origin  本地其他分支dev</span></span><br></pre></td></tr></table></figure></p>\n<p>但是并不是一定要把本地分支往远程推送，那么哪些分支需要推送，哪些不需要呢？</p>\n<ul>\n<li>master分支是主分支，因此要时刻与远程同步；</li>\n<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>\n<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>\n<li>feature(n. 特色，特征；容貌；特写或专题节目)分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>\n</ul>\n<p><br></p>\n<p><strong>抓取分支</strong></p>\n<p>多人协作时，大家都会往master和dev分支上推送各自的修改。现在模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> git@github.com:michaelliao/learngit.git</span><br><span class=\"line\">Cloning into <span class=\"string\">'learngit'</span>...</span><br></pre></td></tr></table></figure>\n<p>当你的小伙伴从远程库clone时，默认情况下你的小伙伴只能看到本地的master分支。<br>用git branch命令看看：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure></p>\n<p>现在你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建远程分支到本地</span></span><br><span class=\"line\">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p>\n<p>现在他就可以在dev上继续修改，然后时不时地把dev分支push到远程：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">\"add /usr/bin/env\"</span></span><br><span class=\"line\">[dev 291bea8] add /usr/bin/env</span><br><span class=\"line\">1 file changed, 1 insertion(+)</span><br><span class=\"line\">​</span><br><span class=\"line\">$ git push origin dev  <span class=\"comment\">#注意这里需要将本地的dev推送到远程的origin/dev中</span></span><br><span class=\"line\"> fc38031..291bea8</span><br></pre></td></tr></table></figure></p>\n<p>你的小伙伴<code>已经向origin/dev分支推送了他的提交</code>，而碰巧你也对同样的文件作了修改，并试图推送：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add hello.py</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add coding: utf-8\"</span></span><br><span class=\"line\">[dev bd6ae48] add coding: utf-8</span><br><span class=\"line\">1 file changed, 1 insertion(+)</span><br><span class=\"line\">​</span><br><span class=\"line\">​</span><br><span class=\"line\">$ git push origin dev</span><br><span class=\"line\">To git@github.com:michaelliao/learngit.git</span><br><span class=\"line\"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class=\"line\">error: failed to push some refs to </span><br><span class=\"line\">hint: its remote counterpart. Merge the remote changes (e.g. <span class=\"string\">'git pull'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>推送失败，<code>因为你的小伙伴的最新提交和你试图推送的提交有冲突</code>，解决办法也很简单Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突再推送：</p>\n<p>但是 git pull 也失败了，原因是没有指定本地dev分支与远程origin/dev分支的关联，根据提示设置dev和origin/dev的链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch --<span class=\"built_in\">set</span>-upstream dev origin/dev  <span class=\"comment\">#设置本地dev分支与远程origin/dev分支进行关联;</span></span><br><span class=\"line\">Branch dev <span class=\"built_in\">set</span> up to track remote branch dev from origin.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#然后再进行pull：这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。</span></span><br><span class=\"line\">$ git pull</span><br><span class=\"line\">Auto-merging hello.py</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> hello.py</span><br><span class=\"line\">Automatic merge failed; fix conflicts and <span class=\"keyword\">then</span> commit the result.</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#解决后提交，再push：</span></span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"merge &amp; fix hello.py\"</span></span><br><span class=\"line\">[dev adca45d] merge &amp; fix hello.py</span><br><span class=\"line\">​</span><br><span class=\"line\">$ git push origin dev</span><br><span class=\"line\">   291bea8..adca45d  dev -&gt; dev</span><br></pre></td></tr></table></figure>\n<p>因此多人协作的工作模式通常是这样,一旦熟悉了就非常简单：</p>\n<ul>\n<li>首先，可以试图用git push origin branch-name推送自己的修改；</li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交；</li>\n<li>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</li>\n<li>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，<code>用命令git branch --set-upstream branch-name origin/branch-name</code></li>\n</ul>\n<p><br></p>\n<p><em>总结：</em></p>\n<ul>\n<li>查看远程库信息，使用git remote -v；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用git push origin branch-name，如果推送失败先用git pull抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</li>\n<li>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突，最后在git push origin branch-name推送</li>\n</ul>\n<p><br></p>\n<h5 id=\"分支之间commit\"><a href=\"#分支之间commit\" class=\"headerlink\" title=\"分支之间commit\"></a>分支之间commit</h5><p>实际案例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#把A分支的某一个commit放到B分支上</span></span><br><span class=\"line\">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"0x04-标签管理\"><a href=\"#0x04-标签管理\" class=\"headerlink\" title=\"0x04 标签管理\"></a>0x04 标签管理</h4><p>描述：发布一个版本时我们通常先在版本库中打一个标签（tag），这样就<code>唯一确定了打标签时刻的版本</code>。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来,<code>所以标签也是版本库的一个快照</code>。</p>\n<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（<em>跟分支很像对不对？但是分支可以移动，标签不能移动</em>），所以创建和删除标签都是瞬间完成的，所以tag就是一个让人容易记住的有意义的名字，它跟某个commitID绑在一起。</p>\n<p><em>Git有commit，为什么还要引入tag？</em><br>“请把上周一的那个版本打包发布，commit号是6a5819e…” / “一串乱七八糟的数字不好找！”<br>如果换一个办法：“请把上周一的那个版本打包发布，版本号是v1.2” / “好的，按照tag v1.2查找commit就行！”</p>\n<p><br></p>\n<h5 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h5><p>在Git中打标签非常简单，首先切换到需要打标签的分支上：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* dev</span><br><span class=\"line\">  master</span><br><span class=\"line\">​</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch <span class=\"string\">'master'</span></span><br></pre></td></tr></table></figure></p>\n<p>然后敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag v1.0  <span class=\"comment\">#默认标签是打在最新提交的commit上的。</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#可以用命令git tag查看所有标签：</span></span><br><span class=\"line\">$ git tag</span><br><span class=\"line\">v1.0</span><br></pre></td></tr></table></figure></p>\n<p>有时候如果忘了打标签，比如现在已经是周五了但应该在周一打的标签没有打怎么办？<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#方法是找到历史提交的commit id，然后打上就可以了：</span></span><br><span class=\"line\">$ git <span class=\"built_in\">log</span> --pretty=oneline --abbrev-commit</span><br><span class=\"line\">6a5819e merged bug fix 101</span><br><span class=\"line\">cc17032 fix bug 101</span><br><span class=\"line\">7825a50 merge with no-ff</span><br><span class=\"line\">6224937 add merge</span><br><span class=\"line\">59bc1cb conflict fixed</span><br><span class=\"line\">400b400 &amp; simple</span><br><span class=\"line\">75a857c AND simple</span><br><span class=\"line\">fec145a branch <span class=\"built_in\">test</span></span><br><span class=\"line\">d17efd8 remove test.txt</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：</span></span><br><span class=\"line\">$ git tag v0.9 6224937</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#再用命令git tag查看标签：#注意，标签不是按时间顺序列出，而是按字母排序的。</span></span><br><span class=\"line\">$ git tag</span><br><span class=\"line\">v0.9</span><br><span class=\"line\">v1.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#可以用git show &lt;tagname&gt;查看标签信息：</span></span><br><span class=\"line\">$ git show v0.9  <span class=\"comment\">#可以看到v0.9确实打在add merge这次提交上。</span></span><br><span class=\"line\">commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Thu Aug 22 11:22:08 2013 +0800</span><br><span class=\"line\"> </span><br><span class=\"line\">    add merge</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</span></span><br><span class=\"line\">$ git tag -a v0.1 -m <span class=\"string\">\"version 0.1 released\"</span> 3628164</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#用命令git show &lt;tagname&gt;可以看到说明文字：</span></span><br><span class=\"line\">$ git show v0.1</span><br><span class=\"line\">tag v0.1</span><br><span class=\"line\">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Mon Aug 26 07:28:11 2013 +0800</span><br><span class=\"line\"> </span><br><span class=\"line\">version 0.1 released</span><br><span class=\"line\"> </span><br><span class=\"line\">commit 3628164fb26d48395383f8f31179f24e0882e1e0</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Tue Aug 20 15:11:49 2013 +0800</span><br><span class=\"line\"> </span><br><span class=\"line\">    append GPL</span><br></pre></td></tr></table></figure></p>\n<p>签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对就会报错：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg: signing failed: secret key not available</span><br><span class=\"line\">error: gpg failed to sign the data</span><br><span class=\"line\">error: unable to sign the tag</span><br></pre></td></tr></table></figure><br>用PGP签名的标签是不可伪造的，因为可以验证PGP签名,通用git tag 可以通过-s用私钥签名一个标签：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -s v0.2 -m <span class=\"string\">\"signed version 0.2 released\"</span> fec145a</span><br></pre></td></tr></table></figure></p>\n<p>用命令git show <tagname>可以看到PGP签名信息：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git show v0.2</span><br><span class=\"line\">tag v0.2</span><br><span class=\"line\">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Mon Aug 26 07:28:33 2013 +0800</span><br><span class=\"line\"> </span><br><span class=\"line\">signed version 0.2 released</span><br><span class=\"line\">-----BEGIN PGP SIGNATURE-----</span><br><span class=\"line\">Version: GnuPG v1.4.12 (Darwin)</span><br><span class=\"line\"> </span><br><span class=\"line\">iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...</span><br><span class=\"line\">-----END PGP SIGNATURE-----</span><br><span class=\"line\"> </span><br><span class=\"line\">commit fec145accd63cdc9ed95a2f557ea0658a2a6537f</span><br><span class=\"line\">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class=\"line\">Date:   Thu Aug 22 10:37:30 2013 +0800</span><br><span class=\"line\"> </span><br><span class=\"line\">    branch <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure></p>\n<p><em>总结：</em></p>\n<ul>\n<li>命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id,git tag可以查看所有标签。</li>\n<li>git tag -a <tagname> -m “blablabla…”可以指定标签信息；</li>\n<li>git tag -s <tagname> -m “blablabla…”可以用PGP签名标签；</li>\n</ul>\n<p><br></p>\n<h5 id=\"操作标签\"><a href=\"#操作标签\" class=\"headerlink\" title=\"操作标签\"></a>操作标签</h5><p>如果标签打错了也可以删除指定的标签,因为创建的标签都只存储在本地，不会自动推送到远程；所以打错的标签可以在本地安全删除。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag -d v0.1</span><br><span class=\"line\">Deleted tag <span class=\"string\">'v0.1'</span> (was e078af9)</span><br></pre></td></tr></table></figure></p>\n<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin v1.0</span><br><span class=\"line\">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To git@github.com:michaelliao/learngit.git</span><br><span class=\"line\"> * [new tag]         v1.0 -&gt; v1.0</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">#或者，一次性推送全部尚未推送到远程的本地标签：</span></span><br><span class=\"line\">$ git push origin --tags</span><br><span class=\"line\">Counting objects: 1, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Writing objects: 100% (1/1), 554 bytes, <span class=\"keyword\">done</span>.</span><br><span class=\"line\">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class=\"line\">To git@github.com:michaelliao/learngit.git</span><br><span class=\"line\"> * [new tag]         v0.2 -&gt; v0.2</span><br><span class=\"line\"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure></p>\n<p>如果标签已经推送到远程，要删除远程标签就麻烦一点,操作完成后要想看看是否真的从远程库删除了标签，可以登陆GitHub查看<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#先从本地删除：</span></span><br><span class=\"line\">$ git tag -d v0.9</span><br><span class=\"line\">Deleted tag <span class=\"string\">'v0.9'</span> (was 6224937)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#然后，从远程删除-删除命令也是push，但是格式如下：</span></span><br><span class=\"line\">$ git push origin :refs/tags/v0.9</span><br><span class=\"line\">To git@github.com:michaelliao/learngit.git</span><br><span class=\"line\"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure></p>\n<p><em>总结:</em></p>\n<ul>\n<li>命令git push origin <tagname>可以推送一个本地标签；</li>\n<li>命令git push origin –tags 可以推送全部未推送过的本地标签；</li>\n<li>命令git tag -d <tagname>可以删除一个本地标签；</li>\n<li>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</li>\n</ul>\n<p><br></p>\n<h4 id=\"0x05-总结\"><a href=\"#0x05-总结\" class=\"headerlink\" title=\"0x05 总结\"></a>0x05 总结</h4><p><strong>.git 仓库元数据</strong><br>每一个 git 的代码仓库目录下，都会有一个 .git 的文件夹，其中包含的重要文件包含以下：<br>文件/文件夹    含义    </p>\n<ul>\n<li>config*    配置文件    </li>\n<li>description    描述仅供 Git Web 程序使用    </li>\n<li>HEAD    当前被检出的分支    </li>\n<li>index    暂存区信息    </li>\n<li>hooks/    客户端或服务端的钩子脚本（hook scripts）    </li>\n<li>info/    全局性排除（global exclude）文件，不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns）    </li>\n<li>objects/    所有数据内容    </li>\n<li>refs/    数据（分支）的提交对象的指针</li>\n</ul>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"版本控制","path":"api/categories/版本控制.json"}],"tags":[{"name":"git","path":"api/tags/git.json"}]}