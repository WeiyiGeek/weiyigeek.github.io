<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="content-language" content="zh-CN"/>
    <meta name="author" content="WeiyiGeek" />
    <meta name="msvalidate.01" content="5C552FB1D885E0E11D2957EC958C8018" />
    <meta name="shenma-site-verification" content="4c655e91c76be0a93c1b6954c666c9d6_1649049085"/>
    <meta name="bytedance-verification-code" content="lKs4FqwCHSJ3A/c5tT7X" />
    <meta name="sogou_site_verification" content="OC65iET6Bk" />
    
    <title>🌐 6.Docker镜像与容器安全最佳实践|WeiyiGeek Blog|唯一极客Geek-IT网络安全运维开发技术知识分享-博客站点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
    <meta name="keywords" content="Docker">
    <meta name="Description" content="WeiyiGeek-唯一极客博客站点,关注于网络安全运维,Web安全开发,IOT物联网安全开发,应用开发,分享技术学习知识与入坑解决,提升网络安全技术与自身技术能力,立志维护大众网络安全为己任,做一个对国家有用的人,为实现中华民族伟大复兴的中国梦不懈奋斗">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/jquery/3.5.2-jquery.fancybox.min.css?v=1.6.6" />
    <link rel="stylesheet" href="/css/style.css?v=1.6.6">
    <!--  -->
     <script type="text/javascript" src="/js/custom/articlecost.js?v=1.6.6"></script> 
    <link rel="stylesheet" href="/css/third-party/gitalk.css?v=1.6.6"> 
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9134434519967436" crossorigin="anonymous"></script>    
    <script type="text/javascript">
        // Data Center
        var DC = {
          reward:	true,
          lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
          v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}')
        };
    </script>
    <script type="text/javascript">window.lazyScripts=[];</script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="WeiyiGeek Blog" type="application/atom+xml">
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg" alt="WeiyiGeek-backgroud">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg" alt="WeiyiGeek-头像">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">WeiyiGeek</h5>
          <a href="mailto:master@weiyigeek.top" title="master@weiyigeek.top" class="mail">
            <span>m</span><span>a</span><span>s</span><span>t</span><span>e</span><span>r</span><span>@</span><span>w</span><span>e</span><span>i</span><span>y</span><span>i</span><span>g</span><span>e</span><span>e</span><span>k</span><span>.</span><span>t</span><span>o</span><span>p</span>
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://weiyigeek.top/img/wechat-search.png" target="_blank">
                  <i class="icon icon-lg icon-wechat"></i>
                </a>
              </li>
            
              <li>
                <a href="https://github.com/weiyigeek" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://t.me/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-telegram"></i>
                </a>
              </li>
            
              <li>
                <a href="https://twitter.com/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-twitter"></i>
                </a>
              </li>
            
              <li>
                <a href="https://weibo.com/615643678" target="_blank">
                  <i class="icon icon-lg icon-weibo"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                首页
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                文章分类
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                文章标签
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章归档
              </a>
            </li>
        
            <li class="">
              <a href="/books"  >
                <i class="icon icon-lg icon-book"></i>
                学习书籍
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于作者
              </a>
            </li>
        
            <li class="">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                站点导航
              </a>
            </li>
        
            <li class="">
              <a href="/img/share-wechat.jpg" target="_blank" >
                <i class="icon icon-lg icon-wechat"></i>
                公众账号
              </a>
            </li>
        
            <li class="">
              <a href="https://space.bilibili.com/385802642" target="_blank" >
                <i class="icon icon-lg icon-youtube-play"></i>
                哔哩哔哩
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/weiyigeek" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="">
              <a href="https://twitter.com/WeiyiGeek" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
            <li class="">
              <a href="https://weibo.com/615643678" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>6.Docker镜像与容器安全最佳实践</span>
            
        </div>

        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        

        
            <a href="/atom.xml" class="header-icon pull-right waves-effect waves-circle waves-light">
                <i class="icon icon-lg icon-rss"></i>
            </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg" alt="文章头部背景">
    <div class="container fade-scale">
        <h1 class="title">6.Docker镜像与容器安全最佳实践</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-06-04T07:36:30.000Z" itemprop="datePublished" class="page-time">
  2019-06-04
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/">Containers</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/OperationTools/">OperationTools</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/OperationTools/Security/">Security</a></li></ul></li></ul></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
  <article id="post-虚拟云容/云容器/Docker/6.Docker镜像与容器安全最佳实践"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">6.Docker镜像与容器安全最佳实践</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-06-04 15:36:30" datetime="2019-06-04T07:36:30.000Z"  itemprop="datePublished">2019-06-04</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/">Containers</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/OperationTools/">OperationTools</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/OperationTools/Security/">Security</a></li></ul></li></ul></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>[TOC]</p>
<a id="more"></a>
<h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p>描述: 在企业中信息系统安全与业务是同样重要, 随着传统运维方式向着容器化运维方式的转变，当下企业里通常都会采用Docker来进行容器化部署和承载业务, 由于运维人员或者开发人员对容器安全的关注较少, 只是简单认为容器是有隔离和限制的, 就算是容器被黑客攻击了, 也单单是容器内部受到影响， 而对宿主的 Linux 系统和网络都不会产生太大影响。其实不然Docker容器安全也是重中之重, 它关乎着应用与数据安全，其中也关乎着宿主机的安全。</p>
<p>所以在本章之中，我将讲述如何更安全配置使用Docker容器环境，优化Docker镜像的安全构建过程，以使我们能够在最短构建时间内构建最小、最安全的满足生产需求的Docker镜像。</p>
<p>温馨提示: 本文中的技巧与示例应该可以提高您的Docker容器安全知识, 并可以改善所使用的Docker镜像质量，希望读者从中有所收获。</p>
<p>Docker 安全问题公告: <a href="https://docs.docker.com/security/" target="_blank" rel="noopener">https://docs.docker.com/security/</a></p>
<p><br></p>
<h3 id="1-容器安全概述"><a href="#1-容器安全概述" class="headerlink" title="1.容器安全概述"></a>1.容器安全概述</h3><p>在正式学习Docker容器安全之前,先解释一下本章节会涉及的相关概念，它可以帮助你扫除概念障碍，以及更好的理解容器安全应该从那几个方面入手。</p>
<ul>
<li>Docker 宿主机: 安装Docker服务的操作系统主机。</li>
<li>Docker 服务: 即Docker提供的相关功能以及在宿主机中的Docker进程，Docker进程是可以直接与Linux内核进行通信的。</li>
<li>Docekr 镜像: 通过Dockerfile文件构建得到的产物。</li>
<li>Docker 容器: 通过镜像创建运行多个Docker容器，即业务是运行在容器之中，注意Docker容器是运行于Docker服务之上。</li>
</ul>
<p><br></p>
<p><strong>Docker 宿主机安全</strong><br>描述: 宿主机作为Docker服务运行的基础环境, 其重要性是无可置疑的，一个安全的基础环境是保证Docker服务安全的基础设施，所以在安装使用docker前我们需要针对其宿主机操作系统进行一系列的加固配置，具体如何进行宿主机的安全加固设置，可以参考我前面所写的Windows与Linux系统加固脚本。</p>
<p><br></p>
<p><strong>Docker 服务安全</strong><br>描述: Docker 服务的安全同样在容器安全中占据着重要地位，如果一旦Docker服务由于脆弱性配置被攻击者控制，将会影响所有运行在该Docker服务下的所有容器，将不能保证业务与数据的安全，攻击者完全可以通过Docker Server提供的REST API接口进行管理容器或者查看容器内某些重要的配置文件。</p>
<p><br></p>
<p><strong>Docekr 镜像安全</strong><br>描述: Docker 镜像安全也是在容器安全中占有一席之地，如果一旦镜像系统或者服务中存在可以被攻击者利用的漏洞,在使用该镜像创建并运行容器后便可能反弹shell进行内网穿透，从而对容器中运行的业务、业务数据产生影响，并且还可能会影响Docker宿主机的安全。所以说一个安全的Docker镜像也是保证容器安全的重要一环,即我们需在构建镜像时选择较小的操作系统并只安装业务需要的服务与软件即可，减少攻击面从而增加攻击难度。</p>
<p><br></p>
<p><strong>Docekr 容器安全</strong><br>描述: Docker 容器作为承载业务的地方，是运维或开发人员接触最多的对象之一，它也是容器安全里的重要一环，如果在创建容器时未对某些功能做相应的限制，一旦docker容器中承载的业务产生漏洞或者包含的动态调用的脚本程序出现问题，都有可能严重危害到容器或者宿主机的安全。所以说为了保证docker容器安全我们不但要从docker安全入手，更要从业务安全入手。</p>
<p>从上面四大方面可以看出，容器安全并不是简单在某一环做出相应的安全配置就可以的，我们需要考虑四个主要方面，一是内核的内在安全性及其对命名空间和 cgroup 的支持，二是Docker 守护进程本身的攻击面，三是容器配置文件中的漏洞，四是内核的“强化”安全特性以及它们如何与容器交互。所以我们必须从基础操作系统环境、容器服务、容器镜像以及业务与运维开发人员分别入手，才能提高容器的安全性，减少被攻击的可能性。</p>
<p><br></p>
<h3 id="2-容器安全机制"><a href="#2-容器安全机制" class="headerlink" title="2.容器安全机制"></a>2.容器安全机制</h3><p>描述: Docker 容器与 LXC 容器非常相似，并且具有相似的安全特性，当您使用 docker run创建或启动容器时，Docker 服务为了防止黑客在控制容器后能够对宿主机进行攻击，提供了三个主要的隔离机制，其分别是<code>Namespace 机制、Capabilities 机制和 CGroups 机制</code>。</p>
<p>通过隔离机制能起到对容器一定的保护，但并不是绝对的，如果攻击对宿主机产生了影响，就说明入侵者已经突破了Docker服务的保护，这就是容器安全中常说的Docker容器逃逸。</p>
<p><br/></p>
<h4 id="内核能力机制"><a href="#内核能力机制" class="headerlink" title="内核能力机制"></a>内核能力机制</h4><p>描述: 通过前面的学习我们知道Docker服务进程是直接与Linux 内核进行通信的，而Linux内核从从2.6.24版本起提供了一个强大的特性，就是可以提供细粒度的权限访问控制操作能力，既可以用在进程上，也可以作用在文件上，使用内核能力机制对加强 Docker 容器的安全有很多好处；</p>
<p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。并且Docker采用白名单机制，禁用必需功能之外的其它权限</p>
<p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 net_bind_service 能力即可。</p>
<p>为了加强安全，容器可以禁用一些没必要的权限。</p>
<ul>
<li>完全禁止任何 mount 操作；</li>
<li>禁止直接访问本地主机的套接字；</li>
<li>禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</li>
<li>禁止模块加载。</li>
</ul>
<p>这样就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p><br/></p>
<p><strong>Namespace 机制</strong><br>描述: Namespace 即名称空间，是Linux内核提供的一种标签机制，Linux内核会针对不同Namespace之间的进程做隔离，避免不同的进程之间互相产生影响，所以Docker服务会为每一个 Docker容器创建一个单独的 Namespace 空间。 由于不同容器之间、容器和系统之间都是不同名称的Namespace，所以在一个容器中运行的进程无法看到运行在另一个容器或主机系统中的进程，并且每个容器还拥有自己的网络堆栈，这意味着一个容器无法获得对另一个容器的套接字或接口的特权访问，但通常Docker主机上的所有容器都是默认位于桥接接口docker0上，除非在创建容器之初指定了其他网络模式。</p>
<p>虽然 Namespace 实现了容器和宿主机环境的”伪隔离”, 但是由于输入、输出、硬件设备的需要，容器仍然可以修改宿主机中部分文件，所以我们又需要一种可以限制对象操作的权限的机制，即下面要说的Capabilities机制。</p>
<p><br></p>
<p><strong>Capabilities 机制</strong><br>描述: Capabilities 提供了更细粒度的授权机制，它定义了主体对象能够进行的某一类操作。例如当一个容器的Web服务需要绑定 到80端口,但是80端口的绑定是需要ROOT权限的。而Docker为了防止 ROOT 权限滥用会通过 Capabilities 机制，给予该容器Web 服务对象 net_bind_service 的权限(其允许绑定到小于 1024 的端口)。</p>
<p>同样地Docker服务对容器中的ROOT权限用户添加了很多默认的限制，比如：拒绝所有的挂载操作、拒绝部分文件的操作(如修改文件所有者等)、拒绝内核模块加载；</p>
<p>虽然 Capabilities 可以最大程度解决容器安全问题, 但Capabilities对容器可进行操作的限制程度是难以把控的，如果设置过松会导致 Docker 容器影响宿主机系统，让 Docker 隔离失效。而如果设置过为严格的话会让容器以及容器内的服务功能受限，导致Docker容器无法正常运行。</p>
<p>所以在默认情况下，Docker 会采用白名单机制（白名单列表你可以在 Docker 源码中查看）进行限制，即只允许 Docker 容器拥有几个默认的能力。那有了白名单限制，即使攻击者成功拿到了容器中的 ROOT 权限，能够对宿主机造成的影响也相对较小，所以“Docker 逃逸”并不是一件不容易的事。</p>
<p><br></p>
<p><strong>CGroups 机制</strong><br>描述: CGroups 提供了资源限制的作用能力，Docker 服务可以利用 CGroups 机制来实现对容器中内存、CPU处理和磁盘IO份额等的限制，减少Docker容器由于业务或者攻击从而过多占用宿主机资源，对宿主机以及其他容器产生影响。</p>
<p>比如，通过下面的命令就可以限制 Docker 容器只使用 2 个 CPU 和 200MB 的内存来运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --cpus=2 --memory=<span class="string">"200m"</span> debian:latest /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>虽然 CGroups 可以解决给每一个容器弹性地分配 CPU 、内存或者其他资源。同样地该限制既不能过松，也不能过为严格，如果设置过松会导致某一 Docker容器耗尽宿主机资源。而如果设置过严又会使得容器内的服务得不到足够的资源支持，可能无法运行。所以此时需要我们自己根据业务的压测结果来进行配置，没有默认的安全机制可以辅助。</p>
<p><br></p>
<h4 id="服务端防护机制"><a href="#服务端防护机制" class="headerlink" title="服务端防护机制"></a>服务端防护机制</h4><p>Docker 服务的运行目前需要 root 权限，因此其安全性十分关键,由于运行一个容器或应用程序的核心是通过 Docker 服务端。</p>
<p>Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制;<br>例如:恶意用户启动容器的时候将主机的根目录/映射到容器的 /host 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了<br>因此当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p>
<p>Docker 的安全特性：</p>
<ul>
<li>首先，确保只有可信的用户才可以访问 Docker 服务(理论上由于攻击层出不穷)。</li>
<li>其次, 在容器内不使用 root 权限来运行进程的话。</li>
<li>确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。</li>
<li>将容器的 root 用户映射到本地主机上的非 root 用户，减轻容器和主机之间因权限提升而引起的安全问题；</li>
<li>允许 Docker 服务端在非 root 权限下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</li>
</ul>
<p><br></p>
<h4 id="辅助安全机制"><a href="#辅助安全机制" class="headerlink" title="辅助安全机制"></a>辅助安全机制</h4><p>描述: 除此之外，我们还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, SELinux, GRSEC 等。<br>Docker 当前默认只启用了能力机制，用户可以采用多种方案来加强 Docker 主机的安全，例如：</p>
<ul>
<li>在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且启用该特性不需要 Docker 进行任何配置。</li>
<li>使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</li>
<li>用户可以自定义访问控制机制来定制安全策略。<br>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</li>
</ul>
<p>默认情况下,如果运行容器内以非特权用户身份运行进程时，容器通常是相对安全的，但是您仍然可以通过启用 <code>AppArmor、SELinux、GRSEC</code> 或其他适当的组件服务系统来添加额外的安全层，来更进一步来保证容器的安全。</p>
<p><br></p>
<h3 id="3-容器安全风险"><a href="#3-容器安全风险" class="headerlink" title="3.容器安全风险"></a>3.容器安全风险</h3><p>描述: 本小节将针对容器化环境中，您有可能会遇到安全风险进行一一罗列，其主要分为如下几方面。</p>
<p><strong>Docker 容器安全常见问题</strong></p>
<ul>
<li><p>宿主机问题<br>例如，宿主机上其他服务漏洞导致的网络穿透代理访问，内网探测、Docker守护进程Socket文件读取。</p>
</li>
<li><p>自身漏洞问题<br>例如，代码执行、权限提升、信息泄漏、runC。</p>
</li>
<li><p>架构缺陷与安全机制未配置问题<br>例如，Namespaces 导致的：容器之间的局域网攻击、共享root、未隔离的文件系统、默认放通所有。<br>例如，CGroups 导致的: DDoS攻击耗尽资源。</p>
</li>
<li><p>镜像源问题<br>例如，恶意镜像、存在漏洞的镜像、容器逃逸。</p>
</li>
<li><p>生态问题<br>例如，Containerd 相关漏洞、Kubernetes相关漏洞。</p>
</li>
</ul>
<p><br></p>
<p><strong>Docker 容器安全防护基线</strong></p>
<ul>
<li><p>内核级别的：Namespaces、Cgroup、SElinux</p>
</li>
<li><p>主机级别的：服务最小化、禁止挂载宿主机敏感目录、挂载目录权限设置为644</p>
</li>
<li><p>网络级别的：禁止映射特权端口、通过iptable设定规则并禁止容器之间的网络流量</p>
</li>
<li><p>镜像级别的：创建本地镜像服务器、使用可信镜像、使用镜像扫描、合理管理镜像标签</p>
</li>
<li><p>容器级别的：容器以单一主进程方式运行、禁止运行SSH等高危服务、以只读方式挂载根目录系统</p>
</li>
</ul>
<hr>
<h2 id="0x01-Docker-镜像安全最佳实践"><a href="#0x01-Docker-镜像安全最佳实践" class="headerlink" title="0x01 Docker 镜像安全最佳实践"></a>0x01 Docker 镜像安全最佳实践</h2><p>描述: Docker 安全管理要趁早，下面分别列举了几个诀窍和指南，确保为测试与生产环境提供更安全和更高质量的 Docker 镜像。</p>
<h3 id="1-选用最小化基础镜像"><a href="#1-选用最小化基础镜像" class="headerlink" title="1.选用最小化基础镜像"></a>1.选用最小化基础镜像</h3><p>描述: 运维人员在编写项目的 Dockerfile 时，经常使用一个通用的 Docker 容器镜像作为基础例如<code>From Node</code>，而Node 镜像实际上是以一个完整安装的 Debian Stretch 发行版为基础，这意味着构建得到的项目容器镜像将包含一个完整的操作系统。所以如果该项目不需要任何通用的系统库或者系统工具应用，最好不要使用完整的操作系统作为基础镜像。</p>
<p>Synx 发布的<code>《开源安全报告-2019[3]》</code>指出，Docker Hub 上流行的很多容器镜像，都用到了包含大量已知安全漏洞的基础镜像。例如执行 <code>docker pull node</code> ，下载并使用 Node 镜像，相当于在应用中引入了一个包含 580 个已知漏洞的操作系统。</p>
<figure class="image-box">
                <a rel=6.Docker镜像与容器安全最佳实践 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210615104351.png" target="_blank" title="WeiyiGeek.Top ten most popular docker images each contain at least 30 vulnerabilities" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210615104351.png" alt="WeiyiGeek.Top ten most popular docker images each contain at least 30 vulnerabilities" title="" class=""></a>
                <p>WeiyiGeek.Top ten most popular docker images each contain at least 30 vulnerabilities</p>
            </figure>
<p><strong>安全实践:</strong> 选用最小化基础镜像，即只包含项目确实需要的系统工具和库的镜像，就能最小化系统的攻击面，确保所用操作系统是安全的。</p>
<p><br></p>
<h3 id="2-设定最小权限的-USER-运行容器"><a href="#2-设定最小权限的-USER-运行容器" class="headerlink" title="2.设定最小权限的 USER 运行容器"></a>2.设定最小权限的 USER 运行容器</h3><p>描述: 如果 Dockerfile 中没有指定 USER ，Docker 默认将会以超级用户 root 的身份运行容器，容器所属的命名空间（namespace）因此映射为 root 所有，这意味着容器有可能获取 Docker 宿主机的超级管理权限。不仅如此以 root 用户身份运行容器，还扩大了攻击面，如果容器应用中存在安全漏洞，很容易造成权限提升。</p>
<p>在实践中一般不需要容器拥有 root 权限。为了尽量降低安全威胁，创建专门的用户和用户组，在 Dockerfile 中使用 USER 指定用户，确保以最小权限的用户身份运行容器应用。</p>
<p><strong>安全实践:</strong></p>
<ul>
<li><p>1) 如果基础镜像中不包含专门的用户，那么就在 Dockerfile 中直接创建。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="string">/app</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">groupadd</span> <span class="bullet">-r</span> <span class="string">weiyigeek</span> <span class="string">&amp;&amp;</span> <span class="string">\</span></span><br><span class="line">    <span class="string">useradd</span> <span class="bullet">-r</span> <span class="bullet">-s</span> <span class="string">/bin/false</span> <span class="bullet">-g</span> <span class="string">weiyigeek</span> <span class="string">weiyigeek</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/app</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">.</span> <span class="string">/app</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">chown</span> <span class="bullet">-R</span> <span class="attr">weiyigeek:weiyigeek</span> <span class="string">/app</span></span><br><span class="line"><span class="string">USER</span> <span class="string">weiyigeek</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">node</span> <span class="string">index.js</span></span><br><span class="line"><span class="comment"># 关键命令解释</span></span><br><span class="line"><span class="comment"># - 创建一个系统用户（ -r 选项），没有密码、没有主目录且没有 shell，并将该用户添加到前面（使用 groupadd ）创建的用户组;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2) 如果你使用的是 Node.js 和 alpine 镜像，已经包含了一个用户 node，直接使用即可：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">10</span>-alpine </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chown -R node:node /app</span></span><br><span class="line"><span class="keyword">USER</span> node</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"index.js"</span>]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h3 id="3-签名和校验镜像，防范中间人攻击"><a href="#3-签名和校验镜像，防范中间人攻击" class="headerlink" title="3.签名和校验镜像，防范中间人攻击"></a>3.签名和校验镜像，防范中间人攻击</h3><p>描述: Docker 镜像的认证颇具挑战性。在生产环境使用这些镜像运行我们的代码，意味着我们对这些镜像的极大信任。因此必须保证我们拉取的容器镜像确实是发布者发布的镜像，没有被任何人篡改。发生镜像篡改，有可能是因为 Docker 客户端和镜像中心之间的中间人攻击，或者是发布者的身份被人盗用并在镜像中心发布了恶意镜像。</p>
<p><strong>安全实践:</strong></p>
<ul>
<li><p>1) 校验 Docker 镜像: Docker 默认直接拉取容器镜像，不会校验镜像的来源和发布者。这意味着你有可能使用来源和发布者不明的任何镜像。无论采用何种策略，最佳实践都是先校验容器镜像，通过验证后再拉取镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.为了体验镜像校验功能我们暂时开启 Docker Content Trust ，可以在系统环境变量中进行执行命令并且可以加入到/etc/profile文件中。</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_CONTENT_TRUST=1</span><br><span class="line"><span class="comment"># 2.现在尝试拉取一个没有签名的容器镜像——请求会被拒绝不会拉取镜像。</span></span><br><span class="line">$ docker pull kacha886/buysbox</span><br><span class="line">  Using default tag: latest   <span class="comment"># 默认latest标记是没有签名的</span></span><br><span class="line">  Error: remote trust data does not exist <span class="keyword">for</span> docker.io/kacha886/buysbox: notary.docker.io does not have trust data <span class="keyword">for</span> docker.io/kacha886/buysbox</span><br><span class="line">$ docker pull busybox:1.33.1    <span class="comment"># 本地不存在busybox 1.33.1的信任数据（没有签名信息）</span></span><br><span class="line">  No valid trust data <span class="keyword">for</span> 1.33.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.我们在设置容器校验的环境中可通过 --disable-content-trust 标志关闭内容信任后在标记镜像上运行单独的操作即可正常拉取、构建、上传非签名镜像。</span></span><br><span class="line">docker pull --<span class="built_in">disable</span>-content-trust busybox:1.33.1</span><br><span class="line">docker build --<span class="built_in">disable</span>-content-trust -t weiyigeek/buysbox:notrust .</span><br><span class="line">docker login -u weiyigeek</span><br><span class="line">docker push --<span class="built_in">disable</span>-content-trust weiyigeek/busybox:1.33.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.推送一个有签名的可信的镜像到仓库中</span></span><br><span class="line">docker push weiyigeek/buysbox:trust</span><br><span class="line">  <span class="comment"># The push refers to a repository [docker.io/weiyigeek/trust] (len: 1)</span></span><br><span class="line">  <span class="comment"># 9a61b6b1315e: Image already exists</span></span><br><span class="line">  <span class="comment"># 902b87aaaec9: Image already exists</span></span><br><span class="line">  <span class="comment"># latest: digest: sha256:d02adacee0ac7a5be140adb94fa1dae64f4e71a68696e7f8e7cbf9db8dd49418 size: 3220</span></span><br><span class="line">  <span class="comment"># Signing and pushing trust metadata</span></span><br><span class="line">  <span class="comment"># You are about to create a new root signing key passphrase. This passphrase</span></span><br><span class="line">  <span class="comment"># will be used to protect the most sensitive key in your signing system. Please</span></span><br><span class="line">  <span class="comment"># choose a long, complex passphrase and be careful to keep the password and the</span></span><br><span class="line">  <span class="comment"># key file itself secure and backed up. It is highly recommended that you use a</span></span><br><span class="line">  <span class="comment"># password manager to generate the passphrase and keep it safe. There will be no</span></span><br><span class="line">  <span class="comment"># way to recover this key. You can find the key in your config directory.</span></span><br><span class="line">  <span class="comment"># Enter passphrase for new root key with id a1d96fb:</span></span><br><span class="line">  <span class="comment"># Repeat passphrase for new root key with id a1d96fb:</span></span><br><span class="line">  <span class="comment"># Enter passphrase for new repository key with id docker.io/weiyigeek/trust (3a932f1):</span></span><br><span class="line">  <span class="comment"># Repeat passphrase for new repository key with id docker.io/weiyigeek/trust (3a932f1):</span></span><br><span class="line">  <span class="comment"># Finished initializing "docker.io/weiyigeek/trust"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2) 签名 Docker 镜像: Docker 支持镜像签名，提供了额外一层的保护,使用 Docker Notary 签名镜像Notary 会检验镜像的签名，如果签名不合法，它会阻止运行该镜像。并在选择基础镜像时优先使用 Docker 认证的镜像，即这些镜像来自经过 Docker Hub 检查和选择的可信提供者，一定不要使用无法检验来源和发布者的容器镜像。</p>
</li>
</ul>
<p>如果开启了 Docker Content Trust ，构建 Docker 镜像的同时也会对镜像签名，例如推送可信标记镜像到仓库流程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 提示需要创建一个新的根密钥</span><br><span class="line">- 请求根密钥的密码</span><br><span class="line">- 在 ~/.docker/trust 目录中生成一个根密钥</span><br><span class="line">- 请求仓库密钥的密码</span><br><span class="line">- 在 ~/.docker/trust 目录中生成一个仓库密钥</span><br></pre></td></tr></table></figure></p>
<p><strong>示例演示:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.基础镜像拉取</span></span><br><span class="line">$ docker pull --<span class="built_in">disable</span>-content-trust busybox:1.33.1</span><br><span class="line">  <span class="comment"># 1.33.1: Pulling from library/busybox</span></span><br><span class="line">  <span class="comment"># b71f96345d44: Pull complete</span></span><br><span class="line">  <span class="comment"># Digest: sha256:930490f97e5b921535c153e0e7110d251134cc4b72bbb8133c6a5065cc68580d</span></span><br><span class="line">  <span class="comment"># Status: Downloaded newer image for busybox:1.33.1</span></span><br><span class="line">  <span class="comment"># docker.io/library/busybox:1.33.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.构建自定义镜像</span></span><br><span class="line">$ tee dockertrust/dockerfile &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">FROM busybox:1.33.1</span><br><span class="line">MAINTAINER weiyigeek master@weiyigeek.top</span><br><span class="line">CMD [<span class="string">"echo"</span>,<span class="string">"Welcome to Visited www.weiyigeek.top"</span>]</span><br><span class="line">EOF</span><br><span class="line">$ docker build --<span class="built_in">disable</span>-content-trust -t weiyigeek/buysbox:1.33.1-trust .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.运行自定义镜像的容器</span></span><br><span class="line">$ docker run --<span class="built_in">disable</span>-content-trust weiyigeek/buysbox:1.33.1-trust</span><br><span class="line"><span class="comment"># Welcome to Visited www.weiyigeek.top</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.登录到docker hub仓库之中(https://hub.docker.com)</span></span><br><span class="line">$ docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you dont have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: weiyigeek</span><br><span class="line">Password: xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.上传可信赖的镜像到docker hub仓库之中。</span></span><br><span class="line">$ docker push weiyigeek/buysbox:1.33.1-trust</span><br><span class="line">The push refers to repository [docker.io/weiyigeek/buysbox]</span><br><span class="line">5b8c72934dfc: Mounted from library/busybox</span><br><span class="line">1.33.1-trust: digest: sha256:99959645871654685ef84dbc4f3cb541a4f5332505752fbb89f0af80e6c84662 size: 527</span><br><span class="line">Signing and pushing trust metadata</span><br><span class="line">You are about to create a new root signing key passphrase. This passphrase</span><br><span class="line">will be used to protect the most sensitive key <span class="keyword">in</span> your signing system. Please</span><br><span class="line">choose a long, complex passphrase and be careful to keep the password and the</span><br><span class="line">key file itself secure and backed up. It is highly recommended that you use a</span><br><span class="line">password manager to generate the passphrase and keep it safe. There will be no</span><br><span class="line">way to recover this key. You can find the key <span class="keyword">in</span> your config directory.</span><br><span class="line">Enter passphrase <span class="keyword">for</span> new root key with ID 7fcbe50:</span><br><span class="line">Repeat passphrase <span class="keyword">for</span> new root key with ID 7fcbe50:</span><br><span class="line">Enter passphrase <span class="keyword">for</span> new repository key with ID 0d40411:</span><br><span class="line">Repeat passphrase <span class="keyword">for</span> new repository key with ID 0d40411:</span><br><span class="line">Finished initializing <span class="string">"docker.io/weiyigeek/buysbox"</span></span><br><span class="line">Successfully signed docker.io/weiyigeek/buysbox:1.33.1-trust</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看生成的根私有密钥和仓库密钥</span></span><br><span class="line">$ ls ~/.docker/trust/private/</span><br><span class="line">0d4041172f5d7286c5199510ad25b795a65bfc774d6e01ce2948c5e217df553f.key  7fcbe50705b0e48526d35b8f928bc52054e899ff08edb44f4fb023fb50979cf1.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.删除可信赖的镜像后并通过远程仓库拉取可信赖镜像</span></span><br><span class="line">$ docker rmi -f weiyigeek/buysbox:1.33.1-trust</span><br><span class="line">$ docker pull docker.io/weiyigeek/buysbox:1.33.1-trust</span><br><span class="line">Pull (1 of 1): weiyigeek/buysbox:1.33.1-trust@sha256:99959645871654685ef84dbc4f3cb541a4f5332505752fbb89f0af80e6c84662  <span class="comment"># 关键点拉取时可以看到内容信任后的特征</span></span><br><span class="line">sha256:99959645871654685ef84dbc4f3cb541a4f5332505752fbb89f0af80e6c84662: Pulling from weiyigeek/buysbox</span><br><span class="line">Digest: sha256:99959645871654685ef84dbc4f3cb541a4f5332505752fbb89f0af80e6c84662</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> weiyigeek/buysbox@sha256:99959645871654685ef84dbc4f3cb541a4f5332505752fbb89f0af80e6c84662</span><br><span class="line">Tagging weiyigeek/buysbox@sha256:99959645871654685ef84dbc4f3cb541a4f5332505752fbb89f0af80e6c84662 as weiyigeek/buysbox:1.33.1-trust</span><br><span class="line">docker.io/weiyigeek/buysbox:1.33.1-trust</span><br></pre></td></tr></table></figure></p>
<p>Tips: 在镜像存储库可以包含同时具有已签名标签和未签名标签的镜像,例如 Mongo 镜像仓库latest 标签是未签名的而 3.1.6 标签是签名的。<br>Tips: 首次调用使用内容信任的操作时会创建密钥集,而密钥集由以下几类密钥组成, <code>1)作为镜像标记的内容信任的根的脱机密钥 2)签名标签的仓库或标签密钥 3)服务器管理的密钥，如时间戳密钥，为仓库提供最新的安全保证</code><br>Tips: 如果是第一次签名Docker 会为当前用户生成一个私钥，保存在 <code>~/docker/trust</code>后续所有的镜像都会使用这个私钥签名,丢失根密钥非常难以恢复纠正这种损失需要 Docker 支持人员的干预来重置仓库状态，所以最好是将应该将根密钥备份到安全的地方。</p>
<p><br></p>
<h3 id="4-检测、修正和监控开源漏洞"><a href="#4-检测、修正和监控开源漏洞" class="headerlink" title="4.检测、修正和监控开源漏洞"></a>4.检测、修正和监控开源漏洞</h3><p>描述: 在指定容器的基础镜像时，同时也引入了该镜像包含的操作系统及系统库有可能存在的所有安全风险。前面我们提到过最好选用能够正常运行应用代码的最小化镜像，这有助于减少攻击面，因为限制了可能的安全漏洞数量。不过这么做并没有对镜像进行安全审计，也不能防范将来发现的新漏洞。</p>
<p>最佳安全实践，我们应该尽可能早地在开发过程中集成安全性，我们越早开始进行安全检查，对组织来说就越便宜，更有效，所以我们要在构建镜像时进行采用辅助扫描工具和安全漏洞库进行集成扫描，例如Snyk、Trivy等工具，其中使用较多的是Snyk引擎。</p>
<ul>
<li>Snyk : 它是一个开发者优先选择的云原生安全工具，该工具可以扫描并监控您的项目构建的基础镜像是否存在安全漏洞，其主要功能是查找并自动修复开源漏洞、实时查找并修复应用程序代码中的漏洞、查找并修复容器镜像和 Kubernetes 应用程序中的漏洞以及查找并修复 Terraform 和 Kubernetes 代码中的不安全配置 ，并且Docker和Snyk建立了合作伙伴关系，以提供容器漏洞扫描以及将Snyk扫描引擎直接集成到docker-cli和Docker Desktop客户端中，但是在此之前我们必须需要将我们构建好的基础环镜像推送到镜像仓库中，才能进行漏洞的扫描，而现在我们可以在上传到仓库前进行镜像漏洞检测。 项目地址: <a href="https://github.com/snyk/snyk" target="_blank" rel="noopener">https://github.com/snyk/snyk</a></li>
</ul>
<ul>
<li>Trivy: 它是是一款简单而全面的扫描仪，用于检查容器映像、文件系统和Git存储库中的漏洞，以及配置问题，它已经被集成到Harbor项目之中为镜像提供安全扫描服务。其主要功能是可以检测操作系统软件包（<code>Alpine、RHEL、CentOS</code>等）和特定语言软件包（<code>Bundler、Composer、npm、Thread</code>等）的漏洞，此外Trivy会将基础设施扫描为代码（IaC）文件，如<code>Terraform、Dockerfile和Kubernetes</code>，以检测可能导致部署面临攻击风险的潜在配置问题，其优点是安装简单，开箱即用。项目地址: <a href="https://github.com/aquasecurity/trivy/" target="_blank" rel="noopener">https://github.com/aquasecurity/trivy/</a></li>
</ul>
<p>温馨提示: 基于扫描效率的考虑，出现了server-client模式，在初次扫描时，server会下载所需的漏洞数据库，并在后台持续获取最新的数据库。</p>
<figure class="image-box">
                <a rel=6.Docker镜像与容器安全最佳实践 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2022/2/20220312144037.png" target="_blank" title="WeiyiGeek.Trivy架构" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2022/2/20220312144037.png" alt="WeiyiGeek.Trivy架构" title="" class=""></a>
                <p>WeiyiGeek.Trivy架构</p>
            </figure>
<p><strong>1.Snyk扫描引擎安装与使用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">步骤01.参考Snyk在github项目地址，我们可以快速进行了解和使用。</span><br><span class="line"><span class="comment"># docker已经集成安装snyk引擎，所以已安装docker的用户无法再次安装snyk。</span></span><br><span class="line">docker scan</span><br><span class="line"></span><br><span class="line">注意: Docker Scan依赖于对第三方提供商Snyk的访问，每月只免费提供10次扫描的限制，如超过此限额使用则可以执行docker scan --login命令进行登陆或者注册Snyk。</span><br><span class="line"></span><br><span class="line">步骤02.在本地使用docker scan命令的好处是，我们可以在推送任何代码之前在本地捕获安全漏洞。</span><br><span class="line"><span class="comment"># 1.使用前需要先登陆docker.io</span></span><br><span class="line">$ docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.snyk 扫描引擎版本查看</span></span><br><span class="line">$ docker scan --version</span><br><span class="line">Version:    v0.12.0</span><br><span class="line">Git commit: 1074dd0</span><br><span class="line">Provider:   Snyk (1.790.0 (standalone))</span><br><span class="line"></span><br><span class="line">步骤03.构建镜像以及扫描构建的镜像存在的安全问题，扫描结果如下图所示。</span><br><span class="line"><span class="comment"># 1.构建并标记镜像</span></span><br><span class="line">docker build -t weiyigeek/go-webserver:v2.0 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.扫描镜像</span></span><br><span class="line">docker scan weiyigeek/go-webserver:v2.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mongo镜像进行扫描</span></span><br><span class="line">docker scan mongo:latest</span><br></pre></td></tr></table></figure></p>
<p>Tips: Snyk 和 Docker 宣布达成合作关系，以帮助开发人员安全地构建和使用容器以及开源,Docker在2.3.6.0或更高版本中包括了一个名为的新命令docker scan。运行docker scan命令时将根据Snyk安全引擎扫描本地镜像，从而使您可以安全查看本地Dockerfile和本地镜像。</p>
<figure class="image-box">
                <a rel=6.Docker镜像与容器安全最佳实践 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2022/1/20220224141400.png" target="_blank" title="WeiyiGeek.Snyk扫描" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2022/1/20220224141400.png" alt="WeiyiGeek.Snyk扫描" title="" class=""></a>
                <p>WeiyiGeek.Snyk扫描</p>
            </figure>
<p><br/></p>
<p><strong>2.Trivy 扫描引擎安装与使用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- 步骤 01.快速进行 Trivy 镜像安全扫描仪安装，主要有两种方式一种是常规的二进制文件方式，第二种则是通过带有该工具的镜像。</span><br><span class="line"><span class="comment"># 方式1</span></span><br><span class="line"><span class="comment"># 1.从Github 的releases中拉取 Trivy 最新的二进制执行文件。</span></span><br><span class="line">wget https://github.com/aquasecurity/trivy/releases/download/v0.23.0/trivy_0.23.0_Linux-64bit.tar.gz -P /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.解压并设置快捷执行方式。</span></span><br><span class="line">tar -zxvf /tmp/trivy_0.23.0_Linux-64bit.tar.gz -C /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.执行权限赋予给trivy二进制文件</span></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/trivy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看trivy版本</span></span><br><span class="line">trivy --version</span><br><span class="line">Version: 0.23.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2.拉取带有Trivy 执行环境的镜像</span></span><br><span class="line">docker pull aquasec/trivy:0.23.0</span><br><span class="line">docker pull ghcr.io/aquasecurity/trivy:0.23.0</span><br><span class="line">docker pull public.ecr.aws/aquasecurity/trivy:0.23.0</span><br><span class="line"></span><br><span class="line">- 步骤 02.我们可以执行扫描镜像命令，注意首次扫描镜像会自动更新下载漏洞库，反馈的扫描结果，如下图所示、</span><br><span class="line"><span class="comment"># 首次扫描可能需要更新漏洞库</span></span><br><span class="line">$ trivy image weiyigeek/go-webserver:v1.0</span><br><span class="line">2022-02-24T11:58:30.219+0800    INFO    Need to update DB</span><br><span class="line">2022-02-24T11:58:30.219+0800    INFO    Downloading DB...</span><br><span class="line"></span><br><span class="line">$ trivy image weiyigeek/go-webserver:v2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 步骤 03.除此之外，我们可以利用其扫描本地目录中的Dockerfile镜像配置文件和远程仓库中的Dockerfile文件扫描，它会针对我们编写的Dockerfile进行检查并给出合理的处理建议，例如。</span><br><span class="line"><span class="comment"># 此处，利用多阶段构建的Dockerfile文件进行演示trivy针对构建文件内容扫描。</span></span><br><span class="line">$ ls</span><br><span class="line">Dockerfile  webserver.go</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描本地配置文件</span></span><br><span class="line">$ trivy config Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描git远程仓库配置文件</span></span><br><span class="line">$ trivy repo https://github.com/weiyigeek/trivy-ci-test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描本地文件系统以查找特定于语言的依赖项和配置文件</span></span><br><span class="line">$ trivy fs /path/to/project</span><br></pre></td></tr></table></figure></p>
<figure class="image-box">
                <a rel=6.Docker镜像与容器安全最佳实践 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2022/1/20220224142119.png" target="_blank" title="WeiyiGeek.trivy扫描" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2022/1/20220224142119.png" alt="WeiyiGeek.trivy扫描" title="" class=""></a>
                <p>WeiyiGeek.trivy扫描</p>
            </figure>
<p>温馨提示: 除了synk和Trivy，其实还有多种工具可以执行镜像安全扫描，例如由Anchore Inc.开发的Anchore和<br>由Quay开发的Clair等</p>
<p><br></p>
<h3 id="5-容器镜像中禁止包含机密信息"><a href="#5-容器镜像中禁止包含机密信息" class="headerlink" title="5.容器镜像中禁止包含机密信息"></a>5.容器镜像中禁止包含机密信息</h3><p>描述: 运维人员在构建包含应用的容器镜像时可能需要用到一些机密信息，例如从私有仓库拉取代码所需的 SSH 私钥，或者安全私有软件包所需的令牌。如果 Dockerfile 中包含复制机密信息的命令，构建镜像时，这行命令对应的中间容器会被缓存，导致机密数据也被缓存，有可能造成机密信息泄漏。因此像令牌和密钥这样的机密信息必须保存在 Dockerfile 之外，所以为了避免机密信息的泄露我们可以采用使用多阶段构建、使用 Docker 的 secret 管理功能、避免无意中复制机密信息等三种方式进行联合使用。</p>
<p><strong>安全实践</strong></p>
<ul>
<li><p>1) 使用多阶段构建: 利用 Docker 的多阶段构建功能，用一个中间镜像层获取和管理机密信息，然后清除中间镜像，这样在应用镜像构建阶段不涉及敏感数据。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例子使用代码将机密信息添加到中间层</span></span><br><span class="line"><span class="keyword">FROM</span>: ubuntu as intermediate</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> secret/key /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> scp -i /tmp/key build@weiyigeek.top/files .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from intermediate /app .</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2) 使用 Docker 的 secret 管理功能：加载敏感信息文件且不会缓存这些信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax = docker/dockerfile:1.0-experimental</span></span><br><span class="line">FROM alpine</span><br><span class="line"><span class="comment"># shows secret from default secret location</span></span><br><span class="line">RUN --mount=<span class="built_in">type</span>=secret,id=mysecret cat /run/secrets/mysecre</span><br><span class="line"><span class="comment"># shows secret from custom secret location</span></span><br><span class="line">RUN --mount=<span class="built_in">type</span>=secret,id=mysecret,dst=/foobar cat /foobar</span><br></pre></td></tr></table></figure>
</li>
<li><p>3) 避免无意中复制机密信息: 在构建镜像时通常都会采用<code>COPY . .</code>的指令将整个构建上下文文件夹复制到 Docker 镜像，但也有可能把敏感文件也复制进去了。所以如果文件夹中有敏感文件，要么先移除这些文件，要么将这些文件包含在<code>.dockerignore</code>中复制时会忽略这些文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat .dockerignore &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">private.key</span><br><span class="line">appsetting.config</span><br><span class="line">appsettings.json</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<h3 id="6-设定镜像的标签，保证镜像的不可更改性"><a href="#6-设定镜像的标签，保证镜像的不可更改性" class="headerlink" title="6.设定镜像的标签，保证镜像的不可更改性"></a>6.设定镜像的标签，保证镜像的不可更改性</h3><p>描述: 每个 Docker 镜像可以有多个标签（tag），代表该镜像的不同变体。最常见的标签是 latest 表示这是该镜像的最新版本。镜像标签是可更改的，也就是说镜像的作者可以多次发布相同标签的镜像。<br>因此，即使你的 Dockerfile 明确指定了使用的基础镜像及其标签，这次镜像构建和下次镜像构建仍然可能用到了不同的基础镜像。</p>
<p><strong>安全实践:</strong></p>
<ul>
<li>1) 优先选用最详细的镜像标签。例如，镜像有<code>8、:8.0.1 和 :8.0.1-alpine</code> 等标签，选择最后这个，因为它提供了最详细的信息,不要建议使用像 latest 这样过于泛泛的标签。</li>
<li>2) 发布者有可能删除镜像的某个标签。应该提前把该镜像复制到私有镜像中心或者公有镜像中心的私人账户下。</li>
<li>3) 使用比签名更具体的 SHA256 引用指明要使用的镜像。好处是能保证每次拉取都是相同内容的镜像，缺点是如果镜像发生改变需要及时的更新SHA256 引用（散列值）。</li>
</ul>
<p><br></p>
<h3 id="7-镜像构建更加安全、快速、精简"><a href="#7-镜像构建更加安全、快速、精简" class="headerlink" title="7.镜像构建更加安全、快速、精简"></a>7.镜像构建更加安全、快速、精简</h3><p>描述: 在实际的生产场景中我们常常需要对基础的镜像根据实际需求编写 dockerfile 进行 build 重构建, 除了前面提到过的最小的基础镜像外，还需要注意下面的几个方面囊括了LABEL、COPY与ADD等指令</p>
<p><strong>安全实践:</strong></p>
<ul>
<li><p>(1) 使用 LABEL 指定镜像元数据: 镜像元数据有助于用户更好地理解和使用该镜像并且除了镜像的维护者信息，添加其他你认为重要的元数据，包括提交对象的散列值、相关构建的链接、质量状态（通过所有测试了吗？）、源代码链接、SECURITY.TXT 文件的位置等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER </span><br><span class="line">LABEL maintainer=<span class="string">"test@weiyigeek.top"</span></span><br><span class="line">LABEL securitytxt=<span class="string">"https://www.example.com/.well-known/security.txt"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>(2) 尽量使用COPY而非ADD指令: 从而为了避免可能导致的安全问题请记住 COPY 和 ADD 的不同</p>
<ul>
<li>COPY - 将本地文件或者目录（递归）复制到容器镜像中的目标目录，复制来源和目标都必须明确指定。</li>
<li>ADD - 1) 如果复制来源是本地压缩文件，ADD 将把该文件解压缩到目标目录; 2) ADD 也可以将远程 URL 指定的文件下载到目标目录。</li>
</ul>
</li>
</ul>
<p>Q: 使用<code>COPY</code>指令相比较于<code>ADD</code>指令的优点及安全性?</p>
<blockquote>
<p>使用 ADD 从远程 URL 下载文件，存在中间人攻击的风险，文件内容有可能因此被篡改。必须确保远程 URL 必须是安全的 TLS 链接，校验远程 URL 的来源和身份。译者注：实际上，官方文档并不鼓励使用 ADD 添加远程文件。<br>如果复制的是本地压缩文件，ADD 自动将它解压缩到目标目录，这有可能触发 zip 炸弹或者 zip 任意文件覆盖漏洞。<br>相比较而言使用 COPY 复制文件或目录，会创建一个缓存的中间镜像层，优化镜像构建的速度。</p>
</blockquote>
<ul>
<li><p>(3) 善用RUN指令: 在<code>dockerfile</code>之中我们常常能看见<code>RUN指令</code>的身影, 所以为了减少镜像构建时的Layer的数量, 我们可以通过将所有RUN命令合并成为一条命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1：添加用户并加入到用户组里并创建一个app目录设置weiyigeek为所属者我们只需要一个RUN指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd weiyigeek &amp;&amp; \</span></span><br><span class="line"><span class="bash">    useradd weiyigeek -r -s /bin/<span class="literal">false</span> -g weiyigeek &amp;&amp;</span></span><br><span class="line">    mkdir /app &amp;&amp; \</span><br><span class="line">    chown weiyigeek:weiyigeek -R /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># Bad, Creates 4 layers</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum --disablerepo=* --enablerepo=<span class="string">"epel"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y httpd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum clean all -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Good, creates only 1 layer</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum --disablerepo=* --enablerepo=<span class="string">"epel"</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">  yum update &amp;&amp; \</span></span><br><span class="line"><span class="bash">  yum install -y httpd &amp;&amp; \</span></span><br><span class="line"><span class="bash">  yum clean all -y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>(4) 缓存以加快构建速度: 镜像的构建时间大都花在系统软件包和应用程序依赖包的下载和安装。但是，这些通常不会经常变更，因此推荐进行缓存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DOCKER_BUILDKIT=1</span><br><span class="line"><span class="comment"># 使用命令--mount选项RUN来选择缓存目录</span></span><br><span class="line">FROM python:3.8 </span><br><span class="line">COPY pom.xml ./pom.xml                   <span class="comment"># Java</span></span><br><span class="line">RUN --mount=<span class="built_in">type</span>=cache,target=/root/.m2 mvn dependency:go-offline -B             <span class="comment"># Java</span></span><br><span class="line"></span><br><span class="line">FROM openjdk:15.0.1</span><br><span class="line">COPY requirements.txt ./requirements.txt <span class="comment"># Python</span></span><br><span class="line">RUN --mount=<span class="built_in">type</span>=cache,target=/root/.cache/pip pip install -r requirements.txt   <span class="comment"># Python</span></span><br><span class="line"><span class="comment"># 镜像构建</span></span><br><span class="line">docker build -t python:3.8-test .</span><br></pre></td></tr></table></figure>
</li>
<li><p>(5) 使用多阶段构建小而安全的镜像: 使用 Dockerfile 构建应用容器镜像时，会生成很多只是构建时需要的镜像层，包括编译时所需的开发工具和库，运行单元测试所需的依赖、临时文件、机密信息等等, 如果保留这些镜像层，不仅会增加镜像的大小，影响镜像下载速度，而且会因为安装更多软件包而面临更大的攻击危险。所以在实践环境中我们常常将软件构建阶段所需的镜像存放到内部的镜像仓库之中,并不会将它用来作为运行应用的环境。</p>
</li>
</ul>
<p><br/></p>
<p>Docker 为我们提供了多阶段构建的功能，允许在构建过程中使用多个临时镜像，只保留最后一个镜像，因此用户可以得到两个镜像:</p>
<ul>
<li>第一个镜像——非常大的镜像，包含了构建应用和运行测试所需的所有依赖；</li>
<li>第二个镜像——非常小的镜像，只包含运行应用所需的极少数依赖。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段</span></span><br><span class="line"><span class="keyword">FROM</span> golang as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="comment"># Static build is required so that we can safely use 'scratch' base image</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> CGO_ENABLED=0 go install -ldflags <span class="string">'-extldflags "-static"'</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /go/bin/app /app</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/app"</span>]</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="8-使用静态分析工具-Dockerfile编写指导"><a href="#8-使用静态分析工具-Dockerfile编写指导" class="headerlink" title="8.使用静态分析工具,Dockerfile编写指导"></a>8.使用静态分析工具,Dockerfile编写指导</h3><p>描述: 使用静态分析工具，能够避免常见的错误，建立工程师自动遵循的最佳实践指南，在集成开发环境（IDE）中使用 hadolint 更好。</p>
<p>例如，使用hadolint工具分析 Dockerfile 并列出不符合最佳实践规则的地方，或者在 VS Code 安装的 hadolint 扩展后，编写 Dockerfile 时边写边检查既快又好。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -i hadolint/hadolint &lt; Dockerfile</span><br></pre></td></tr></table></figure><br><figure class="image-box">
                <a rel=6.Docker镜像与容器安全最佳实践 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210615182435.png" target="_blank" title="WeiyiGeek." data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210615182435.png" alt="WeiyiGeek." title="" class=""></a>
                <p>WeiyiGeek.</p>
            </figure></p>
<p><br></p>
<h2 id="0x02-Docker-容器安全最佳实践"><a href="#0x02-Docker-容器安全最佳实践" class="headerlink" title="0x02 Docker 容器安全最佳实践"></a>0x02 Docker 容器安全最佳实践</h2><h3 id="1-主机安全配置"><a href="#1-主机安全配置" class="headerlink" title="1.主机安全配置"></a>1.主机安全配置</h3><h4 id="1-1-更新docker到最新版本"><a href="#1-1-更新docker到最新版本" class="headerlink" title="1.1 更新docker到最新版本"></a>1.1 更新docker到最新版本</h4><p>描述: Docker频繁发布更新，旧版本可能存在安全漏洞，应及时更新。<br>加固说明: 通过及时了解Docker更新，Docker中的漏洞可以得到修复。攻击者可能会尝试获得访问权限或提升权限时利用已知的漏洞。不安装常规的Docker更新可能会让现有的Docker受到攻击。可能会导致提升权限，未经授权的访问或其他安全漏洞。所以需要跟踪新版本并根据需要进行更新。<br>判断方法: 和最新版本进行比对，查看是否为最新。<br>检测加固: 检查docker版本是否为最新docker version,跟踪Docker发布并根据需要进行更新。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.检查docker版本是否为最新,和最新版本进行比对，查看是否为最新。</span></span><br><span class="line">$ docker version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.跟踪Docker发布并根据需要进行更新，例如此处在ubuntu上更新docker。</span></span><br><span class="line">$ apt update &amp;&amp; apt-cache madison docker-ce</span><br><span class="line">docker-ce | 5:20.10.12~3-0~ubuntu-focal | https://download.docker.com/linux/ubuntu focal/stable amd64 Packages</span><br><span class="line">$ apt install docker-ce docker-ce-cli</span><br></pre></td></tr></table></figure><br>操作影响: 有些使用Docker的第三方产品可能依赖较老版本的Docker。<br>默认值: 不适用<br>备注: Docker频频曝出漏洞问题，应密切关注容器安全相关漏洞</p>
<p><br/></p>
<h4 id="1-2-为容器创建一个单独的分区"><a href="#1-2-为容器创建一个单独的分区" class="headerlink" title="1.2 为容器创建一个单独的分区"></a>1.2 为容器创建一个单独的分区</h4><p>描述: 默认情况下，所有Docker容器、镜像及数据和元数据都存储在 <code>/var/lib/docker</code> 目录下。<br>加固说明: /var/lib/docker作为docker默认目录，其存储所有Docker相关文件，包括镜像文件。该目录写满时，会导致Docker、甚至主机可能无法使用。因此，建议为Docker创建一个单独的分区。<br>判断方法: 应该返回<code>/var/lib/docker</code>挂载点的分区详细信息。<br>检测加固: 新安装docker时为<code>/var/lib/docker</code>挂载点创建一个单独的分区,对于先前安装的系统可使用LVM创建分区。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.查看docker数据目录</span></span><br><span class="line"><span class="comment"># $ df -h | grep docker</span></span><br><span class="line">$ docker info -f <span class="string">'&#123;&#123;.DockerRootDir&#125;&#125;'</span></span><br><span class="line">/app/docker</span><br><span class="line">$ docker info | grep <span class="string">"Docker Root Dir:"</span></span><br><span class="line">Docker Root Dir: /app/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.配置 docker data 数据挂载点，修改后重载systemd守护进行以及重新docker服务。</span></span><br><span class="line">$ vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 在json格式的 &#123;&#125; 中加入如下字段及内容。</span></span><br><span class="line"><span class="string">"data-root"</span>: <span class="string">"/app/docker"</span>,</span><br><span class="line">$ systemctl daemon-reload &amp;&amp; systemctl restart</span><br></pre></td></tr></table></figure><br>操作影响: None<br>默认值: /var/lib/docker将根据可用性挂载在/或/var分区下。</p>
<p><br/></p>
<h4 id="1-3-只有受信任的用户才能控制docker守护进程"><a href="#1-3-只有受信任的用户才能控制docker守护进程" class="headerlink" title="1.3 只有受信任的用户才能控制docker守护进程"></a>1.3 只有受信任的用户才能控制docker守护进程</h4><p>描述: Docker守护进程绑定到unix socks需要root权限运行。对于添加到docker组的用户为提供了完整的root访问权限。<br>加固说明: Docker允许在Docker主机和容器之间共享目录，而不会限制容器的访问权限。这意味着可以启动容器并将主机上的根目录映射到容器。容器将能够不受任何限制地更改的主机文件系统。<br>判断方法:    判断是否必须要加入docker组的用户<br>检测加固:    检查docker用户组里的用户.从’docker’组中删除任何不受信任的用户,不要在主机上创建敏感目录到容器卷的映射。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议docker组中不包含root或者其他高权限用户。</span></span><br><span class="line"><span class="comment"># 建立 docker 组： $ sudo groupadd docker</span></span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span>   <span class="comment"># 将当前低权限用户加入 docker 组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查系统中用户组里的用户是否必须要加入docker组的用户</span></span><br><span class="line">$ grep <span class="string">"docker"</span> /etc/group</span><br><span class="line">docker:x:998:root,app</span><br></pre></td></tr></table></figure><br>操作影响:    作为普通用户构建和执行容器的权限将受到限制<br>默认值:    不适用</p>
<p><br/></p>
<h4 id="1-4-审计docker守护进程"><a href="#1-4-审计docker守护进程" class="headerlink" title="1.4 审计docker守护进程"></a>1.4 审计docker守护进程</h4><p>描述：审计所有活动的Docker守护进程<br>加固说明：除了审核常规的Linux文件系统和系统调用外，还要审Docker守护进程。Docker守护进程以root特权运行。因此有必要审核其活动和使用情况。<br>判断方法：应该列出Docker守护进程的规则<br>检测加固：验证是否存在Docker守护进程的审计规则，并为Docker守护进程添加审计规则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装审计进程</span></span><br><span class="line">sudo apt install auditd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker守护进程的审核规则</span></span><br><span class="line">auditctl -l | grep /usr/bin/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用命令向 /etc/audit/audit.rules 添加审计规则</span></span><br><span class="line">auditctl -w /usr/bin/docker -k docker</span><br><span class="line"><span class="comment"># 重新启动审计守护进程</span></span><br><span class="line">systemctl restart auditd.service</span><br></pre></td></tr></table></figure><br>操作影响：审计生成相当大的日志文件,确保定期归档它们，另外建议创建一个单独的审计分区以避免写满根文件系统。<br>默认值：默认安装后，Docker守护进程没有审计</p>
<p><br/></p>
<h4 id="1-5-审计docker相关的文件和目录"><a href="#1-5-审计docker相关的文件和目录" class="headerlink" title="1.5 审计docker相关的文件和目录"></a>1.5 审计docker相关的文件和目录</h4><p>描述: 在条件允许的情况，审计docker相关的文件和目录，例如 docker.service、/etc/default/docker、/etc/docker docker.socket、daemon.json、/var/lib/docker<br>加固说明    除了正常的Linux文件系统和系统调用审核外，还可以审核所有与Docker相关的文件和目录。Docker守护进程以root权限运行。<br>判断方法: 如果以上文件存在，验证是否存在与之对应的审核规则,应该根据其位置列出docker相关的规则。<br>检测加固方法: 添加审计规则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 /etc/audit/audit.rules 文件中添加以下行,然后重新启动审计守护进程</span></span><br><span class="line">$ touch /etc/audit/rules.d/docker-audit.rules</span><br><span class="line">$ cat &gt; /etc/audit/rules.d/docker-audit.rules &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">-w /usr/bin/docker -k docker</span><br><span class="line">-w /usr/lib/systemd/system/docker.service -k docker </span><br><span class="line">-w /usr/lib/systemd/system/docker.socket -k docker</span><br><span class="line">-w /usr/bin/docker-containerd -k docker</span><br><span class="line">-w /usr/bin/docker-runc -k docker</span><br><span class="line">-w /etc/docker -k docker</span><br><span class="line">-w /etc/docker/daemon.json -k docker</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><br>操作影响: 审核会生成相当大的日志文件。确保定期归档。另外需要创建一个单独的审计分区，以避免填写根文件系统。<br>默认值: 默认情况下，Docker相关的文件和目录不会被审计，文件 docker.service 可能在系统上不可用</p>
<hr>
<h3 id="2-docker守护进程配置"><a href="#2-docker守护进程配置" class="headerlink" title="2.docker守护进程配置"></a>2.docker守护进程配置</h3><h4 id="2-1-限制默认网桥上容器之间的网络流量"><a href="#2-1-限制默认网桥上容器之间的网络流量" class="headerlink" title="2.1 限制默认网桥上容器之间的网络流量"></a>2.1 限制默认网桥上容器之间的网络流量</h4><p>描述: 默认情况下网桥上同一主机上的容器之间允许所有网络通信。如果不需要所有网络通信，建议限制容器间通信。将需要通信的特定容器链接在一起。或者创建自定义网络，并只加入需要与该自定义网络通信的容器。<br>加固说明: 每个容器都有可能读取同一主机上容器网络上的所有数据包。这可能会导致意外和不必要的信息泄露给其他容器。因此，限制默认网桥上的容器间通信。<br>判断方法: 它应该返回默认网桥的com.docker.network.bridge.enable_icc：false。<br>检测加固: 在守护进程模式下运行docker并传递–icc=false作为参数或创建自定义网络,注意–icc参数仅适用于默认网桥，如果使用自定义网络，则应采用分段网络的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行以下命令并确认默认网桥已被配置为限制集装箱间通信。</span></span><br><span class="line">docker network ls -q | xargs docker network inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125;: &#123;&#123;.Options&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置不同容器之间是不允许网络互通的。</span></span><br></pre></td></tr></table></figure><br>操作影响: 默认网桥上的容器间通信将被禁用。如果需要在同一主机上的容器之间进行通信，则需要使用容器链接来明确定义它，或者必须定义自定义网络。<br>默认值: 默认情况下，默认网桥上允许所有容器间通信。</p>
<p><br/></p>
<h4 id="2-2-设置日志级别为info"><a href="#2-2-设置日志级别为info" class="headerlink" title="2.2 设置日志级别为info"></a>2.2 设置日志级别为info</h4><p>描述: 将Docker守护进程日志级别设置为info。<br>加固说明: 设置适当的日志级别，配置Docker守护进程以记录需要查看的事件。info及以上的基准日志级别将捕获除调试日志之外的所有日志。若无必须，不应该在’debug’日志级别运行Docker守护进程<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保--log-level参数不存在或存在，然后将其设置 info。</span></span><br><span class="line">ps -ef | grep dockerd</span><br><span class="line">grep <span class="string">"log-level"</span> | /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行Docker守护进程参数如下。</span></span><br><span class="line">Dockerd --<span class="built_in">log</span>-level=info</span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 默认情况下，Docker守护进程设置为info的日志级别。</p>
<p><br/></p>
<h4 id="2-3-允许-docker-更改iptables"><a href="#2-3-允许-docker-更改iptables" class="headerlink" title="2.3 允许 docker 更改iptables"></a>2.3 允许 docker 更改iptables</h4><p>描述: iptables用于建立、维护和检查Linux内核中的IP包过滤规则表。允许Docker守护进程更改iptables<br>加固说明: Docker会根据用户为容器选择网络选项的方式自动对iptables进行必要的更改。建议让Docker自动更改iptables，以避免可能妨碍容器与外界通信的网络配置错误。<br>检测加固: 不要使用’–iptables=false’参数运行Docker守护进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保'--iptables'参数不存在或不设置为'false'</span></span><br><span class="line">ps -ef | grep dockerd</span><br></pre></td></tr></table></figure><br>操作影响: Docker守护进程需要在启动之前启用iptables规则。在Docker守护进程操作期间任何重新启动iptables都可能导致丢失docker创建的规则。使用iptables-persistent持久iptables规则可以帮助减轻这种操作影响。<br>默认值: 默认情况下，’iptables’设置为’true’。</p>
<p><br/></p>
<h4 id="2-4-不使用不安全的镜像仓库"><a href="#2-4-不使用不安全的镜像仓库" class="headerlink" title="2.4 不使用不安全的镜像仓库"></a>2.4 不使用不安全的镜像仓库</h4><p>描述: Docker在默认情况下私有仓库被认为是相对安全的，所以我们需要保证私有镜像仓库的安全。<br>加固说明: 一个安全的镜像仓库建议使用TLS,在 <code>/etc/docker/certs.d/&lt;registry-name&gt;/</code>目录下，将镜像仓库的CA证书副本放置在Docker主机上。不安全的镜像仓库是没有有效的镜像仓库证书或不使用TLS的镜像仓库。不应该在生产环境中使用任何不安全的镜像仓库。不安全的镜像仓库中的镜像可能会被篡改，从而导致生产系统可能受到损害。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用镜像扫描工具检测, 验证本地或者远程镜像仓库是否存在不安全的基础镜像。</span></span><br><span class="line"><span class="comment"># 查看镜像所属以及构建操作</span></span><br><span class="line">docker images </span><br><span class="line">docker <span class="built_in">history</span></span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 默认情况下，Docker假定所有的本地镜像仓库都是安全的。<br>备注: Hub仓库中中各基础发行版官方的镜像也可能是不安全的，我们需要用镜像扫描工具进行扫描验证。</p>
<p><br/></p>
<h4 id="2-5-建议不使用aufs存储驱动程序"><a href="#2-5-建议不使用aufs存储驱动程序" class="headerlink" title="2.5 建议不使用aufs存储驱动程序"></a>2.5 建议不使用aufs存储驱动程序</h4><p>描述：不要使用’aufs’作为Docker实例的存储驱动<br>加固说明：aufs代码太烂没能加入Linux内核主线，在Docker中只是保留了历史遗留支持,<br>检测加固：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令并验证aufs不被用作存储驱动，此时命令结果不应该返回aufs。</span></span><br><span class="line">docker info | grep -e StorageDriver:\s*aufs\s*$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在启动dockerd不要设置--storage-driveraufs参数，不要刻意的使用'aufs'作为存储驱动。</span></span><br><span class="line">dockerd --storage-driveraufs</span><br></pre></td></tr></table></figure><br>操作影响：aufs’是允许容器共享可执行文件和共享库内存的存储驱动程序。如果使用相同的程序或库运行数千个容器可以选用。<br>默认值：默认情况下，在大多数平台上使用overlay2和devicemapper作为Docker存储驱动程序。默认存储驱动程序可能因操作系统而异。应该首选操作系统最佳支持的存储驱动程序。<br>备注：在许多使用最新Linux内核的发行版中，’aufs’不再被支持。</p>
<p><br/></p>
<h4 id="2-6-docker守护进程配置TLS身份认证"><a href="#2-6-docker守护进程配置TLS身份认证" class="headerlink" title="2.6 docker守护进程配置TLS身份认证"></a>2.6 docker守护进程配置TLS身份认证</h4><p>描述：可以让Docker守护进程监听特定的IP和端口以及除默认Unix套接字以外的任何其他Unix套接字。配置TLS身份验证以限制通过IP和端口访问Docker守护进程。<br>加固说明：默认情况下，Docker守护进程绑定到非联网的Unix套接字，并以root权限运行。如果将默认的docker守护进程更改为绑定到TCP端口或任何其他Unix套接字，那么任何有权访问该端口或套接字的人都可以完全访问Docker守护进程，进而可以访问主机系统。因此，不应该将Docker守护进程绑定到另一个IP/端口或Unix套接字。如果必须通过网络套接字暴露Docker守护进程，建议为守护进程和 Docker Swarm API配置TLS身份验证。<br>检测加固: 按照Docker文档或其他参考中提到的步骤进行操作.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行如下命令，确保存在以下参数：'--tlsverify'·'--tlscacert'·'--tlscert'·'--tlskey'</span></span><br><span class="line">ps -ef | grep dockerd</span><br></pre></td></tr></table></figure><br>操作影响: 需要管理Docker守护进程和Docker客户端的证书和密钥。<br>默认值: 默认情况下，未配置TLS认证<br>备注    </p>
<p><br/> </p>
<h4 id="2-7-配置合适的-ulimit-资源控制"><a href="#2-7-配置合适的-ulimit-资源控制" class="headerlink" title="2.7 配置合适的 ulimit 资源控制"></a>2.7 配置合适的 ulimit 资源控制</h4><p>描述: 根据业务环境设置默认的ulimit选项<br>加固说明：ulimit提供对shell可用资源的控制。设置系统资源控制可以防止资源耗尽带来的问题，如fork炸弹。有时候合法的用户和进程也可能过度使用系统资源，导致系统资源耗尽。为Docker守护进程设置默认ulimit将强制执行所有容器的ulimit。不需要单独为每个容器设置ulimit。但默认的ulimit可能在容器运行时被覆盖。因此，要控制系统资源，需要自定义默认的ulimit。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保根据需要设置'--default-ulimit'参数</span></span><br><span class="line">ps -ef| grep dockerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在守护进程模式下运行docker，并根据相应的ulimits传递'--default-ulimit'作为参数。</span></span><br><span class="line">dockerd --default-ulimit nproc=1024:2408 --default-ulimit nofile=100:200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 daemon.json 中设置</span></span><br><span class="line"><span class="string">"default-ulimits"</span>: &#123;</span><br><span class="line">    <span class="string">"nofile"</span>: &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"nofile"</span>,</span><br><span class="line">        <span class="string">"Hard"</span>: 1024000,</span><br><span class="line">        <span class="string">"Soft"</span>: 1024000</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"nproc"</span>: &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"nproc"</span>,</span><br><span class="line">        <span class="string">"Hard"</span>: 1024000,</span><br><span class="line">        <span class="string">"Soft"</span>: 1024000</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"core"</span>: &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"core"</span>,</span><br><span class="line">        <span class="string">"Hard"</span>: -1,</span><br><span class="line">        <span class="string">"Soft"</span>: -1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>操作影响: 如果ulimits未正确设置，则可能无法实现所需的资源控制，甚至可能导致系统无法使用<br>默认值: 默认情况下，不设置ulimit<br>备注:    慎用</p>
<p><br/> </p>
<h4 id="2-8-启用用户命名空间"><a href="#2-8-启用用户命名空间" class="headerlink" title="2.8 启用用户命名空间"></a>2.8 启用用户命名空间</h4><p>描述: 在Docker守护进程中启用用户命名空间支持，可对用户进行重新映射。该建议对镜像中没有指定用户是有帮助的。如果在容器镜像中已经定义了非root运行，可跳过此建议，因为该功能比较新，可能会给带来不可预测的问题。<br>加固说明: Docker守护进程中对Linux内核用户命名空间支持为Docker主机系统提供了额外的安全性。它允许容器具有独特的用户和组ID，这些用户和组ID在主机系统所使用的传统用户和组范围之外。root用户希望有容器内的管理权限，可映射到主机系统上的非root的UID上。<br>检测加固：可参考Docke文档了解具体的配置方式。操作可能因平台而异在RedHat上，子UID和子GID映射创建不会自动工作。必须。确保存在/etc/subuid 、/etc/subgid 并使用–userns-remap标志启动docker守护进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行命令将查找容器的PID，然后列出与容器进程关联的主机用户。如果容器进程以root身份运行，则不符合安全要求。</span></span><br><span class="line">~$ ps -o pid,user,<span class="built_in">command</span> `docker inspect -format=<span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> $(docker ps -aq) | cut -d <span class="string">'='</span> -f 2`</span><br><span class="line">    PID USER     COMMAND</span><br><span class="line">  22429 root     /bin/bash /usr/<span class="built_in">local</span>/bin/start.sh</span><br><span class="line">  22619 10000    /home/chart/chartm</span><br><span class="line">  22638 10000    nginx: master process nginx -g daemon off;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动创建映射,手动设置docker启用标志启动</span></span><br><span class="line">touch /etc/subuid /etc/subgid</span><br><span class="line">dockerd --userns-remap=default</span><br></pre></td></tr></table></figure><br>操作影响: 注意用户命名空间重新映射使得一些Docker功能不兼容，可查看Docker文档和参考链接以获取详细信息。<br>默认值: 默认情况下，用户命名空间不会重新映射。</p>
<p><br/></p>
<h4 id="2-9-使用默认cgroup"><a href="#2-9-使用默认cgroup" class="headerlink" title="2.9 使用默认cgroup"></a>2.9 使用默认cgroup</h4><p>描述: 查看–cgroup-parent 选项允许设置用于所有容器的默认 cgroup parent。如果没有特定用例,则该设置应保留默认值。<br>加固说明: 系统管理员可定义容器应运行的cgroup。若系统管理员没有明确定义cgroup，容器也会在docker cgroup下运行。应该监测和确认使用情况。通过加到与默认不同的cgroup，导致不合理地共享资源，从而可能会主机资源耗尽。<br>检测加固：默认设置够用的话可保留。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行如下命令，确保'--cgroup-parent'参数未设置或设置为适当的非默认cgroup。</span></span><br><span class="line">ps -ef | grep dockerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要特别设置非默认cgroup，在启动时将-cgroup-parent参数传递给docker守护进程。</span></span><br><span class="line">dockerd --cgroup-parent=/foobar</span><br></pre></td></tr></table></figure><br>加固方法: 默认设置够用的话，可保留。如果要特别设置非默认cgroup，<br>操作影响:    None<br>默认值:  如果未设置此选项，则默认为 /docker为了 fs cgroup 驱动程序和 system.slice用于 systemd cgroup 驱动程序。<br>如果 cgroup 有一个前导正斜杠 ( /)，创建 cgroup 在根 cgroup 下，否则在 daemon 下创建 cgroup c组。假设守护进程在 cgroup 中运行 <code>daemoncgroup, --cgroup-parent=/foobar</code>在中创建一个 <code>cgroup /sys/fs/cgroup/memory/foobar</code>，而使用 –cgroup-parent=foobar 在中创建 <code>cgroup /sys/fs/cgroup/memory/daemoncgroup/foobar</code></p>
<p><br/></p>
<h4 id="2-10-启用docker客户端命令的授权"><a href="#2-10-启用docker客户端命令的授权" class="headerlink" title="2.10 启用docker客户端命令的授权"></a>2.10 启用docker客户端命令的授权</h4><p>描述: 使用本机Docker授权插件或第三方授权机制与Docker守护进程来管理对Docker客户端命令的访问。<br>加固说明: Docker默认是没有对客户端命令进行授权管理的功能。任何有权访问Docker守护进程的用户都可以运行任何Docker客户端命令。对于使用Docker远程API来调用守护进程的调用者也是如此。如果需要细粒度的访问控制，可以使用授权插件并将其添加到Docker守护进程配置中。使用授权插件，Docker管理员可以配置更细粒度访问策略来管理对Docker守护进程的访问。Docker的第三方集成可以实现他们自己的授权模型，以要求Docker的本地授权插件（即Kubernetes，CloudFoundry，Openshift）之外的Docker守护进程的授权。<br>检测加固：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果使用docker本地授权，可使用--authorization-plugin参数加载授权插件。</span></span><br><span class="line">ps -ef | grep dockerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加固流程</span></span><br><span class="line">第1步：安装/创建授权插件。</span><br><span class="line">第2步：根据需要配置授权策略。</span><br><span class="line">第3步：重启docker守护进程</span><br></pre></td></tr></table></figure><br>操作影响: 使用授权插件可能会导致性能下降。<br>默认值: 默认情况下，未设置授权插件。<br><br/></p>
<h4 id="2-11-配置集中和远程日志记录"><a href="#2-11-配置集中和远程日志记录" class="headerlink" title="2.11 配置集中和远程日志记录"></a>2.11 配置集中和远程日志记录</h4><p>描述: Docker现在支持各种日志驱动程序, 存储日志的最佳方式是支持集中式和远程日志记录。<br>加固说明: 集中和远程日志确保所有重要的日志记录都是安全的，以满足容灾的要求。Docker支持多种类型的日志驱动程序，可根据自身情况选取。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行docker info并确保日志记录驱动程序属性被设置为适当的。</span></span><br><span class="line">docker info --format <span class="string">'&#123;&#123;.LoggingDriver&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可通过如下命令查看 --log-driver 的设置。</span></span><br><span class="line">ps -ef | grep dockerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加固流程</span></span><br><span class="line">第1步：按照其文档设置所需的日志驱动程序。</span><br><span class="line">第2步：使用该日志记录驱动程序启动docker守护进程。</span><br><span class="line">dockerd --<span class="built_in">log</span>-driver=syslog --<span class="built_in">log</span>-optsyslog-address=tcp://10.10.107.233</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># 设置log-driver字段值为syslog并添到daemon.json 文件中</span></span><br><span class="line">$ vim /etc/docker/daemon.json</span><br><span class="line"><span class="string">"log-driver"</span>: <span class="string">"syslog"</span>,</span><br><span class="line">  <span class="string">"log-level"</span>: <span class="string">"info"</span>,</span><br><span class="line">  <span class="string">"log-opts"</span>: &#123;</span><br><span class="line">    <span class="string">"syslog-address"</span>: <span class="string">"tcp://10.10.107.233"</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><br>操作影响: None<br>默认值: 默认情况下，容器日志为json文件格式</p>
<p><br/></p>
<h4 id="2-12-禁用docker-resitry-v1版本支持"><a href="#2-12-禁用docker-resitry-v1版本支持" class="headerlink" title="2.12 禁用docker resitry v1版本支持"></a>2.12 禁用docker resitry v1版本支持</h4><p>描述: 最新的Docker registry版本是v2。v1版本存在很多安全问题，V1上的所有操作都应受到限制<br>加固说明: Docker镜像仓库v2在v1中引入了许多性能和安全性改进。它支持容器镜像来源验证和其他安全功能。因此对DockerV1仓库的操作应该受到限制。好在当前<code>20.10.x</code>已经不再针对仅支持旧版 v1 协议的注册表进行操作支持的，但是一些旧的版本是仍然支持的，此时可以采用如下方法禁用。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的命令应该列出--disable-legacy-registry作为传递给docker守护进程的选项。</span></span><br><span class="line">ps -ef | grep dockerd</span><br><span class="line">grep <span class="string">"disable-legacy-registry"</span> /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 daemon.json 文件中配置 disable-legacy-registry 字段</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="string">"disable-legacy-registry"</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure><br>操作影响: 旧版镜像仓库操作将受到限制<br>默认值: 默认情况下，允许旧版镜像仓库操作<br>备注    </p>
<p><br/></p>
<h4 id="2-13-启用实时恢复"><a href="#2-13-启用实时恢复" class="headerlink" title="2.13 启用实时恢复"></a>2.13 启用实时恢复</h4><p>描述: 使用–live-restore参数可以支持无守护进程的容器运行。它确保Docker daemon在关闭或恢复时不会停止容器，并在重新启动后重新连接到容器。<br>加固说明: 可用性作为安全一个重要的属性, 在Docker守护进程中设置<code>&#39;--live-restore&#39;</code>标志可确保当docker守护进程不可用时容器执行不会中断,这也意味着当更新和修复docker守护进程而不会导致容器停止工作。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保LiveRestoreEnabled属性设置为true。</span></span><br><span class="line">docker info --format <span class="string">'&#123;&#123;.LiveRestoreEnabled&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 daemon.json 文件中配置live-restore字段</span></span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="string">"live-restore"</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure><br>操作影响: None<br>默认值: 默认情况下–live-restore不启用<br>备注    </p>
<p><br/></p>
<h4 id="2-14-禁用-userland-代理"><a href="#2-14-禁用-userland-代理" class="headerlink" title="2.14 禁用 userland 代理"></a>2.14 禁用 userland 代理</h4><p>描述: 当容器端口需要被映射时，docker守护进程都会启动用于端口转发的userland-proxy方式, 如果使用了DNAT方式则该功能可以禁用，是否使用用户态代理来实现容器间和出容器的回环通信。<br>加固说明: Docker引擎提供了两种机制将主机端口转发到容器,DNAT和userland-proxy。在大多数情况下，DNAT模式是首选，因为它提高了性能，并使用本地Linux iptables功能而需要附加组件, 如果DNAT可用，则应在启动时禁用userland-proxy以减少安全风险。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保--userland-proxy参数设置为false。</span></span><br><span class="line">ps -ef | grep dockerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行Docker守护进程如下：</span></span><br><span class="line">dockerd --userland-proxy=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者设置userland-proxy字段值为false并添到daemon.json 文件中</span></span><br><span class="line">$ vim /etc/docker/daemon.json</span><br><span class="line"> <span class="string">"userland-proxy"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="string">"userland-proxy-path"</span>: <span class="string">"/usr/libexec/docker-proxy"</span>,</span><br></pre></td></tr></table></figure><br>操作影响: 某些旧版Linux内核的系统可能无法支持DNAT，因此需要userland-prox服务。此外，某些网络设置可能会因删除userland-prox而受到操作影响。<br>默认值: 默认情况下，userland-prox已启用。<br>备注：建议使用较新内核的Linux发行版</p>
<p><br></p>
<h4 id="2-15-限制容器获取新的权限"><a href="#2-15-限制容器获取新的权限" class="headerlink" title="2.15 限制容器获取新的权限"></a>2.15 限制容器获取新的权限</h4><p>描述: 默认情况下，限制容器通过suid或sgid位获取附加权限。<br>加固说明: 一个进程可以在内核中设置no_new_priv。它支持fork，clone和execve。no_new_priv确保进程或其子进程不会通过suid或sgid位获得任何其他特权。这样，很多危险的操作就降低安全风险。在守护程序级别进行设置可确保默认情况下，所有新容器不能获取新的权限。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保--no-new-privileges参数存在且未设置为false。</span></span><br><span class="line">ps -ef | grep dockerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行Docker守护进程如下：</span></span><br><span class="line">dockerd --no-new-privileges</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置no-new-privileges字段值为false并添到daemon.json 文件中</span></span><br><span class="line"><span class="string">"no-new-privileges"</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure><br>操作影响：no_new_priv会阻止像SELinux这样的LSM访问当前进程的进程标签。<br>默认值：默认情况下，容器不会获得新的权限。<br>备注    </p>
<hr>
<h3 id="3-docker-守护进程文件配置"><a href="#3-docker-守护进程文件配置" class="headerlink" title="3.docker 守护进程文件配置"></a>3.docker 守护进程文件配置</h3><h4 id="3-1-设置-docker-service-文件所属和权限"><a href="#3-1-设置-docker-service-文件所属和权限" class="headerlink" title="3.1 设置 docker.service 文件所属和权限"></a>3.1 设置 docker.service 文件所属和权限</h4><p>描述：验证’docker.service’文件所属和所属组是否正确设置为root。文件权限是否正确设置为’644’或更多限制。<br>加固说明：docker.service’文件包含可能会改变Docker守护进程行为的敏感参数。因此，它应该由root拥有和归属，以保持文件的完整性。<br>检测加固：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker.service文件属性，文件所属为root，权限为644</span></span><br><span class="line">ls -l /lib/systemd/system/docker.service</span><br><span class="line"><span class="built_in">stat</span> -c %a-%U:%G /lib/systemd/system/docker.service</span><br><span class="line"><span class="comment"># 644-root:root</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件所属与权限所属</span></span><br><span class="line">chown root:root /usr/lib/systemd/system/docker.service</span><br><span class="line">chmod 644 /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><br>操作影响：None.<br>默认值：该文件可能不存在于系统上。在这种情况下，此建议不适用。默认情况下，如果文件存在，则该文件的所属和所属组正确设置为root 权限为644。<br>备注    </p>
<p><br></p>
<h4 id="3-2-设置docker-socket文件所属和权限"><a href="#3-2-设置docker-socket文件所属和权限" class="headerlink" title="3.2 设置docker.socket文件所属和权限"></a>3.2 设置docker.socket文件所属和权限</h4><p>描述：验证docker.socket文件所属和所属组是否正确设置为root，文件权限是否正确设置为’644’或更多限制。<br>加固说明：docker.socket文件包含可能会改变Docker远程API行为的敏感参数。因此，它应该拥有root权限，以保持文件的完整性。<br>检测加固：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断文件所属用户及用户组和权限</span></span><br><span class="line">ls -al /usr/lib/systemd/system/docker.socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属和用户组应该为root，权限为644</span></span><br><span class="line">chown root：root /usr/lib/systemd/system/docker.socket</span><br><span class="line">chmod 644 /usr/lib/systemd/system/docker.socket</span><br></pre></td></tr></table></figure><br>操作影响: None<br>默认值: 该文件可能不存在于系统上。在这种情况下，此建议不适用。默认情况下，如果文件存在，则该文件的所属和所属组正确设置为root, 文件权限正确设置为644。<br>备注    </p>
<p><br></p>
<h4 id="3-3-设置-etc-docker目录所有权为root-root"><a href="#3-3-设置-etc-docker目录所有权为root-root" class="headerlink" title="3.3 设置/etc/docker目录所有权为root:root"></a>3.3 设置/etc/docker目录所有权为root:root</h4><p>描述:验证/etc/docker目录所属和所属组是否正确设置为root, 权限是否正确设置为750或更多限制。<br>加固说明: 除了各种敏感文件之外/etc/docker目录还包含证书和密钥。<br>因此，它应该由root拥有和归组来维护目录的完整性。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令以验证该目录是由root拥有和归属的(所属和所属组设置为root,权限设置为750)</span></span><br><span class="line"><span class="built_in">stat</span> -c %U:%G /etc/docker | grep  root:root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录的所属和所属组设置为root,权限设置为750</span></span><br><span class="line">chown root:root /etc/docker</span><br><span class="line">chmod 750 /etc/docker</span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 默认情况下所属和所属组为 root，权限为755。<br>备注    </p>
<p><br></p>
<h4 id="3-4-设置仓库证书文件所有权为root：root"><a href="#3-4-设置仓库证书文件所有权为root：root" class="headerlink" title="3.4 设置仓库证书文件所有权为root：root"></a>3.4 设置仓库证书文件所有权为root：root</h4><p>描述: 验证所有仓库证书文件<code>/etc/docker/certs.d/&lt;registry-name&gt;</code>所属和所属组是否为root，权限为600或更多限制的权限<br>加固说明: 在<code>/etc/docker/certs.d/&lt;registry-name&gt;</code>目录包含Docker镜像仓库证书，这些证书文件必须由root和其组拥有，以维护证书的完整性<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所属和所属组设置为root,权限设置为600</span></span><br><span class="line">find /etc/docker/certs.d/ -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">stat</span> -c <span class="string">'%U:%G - %a - %n'</span> &#123;&#125;  +</span><br><span class="line">root:root - 600 - /etc/docker/certs.d/harbor.weiyigeek.top/server.key</span><br><span class="line">root:root - 600 - /etc/docker/certs.d/harbor.weiyigeek.top/harbor.weiyigeek.top.crt</span><br><span class="line">root:root - 600 - /etc/docker/certs.d/hub.weiyigeek.top/hub.weiyigeek.top.crt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将镜像仓库证书文件的所属和所属组设置为root。</span></span><br><span class="line">chown root:root /etc/docker/certs.d/&lt;registry-name&gt;/*</span><br><span class="line">chmod -R 600  /etc/docker/certs.d/&lt;registry-name&gt;/</span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 默认情况下，镜像仓库证书文件的所属和所属组正确设置为root 权限为444.<br>备注    </p>
<p><br></p>
<h4 id="3-5-设置TLS-CA证书文件所有权为root-root"><a href="#3-5-设置TLS-CA证书文件所有权为root-root" class="headerlink" title="3.5 设置TLS CA证书文件所有权为root:root"></a>3.5 设置TLS CA证书文件所有权为root:root</h4><p>描述: 验证TLSCA证书文件是由root拥有和分组拥有的，权限为444。<br>加固说明: TLS CA证书文件应受到保护，不受任何篡改。它用于指定的CA证书验证。因此，它必须由root拥有，权限为444，以维护CA证书的完整性。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行以下命令判断CA证书的所属和权限, 以验证TLS CA证书文件是否由root和其组拥有：</span></span><br><span class="line"><span class="built_in">stat</span>-c %U:%G &lt;路径到TLS CA证书文件&gt; | grep -v root:root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将TLS CA证书文件所属和所属组设置为root，权限为444。</span></span><br><span class="line">chown root:root  -R &lt;路径到TLS CA证书文件&gt;</span><br><span class="line">chmod 444 -R &lt;路径到TLS CA证书文件&gt;</span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 默认情况下，TLS CA证书文件的所有权和组属性正确设置为root。默认文件权限由系统或用户特定的umask值控制。<br>备注    </p>
<p><br></p>
<h4 id="3-6-设置docker服务器证书文件所有权为root-root"><a href="#3-6-设置docker服务器证书文件所有权为root-root" class="headerlink" title="3.6 设置docker服务器证书文件所有权为root:root"></a>3.6 设置docker服务器证书文件所有权为root:root</h4><p>描述: 验证Docker服务器证书文件（与–tlscert’参数一起传递的文件）是否由root和其组拥有，权限为444。<br>加固说明: Docker服务器证书文件应受到保护，不受任何篡改。它用于验证Docker服务器。因此，它必须由root拥有以维护证书的完整性。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面的命令所属和所属组为root，权限为444</span></span><br><span class="line">ls -al &lt;Docker服务器证书文件的路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将docker服务器证书文件的所属和所属组设置为root。</span></span><br><span class="line">chown root:root -R &lt;路径到Docker服务器证书文件&gt;</span><br><span class="line">chmod 444 -R  &lt;路径到Docker服务器证书文件&gt;</span><br></pre></td></tr></table></figure><br>操作影响:None.<br>默认值:默认情况下，Docker服务器证书文件的所属和所属组正确设置为root, 默认文件权限由系统或用户特定的umask值控制。<br>备注    </p>
<p><br></p>
<h4 id="3-7-设置docker服务器证书密钥文件所有权为root：root"><a href="#3-7-设置docker服务器证书密钥文件所有权为root：root" class="headerlink" title="3.7 设置docker服务器证书密钥文件所有权为root：root"></a>3.7 设置docker服务器证书密钥文件所有权为root：root</h4><p>描述: 验证Docker服务器证书密钥文件（与–tlskey’参数一起传递的文件）是由由root拥有，权限设置为400。</p>
<p>加固说明: Docker服务器证书密钥文件应受到保护，不受任何篡改或不必要的读取。它保存Docker服务器证书的私钥。因此它必须由root拥有，权限为400 以维护Docker服务器证书的完整性。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所属和所属组为root，权限为400</span></span><br><span class="line">ls -al &lt;路径到Docker服务器证书密钥文件&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将Docker服务器证书密钥文件的所属和所属组设置为root，权限设置为400</span></span><br><span class="line">chown root:root -R &lt;路径到Docker服务器证书密钥文件&gt;</span><br><span class="line">chmod 400 -R &lt;路径到docker服务器证书密钥文件&gt;</span><br></pre></td></tr></table></figure></p>
<p>操作影响    None.<br>默认值    默认情况下，Docker服务器证书密钥文件的所属和所属组正确设置为root。文件权限由系统或用户特定的umask值控制。<br>备注    </p>
<p><br></p>
<h4 id="3-8-设置-var-run-docker-sock文件所有权为root-docker"><a href="#3-8-设置-var-run-docker-sock文件所有权为root-docker" class="headerlink" title="3.8  设置/var/run/docker.sock文件所有权为root:docker"></a>3.8  设置/var/run/docker.sock文件所有权为root:docker</h4><p>描述: 验证docker.sock文件由root拥有，而用户组为docker，权限为660。<br>加固说明:Docker守护进程以root用户身份运行。因此，默认的Unix套接字必须由root拥有。如果任何其他用户或进程拥有此套接字，那么该非特权用户或进程可能与Docker守护进程交互。另外，这样的非特权用户或进程可能与容器交互。这样非常不安全。另外，Docker安装程序会创建一个名为docker的用户组。可以将用户添加到该组，然后这些用户将能够读写默认的DockerUnix套接字。docker组成员由系统管理员严格控制。如果任何其他组拥有此套接字，那么该组的成员可能会与Docker守护进程交互。。<br>因此，默认的DockerUnix套接字文件必须由docker组拥有权限，以维护套接字文件的完整性。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所属和所属组为root，权限为660</span></span><br><span class="line">ls -al /var/run/docker.sock</span><br><span class="line">~$ <span class="built_in">stat</span> -c %a-%U:%G /var/run/docker.sock</span><br><span class="line">660-root:docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有权设置为root和组所有权到docker作为默认Docker套接字文件。</span></span><br><span class="line">chown root：docker /var/run/docker.sock</span><br><span class="line">chmod 660 /var/run/docker.sock</span><br></pre></td></tr></table></figure><br>操作影响    None.<br>默认值    默认情况下，Docker套接字文件的所属和所属组正确设置为root：docker，权限正确设置为’660’</p>
<p><br></p>
<h4 id="3-9-设置daemon-json文件所有权为root：root"><a href="#3-9-设置daemon-json文件所有权为root：root" class="headerlink" title="3.9 设置daemon.json文件所有权为root：root"></a>3.9 设置daemon.json文件所有权为root：root</h4><p>描述: 验证daemon.json文件所属和所属组是否正确设置为root，文件权限是否正确设置为644或更多限制。<br>加固说明: daemon.json文件包含可能会改变docker守护进程行为的敏感参数。因此，它应该由root拥有，以维护文件的完整性。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件所属和所属组为root，权限为644</span></span><br><span class="line">ls -l /etc/docker/daemon.json</span><br><span class="line"><span class="built_in">stat</span> -c %a-%U:%G /etc/docker/daemon.json</span><br><span class="line">644-root:root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件的所属和所属组设置为root，权限为644。</span></span><br><span class="line">chown root:root /etc/docker/daemon.json</span><br><span class="line">chmod 644 /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><br>操作影响    None.<br>默认值: 该文件可能不存在于系统上。在这种情况下，此建议不适用.文件权限由系统或用户特定的umask值控制。<br>备注    </p>
<p><br></p>
<h4 id="3-10-设置-etc-default-docker-文件所有权为-root-root"><a href="#3-10-设置-etc-default-docker-文件所有权为-root-root" class="headerlink" title="3.10 设置 /etc/default/docker 文件所有权为 root:root"></a>3.10 设置 /etc/default/docker 文件所有权为 root:root</h4><p>描述: 验证/etc/default/docker文件所属和所属组是否正确设置为root，文件权限是否正确设置为644或更多限制。<br>加固说明: /etc/default/docker文件包含可能会改变docker守护进程行为的敏感参数。因此，它应该由root拥有，以维护文件的完整性。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件所属和所属组为root，权限为644</span></span><br><span class="line">ls -l /etc/default/docker</span><br><span class="line"><span class="built_in">stat</span> -c %a-%U:%G /etc/default/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这将文件的所属和所属组设置为root。</span></span><br><span class="line">chown root:root/etc/default/docker</span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 该文件可能不存在于系统上。在这种情况下，此建议不适用。<br>备注    </p>
<p><br></p>
<h3 id="4-容器镜像和构建文件"><a href="#4-容器镜像和构建文件" class="headerlink" title="4.容器镜像和构建文件"></a>4.容器镜像和构建文件</h3><h4 id="4-1-创建容器的用户"><a href="#4-1-创建容器的用户" class="headerlink" title="4.1 创建容器的用户"></a>4.1 创建容器的用户</h4><p>描述: 为容器镜像的Dockerfile中的容器创建非root用户。<br>加固说明: 如果可能，最好指定非root用户身份运行容器。虽然用户命名空间映射可用，但是如果用户在容器镜像中指定了用户，则默认情况下容器将作为该用户运行，并且不需要特定的用户命名空间重新映射。<br>检测加固<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果为空则表示容器以root身份运行。</span></span><br><span class="line">docker ps -q |xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:User=&#123;&#123;.Config.User&#125;&#125;'</span></span><br><span class="line"><span class="comment"># 确保容器镜像的Dockerfile包含以下指令：USER&lt;用户名或ID&gt;其中用户名或ID是指可以在容器基础镜像中找到的用户。如果在容器基础镜像中没有创建特定用户，则在USER指令之前添加user add命令以添加特定用户。</span></span><br><span class="line">RUN user add -d /home/app -m -s/bin/bash app </span><br><span class="line">USER app</span><br><span class="line">``` </span><br><span class="line">注意：如果镜像中有容器不需要的用户，应删除它们。删除这些用户后，提交镜像，然后生成新的容器实例以供使用。</span><br><span class="line">操作影响: None.</span><br><span class="line">默认值: 默认情况下，容器以root权限运行，并以容器中的用户root身份运行。</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.2 容器使用可信的基础镜像</span></span><br><span class="line">描述: 确保容器镜像是从头开始编写的，或者是基于通过安全仓库下载的另一个已建立且可信的基本镜像。</span><br><span class="line">加固说明: 官方存储库是由Docker社区或供应商优化的Docker镜像。可能还存在其他不安全的公共存储库。在从Docker和第三方获取容器镜像时，需谨慎使用。</span><br><span class="line">检测方法: 检查Docker主机以查看执行以下命令使用的Docker镜像：docker images这将列出当前可用于Docker主机的所有容器镜像。再对在Docker主机上找到的每个Docker镜像，检查镜像的构建方式，以验证是否来自可信来源</span><br><span class="line">判断方法: 判断镜像来源的合法性</span><br><span class="line">加固方法: 配置和使用Docker内容信任。检查Docker镜像历史记录以评估其在网络上运行的风险。使用镜像扫描工具扫描Docker镜像以查找其依赖关系中的漏洞。</span><br><span class="line">操作影响: None.</span><br><span class="line">默认值: 无</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.3 容器中不安装没有必要的软件包</span></span><br><span class="line">描述: 选用精简的镜像作为基础镜像，不安装不必要的软件</span><br><span class="line">加固说明: 安装不必要的软件可能会增加容器的攻击风险。因此，除了容器的真正需要的软件之外，不要安装其他多余的软件。</span><br><span class="line">检测方法: 进入容器中执行命令检查安装的软件包</span><br><span class="line">判断方法: 查看软件包列表并确保它是合法的。</span><br><span class="line">加固方法: 建议选用alpine镜像或官方Linux发行版精简的镜像</span><br><span class="line">操作影响: None.</span><br><span class="line">默认值: 不适用。</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.4 扫描镜像漏洞并且构建包含安全补丁的镜像</span></span><br><span class="line">描述: 应该经常扫描镜像以查找漏洞。重建镜像安装最新的补丁。</span><br><span class="line">加固说明: 安全补丁可以解决软件的安全问题。可以使用镜像漏洞扫描工具来查找镜像中的任何类型的漏洞，然后检查可用的补丁以减轻这些漏洞。修补程序将系统更新到最新的代码库。</span><br><span class="line">检测方法: 运行镜像漏洞扫描工具扫描镜像</span><br><span class="line">判断方法: 检查扫描结果中存在的安全隐患</span><br><span class="line">加固方法: </span><br><span class="line">* 第1步：取出所有基本镜像（即给定一组Dockerfiles，提取在FROM指令中声明的所有镜像，并重新提取它们以检查更新</span><br><span class="line">* 第2步：重建每个镜像：docker build --no-cache</span><br><span class="line">* 第3步：使用更新的镜像重新启动所有容器,还可以在Dockerfile中使用ONBUILD指令来触发经常用作基本镜像的特定更新指令。</span><br><span class="line">操作影响: None.</span><br><span class="line">默认值: 默认情况下，容器和镜像不会自动更新。</span><br><span class="line">备注: 如果镜像漏洞扫描工具可以执行二进制级别分析，而不仅仅是版本字符串匹配，则会更好。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.5 启用docker内容信任</span></span><br><span class="line">描述: 默认情况下禁用内容信任，为了安全起见，可以启用。</span><br><span class="line">加固说明: 内容信任为向远程Docker镜像仓库发送和接收的数据提供了使用数字签名的能力。这些签名允许客户端验证特定镜像标签的完整性和发布者。这确保了容器镜像的来源的合法性。</span><br><span class="line">检测加固: </span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># DOCKER_CONTENT_TRUST 环境变量执行应该返回1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DOCKER_CONTENT_TRUST</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要在bash shell中启用内容信任或者，在配置文件中设置此环境变量</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_CONTENT_TRUST=1</span><br></pre></td></tr></table></figure><br>操作影响: 在设置了DOCKER_CONTENT_TRUST的环境中，需要在处理镜像时遵循信任过程-构建，创建，拉取，推送和运行。可以使用–disable-content-trust标志按照需要在标记镜像上运行单独的操作，一般用于测试目的，生成环境中应尽不要使用。<br>默认值: 默认情况下，内容信任被禁用。</p>
<p><br></p>
<h4 id="4-6-将HEALTHCHECK说明添加到容器镜像"><a href="#4-6-将HEALTHCHECK说明添加到容器镜像" class="headerlink" title="4.6 将HEALTHCHECK说明添加到容器镜像"></a>4.6 将<code>HEALTHCHECK</code>说明添加到容器镜像</h4><p>描述: 在Docker容器镜像中添加HEALTHCHECK指令以对正在运行的容器执行运行状况检查。<br>加固说明: 安全性最重要的一个特性就是可用性。将HEALTHCHECK指令添加到容器镜像可确保docker引擎定期检查运行的容器实例是否符合该指令，以确保实例仍在运行。根据报告的健康状况，docker引擎可以退出非工作容器并实例化新容器。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行以下命令，并确保docker镜像对HEALTHCHECK指令设置, 应当返回设置值</span></span><br><span class="line">docker inspect --format=<span class="string">'&#123;&#123;.Config.Healthcheck&#125;&#125;'</span> &lt;镜像ID&gt;</span><br><span class="line">~$ docker inspect --format=<span class="string">'&#123;&#123;.RepoTags&#125;&#125; - &#123;&#123;.Config.Healthcheck&#125;&#125;'</span> $(docker images -q)</span><br><span class="line">[weiyigeek/go-webserver:v2.0] - &#123;[CMD-SHELL wget --spider http://localhost:8080 || <span class="built_in">exit</span> 1] 5s 3s 0s 5&#125;</span><br><span class="line">[weiyigeek/go-webserver:v1.0 hub.weiyigeek.top/go-webserver:v1.0] - &#123;[CMD-SHELL curl -fs http://localhost:8080 || <span class="built_in">exit</span> 1] 5s 3s 0s 5&#125;</span><br><span class="line">[weiyigeek/go-webserver:v1.0 hub.weiyigeek.top/go-webserver:v1.0] - &#123;[CMD-SHELL curl -fs http://localhost:8080 || <span class="built_in">exit</span> 1] 5s 3s 0s 5&#125;</span><br><span class="line">[ubuntu-htop:v0.1] - &lt;nil&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照Dockerfile文档，并使用HEALTHCHECK指令重建容器镜像。</span></span><br><span class="line">HEALTHCHECK --interval=5s --timeout=3s --retries=5 \</span><br><span class="line">  CMD curl -fs http://localhost:8080/ || <span class="built_in">exit</span> 1</span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 默认情况下，HEALTHCHECK未设置。</p>
<p><br></p>
<h4 id="4-7-不在dockerfile中单独使用更新命令"><a href="#4-7-不在dockerfile中单独使用更新命令" class="headerlink" title="4.7 不在dockerfile中单独使用更新命令"></a>4.7 不在dockerfile中单独使用更新命令</h4><p>描述: 不要单独使用<code>apt-get upgrade</code>或<code>yum makecache</code>等更新指令也不要在Dockerfile中使用更新指令。<br>加固说明: 在Dockerfile添加更新指令将缓存更新的层。稍后使用相同的指令构建任何镜像时，将使用先前缓存的更新图层。这可能会拒绝任何新版本进入到以后的版本。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Dockerfile，请确认没有上述更新指示。</span></span><br><span class="line">docker images </span><br><span class="line">docker <span class="built_in">history</span> &lt;Image_ID&gt; | grep <span class="string">"upgrade"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在安装软件包时，请使用最新的固定版本软件包。或可以在docker构建过程中使用--no-cache标志，以避免使用缓存的层。</span></span><br></pre></td></tr></table></figure><br>操作影响: None.<br>默认值: 默认情况下，docker对更新无限制。</p>
<p><br></p>
<h4 id="4-8-镜像中删除setuid和setgid权限"><a href="#4-8-镜像中删除setuid和setgid权限" class="headerlink" title="4.8 镜像中删除setuid和setgid权限"></a>4.8 镜像中删除setuid和setgid权限</h4><p>描述: 删除镜像中的setuid和setgid权限防止容器中的提权攻击。<br>加固说明: setuid和setgid可用于提升权限。虽然这些权限有时必须，应考虑为镜像中不需要的软件包删除这些权限。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在镜像上运行以下命令以列出具有setuid和setgid权限的可执行文件, 仔细检查列表确保它是合法的</span></span><br><span class="line">docker run &lt;Image_ID&gt; find / -perm +6000 -typef -<span class="built_in">exec</span> ls -ld &#123;&#125;\; 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在需要可执行的文件上允许setuid和setgid权限。可在构建时通过在Dockerfile中添加以下命令来删除这些权限，最好添加在Dockerfile的末尾：</span></span><br><span class="line">RUN find /- perm +6000 -typef -<span class="built_in">exec</span> chmod a -s &#123;&#125;\;||<span class="literal">true</span></span><br><span class="line">```	</span><br><span class="line">操作影响: 以上命令会导致依赖setuid或setgid权限（包括合法权限）的可执行文件无法执行，需要小心处理。</span><br><span class="line">默认值: None</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.9 在dockerfile中使用copy而不是add</span></span><br><span class="line">描述: 在Dockerfile中使用COPY指令而不是ADD指令。</span><br><span class="line">加固说明: COPY指令只是将文件从本地主机复制到容器文件系统。ADD指令可能会从远程URL下载文件并执行诸如解包等操作。因此，ADD指令增加了从URL添加恶意文件的风险。</span><br><span class="line">检测方法: 通过`docker <span class="built_in">history</span> &lt;Image_ID&gt;`或`Dockerfile`</span><br><span class="line">查找构建镜像过程中是否使用了ADD指令</span><br><span class="line">判断方法: 不允许存在ADD指令</span><br><span class="line">加固方法: 在Dockerfiles中使用COPY指令。</span><br><span class="line">操作影响: 可能需ADD指令提供的功能，从远程URL获取文件。</span><br><span class="line">默认值: none</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.10 涉密信息不存储在dockerfile</span></span><br><span class="line">描述: 不要在Dockerfiles中存储任何涉密信息。</span><br><span class="line">加固说明: 通过使用docker <span class="built_in">history</span>历史命令，可以查看各种工具和实用程序。镜像发布者提供Dockerfiles来构建镜像。所以，Dockerfiles中的涉密信息可能会被暴露并被恶意利用。</span><br><span class="line">检测方法: `docker <span class="built_in">history</span> &lt;Image_ID&gt;` 或查看Dockerfile查找是否有涉密信息</span><br><span class="line">判断方法: 不应该有涉密的信息，如用户账号，私钥证书等。</span><br><span class="line">加固方法: 不要在Dockerfiles中存储任何类型的涉密信息。</span><br><span class="line">操作影响: 若必须使用，需要制定相应的措施</span><br><span class="line">默认值: 默认情况下，在Dockerfiles中存储配置密码没有限制。</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.11 仅安装已经验证的软件包</span></span><br><span class="line">描述: 在将软件包安装到镜像中之前，验证软件包可靠性。</span><br><span class="line">加固说明: 验证软件包的可靠性对于构建安全的容器镜像至关重要。不合法的软件包可能具有恶意或者存在一些可能被利用的已知漏洞。</span><br><span class="line">检测方法: `docker <span class="built_in">history</span> &lt;Image_ID&gt;`或查看Dockerfile查看软件包的合法性</span><br><span class="line">加固方法: 使用GPG密钥下载和验证所选择的软件包。</span><br><span class="line">操作影响: None</span><br><span class="line">默认值: 不适用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 4.12 容器内部项目指定运行用户</span></span><br><span class="line">_Q:在说此项前我们先来了解容器内部应用程序运行用户设置建议采用gosu还是sudo?_</span><br><span class="line">答:我们通过实战来确定到底使用哪一个命令较好;</span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># gosu</span></span><br><span class="line">docker run --rm gosu/alpine gosu root ps aux</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 ps aux  <span class="comment"># 通过gosu启动的是符合我们要求的（PID为1）容器内的唯一进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sudo</span></span><br><span class="line">docker run --rm ubuntu:trusty sudo ps aux</span><br><span class="line"><span class="comment">#容器内出现了两个进程，sudo命令会创建第一个进程，然后该进程再创建了ps进程，而且ps进程的PID并不等于1，这是达不到我们要求的，此时在宿主机向该容器发送信号量收到信号量的是sudo进程;</span></span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0  46012  1772 ?        Rs   12:05   0:00 sudo ps aux</span><br><span class="line">root          6  0.0  0.0  15568  1140 ?        R    12:05   0:00 ps aux</span><br></pre></td></tr></table></figure><br><em>小结：</em></p>
<ul>
<li>gosu 启动命令时只有一个进程，所以docker容器启动时使用gosu，那么该进程可以做到PID等于1；</li>
<li>sudo 启动命令时先创建sudo进程，然后该进程作为父进程去创建子进程，1号PID被sudo进程占据；</li>
</ul>
<p><strong>正题回归</strong></p>
<p>描述:为了安全容器中不要使用root账号(即最小权限)，此时就需要一个能够提升自定账号权限的命令 gosu 便应运而生它与 sudo 类似但它比sudo更安全；</p>
<p>方便学习先来看看一个小例子(<code>在镜像中创建非root账号</code>):</p>
<p>首先我们以redis官方镜像的Dockerfile为例，来看看如何创建账号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.先添加我们的用户和组，以确保他们的id被一致地分配，不管添加了什么依赖项</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.可见redis官方镜像使用groupadd和useradd创建了名为redis的组合账号，接下来就是用redis账号来启动服务了，理论上应该是以下套路；</span></span><br><span class="line">* 用USER redis将账号切换到redis；</span><br><span class="line">* 在docker-entrypoint.sh执行的时候已经是redis身份了，如果遇到权限问题，例如一些文件只有root账号有读、写、执行权限，用sudo xxx命令来执行即可；</span><br></pre></td></tr></table></figure><br>但事实并非如此！<br>在Dockerfile脚本中未发现<code>USER redis</code>命令,意味着执行docker-entrypoint.sh文件的身份是root；</p>
<p>其次在docker-entrypoint.sh中<code>没有发现su - redis命令，也没有sudo命令</code>；</p>
<p><em>这是怎么回事呢？难道容器内的redis服务是用root账号启动的？</em><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动手实践</span></span><br><span class="line">docker run --name myredis -idt redis</span><br><span class="line">docker <span class="built_in">exec</span> -it myredis /bin/bash</span><br><span class="line">apt-get update &amp;&amp; apt-get install procps <span class="comment">#更新软件源以及PS命令安装</span></span><br><span class="line">root@122c2df16bbb:/data<span class="comment"># ps -ef</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">redis         1      0  0 09:22 ?        00:00:01 redis-server *:6379</span><br><span class="line">root        287      0  0 09:36 ?        00:00:00 /bin/bash</span><br><span class="line">root        293    287  0 09:39 ?        00:00:00 ps -ef</span><br></pre></td></tr></table></figure></p>
<p>上面的结果展示了两个关键信息：<br>第一,redis服务是redis账号启动的并非root；<br>第二,redis服务的PID等于(重要)，宿主机执行<code>docker stop命令时，该进程可以收到SIGTERM信号量</code>，于是redis应用可以做一些退出前的准备工作，例如保存变量、退出循环等，也就是优雅停机(<code>Gracefully Stopping</code>)；</p>
<p>现在我们已经证实了redis服务并非root账号启动，而且该服务进程在容器内还是一号进程，但是我们在Dockerfile和docker-entrypoint.sh脚本中都没有发现切换到redis账号的命令，也没有sudo和su，这是怎么回事呢？</p>
<p>答案:在于redis的docker-entrypoint.sh文件之中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># first arg is `-f` or `--some-option`</span></span><br><span class="line"><span class="comment"># or first arg is `something.conf`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1#-&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ] || [ <span class="string">"<span class="variable">$&#123;1%.conf&#125;</span>"</span> != <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> -- redis-server <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allow the container to be started with `--user` | 首次运行进入</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'redis-server'</span> -a <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># 当前文件夹下不属于redis用户的文件，全部授权为redis用户</span></span><br><span class="line">  find . \! -user redis -<span class="built_in">exec</span> chown redis <span class="string">'&#123;&#125;'</span> +</span><br><span class="line">  <span class="built_in">exec</span> gosu redis <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>注意上图中的代码分析一下:</p>
<ul>
<li>1.假设启动容器的命令是<code>docker run --name myredis -idt redis redis-server /usr/local/etc/redis/redis.conf</code>；</li>
<li>2.容器启动后会执行<code>docker-entrypoint.sh</code>脚本此时的账号是root；</li>
<li>3.当前账号是root因此进入后会执行第二个if条件中命令,其中位置参数含税表示如下;<ul>
<li>$0表示当前脚本的名称即docker-entrypoint.sh；</li>
<li>$@表示外部传入的所有参数，即redis-server /usr/local/etc/redis/redis.conf；</li>
</ul>
</li>
<li>表示以redis账号的身份执行以下命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gosu redis "$0" "@"</span></span><br><span class="line">docker-entrypoint.sh redis-server /usr/<span class="built_in">local</span>/etc/redis/redis.conf</span><br></pre></td></tr></table></figure></li>
<li><code>gosu redis &quot;$0&quot; &quot;@&quot;</code>前面加上个exec，表示以gosu redis “$0” “@”这个命令启动的进程替换正在执行的 docker-entrypoint.sh 进程 <code>保证了对应的进程ID为1</code>；</li>
<li><code>gosu redis &quot;$0&quot; &quot;@&quot;</code>导致docker-entrypoint.sh再执行一次，但是当前的账号已经不是root了，所以会执行兜底逻辑 exec “$@”;</li>
<li>此时的$@是<code>redis-server /usr/local/etc/redis/redis.conf</code>，因此redis服务会启动并且启动服务的用户为redis；</li>
</ul>
<p>最后我们在 Redis 的Dockerfile 中可以看见安装gosu的一些身影<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grab gosu for easy step-down from root</span></span><br><span class="line"><span class="comment"># https://github.com/tianon/gosu/releases</span></span><br><span class="line"><span class="keyword">ENV</span> GOSU_VERSION <span class="number">1.14</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash">	fetchDeps=<span class="string">" \</span></span></span><br><span class="line"><span class="bash">		ca-certificates \</span></span><br><span class="line"><span class="bash">		dirmngr \</span></span><br><span class="line"><span class="bash">		gnupg \</span></span><br><span class="line"><span class="bash">		wget \</span></span><br><span class="line"><span class="bash">	<span class="string">"; \</span></span></span><br><span class="line"><span class="bash">	apt-get update; \</span></span><br><span class="line"><span class="bash">	apt-get install -y --no-install-recommends <span class="variable">$fetchDeps</span>; \</span></span><br><span class="line"><span class="bash">	rm -rf /var/lib/apt/lists/*; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash">	dpkgArch=<span class="string">"<span class="variable">$(dpkg --print-architecture | awk -F- '&#123; print $NF &#125;')</span>"</span>; \</span></span><br><span class="line"><span class="bash">	wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">"https://github.com/tianon/gosu/releases/download/<span class="variable">$GOSU_VERSION</span>/gosu-<span class="variable">$dpkgArch</span>"</span>; \</span></span><br><span class="line"><span class="bash">	wget -O /usr/<span class="built_in">local</span>/bin/gosu.asc <span class="string">"https://github.com/tianon/gosu/releases/download/<span class="variable">$GOSU_VERSION</span>/gosu-<span class="variable">$dpkgArch</span>.asc"</span>; \</span></span><br><span class="line"><span class="bash">	<span class="built_in">export</span> GNUPGHOME=<span class="string">"<span class="variable">$(mktemp -d)</span>"</span>; \</span></span><br><span class="line"><span class="bash">	gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4; \</span></span><br><span class="line"><span class="bash">	gpg --batch --verify /usr/<span class="built_in">local</span>/bin/gosu.asc /usr/<span class="built_in">local</span>/bin/gosu; \</span></span><br><span class="line"><span class="bash">	gpgconf --<span class="built_in">kill</span> all; \</span></span><br><span class="line"><span class="bash">	rm -r <span class="string">"<span class="variable">$GNUPGHOME</span>"</span> /usr/<span class="built_in">local</span>/bin/gosu.asc; \</span></span><br><span class="line"><span class="bash">	chmod +x /usr/<span class="built_in">local</span>/bin/gosu; \</span></span><br><span class="line"><span class="bash">	gosu nobody <span class="literal">true</span>; \</span></span><br><span class="line"><span class="bash">	\</span></span><br><span class="line"><span class="bash">	apt-get purge -y --auto-remove <span class="variable">$fetchDeps</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="5-容器运行时保护"><a href="#5-容器运行时保护" class="headerlink" title="5.容器运行时保护"></a>5.容器运行时保护</h3><h4 id="5-1-设置SElinux安全选项"><a href="#5-1-设置SElinux安全选项" class="headerlink" title="5.1 设置SElinux安全选项"></a>5.1 设置SElinux安全选项</h4><p>描述: SELinux是一个有效且易于使用的Linux访问控制机制。<br>加固说明: SELinux提供强制访问控制（MAC）系统，大大增强了默认的自由访问控制（DAC）模型。因此，可以通过在Linux主机上启用SELinux（如果适用）来增加额外的安全防护。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查方式</span></span><br><span class="line">$ ~$ docker ps -q -a | xargs docker inspect --format <span class="string">'Name = &#123;&#123;.Name&#125;&#125;, SecurityOpt = &#123;&#123;json .HostConfig.SecurityOpt&#125;&#125;'</span></span><br><span class="line">Name = /nginx, SecurityOpt = null</span><br><span class="line">Name = /harbor-jobservice, SecurityOpt = null</span><br></pre></td></tr></table></figure><br>判断方法: 上述命令应返回当前为容器配置的所有安全选项。<br>加固方法: 如果SELinux适用于你的Linux操作系统，请使用它,可能需要遵循以下步骤：</p>
<ul>
<li>1.设置SELinux状态。</li>
<li>2.设置SELinux策略。</li>
<li>3.为Docker容器创建或导入SELinux策略模板。</li>
<li>4.启用SELinux的守护进程模式下启动Docker。docker daemon –selinux-enabled</li>
<li>5.使用安全选项启动Docker容器。<code>docker run --interactive—tty --security-optlabel=level TopSecretcentos /bin/bash</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.设置selinux-enabled字段值为true并添到daemon.json 文件中</span></span><br><span class="line"><span class="string">"selinux-enabled"</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>
操作影响: selinux配置文件中定义的一组操作限制。如果配置错误，容器可能无法完成工作。<br>默认值: 默认情况下，在容器上不应用SELinux安全选项。</li>
</ul>
<p><br></p>
<h4 id="5-2-linux内核特性在容器内受限"><a href="#5-2-linux内核特性在容器内受限" class="headerlink" title="5.2 linux内核特性在容器内受限"></a>5.2 linux内核特性在容器内受限</h4><p>描述: 默认情况下，Docker使用一组受限制的Linux内核特性启动容器, 这意味着可以将任何进程授予所需的功能，而不是root访问, 使用Linux内核特性，这些进程不必以root权限运行。(<code>为容器运行中的任何进程授予最小所需功能</code>)<br>加固说明: Docker支持添加和删除功能，允许使用非默认配置文件。这可能会使Docker通过移除功能更加安全，或者通过增加功能来减少安全性。因此，建议除去容器进程明确要求的所有功能。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps -q -a  | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:CapAdd=&#123;&#123;.HostConfig.CapAdd&#125;&#125;CapDrop=&#123;&#123;.HostConfig.CapDrop&#125;&#125;'</span></span><br><span class="line">72b163c7e64e66fcecd09336bde28ee393cf07ca80c091c920eeb50c2f596bf8:CapAdd=&lt;no value&gt;CapDrop=&lt;no value&gt;</span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:CapAdd=[CHOWN SETGID SETUID NET_BIND_SERVICE]CapDrop=[ALL]</span><br><span class="line"></span><br><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'Name = &#123;&#123;.Name&#125;&#125;, CapAdd=&#123;&#123;json .HostConfig.CapAdd&#125;&#125;, CapDrop=&#123;&#123;json .HostConfig.CapDrop&#125;&#125;'</span></span><br><span class="line">Name = /nginx, CapAdd=[<span class="string">"CHOWN"</span>,<span class="string">"SETGID"</span>,<span class="string">"SETUID"</span>,<span class="string">"NET_BIND_SERVICE"</span>], CapDrop=[<span class="string">"ALL"</span>]</span><br><span class="line">Name = /harbor-jobservice, CapAdd=[<span class="string">"CHOWN"</span>,<span class="string">"SETGID"</span>,<span class="string">"SETUID"</span>], CapDrop=[<span class="string">"ALL"</span>]</span><br></pre></td></tr></table></figure><br>判断方法: 验证添加和删除的Linux内核功能是否符合每个容器实例的容器进程所需的功能。</p>
<p>加固方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.分别使用--cap-add和--cap-drop参数来增加所需的功能或者移除所需功能。</span></span><br><span class="line">$ docker run --<span class="built_in">cap</span>-add=&#123;Capability1，Capability2&#125; --<span class="built_in">cap</span>-drop=all  <span class="comment"># 白名单机制</span></span><br><span class="line">$ docker run -it --name captest --<span class="built_in">cap</span>-add=&#123;chown,net_bind_service,net_admin&#125; --<span class="built_in">cap</span>-drop=all ubuntu:latest /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.在容器内部查询支持那些capability</span></span><br><span class="line">$ capsh --<span class="built_in">print</span></span><br><span class="line">Current: = cap_chown,cap_net_bind_service,cap_net_admin+eip</span><br><span class="line">Bounding <span class="built_in">set</span> =cap_chown,cap_net_bind_service,cap_net_admin</span><br><span class="line"></span><br><span class="line">$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125;, CapAdd=&#123;&#123;json .HostConfig.CapAdd&#125;&#125;, CapDrop=&#123;&#123;json .HostConfig.CapDrop&#125;&#125;'</span></span><br><span class="line">captest, CapAdd=[<span class="string">"chown"</span>,<span class="string">"net_bind_service"</span>,<span class="string">"net_admin"</span>], CapDrop=[<span class="string">"all"</span>]</span><br></pre></td></tr></table></figure><br>操作影响: 基于添加或删除的Linux内核功能，容器中功能会受到限制。<br>默认值: 默认情况下以下功能可用于容器,参考containerd项目地址 (<a href="https://github.com/containerd/containerd/blob/main/oci/spec.go" target="_blank" rel="noopener">https://github.com/containerd/containerd/blob/main/oci/spec.go</a>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func defaultUnixCaps() []string &#123;</span><br><span class="line">  <span class="built_in">return</span> []string&#123;</span><br><span class="line">    <span class="string">"CAP_CHOWN"</span>,</span><br><span class="line">    <span class="string">"CAP_DAC_OVERRIDE"</span>,</span><br><span class="line">    <span class="string">"CAP_FSETID"</span>,</span><br><span class="line">    <span class="string">"CAP_FOWNER"</span>,</span><br><span class="line">    <span class="string">"CAP_MKNOD"</span>,</span><br><span class="line">    <span class="string">"CAP_NET_RAW"</span>,</span><br><span class="line">    <span class="string">"CAP_SETGID"</span>,</span><br><span class="line">    <span class="string">"CAP_SETUID"</span>,</span><br><span class="line">    <span class="string">"CAP_SETFCAP"</span>,</span><br><span class="line">    <span class="string">"CAP_SETPCAP"</span>,</span><br><span class="line">    <span class="string">"CAP_NET_BIND_SERVICE"</span>,</span><br><span class="line">    <span class="string">"CAP_SYS_CHROOT"</span>,</span><br><span class="line">    <span class="string">"CAP_KILL"</span>,</span><br><span class="line">    <span class="string">"CAP_AUDIT_WRITE"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="5-3-不使用特权容器"><a href="#5-3-不使用特权容器" class="headerlink" title="5.3 不使用特权容器"></a>5.3 不使用特权容器</h4><p>描述: 使用–privileged标志将所有Linux内核功能提供给容器，从而覆盖-cap-add和-cap-drop标志。若无必须请不要使用它。<br>加固说明: –privileged标志给容器提供所有功能,并且还提升了cgroup控制器执行的所有限制, 若无必须不要使用它。<br>检测加固:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令应为每个容器实例返回Privileged=</span></span><br><span class="line">docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:Privileged=&#123;&#123;.HostConfig.Privileged&#125;&#125;'</span></span><br><span class="line">72b163c7e64e66fcecd09336bde28ee393cf07ca80c091c920eeb50c2f596bf8:Privileged=<span class="literal">false</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:Privileged=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要运行带有--privileged标志的容器。</span></span><br><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125;:Privileged=&#123;&#123;.HostConfig.Privileged&#125;&#125;'</span></span><br><span class="line">/captest:Privileged=<span class="literal">false</span></span><br><span class="line">/cap_test:Privileged=<span class="literal">false</span></span><br><span class="line">/nginx:Privileged=<span class="literal">false</span></span><br><span class="line">/harbor-jobservice:Privileged=<span class="literal">false</span></span><br></pre></td></tr></table></figure><br>操作影响: 除默认值之外的Linux内核功能将无法在容器内使用。<br>默认值: False.</p>
<p><br></p>
<h4 id="5-4-敏感的主机系统目录不要挂载在容器上"><a href="#5-4-敏感的主机系统目录不要挂载在容器上" class="headerlink" title="5.4 敏感的主机系统目录不要挂载在容器上"></a>5.4 敏感的主机系统目录不要挂载在容器上</h4><p>描述: 不应允许将敏感的主机系统目录（如<code>/boot /dev /etc /lib /proc /sys /usr</code>）作为容器卷进行挂载，特别是在读写模式下。<br>加固说明: 如果敏感目录以读写方式挂载，则可以对这些敏感目录中的文件进行更改。这些更改可能会降低安全性，且直接操作影响Docker宿主机。<br>检测方法: 命令将返回当前映射目录的列表，以及是否以每个容器实例的读写模式进行挂载。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看创建运行的容器挂载的主机系统目录</span></span><br><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:Volumes=&#123;&#123;.Mounts&#125;&#125;'</span></span><br><span class="line">72b163c7e64e66fcecd09336bde28ee393cf07ca80c091c920eeb50c2f596bf8:Volumes=[map[Destination:/var/run/docker.sock Mode: Propagation:rprivate RW:<span class="literal">true</span> Source:/var/run/docker.sock Type:<span class="built_in">bind</span>]]</span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:Volumes=[map[Destination:/etc/cert Mode:z Propagation:rprivate RW:<span class="literal">true</span> Source:/data/harbor/secret/cert Type:<span class="built_in">bind</span>] map[Destination:/etc/nginx Mode:z Propagation:rprivate RW:<span class="literal">true</span> Source:/opt/harbor/common/config/nginx Type:<span class="built_in">bind</span>] map[Destination:/harbor_cust_cert Mode: Propagation:rprivate RW:<span class="literal">true</span> Source:/opt/harbor/common/config/shared/trust-certificates Type:<span class="built_in">bind</span>] map[Destination:/run Driver:<span class="built_in">local</span> Mode: Name:2cbf86a1597dc82401969b05222e10b266d28c74382e97e1d402160c527a7633 Propagation: RW:<span class="literal">true</span> Source:/app/docker/volumes/2cbf86a1597dc82401969b05222e10b266d28c74382e97e1d402160c527a7633/_data Type:volume] map[Destination:/var/cache/nginx Driver:<span class="built_in">local</span> Mode: Name:0955b631512898189af6c65b47098f6a791733f8ad560830726105608ba675ff Propagation: RW:<span class="literal">true</span> Source:/app/docker/volumes/0955b631512898189af6c65b47098f6a791733f8ad560830726105608ba675ff/_data Type:volume] map[Destination:/var/<span class="built_in">log</span>/nginx Driver:<span class="built_in">local</span> Mode: Name:afab7f34d4fa4dbcfae33ceadc0bc8b17fbfb79abdeabecda6cbe30cd861bef6 Propagation: RW:<span class="literal">true</span> Source:/app/docker/volumes/afab7f34d4fa4dbcfae33ceadc0bc8b17fbfb79abdeabecda6cbe30cd861bef6/_data Type:volume]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排查那些容器挂载了主机敏感目录</span></span><br><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125;: Volumes=&#123;&#123;json .Mounts&#125;&#125;'</span> | grep -E <span class="string">'"Source":"(/boot|/dev|/etc|/lib|/proc|/sys|/usr)'</span></span><br></pre></td></tr></table></figure><br>加固方法: 不要将主机敏感目录挂载在容器上，尤其是在读写模式下。<br>操作影响: None.<br>默认值: Docker默认为读写卷，也可以以只读方式挂载一个目录。默认情况下，不会在容器上挂载敏感的主机目录。</p>
<p><br></p>
<h4 id="5-5-SSH-不在容器中运行"><a href="#5-5-SSH-不在容器中运行" class="headerlink" title="5.5 SSH 不在容器中运行"></a>5.5 SSH 不在容器中运行</h4><p>描述: SSH服务不应该在容器内运行。<br>加固说明: 在容器内运行SSH可以增加安全管理的复杂性难以管理SSH服务器的访问策略和安全合规性难以管理各种容器的密钥和密码难以管理SSH服务器的安全升级可以在不使用SSH的情况下对容器进行shell访问，避免不必要地增加安全管理的复杂性。<br>检测方法: 对于每个容器实例，执行以下命令 <code>docker exec $INSTANCE_ID ps -el</code><br>判断方法: 确保容器内没有SSH服务<br>加固方法: 从容器中卸载SSH服务<br>操作影响: None.<br>默认值: 默认情况下，SSH服务不在容器内运行</p>
<p><br></p>
<h4 id="5-6-特权端口禁止映射到容器内"><a href="#5-6-特权端口禁止映射到容器内" class="headerlink" title="5.6 特权端口禁止映射到容器内"></a>5.6 特权端口禁止映射到容器内</h4><p>描述: 低于1024的TCP/IP端口号被认为是特权端口, 由于各种安全原因，普通用户和进程不允许使用它们。<br>加固说明: 默认情况下，如果用户没有明确声明容器端口进行主机端口映射，Docker会自动地将容器端口映射到主机上的49153-65535中。但是，如果用户明确声明它，Docker可以将容器端口映射到主机上的特权端口。这是因为容器使用不限制特权端口映射的NET_BIND_SERVICELinux内核功能来执行。特权端口接收和发送各种敏感和特权的数据。允许docker使用它们可能会带来严重的操作影响。</p>
<p>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过执行以下命令列出容器的所有运行实例及其端口映射</span></span><br><span class="line">$ docker ps -q | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;：Ports=&#123;&#123;.NetworkSettings.Ports&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04：Ports=map[4443/tcp:[map[HostIp:0.0.0.0 HostPort:4443]] 8080/tcp:[map[HostIp:0.0.0.0 HostPort:80]] 8443/tcp:[map[HostIp:0.0.0.0 HostPort:443]]]</span><br><span class="line">b769645200f1eb51bb04ad65b9d9fd122b017ebb7ec707437beb9883ce117285：Ports=map[10514/tcp:[map[HostIp:127.0.0.1 HostPort:1514]]]</span><br></pre></td></tr></table></figure><br>判断方法: 查看列表，并确保容器端口未映射到低于1024的主机端口号。<br>加固方法: 启动容器时，不要将容器端口映射到特权主机端口。另外，确保没有容器在Docker文件中特权端口映射声明。<br>操作影响: None.<br>默认值: 默认情况下，允许将容器端口映射到主机上的特权端口。<br>备注: 有些端口是必须使用的HTTP和HTTPS必须绑定80/tcp和443/tcp。</p>
<p><br></p>
<h4 id="5-7-只映射必要的端口"><a href="#5-7-只映射必要的端口" class="headerlink" title="5.7 只映射必要的端口"></a>5.7 只映射必要的端口</h4><p>描述: 容器镜像的Dockerfile定义了在容器实例上默认要打开的端口。端口列表可能与在容器内运行的应用程序相关。<br>加固说明: 一个容器可以运行在Docker文件中为其镜像定义的端口，也可以任意传递运行时参数以打开一个端口列表。此外，Docker文件可能会进行各种更改，暴露的端口列表可能与在容器内运行的应用程序不相关。推荐做法是不要打开不需要的端口。<br>检测方法: 通过执行以下命令列出容器的所有运行实例及其端口映射:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -q | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;：Ports=&#123;&#123;.NetworkSettings.Ports&#125;&#125;'</span></span><br></pre></td></tr></table></figure><br>判断方法: 查看列表，并确保映射的端口是容器真正需要的端口。<br>加固方法: 修复容器镜像的Dockerfile，以便仅通过容器化应用程序公开所需的端口。也可以通过在启动容器时不使用-P（UPPERCASE）或–publish -a 标志来完全忽略Dockerfile中定义的端口列表。使用-p明确定义特定容器实例所需的端口。<br>操作影响: None.<br>默认值: 默认情况下，当使用’-P’或’–publish -a ‘标志运行容器时，打开在EXPOSE指令下的Dockerfile中列出的所有端口。</p>
<p><br></p>
<h4 id="5-8-不共享主机的网络命名空间"><a href="#5-8-不共享主机的网络命名空间" class="headerlink" title="5.8 不共享主机的网络命名空间"></a>5.8 不共享主机的网络命名空间</h4><p>描述: 当设置为–net=host时，容器上的网络模式将容器放置在单独的网络堆栈中。这个选择告诉Docker不使用Docker内部网络，那就意味着容器在可以完全访问主机的网络接口。<br>加固说明: 这有一定的安全风险，允许容器进程像任何其他root进程一样打开低端端口。还允许容器访问Docker主机上的D-bus等网络服务。因此容器进程可以潜在地执行恶意的事，关闭Docker主机。若无需要不要使用host模式。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当命令执行返回 NetworkMode=host时则意味着在启动容器时传递了--net=host选项。</span></span><br><span class="line">~$ docker ps -q -all | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:NetworkMode=&#123;&#123;.HostConfig.NetworkMode&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:NetworkMode=harbor_harbor</span><br></pre></td></tr></table></figure><br>加固方法: 启动容器时不要通过’–net=host’选项。<br>操作影响: None.<br>默认值: 默认情况下，容器连接到Docker网桥。</p>
<p><br></p>
<h4 id="5-9-确保容器的内存使用合理"><a href="#5-9-确保容器的内存使用合理" class="headerlink" title="5.9 确保容器的内存使用合理"></a>5.9 确保容器的内存使用合理</h4><p>描述: 默认情况下，Docker主机上的所有容器均等共享资源。通过使用Docker主机的资源管理功能，内存限制，可以控制容器可能消耗的内存量。<br>加固说明: 默认情况下，容器可以使用主机上的所有内存。可以使用内存限制机制来防止由于一个容器消耗了所有主机资源而导致拒绝服务，以致同一主机上的其他容器无法执行预期功能。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:Memory=&#123;&#123;.HostConfig.Memory&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:Memory=0</span><br></pre></td></tr></table></figure><br>判断方法: 如果上述命令返回0，则表示内存无限制。如果上述命令返回非零值，则表示已有内存限制策略。<br>加固方法: 建议使用–memory参数运行容器。<br>操作影响: 如果有设置适当的限制，容器可能将无法使用。<br>默认值: 默认情况下没有内存限制。</p>
<p><br></p>
<h4 id="5-10-正确设置容器上的CPU优先级"><a href="#5-10-正确设置容器上的CPU优先级" class="headerlink" title="5.10 正确设置容器上的CPU优先级"></a>5.10 正确设置容器上的CPU优先级</h4><p>描述: 默认情况下，Docker主机上的所有容器均可共享资源。通过使用<br>Docker主机的资源管理功能（如CPU共享），可以控制容器可能占用的主机CPU资源。<br>加固说明: 默认情况下，CPU时间在容器间平均分配。如果需要，为了控制容器实例之间的CPU时间，可以使用CPU共享功能。CPU共享允许将一个容器优先于另一个容器，并禁止较低优先级的容器更频繁占用CPU资源。可确保高优先级的容器更好地运行。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps -q -a|xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:CpuShares= &#123;&#123;.HostConfig.CpuShares&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:CpuShares= 0</span><br></pre></td></tr></table></figure><br>判断方法: 如果上述命令返回0或1024，则表示CPU无限制。如果上述命令返回非1024值以外的非零值，则表示CPU已经限制。<br>加固方法: 使用–cpu-shares参数启动容器。<br>操作影响: 如果没有设置适当的CPU共享，容器进程可能会不能执行。<br>默认值: 默认情况下没有执行CPU份额限制。</p>
<p><br></p>
<h4 id="5-11-确保进入容器的流量绑定到特定的网卡"><a href="#5-11-确保进入容器的流量绑定到特定的网卡" class="headerlink" title="5.11 确保进入容器的流量绑定到特定的网卡"></a>5.11 确保进入容器的流量绑定到特定的网卡</h4><p>描述: 默认情况下，Docker容器可以连接到外部，但外部无法连接到容器。每个传出连接都源自主机自己的IP地址。所以只允许通过主机上的特定外部接口访问容器服务。<br>加固说明: 如果主机上有多个网卡，则容器可以接受任何网络接口上公开端口的连接。这可能不安全。很多时候，特定的端口暴露在外部，并且在这些端口上运行诸如入侵检测，入侵防护，防火墙，负载均衡等服务以筛选传入的公共流量。因此，只允许来自特定外部接口的传入连接。<br>检测方法: 通过执行以下命令列出容器的所有运行实例及其端口映射<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps -q | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;：Ports=&#123;&#123;.NetworkSettings.Ports.HostIp&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04：Ports=map[4443/tcp:[map[HostIp:0.0.0.0 HostPort:4443]] 8080/tcp:[map[HostIp:0.0.0.0 HostPort:80]] 8443/tcp:[map[HostIp:0.0.0.0 HostPort:443]]]</span><br></pre></td></tr></table></figure><br>判断方法: 查看列表并确保公开的容器端口与特定接口绑定，而不是通配符IP地址-0.0.0.0。<br>加固方法: 将容器端口绑定到所需主机端口上的特定网卡。<br>默认值: 默认情况下，Docker将容器端口公开在0.0.0.0，可接受主机上任何可能的传入网络端口。<br>操作影响: None.</p>
<p><br></p>
<h4 id="5-12-容器重启策略on-failure设置为5"><a href="#5-12-容器重启策略on-failure设置为5" class="headerlink" title="5.12 容器重启策略on-failure设置为5"></a>5.12 容器重启策略on-failure设置为5</h4><p>描述: 在docker run命令中使用 –restart标志，可以指定重启策略，以便在退出时确定是否重启容器。基于安全考虑，应该设置重启尝试次数限制为5次。<br>加固说明: 如果无限期地尝试启动容器，可能会导致主机上的拒绝服务。这可能是一种简单的方法来执行分布式拒绝服务攻击，特别是在同一主机上有多个容器时。此外，忽略容器的退出状态并始终尝试重新启动容器导致未调查容器终止的根本原因。如果一个容器被终止，应该做的是去调查它重启的原因，而不是试图无限期地重启它。因此，建议使用故障重启策略并将其限制为最多5次重启尝试。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Docker run 上使用 --restart 标志，您可以指定容器在退出时应该或不应该如何重新启动的重新启动策略。</span></span><br><span class="line">docker run --restart=on-failure:5  <span class="comment"># 此处设置重试数为5次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前容器异常导致的重启次数</span></span><br><span class="line">~$ docker ps -q  -a | xargs docker inspect -f <span class="string">"&#123;&#123; .RestartCount &#125;&#125;"</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看重启策略及其重试次数</span></span><br><span class="line">~$ docker ps -q  -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:RestartPolicyName=&#123;&#123;.HostConfig.RestartPolicy.Name&#125;&#125;, MaximumRetryCount=&#123;&#123;.HostConfig.RestartPolicy.MaximumRetryCount&#125;&#125;'</span>  <span class="comment"># </span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:RestartPolicyName=always，MaximumRetryCount=0</span><br><span class="line">b28b6bd4264d9aad4eff7214df6d368c44b5c252a6d61bb7fd85ebc75ffdc957:RestartPolicyName=always，MaximumRetryCount=0</span><br></pre></td></tr></table></figure><br>判断方法: 如果上述命令返回RestartPolicyName=always，那么系统没有按需要进行配置。如果上述命令返回RestartPolicyName=no或仅RestartPolicyName=，则重新启动策略未被使用，容器不会重新启动。如果上述命令返RestartPolicyName=onfailure，则通过查看MaximumRetryCount验证重新启动尝试的次数是否设置为5或更少。<br>加固方法: 在docker run 或 docker-compos e中设定容器重启次数<br>操作影响: 容器只会尝试重新启动5次。<br>默认值: 默认情况下，容器未配置重新启动策略。</p>
<p><br></p>
<h4 id="5-13-确保主机的进程命名空间不共享"><a href="#5-13-确保主机的进程命名空间不共享" class="headerlink" title="5.13 确保主机的进程命名空间不共享"></a>5.13 确保主机的进程命名空间不共享</h4><p>描述: 进程PID命名空间隔离进程，不同PID命名空间中的进程可以具有相同的PID。这就是容器和主机之间的进程级隔离。<br>加固说明: PID名称空间提供了进程的隔离。PID命名空间删除了系统进程的视图，并允许重用包括PID的进程ID。如果主机的PID名称空间与容器共享，它基本上允许容器内的进程查看主机上的所有程。这就打破了主机和容器之间进程级别隔离的优点。若访问容器最终可以知道主机系统上运行的所有进程，甚至可以从容器内杀死主机系统进程。。因此不要将容器与主机的进程名称空间共享。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:PidMode=&#123;&#123;.HostConfig.PidMode&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:PidMode=</span><br></pre></td></tr></table></figure><br>判断方法: 如果上述命令返回host，则表示主机PID名称空间与容器共享，存在安全风险。<br>加固方法: 不要使用’–pid=host’参数启动容器。<br>操作影响: 容器进程无法看到主机系统上的进程。在某些情况下，可能需要容器共享主机的进程命名空间。可以使用像strace或gdb这样的调试工具构建容器，在调试容器中的进程时要使用这些工具。<br>默认值: 默认情况下，所有容器都启用了PID命名空间，并且主机的进程命名空间不与容器共享。</p>
<p><br></p>
<h4 id="5-14-主机的IPC命令空间不共享"><a href="#5-14-主机的IPC命令空间不共享" class="headerlink" title="5.14 主机的IPC命令空间不共享"></a>5.14 主机的IPC命令空间不共享</h4><p>描述: IPC命名空间提供命名共享内存段，信号量和消息队列的分离。主机上的IPC命名空间不应该与容器共享，并且应该保持独立。<br>加固说明: IPC命名空间提供主机和容器之间的IPC分离。如果主机的IPC名称空间与容器共享，它允许容器内的进程查看主机系统上的所有IPC。这打破了主机和容器之间IPC级别隔离。可通过访问容器操纵主机IPC。因此不要将主机的IPC命名空间与容器共享。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:IpcMode=&#123;&#123;.HostConfig.IpcMode&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:IpcMode=shareable</span><br></pre></td></tr></table></figure><br>判断方法: 如果上述命令返回host，则意味着主机IPC命名空间与容器共享。如果上述命令不返回任何内容，则主机的IPC命名空间不会共享。<br>加固方法: 不要使用’–ipc=host’参数启动容器。<br>操作影响: 共享内存段用于加速进程间通信。它通常被高性能应用程序使用。如果这些应用程序被容器化为多个容器，则可能需要共享容器的IPC名称空间以实现高性能。在这种情况下，仍然应该共享容器特定的IPC命名空间而不是整个主机IPC命名空间。可以将容器的IPC名称空间与另一个容器共享<br>默认值: 默认情况下，所有容器都启用IPC命名空间，并且主机IPC命名空间不与任何容器共享。</p>
<p><br></p>
<h4 id="5-15-主机设备不直接共享给容器"><a href="#5-15-主机设备不直接共享给容器" class="headerlink" title="5.15 主机设备不直接共享给容器"></a>5.15 主机设备不直接共享给容器</h4><p>描述: 主机设备可以在运行时直接共享给容器。不要将主机设备直接共享给容器，特别是对不受信任的容器。<br>加固说明: 选项–device将主机设备共享给容器，因此容器可以直接访问这些主机设备。不允许容器以特权模式运行以访问和操作主机设备。默认情况下，容器将能够读取，写入和mknod这些设备。此外，容器可能会从主机中删除设备。因此，不要直接将主机设备共享给容器。如果必须的将主机设备共享给容器，适当地使用共享权限：r-readw -writem -mknod allowed<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -q -a |xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:Devices=&#123;&#123;.HostConfig.Devices&#125;&#125;'</span></span><br></pre></td></tr></table></figure><br>判断方法: 验证从容器中访问主机设备，并且正确设置所需的权限。<br>加固方法: 不要将主机设备直接共享于容器。如果必须将主机设备共享给容器，使用正确的一组权限：<br>操作影响: 将无法直接在容器内使用主机设备。<br>默认值: 默认情况下，主机设备不共享于容器。如果不提供共享权限并选择将主机设备展示给容器，则主机设备将具有读取写入权限。</p>
<p><br></p>
<h4 id="5-16-设置默认的ulimit配置（在需要时）"><a href="#5-16-设置默认的ulimit配置（在需要时）" class="headerlink" title="5.16 设置默认的ulimit配置（在需要时）"></a>5.16 设置默认的ulimit配置（在需要时）</h4><p>描述: 默认的ulimit是在Docker守护进程级别设置的, 如果需要可以在容器运行时重写默认的ulimit设置。<br>加固说明: ulimit提供对shell可用资源的控制。设置系统资源控制可以防止资源耗尽带来的问题，如fork炸弹。有时候合法的用户和进程也可能过度使用系统资源，导致系统资源耗尽应该遵守在Docker守护进程级别设置的默认ulimit。如果默认的ulimit设置不适合特定的容器实例，则可以将它们覆盖为例外。但是尽量不要这样做。如果有太多例外的话，可以直接修改默认的ulimit设置。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:Ulimits=&#123;&#123;.HostConfig.Ulimits&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:Ulimits=&lt;no value&gt;</span><br></pre></td></tr></table></figure><br>判断方法: 对于每个容器实例，上述命令应该返回 <code>Ulimits=&lt;novalue&gt;</code>，除非出现异常并且需要覆盖默认的ulimit设置。<br>加固方法: 如果需要，在docker run或docker-compose启动参数中设定正确合理的ulimit值。<br>操作影响: 如果ulimits未正确设置，则可能无法实现所需的资源控制，甚至导致系统无法使用。<br>默认值: 容器实例继承在Docker守护进程级别设置的默认ulimit</p>
<p><br></p>
<h4 id="5-17-设置主机的UTS命令空间不共享"><a href="#5-17-设置主机的UTS命令空间不共享" class="headerlink" title="5.17 设置主机的UTS命令空间不共享"></a>5.17 设置主机的UTS命令空间不共享</h4><p>描述: UTS命名空间提供两个系统标识符的隔离：主机名和NIS域名。<br>加固说明: 它于设置在该名称空间中运行进程可见的主机名和域名。在容器中运行的进程通常不需要知道主机名和域名。与主机共享UTS命名空间提供了容器可更改主机的主机名。这是不安全的，因此名称空间不应与主机共享。<br>检测方法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker ps -q -a | xargs docker inspect --format <span class="string">'&#123;&#123;.Id&#125;&#125;:UTSMode=&#123;&#123;.HostConfig.UTSMode&#125;&#125;'</span></span><br><span class="line">5d8e597549062d7709b667457e278e33f15221cb5c8e112bcbb648b3bca59f04:UTSMode=</span><br><span class="line">b28b6bd4264d9aad4eff7214df6d368c44b5c252a6d61bb7fd85ebc75ffdc957:UTSMode=</span><br></pre></td></tr></table></figure><br>判断方法: 如果上述命令返回host，则意味着主机UTS名称空间与容器共享，不符合要求。如果上述命令不返回任何内容，则主机的UTS名称空间不共享。<br>加固方法: 不要使用<code>&#39;--uts=host&#39;</code>参数启动容器。<br>操作影响: None.<br>默认值: 默认情况下，所有容器都启用了UTS命名空间，并且主机UTS命名空间不与任何容器共享。<br>备注: </p>
<p><br></p>
<h4 id="5-18-不要使用docker的默认网桥docker0"><a href="#5-18-不要使用docker的默认网桥docker0" class="headerlink" title="5.18 不要使用docker的默认网桥docker0"></a>5.18 不要使用docker的默认网桥docker0</h4><p>描述: 不要使用Docker的默认bridge docker0。使用docker的用户定义的网络进行容器联网。<br>加固说明: Docker将以桥模式创建的虚拟接口连接到名为docker0的公共桥。这种默认网络模型易受ARP欺骗和MAC洪泛攻击的攻击，因为没有应用过滤。<br>检测方法: 运行以下命令，并验证容器是否在用户定义的网络上，而不是默认的docker0网桥。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ docker network ls -q | xargs docker network inspect --format <span class="string">'&#123;&#123;.Name&#125;&#125;：&#123;&#123;.Options&#125;&#125;'</span></span><br><span class="line">bridge：map[com.docker.network.bridge.default_bridge:<span class="literal">true</span> com.docker.network.bridge.enable_icc:<span class="literal">true</span> com.docker.network.bridge.enable_ip_masquerade:<span class="literal">true</span> com.docker.network.bridge.host_binding_ipv4:0.0.0.0 com.docker.network.bridge.name:docker0 com.docker.network.driver.mtu:1500]</span><br><span class="line">harbor_harbor：map[]</span><br></pre></td></tr></table></figure></p>
<p>判断方法: 检查是否在使用bridge docker0默认网桥<br>加固方法: 遵循Docker文档并设置用户定义的网络。运行定义的网络中的所有容器。<br>操作影响: 必须管理用户定义的网络。<br>默认值: 默认情况下，docker在其docker0桥上运行容器。</p>
<hr>
<h2 id="0x0n-本章总结"><a href="#0x0n-本章总结" class="headerlink" title="0x0n 本章总结"></a>0x0n 本章总结</h2><p>描述: 本章中的技巧和示例可以提高您的Docker相关知识并改善Docker镜像的安全及其质量。但是在构建Docker镜像之外，还有许多其他事情可以改善我们处理镜像和容器的方式，例如应用seccomp策略，使用cgroups或可能使用完全不同的容器运行时与引擎来限制资源消耗。</p>
<h3 id="1-参考来源"><a href="#1-参考来源" class="headerlink" title="1.参考来源"></a>1.参考来源</h3><p>Docker 安全性解决实践: <a href="https://docs.docker.com/engine/security/" target="_blank" rel="noopener">https://docs.docker.com/engine/security/</a><br>CIS Docker Community Edition Benchmark</p>
<h3 id="2-工具展示"><a href="#2-工具展示" class="headerlink" title="2.工具展示"></a>2.工具展示</h3><ul>
<li>snyk : 查找、检测、监控镜像容器安全漏洞软件平台，项目地址: <a href="https://snyk.io/" target="_blank" rel="noopener">https://snyk.io/</a></li>
<li>trivy : 镜像扫描工具，项目地址: <a href="https://github.com/trivy/trivy" target="_blank" rel="noopener">https://github.com/trivy/trivy</a></li>
<li>docker-bench-security : 镜像扫描工具 ，项目地址: <a href="https://github.com/docker/docker-bench-security" target="_blank" rel="noopener">https://github.com/docker/docker-bench-security</a></li>
</ul>

        </div>
        <!-- Google 广告 -->
        
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-9134434519967436" data-ad-slot="7905848205"></ins>
  

        
<hr/>
<div style="text-align: center;font-weight: bold;">
  <p> 欢迎各位志同道合的朋友一起学习交流，如文章有误请在下方留下您宝贵的经验知识，个人邮箱地址<b style="color:#ff654e"><code>【master#weiyigeek.top】</code></b>或者个人公众号<b style="color:#ff654e"><code>【WeiyiGeek】</code></b>联系我。 </p>
  <p> 更多文章来源于<b style="color:#03a9f4">【WeiyiGeek Blog - 为了能到远方，脚下的每一步都不能少】</b>, 个人首页地址( <a style="color: #03a9f4;" href="https://weiyigeek.top" target="_blank"> https://weiyigeek.top </a> )</p>
<!-- 

  <ul style="font-weight: bolder;">
    <li>
      <p><span style="color: #03a9f4">echo&nbsp;&nbsp;"【点个赞】，动动你那粗壮的拇指或者芊芊玉手，亲！"</span></p>
    </li>
    <li>
      <p><span style="color: #ff9201">printf("%s",&nbsp;"【投个币】，万水千山总是情，投个硬币行不行，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #02a2ff">fmt.Printf("【收个藏】，阅后即焚不吃灰，亲！")&nbsp;&nbsp;</span></p>
    </li>
    <li>
      <p><span style="color:red">console.info("【转个发】，让更多的志同道合的朋友一起学习交流，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #ff654e">System.out.println("【关个注】，后续浏览查看不迷路哟，亲！")</span></p>
    </li>
  </ul> -->
  <div>
    <img src="/img/share-wechat.jpg" class="img-responsive" alt="扫描Follow(关注)WeiyiGeek公众号与Visit(浏览)极客全栈修炼小程序" >
    <p>专栏书写不易，如果您觉得这个专栏还不错的，请给这篇专栏 <b style="color: red;">【点个赞、投个币、收个藏、关个注、转个发、赞个助】</b>，这将对我的肯定，我将持续整理发布更多优质原创文章！。</p>
    <img src="/img/weiyigeek.jpg" class="img-responsive" alt="WeiyiGeek-banner">
  </div>
</div>
  <hr>
  

  <blockquote class="post-copyright">
    <div class="content">
      
        
<span class="post-time">
    最后更新时间：<time datetime="2022-03-29T05:39:03.713Z" itemprop="dateUpdated">2022-03-29 13:39:03</time>
</span><br>


        <span>文章原始路径：<a href="https://github.com/WeiyiGeek/blog/edit/master/source/_posts/虚拟云容/云容器/Docker/6.Docker镜像与容器安全最佳实践.md" target="_blank" rel="noopener noreferrer">_posts/虚拟云容/云容器/Docker/6.Docker镜像与容器安全最佳实践.md</a></span><br>
         <span class="copy-copyright">转载注明出处，原文地址：<a href="/2019/6-4-460.html" target="_blank" rel="external">https://blog.weiyigeek.top/2019/6-4-460.html</a></span><br>本站文章内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a> 
    </div>
    <footer>
      <a href="https://blog.weiyigeek.top">
        <img src="/img/avatar.jpg" alt="WeiyiGeek">
        WeiyiGeek
      </a>
    </footer>
  </blockquote>


        
            <div class="page-reward">
  <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-rectangle waves-light">☕️ 请作者喝杯咖啡!</a>
</div>
            
        
        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2019/6-4-460.html&title=《6.Docker镜像与容器安全最佳实践》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2019/6-4-460.html&title=《6.Docker镜像与容器安全最佳实践》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2019/6-4-460.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《6.Docker镜像与容器安全最佳实践》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2019/6-4-460.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2019/6-4-460.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
          <!-- 评论组件 -->


<div id="gitalk-container"></div>
<script type="text/javascript" src="/js/plugins/gitalk.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/custom/gitalk.init.js?v=1.6.6"></script>
        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/6-4-437.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">7.Docker使用辅助工具汇总</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/6-4-75.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">SSH远程连接服务安装与介绍</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x00-前言简述"><span class="post-toc-number">1.</span> <span class="post-toc-text">0x00 前言简述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-容器安全概述"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">1.容器安全概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-容器安全机制"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">2.容器安全机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内核能力机制"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">内核能力机制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#服务端防护机制"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">服务端防护机制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#辅助安全机制"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">辅助安全机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-容器安全风险"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">3.容器安全风险</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x01-Docker-镜像安全最佳实践"><span class="post-toc-number">2.</span> <span class="post-toc-text">0x01 Docker 镜像安全最佳实践</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-选用最小化基础镜像"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">1.选用最小化基础镜像</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-设定最小权限的-USER-运行容器"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">2.设定最小权限的 USER 运行容器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-签名和校验镜像，防范中间人攻击"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">3.签名和校验镜像，防范中间人攻击</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-检测、修正和监控开源漏洞"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">4.检测、修正和监控开源漏洞</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-容器镜像中禁止包含机密信息"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">5.容器镜像中禁止包含机密信息</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-设定镜像的标签，保证镜像的不可更改性"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">6.设定镜像的标签，保证镜像的不可更改性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-镜像构建更加安全、快速、精简"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">7.镜像构建更加安全、快速、精简</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-使用静态分析工具-Dockerfile编写指导"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">8.使用静态分析工具,Dockerfile编写指导</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x02-Docker-容器安全最佳实践"><span class="post-toc-number">3.</span> <span class="post-toc-text">0x02 Docker 容器安全最佳实践</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-主机安全配置"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">1.主机安全配置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-1-更新docker到最新版本"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">1.1 更新docker到最新版本</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2-为容器创建一个单独的分区"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">1.2 为容器创建一个单独的分区</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-只有受信任的用户才能控制docker守护进程"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">1.3 只有受信任的用户才能控制docker守护进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-4-审计docker守护进程"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">1.4 审计docker守护进程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-5-审计docker相关的文件和目录"><span class="post-toc-number">3.1.5.</span> <span class="post-toc-text">1.5 审计docker相关的文件和目录</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-docker守护进程配置"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">2.docker守护进程配置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-限制默认网桥上容器之间的网络流量"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">2.1 限制默认网桥上容器之间的网络流量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-设置日志级别为info"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">2.2 设置日志级别为info</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-允许-docker-更改iptables"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">2.3 允许 docker 更改iptables</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-不使用不安全的镜像仓库"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">2.4 不使用不安全的镜像仓库</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5-建议不使用aufs存储驱动程序"><span class="post-toc-number">3.2.5.</span> <span class="post-toc-text">2.5 建议不使用aufs存储驱动程序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-6-docker守护进程配置TLS身份认证"><span class="post-toc-number">3.2.6.</span> <span class="post-toc-text">2.6 docker守护进程配置TLS身份认证</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-7-配置合适的-ulimit-资源控制"><span class="post-toc-number">3.2.7.</span> <span class="post-toc-text">2.7 配置合适的 ulimit 资源控制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-8-启用用户命名空间"><span class="post-toc-number">3.2.8.</span> <span class="post-toc-text">2.8 启用用户命名空间</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-9-使用默认cgroup"><span class="post-toc-number">3.2.9.</span> <span class="post-toc-text">2.9 使用默认cgroup</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-10-启用docker客户端命令的授权"><span class="post-toc-number">3.2.10.</span> <span class="post-toc-text">2.10 启用docker客户端命令的授权</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-11-配置集中和远程日志记录"><span class="post-toc-number">3.2.11.</span> <span class="post-toc-text">2.11 配置集中和远程日志记录</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-12-禁用docker-resitry-v1版本支持"><span class="post-toc-number">3.2.12.</span> <span class="post-toc-text">2.12 禁用docker resitry v1版本支持</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-13-启用实时恢复"><span class="post-toc-number">3.2.13.</span> <span class="post-toc-text">2.13 启用实时恢复</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-14-禁用-userland-代理"><span class="post-toc-number">3.2.14.</span> <span class="post-toc-text">2.14 禁用 userland 代理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-15-限制容器获取新的权限"><span class="post-toc-number">3.2.15.</span> <span class="post-toc-text">2.15 限制容器获取新的权限</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-docker-守护进程文件配置"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">3.docker 守护进程文件配置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-设置-docker-service-文件所属和权限"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">3.1 设置 docker.service 文件所属和权限</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-设置docker-socket文件所属和权限"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">3.2 设置docker.socket文件所属和权限</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-设置-etc-docker目录所有权为root-root"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">3.3 设置&#x2F;etc&#x2F;docker目录所有权为root:root</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-设置仓库证书文件所有权为root：root"><span class="post-toc-number">3.3.4.</span> <span class="post-toc-text">3.4 设置仓库证书文件所有权为root：root</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-设置TLS-CA证书文件所有权为root-root"><span class="post-toc-number">3.3.5.</span> <span class="post-toc-text">3.5 设置TLS CA证书文件所有权为root:root</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-6-设置docker服务器证书文件所有权为root-root"><span class="post-toc-number">3.3.6.</span> <span class="post-toc-text">3.6 设置docker服务器证书文件所有权为root:root</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-7-设置docker服务器证书密钥文件所有权为root：root"><span class="post-toc-number">3.3.7.</span> <span class="post-toc-text">3.7 设置docker服务器证书密钥文件所有权为root：root</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-8-设置-var-run-docker-sock文件所有权为root-docker"><span class="post-toc-number">3.3.8.</span> <span class="post-toc-text">3.8  设置&#x2F;var&#x2F;run&#x2F;docker.sock文件所有权为root:docker</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-9-设置daemon-json文件所有权为root：root"><span class="post-toc-number">3.3.9.</span> <span class="post-toc-text">3.9 设置daemon.json文件所有权为root：root</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-10-设置-etc-default-docker-文件所有权为-root-root"><span class="post-toc-number">3.3.10.</span> <span class="post-toc-text">3.10 设置 &#x2F;etc&#x2F;default&#x2F;docker 文件所有权为 root:root</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-容器镜像和构建文件"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">4.容器镜像和构建文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-1-创建容器的用户"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">4.1 创建容器的用户</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-6-将HEALTHCHECK说明添加到容器镜像"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">4.6 将HEALTHCHECK说明添加到容器镜像</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-7-不在dockerfile中单独使用更新命令"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">4.7 不在dockerfile中单独使用更新命令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4-8-镜像中删除setuid和setgid权限"><span class="post-toc-number">3.4.4.</span> <span class="post-toc-text">4.8 镜像中删除setuid和setgid权限</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-容器运行时保护"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">5.容器运行时保护</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-1-设置SElinux安全选项"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">5.1 设置SElinux安全选项</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-2-linux内核特性在容器内受限"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">5.2 linux内核特性在容器内受限</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-3-不使用特权容器"><span class="post-toc-number">3.5.3.</span> <span class="post-toc-text">5.3 不使用特权容器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-4-敏感的主机系统目录不要挂载在容器上"><span class="post-toc-number">3.5.4.</span> <span class="post-toc-text">5.4 敏感的主机系统目录不要挂载在容器上</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-5-SSH-不在容器中运行"><span class="post-toc-number">3.5.5.</span> <span class="post-toc-text">5.5 SSH 不在容器中运行</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-6-特权端口禁止映射到容器内"><span class="post-toc-number">3.5.6.</span> <span class="post-toc-text">5.6 特权端口禁止映射到容器内</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-7-只映射必要的端口"><span class="post-toc-number">3.5.7.</span> <span class="post-toc-text">5.7 只映射必要的端口</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-8-不共享主机的网络命名空间"><span class="post-toc-number">3.5.8.</span> <span class="post-toc-text">5.8 不共享主机的网络命名空间</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-9-确保容器的内存使用合理"><span class="post-toc-number">3.5.9.</span> <span class="post-toc-text">5.9 确保容器的内存使用合理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-10-正确设置容器上的CPU优先级"><span class="post-toc-number">3.5.10.</span> <span class="post-toc-text">5.10 正确设置容器上的CPU优先级</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-11-确保进入容器的流量绑定到特定的网卡"><span class="post-toc-number">3.5.11.</span> <span class="post-toc-text">5.11 确保进入容器的流量绑定到特定的网卡</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-12-容器重启策略on-failure设置为5"><span class="post-toc-number">3.5.12.</span> <span class="post-toc-text">5.12 容器重启策略on-failure设置为5</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-13-确保主机的进程命名空间不共享"><span class="post-toc-number">3.5.13.</span> <span class="post-toc-text">5.13 确保主机的进程命名空间不共享</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-14-主机的IPC命令空间不共享"><span class="post-toc-number">3.5.14.</span> <span class="post-toc-text">5.14 主机的IPC命令空间不共享</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-15-主机设备不直接共享给容器"><span class="post-toc-number">3.5.15.</span> <span class="post-toc-text">5.15 主机设备不直接共享给容器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-16-设置默认的ulimit配置（在需要时）"><span class="post-toc-number">3.5.16.</span> <span class="post-toc-text">5.16 设置默认的ulimit配置（在需要时）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-17-设置主机的UTS命令空间不共享"><span class="post-toc-number">3.5.17.</span> <span class="post-toc-text">5.17 设置主机的UTS命令空间不共享</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5-18-不要使用docker的默认网桥docker0"><span class="post-toc-number">3.5.18.</span> <span class="post-toc-text">5.18 不要使用docker的默认网桥docker0</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x0n-本章总结"><span class="post-toc-number">4.</span> <span class="post-toc-text">0x0n 本章总结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-参考来源"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">1.参考来源</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-工具展示"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">2.工具展示</span></a></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    


    <!-- 支付宝微信文章赞赏 -->
    
      <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        如果此篇文章对您有帮助，就请作者喝杯 Coffee ☕️☕️!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardwechat" src="/img/reward-wechat.jpg" height="250" height="250" alt="微信打赏二维码">
            <img id="rewardalipay" src="/img/reward-alipay.png" height="250" height="250" alt="支付宝打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <!-- <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.png"> -->
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

      

    <!-- 微信公众号关注/文章版权复制 -->
    
      <div id="btw-mask" style="position: fixed; top: 0px; right: 0px; bottom: 0px; left: 0px; opacity: 0.7; z-index: 999; background: rgb(0, 0, 0); display:none"></div>
<div id="btw-modal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 360px; text-align: center; font-size: 13px; background: rgb(255, 255, 255); border-radius: 10px; z-index: 9999; font-family: PingFangSC-Regular, sans-serif;display:none">
<span id="btw-modal-close-btn" style="position: absolute; top: 5px; right: 15px; line-height: 1.8; font-size: 15px; cursor: pointer; opacity: 0.2; z-index: 9999; color: rgb(0, 0, 0); background: none; border: none; outline: none;">X</span>
<p id="btw-modal-header" style="margin-top: 40px; line-height: 1.8; font-size: 13px; ">
<b style="color:#6190e8;">你好朋友,可以关个注吗? ❤ <br> 这将是我持续更新文章的动力源泉，谢谢支持！(๑′ᴗ‵๑) </b> <br> 如不想关注请点击右上角的【X】<br>
<br>Method 1.Please visit <strong><a href="https://twitter.com/WeiyiGeek" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【My Twitter】</a></strong>. There is an article verification code in the homepage.
<br>方式2.请访问本博主的B站<strong><a href="https://space.bilibili.com/385802642" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【WeiyiGeek】</a></strong>首页关注UP主,<br>将自动随机获取解锁验证码。
<br>方式3.扫一扫下方二维码，关注本站<strong>官方公众号</strong><br>
回复：<strong style="color: rgb(240, 65, 52);">验证码</strong>
将获取<strong style="color: rgb(240, 65, 52);">解锁(有效期7天)</strong>本站所有技术文章哟!</p>
<img src="/img/wechat-search.png" style="width: 300px; margin-top: 10px;">
<div id="btw-modal-input-code" style="margin-top: 20px; background: rgb(255, 255, 255);">
  <input id="btw-modal-input" type="number" minlength="4" maxlength="4" placeholder="请输入验证码|Verification Code"
    style="width: 165px; height: 32px; line-height: 32px; padding: 0px 10px; margin: 0px 10px; font-size: 13px; text-rendering: auto; text-transform: none; cursor: text; outline: none; box-sizing: border-box; border: 1px solid rgb(221, 221, 221); -webkit-appearance: textfield; background-color: white; -webkit-rtl-ordering: logical;"/>
  <button id="btw-submit-btn" onclick="yzm_vertify()"
    style="padding: 0px 20px; height: 32px; font-size: 14px; outline: none; border: none; color: rgb(255, 255, 255); background: rgb(222, 104, 109); cursor: pointer;">提
    交</button> </div>
<p id="btw-footer" style="margin: 40px 0px 20px; color: rgb(153, 153, 153);">@WeiyiGeek - 为了能到远方，脚下的每一步都不能少</p>
</div>
        
</article>
</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://weiyigeek.top" target="_blank">https://weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.weiyigeek.top" target="_blank">https://blog.weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://weiyigeek.top/img/search-wechat.jpg" target="_blank">公众账号</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://space.bilibili.com/385802642/article" target="_blank">哔哩哔哩专栏</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/weiyigeek" target="_blank">博主Github</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://gitee.com/WeiyiGeek" target="_blank">博主Gitee</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.zhihu.com/people/weiyiSec" target="_blank">知乎</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.cnblogs.com/WeiyiGeek" target="_blank">博客园</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://my.oschina.net/weiyigeek" target="_blank">OSCHINA</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAqcPSoMqfctaEqJpGSF775eeCjWkrop4AOyLITdMx-L78F5iXzfQcSRM5sY4dq3wR" target="_blank">今日头条</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.csdn.net/u013072756?type=lately" target="_blank">CSDN</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.jianshu.com/u/5199a1104739" target="_blank">简书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cloud.tencent.com/developer/user/1389665/articles" target="_blank">腾讯云社区</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cuttlefish.baidu.com/shop/75c5dbd8d15abe23482f4d40" target="_blank">百度文库</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://author.baidu.com/home?from=blog&app_id=1726736601523415" target="_blank">IT极客知识分享</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.51cto.com/weiyigeek" target="_blank">51CTO博客</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://juejin.cn/user/122767337595934" target="_blank">掘金</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://weibo.com/a/hot/7622022703618049_1.html" target="_blank">微博文章</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.xiaohongshu.com/user/profile/627c98bb000000001000e7ba" target="_blank">小红书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://segmentfault.com/u/weiyigeek" target="_blank">Segmentfault</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.modb.pro/u/506690" target="_blank">墨天轮</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.douyin.com/user/MS4wLjABAAAAMSBdMja6XLsdmzafb0RNbFeBemIOk38K1PaOClZeI1Q" target="_blank">抖音主页</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.kuaishou.com/profile/3xfbrsrhd2i69x9" target="_blank">快手主页</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.ixigua.com/home/3984243135350727" target="_blank">西瓜视频</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
      <p>
        <span>WeiyiGeek &copy; 2018 - 2022 <a href="https://weiyigeek.top" target="_blank" rel="noopener">weiyigeek.top</a> All rights reserved.唯一极客IT知识分享 版权所有 </span>
        
        <span>
          Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/weiyigeek" target="_blank">mellow</a>
        </span>
        
        <br/>访问统计
        <span><a href="/sitemap.xml" target="_blank" rel="Sitemaps-站点地图">Sitemaps</a> </span>
        <span><a href="/baidusitemap.xml" target="_blank" rel="baidusitemaps-百度站点地图">站点地图</a> </span>
        <!-- 
  -->
        <br/>ICP备案号<span><a href="https://beian.miit.gov.cn" target="_blank">渝ICP备2022003447号</a></span>
        <br/>
        <div id="cc-myssl-id">
          <a href="https://myssl.com/blog.weiyigeek.top?from=mysslid" target="_blank" rel="noopener"><img src="https://static.myssl.com/res/images/myssl-id1.png" alt="MySSL安全认证" style="max-height:50px;display:block;margin:0 auto"></a>
        </div>
      </p>
    </div>
</footer>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2019/6-4-460.html&title=《6.Docker镜像与容器安全最佳实践》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2019/6-4-460.html&title=《6.Docker镜像与容器安全最佳实践》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2019/6-4-460.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《6.Docker镜像与容器安全最佳实践》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2019/6-4-460.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2019/6-4-460.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMElEQVR42u3aQXLCMAwFUO5/aTrTLSR8SUlLnOcVQzPYzwtVivR4xOv5u7Y+v67XJ1+f39pl668HLAwMjMsynrtra4P9b/ZJW7z8mt5QMTAwbsBIgmweUvevKTl6fjYMDAyMPETmpCTcY2BgYEwYSalZfeYfAi4GBsYFGUeVoPvbf0UtjoGBcUHGvDFw3uc/7W9gYGB8JeNZXPMgWG1zRqfCwMBYmlF96V9tZ54X+qMMFwMDY2nGsUlePpCRXO5mMYyBgbEooxpS8/qx1yrIr/VNhouBgbE0Iy9Q94/baz1OznDAT2BgYFyEUU3FesNeveQvOgMGBsbSjHw4bH6s/eI2v9ZocgQDA2M5Rq/12Bsp641WRL+MgYGxKCMvKXsjFL2ytpx0YmBgLM04L7GbNwaawRoDA2M5xqQNUL2t3jBHkpJiYGDcgTFJ0XpjYfMQjIGBcTdGLwjm21SHMw4rXDEwMBZlJEEwbwDkL+N6xXCU4WJgYFycUQ12yfhF71KqReyHTiwGBsZCjDMCX/5avzpYFjUGMDAwbsCYl6zzhLJc0GJgYCzNqI5EVBsJk8ZDchEYGBh3YPSGLZLv8wK4N5ZxwFgYBgbGRRj5Oqr4rIbyZmqIgYGxHOOoIFtN73pBeROJgYFxA8akZJ20Dar/ATAwMDCSBkAS/nqv+6sv5jAwMDAKaVmxJdBjfOhvYGBg3ICRF7E5eFLWVktcDAyMtRmT0jFvK/Y2rl4oBgbGcowfeFplq/EDWqcAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="/js/jquery/2.1.0-jquery.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/jquery/3.5.2-jquery.fancybox.min.js?v=1.6.6"></script>
<!--  //cdn.bootcss.com/node-waves/0.7.4/waves.min.js -->
<script type="text/javascript" src="/js/node-waves/0.7.4-waves.min.js?v=1.6.6"></script> 

<script type="text/javascript" src="/js/method.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/blog.js?v=1.6.6"></script>

<!-- third-party -->
<script type="text/javascript" src="/js/plugins/local_search.js?v=1.6.6"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) { search_path = "search.xml";}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script> 

<script> (adsbygoogle = window.adsbygoogle || []).push({});</script>    


<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> --> 


  


<script>
  var _hmt = _hmt || [];
  (function() {
    // 百度统计
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?53923c4b5560739bc0ed61e183be6acf";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>
 


<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.staticfile.org/mathjax/2.7.9/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
<script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = 'WeiyiGeek Blog-关注于网络安全_物联网安全开发_网络安全运维-学习心得分享';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)咦!又好了!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>
 

     <script type="text/javascript" src="/js/custom/copytips.js?v=1.6.6"></script> 
</body>
</html>