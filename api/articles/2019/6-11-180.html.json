{"title":"Shell脚本管道符与重定向","slug":"系统运维/Linux/常用命令/脚本常用类命令/Shell脚本管道符与重定向","date":"2019-06-11T10:37:30.000Z","updated":"2023-01-31T02:29:09.172Z","url":"2019/6-11-180.html","path":"api/articles/2019/6-11-180.html.json","covers":["https://img.weiyigeek.top/2019/20190611141854.png","https://img.weiyigeek.top/2019/20190611153008.png","https://img.weiyigeek.top/2019/20190611154512.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0x00-快速入门\"><a href=\"#0x00-快速入门\" class=\"headerlink\" title=\"0x00 快速入门\"></a>0x00 快速入门</h4><p>主要介绍管道符与输出重定向的基础知识</p>\n<h5 id=\"1-多命令执行\"><a href=\"#1-多命令执行\" class=\"headerlink\" title=\"1. 多命令执行\"></a>1. 多命令执行</h5><p><em>多命令顺序执行符列表</em>：</p>\n<table>\n<thead>\n<tr>\n<th>多命令执行符</th>\n<th>格式</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>;</td>\n<td>命令1 ; 命令2</td>\n<td>多个命令顺序执行，命令之间没有任何逻辑联系</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>命令1 &amp;&amp; 命令2</td>\n<td>逻辑与，命令1正确执行才会执行命令2，命令1不正确执行，则命令2不会执行</td>\n</tr>\n<tr>\n<td>shift+\\shift+\\ =ll</td>\n<td>命令1 ll 命令2</td>\n<td>逻辑或，当命令1执行不正确，则命令2才会执行，当命令1正确执行，则命令2不会执行。注释：其中shift+\\意味着</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>例如：date ; tar -zcvf etc.tar.gz /etc ; date可以计算中间打包压缩命令执行的耗时<br>再如：ls &amp;&amp; echo yes || echo no，第一个命令正确执行，输出yes，错误执行输出no</p>\n</blockquote>\n<p><br></p>\n<h5 id=\"2-管道符\"><a href=\"#2-管道符\" class=\"headerlink\" title=\"2. 管道符\"></a>2. 管道符</h5><p>命令格式：<br>命令1 | 命令2，有一定的编程思想在里面 命令1的正确输出作为命令2的操作对象，和逻辑与不一样</p>\n<p>实际案例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l /etc | more   <span class=\"comment\">#代表将ls -l /etc的输出分屏显示</span></span><br><span class=\"line\">netstat -an | grep ESTABLISHED   <span class=\"comment\">#代表搜索netstat -an输出中带有ESTABLISHED的行</span></span><br><span class=\"line\">netstat -an | grep ESTABLISHED | wc -l   <span class=\"comment\">#此为多管道符命令，代表到最后统计带有ESTABLISHED的行的数目，即可看出服务器上连接了多少人</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h5 id=\"3-标准输入输出\"><a href=\"#3-标准输入输出\" class=\"headerlink\" title=\"3. 标准输入输出\"></a>3. 标准输入输出</h5><p>linux启动后会默认打开3个文件描述符：</p>\n<table>\n<thead>\n<tr>\n<th>设备</th>\n<th>设备文件名</th>\n<th>类型</th>\n<th>文件描述符</th>\n<th>内存文件名</th>\n<th>使用符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>键盘</td>\n<td>/dev/stdin</td>\n<td>标准输入/读取数据</td>\n<td>0</td>\n<td>/proc/self/fd/0</td>\n<td>使用 &lt; 或 &lt;&lt;</td>\n</tr>\n<tr>\n<td>显示器</td>\n<td>/dev/stdout</td>\n<td>标准输出数据</td>\n<td>1</td>\n<td>/proc/self/fd/1</td>\n<td>使用 &gt; 或 &gt;&gt;</td>\n</tr>\n<tr>\n<td>显示器</td>\n<td>/dev/stderr</td>\n<td>标准错误输出</td>\n<td>2</td>\n<td>/proc/self/fd/2</td>\n<td>使用 2&gt; 或 2&gt;&gt;</td>\n</tr>\n</tbody>\n</table>\n<p>一条shell命令执行，都会继承父进程的文件描述符因此,所有运行的shell命令，都会有默认3个文件描述符。<br>即对于任何一条linux 命令执行它会是这样一个过程：</p>\n<blockquote>\n<p>先有一个输入：输入可以从键盘，也可以从文件得到<br>命令执行完成：成功了就会把成功结果输出到屏幕：standard output默认是屏幕<br>命令执行有错误：会把错误也输出到屏幕上面：standard error默认也是指的屏幕</p>\n</blockquote>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190611141854.png\" alt=\"WeiyiGeek.标准输入输出\" title=\"\" class=\"\">\n                <p>WeiyiGeek.标准输入输出</p>\n            </figure>\n<p><br></p>\n<p><em>（1）输出重定向</em></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>符号</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>标准输出重定向</td>\n<td>命令 &gt; 文件</td>\n<td>以覆盖的方式,把命令的正确的输出,输出到指定文件或者设备中</td>\n</tr>\n<tr>\n<td>标准输出重定向</td>\n<td>命令 &gt;&gt; 文件</td>\n<td>以追加的方式,把命令的正确输出,输出到指定文件或者设备之中</td>\n</tr>\n<tr>\n<td>标准错误输出重定向</td>\n<td>错误命令 2 &gt; 文件</td>\n<td>以覆盖的方式,把命令的错误的输出,输出到指定文件或者设备中</td>\n</tr>\n<tr>\n<td>标准错误输出重定向</td>\n<td>错误命令 2 &gt;&gt; 文件</td>\n<td>以追加的方式,把命令的错误输出,输出到指定文件或者设备之中</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<p><em>（2）正确和错误输出同时保存</em></p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>符号</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正确输出和错误输入同时保持</td>\n<td>命令 &gt; 文件 2&gt;&amp;1  或者 命令 &amp;&gt; 文件</td>\n<td>以覆盖方式,把suc与err输出都保存到同一个文件中</td>\n</tr>\n<tr>\n<td></td>\n<td>命令 &gt;&gt; 文件 2&gt;&amp;1  或者 命令 &amp;&gt;&gt; 文件</td>\n<td>以追加方式,把suc与err输出都保存到同一个文件中+</td>\n</tr>\n<tr>\n<td></td>\n<td>命令 &gt;&gt; suc文件 2&gt;&gt;err文件</td>\n<td>把正确的输出追加到文件1中,把错误的输出追加到文件2中</td>\n</tr>\n</tbody>\n</table>\n<p>实际示例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#语法案例</span></span><br><span class=\"line\"><span class=\"built_in\">command</span>-line1 [0-2] &gt; file   <span class=\"comment\">#0,1,2文件描述符或&amp;设备/dev/null</span></span><br><span class=\"line\">&amp;[n] 代表是已经存在的文件描述符，&amp;1 代表输出 &amp;2代表错误输出 &amp;-代表关闭与它绑定的描述符</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例1.这个例子是讲，我们执行了任意命令，并输出到/dev/sda。</span></span><br><span class=\"line\"><span class=\"comment\">#这样的话/dev/sda 里面的文件会被命令输出的内容全部替换掉，最后丢失掉其中原有的数据。</span></span><br><span class=\"line\">$任意命令 &gt; /dev/sda</span><br><span class=\"line\">ifconfig &gt; ~/desktop/test.log     <span class=\"comment\">##将内容保存在日志文件中</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例2.正确输出与错误输出都显示在屏幕了，现在需要把正确输出写入suc.txt</span></span><br><span class=\"line\"><span class=\"comment\"># 1&gt;可以省略不写，默认所至标准输出</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh</span><br><span class=\"line\">ls: test1.sh: 没有这个文件和目录</span><br><span class=\"line\">test.sh</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例3.把错误输出到err.txt,正确输出到suc.txt中</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh 1&gt;suc.txt 2&gt; err.txt <span class=\"comment\"># 2&gt;是将错误输出到文件</span></span><br><span class=\"line\"><span class=\"variable\">$cat</span> suc.txt err.txt</span><br><span class=\"line\">test.sh</span><br><span class=\"line\">ls: 无法访问test1.sh: 没有那个文件或目录</span><br><span class=\"line\"><span class=\"comment\"># 继续追加把输出写入suc.txt err.txt  “&gt;&gt;”追加操作符</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh 1&gt;&gt;suc.txt 2&gt;&gt;err.txt </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例4.#&amp;代表标准输出错误输出，将所有标准输出与错误输出 输入到/dev/null文件或者file.txt文件中.</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh &amp;&gt;/dev/null  <span class=\"comment\">#及屏蔽stdout与stderr</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh &gt;/dev/null 2&gt;&amp;1  <span class=\"comment\">#将错误输出2绑定给正确输出1，然后将正确输出发送给/dev/null设备这种常用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh &amp;&gt;file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例5.将错误输出信息关闭掉</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh 2&gt;&amp;-</span><br><span class=\"line\">test.sh</span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh 2&gt;/dev/null</span><br><span class=\"line\">test.sh</span><br><span class=\"line\"><span class=\"comment\"># 关闭所有输出</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span> test.sh test1.sh  1&gt;&amp;- 2&gt;&amp;-  <span class=\"comment\">#关闭 1 ，2 文件描述符</span></span><br></pre></td></tr></table></figure></p>\n<p><em>注意事项：</em></p>\n<ul>\n<li>特别注意错误输出大于号和文件之间不能有空格！！！</li>\n<li>1、shell遇到”&gt;”操作符，会判断右边文件是否存在，如果存在就先删除，并且创建新文件,不存在直接创建, 无论左边命令执行是否成功,右边文件都会变为空</li>\n<li>2、“&gt;&gt;”操作符，判断右边文件，如果不存在就先创建。以添加方式打开文件，会分配一个文件描述符[不特别指定，默认为[1,2]然后，与左边的标准输出（1）或错误输出（2） 绑定</li>\n<li>3、当命令：执行完，绑定文件的描述符也自动失效0,1,2又会空闲</li>\n<li>4、一条命令启动，命令的输入，正确输出，错误输出，默认分别绑定0,1,2文件描述符</li>\n<li>5、一条命令在执行前，先会检查输出是否正确，如果输出设备错误，将不会进行命令执行</li>\n</ul>\n<p><br></p>\n<p><em>（3）输入重定向</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基础语法</span></span><br><span class=\"line\"><span class=\"built_in\">command</span>-line [n] &lt;file   <span class=\"comment\">##0,1,2文件描述符或&amp;设备/dev/null</span></span><br><span class=\"line\"></span><br><span class=\"line\">n &gt;&amp; m\t将输出文件 m 和 n 合并</span><br><span class=\"line\">n &lt;&amp; m\t将输入文件 m 和 n 合并</span><br></pre></td></tr></table></figure></p>\n<p>实际案例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例1. 和输出重定向一样，Unix 命令也可以从文件获取输入，语法为： </span></span><br><span class=\"line\"><span class=\"variable\">$cat</span> &lt; catfile   <span class=\"comment\">#按下 [ctrl]+d 离开 </span></span><br><span class=\"line\">testing </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例2.从标准输入【键盘】获得数据，然后输出给catfile文件</span></span><br><span class=\"line\"><span class=\"variable\">$cat</span> &gt; file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例3.cat 从test.sh 获得输入数据，然后输出给文件catfile</span></span><br><span class=\"line\">cat &gt;catfile &lt;test.sh</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190611153008.png\" alt=\"WeiyiGeek.示例2/3\" title=\"\" class=\"\">\n                <p>WeiyiGeek.示例2/3</p>\n            </figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例4.用的最多输入重定向到文件</span></span><br><span class=\"line\"><span class=\"variable\">$cat</span> &gt;catfile &lt;&lt;eof</span><br><span class=\"line\"><span class=\"built_in\">test</span> a file</span><br><span class=\"line\"><span class=\"built_in\">test</span>!</span><br><span class=\"line\">eof</span><br><span class=\"line\"><span class=\"comment\">##&lt;&lt; 这个连续两个小符号， 他代表的是『结束的输入字符』的意思。这样当空行输入eof字符，&gt;输入多行数据后按ctrl+D结束写入</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例5.输入重定向描述符的妙用</span></span><br><span class=\"line\"><span class=\"variable\">$wc</span> &lt; test.log  <span class=\"comment\">#wc命令原本的输入是键盘，现在重新定向为文件，当然，其实不需要&lt;</span></span><br><span class=\"line\">1  3 54 <span class=\"comment\">#行数 单词数 字节数</span></span><br><span class=\"line\"><span class=\"comment\">#下面它会要求你不断输入，知道再遇到ddy，就会停止并做相关统计，实际工作中基本不会用到.</span></span><br><span class=\"line\"><span class=\"variable\">$wc</span> &lt;&lt;ddy &gt;test.log</span><br><span class=\"line\">  This is a input content;</span><br><span class=\"line\">ddy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$cat</span> test.log</span><br><span class=\"line\">1  5 27</span><br><span class=\"line\"><span class=\"comment\">#还能将将字符统计的输入到Test.log中（可以无先）</span></span><br></pre></td></tr></table></figure>\n<p>补充知识点：</p>\n<ul>\n<li>EOF字符前面可以采用一个-,后面连接的EOF结束字符不用一定在首行(但是需要采用Tab键功能进行缩进)</li>\n</ul>\n<p><br></p>\n<h5 id=\"4-exec-命令\"><a href=\"#4-exec-命令\" class=\"headerlink\" title=\"4. exec 命令\"></a>4. exec 命令</h5><p>描述：在上面讲的输入输出重定向，是将输入输出绑定文件或设备后。只对当前那条指令是有效的。如果需要在绑定之后，接下来的所有命令都支持的话,就需要用exec命令来绑定重定向;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基础语法</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 文件描述符[n] &lt;或&gt; file或文件描述符或设备</span><br></pre></td></tr></table></figure></p>\n<p>实际案例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例1.将标准输出与fd 6绑定</span></span><br><span class=\"line\"><span class=\"variable\">$exec</span> 6&gt;&amp;1</span><br><span class=\"line\"><span class=\"variable\">$ls</span> /proc/self/fd/  </span><br><span class=\"line\">0  1  2  3  6  <span class=\"comment\">#出现文件描述符6</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例2.将命令标准输出绑定到suc.txt文件中(输出到该文件)</span></span><br><span class=\"line\"><span class=\"variable\">$exec</span> 1&gt;suc.txt</span><br><span class=\"line\">ls -al  <span class=\"comment\">##执行命令，发现什么都不返回了，因为标准输出已经输出到suc.txt文件了</span></span><br><span class=\"line\"><span class=\"variable\">$exec</span> 1&gt;&amp;6  <span class=\"comment\">##恢复标准输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例3.关闭fd 6描述符</span></span><br><span class=\"line\"><span class=\"comment\">#说明：使用前先将标准输入保存到文件描述符6，文件描述符默认会打开0,1,2 还可以使用自定义描述符 。</span></span><br><span class=\"line\"><span class=\"comment\">#然后对标准输出绑定到文件，接下来所有输出都会发生到文件使用完后，恢复标准的输出，关闭打开文件描述符6。</span></span><br><span class=\"line\"><span class=\"variable\">$exec</span> 6&gt;&amp;-</span><br><span class=\"line\"><span class=\"variable\">$ls</span> /proc/self/fd/</span><br><span class=\"line\">0  1  2  3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例4.exec执行如果命令是执行一次后就退出，如果命令是一直在前台执行的情况下会持续执行;</span></span><br><span class=\"line\"><span class=\"variable\">$exec</span> ps aux</span><br><span class=\"line\">root      84387  0.0  0.0 155372  1868 pts/0    Rs+  09:22   0:00 ps aux</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 示例4.同时输出到终端以及文件中</span></span><br><span class=\"line\"><span class=\"comment\"># Send all output to the logfile as well as stdout.</span></span><br><span class=\"line\"><span class=\"comment\"># Output to 1 goes to stdout and the logfile.</span></span><br><span class=\"line\"><span class=\"comment\"># Output to 2 goes to stderr and the logfile.</span></span><br><span class=\"line\"><span class=\"comment\"># Output to 3 just goes to stdout. 标准输出</span></span><br><span class=\"line\"><span class=\"comment\"># Output to 4 just goes to stderr. 错误输出</span></span><br><span class=\"line\"><span class=\"comment\"># Output to 5 just goes to the logfile.</span></span><br><span class=\"line\">LOGFILE=/var/<span class=\"built_in\">log</span>/weiyigeek-$(date +%Y%m%d-%s).<span class=\"built_in\">log</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> \\</span><br><span class=\"line\">  3&gt;&amp;1 \\</span><br><span class=\"line\">  4&gt;&amp;2 \\</span><br><span class=\"line\">  5&gt;&gt; <span class=\"string\">\"<span class=\"variable\">$&#123;LOGFILE&#125;</span>\"</span> \\</span><br><span class=\"line\">  &gt; &gt;(tee -a <span class=\"string\">\"<span class=\"variable\">$&#123;LOGFILE&#125;</span>\"</span>) \\</span><br><span class=\"line\">  2&gt; &gt;(tee -a <span class=\"string\">\"<span class=\"variable\">$&#123;LOGFILE&#125;</span>\"</span> &gt;&amp;2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如:</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">\"[<span class=\"variable\">$(date +'%Y-%m-%dT%H:%M:%S')</span>]-\\033[31mERROR: <span class=\"variable\">$&#123;MSG&#125;</span> \\033[0m \\n\"</span> &gt;&amp;5</span><br><span class=\"line\"><span class=\"built_in\">printf</span> <span class=\"string\">\"[<span class=\"variable\">$(date +'%Y-%m-%dT%H:%M:%S')</span>]-\\033[31mERROR: <span class=\"variable\">$&#123;MSG&#125;</span> \\033[0m \\n\"</span> &gt;&amp;3</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190611154512.png\" alt=\"WeiyiGeek.删除文件描述符\" title=\"\" class=\"\">\n                <p>WeiyiGeek.删除文件描述符</p>\n            </figure></p>\n<p>补充知识点：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#故障案例1</span></span><br><span class=\"line\">可能有朋友会这样用：<span class=\"built_in\">exec</span> 1&gt;suc.txt ，接下来所有输出都绑定到suc.txt 文件</span><br><span class=\"line\"><span class=\"built_in\">exec</span> 1&gt;&amp;2 <span class=\"comment\">#恢复采用错误输出 ,1 &gt;&amp; 2 意思是将标准输出重定向到句柄2错误输出</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#故障案例2</span></span><br><span class=\"line\"><span class=\"comment\">#打开test.sh可读写操作与文件描述符3绑定</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 3&lt;&gt;test.sh</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">read</span> line&lt;&amp;3</span><br><span class=\"line\"> <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"variable\">$line</span>; <span class=\"comment\">#循环读取文件描述符3（读取的是test.sh内容）</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#关闭文件的输入、输出绑定</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 3&gt;&amp;-</span><br><span class=\"line\"><span class=\"built_in\">exec</span> 3&lt;&amp;-</span><br><span class=\"line\">&gt;&amp; 将一个句柄的输出写入到另一个句柄的输入中</span><br><span class=\"line\">&lt;&amp; 从一个句柄读取输入并将其写入到另一个句柄输出中</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#故障案例3: 直接采用exec来进行绑定</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span>&lt;a.log</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">read</span> line</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"variable\">$line</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure></p>\n<p>总结重定向应用通常就以下两点：</p>\n<ul>\n<li>1、重新设置命令的默认输入、输出，指向到自己文件（文件，文件描述符，设备其实都是文件，因为linux就是基于设备也是文件，描述符也指向是文件）</li>\n<li>2、扩展自己新的描述符，对文件进行读写操作</li>\n</ul>\n<hr/>\n\n<h4 id=\"0x02-高级管道命令\"><a href=\"#0x02-高级管道命令\" class=\"headerlink\" title=\"0x02 高级管道命令\"></a>0x02 高级管道命令</h4><h5 id=\"lt-lt-EOF\"><a href=\"#lt-lt-EOF\" class=\"headerlink\" title=\"&lt;&lt;EOF\"></a>&lt;&lt;EOF</h5><p>描述：Here Document(”嵌入文档“)是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;&lt; delimiter\t将开始标记 delimiter 和结束标记 delimiter 之间的内容作为输入，当遇到 delimiter则结束输入</span><br><span class=\"line\"></span><br><span class=\"line\">#它的作用是将两个 delimiter（分隔符号）之间的内容(document) 作为输入传递给 command.</span><br><span class=\"line\">command &lt;&lt; delimiter</span><br><span class=\"line\">     document</span><br><span class=\"line\">delimiter</span><br></pre></td></tr></table></figure></p>\n<p>实际案例:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例1.下面的例子，通过 wc -l 命令计算 document 的行数：</span></span><br><span class=\"line\"><span class=\"variable\">$wc</span> -l &lt;&lt; EOF</span><br><span class=\"line\">    This is a simple lookup program</span><br><span class=\"line\">    <span class=\"keyword\">for</span> good (and bad) restaurants 餐厅</span><br><span class=\"line\">    <span class=\"keyword\">in</span> Cape Town.</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例2.在shell脚本中进行使用</span></span><br><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">cat &lt;&lt; EOF</span><br><span class=\"line\">This is a simple lookup program</span><br><span class=\"line\"><span class=\"keyword\">for</span> good (and bad) restaurants</span><br><span class=\"line\"><span class=\"keyword\">in</span> Cape Town.</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#实例3.通过管道与应用交交互</span></span><br><span class=\"line\">FTP_SERVER=ftp.n1.dabian.org</span><br><span class=\"line\">FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom</span><br><span class=\"line\">REMOTE_FILE=debian-cd_info.tar.gz</span><br><span class=\"line\"><span class=\"comment\"># -n: inhibit auto-login</span></span><br><span class=\"line\">ftp -n &lt;&lt; EOF</span><br><span class=\"line\">open <span class=\"variable\">$FTP_SERVER</span></span><br><span class=\"line\">user anonymous me@linuxbox</span><br><span class=\"line\"><span class=\"built_in\">cd</span> <span class=\"variable\">$FTP_PATH</span></span><br><span class=\"line\"><span class=\"built_in\">hash</span></span><br><span class=\"line\">get <span class=\"variable\">$REMOTE_FILE</span></span><br><span class=\"line\"><span class=\"built_in\">bye</span></span><br><span class=\"line\">EOF</span><br><span class=\"line\">ls -l <span class=\"variable\">$REMOTE_FILE</span></span><br></pre></td></tr></table></figure></p>\n<p><em>注意：</em></p>\n<ul>\n<li>开始的delimiter前后的空格会被忽略掉\\</li>\n<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进</li>\n</ul>\n<p><br></p>\n<h5 id=\"mkfifo-模块\"><a href=\"#mkfifo-模块\" class=\"headerlink\" title=\"mkfifo 模块\"></a>mkfifo 模块</h5><p>mkfifo 使用指定的文件名创建FIFO(也称为”命名管道”)，它是一种特殊的文件类型，它允许独立的进程通讯（反弹Shell你懂的）<br>一个进程打开FIFO文件进行写操作,而另一个进程对之进行读操作, 然后数据便可以如同在shell或者其它地方常见的的匿名管道一样流线执行.<br>默认情况下,创建的FIFO的模式为0666(‘a+rw’)减去umask中设置的位<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基础语法</span></span><br><span class=\"line\">mkfifo [options] file</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#选项</span></span><br><span class=\"line\">-m mode, --mode=mode：设置创建的FIFO的模式为 mode, 这可以是 chmod(1) 中的符号模式,并使用默认模式作为起始点,其实就是rwx权限</span><br><span class=\"line\">GNU STANDARD OPTIONS(GNU标准选项)</span><br><span class=\"line\">--<span class=\"built_in\">help</span>：在标准输出上打印一条用法信息,并以成功状态退出.</span><br><span class=\"line\">--version：在标准输出上打印版本信息,然后以成功状态退出.</span><br><span class=\"line\">--：终止选项列表.</span><br></pre></td></tr></table></figure></p>\n<p>实际案例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例1.mkfifo -m 使用案例</span></span><br><span class=\"line\">mkfifo -m 777  myfifo</span><br><span class=\"line\">cat /etc/passwd &gt; myfifo &amp;  <span class=\"comment\">#将cat命令的输出作为此myfifo的输入，并放在后太运行、</span></span><br><span class=\"line\">[10] 6285</span><br><span class=\"line\"><span class=\"comment\">#再用cut命令从该myfifo中读出数据进行处理</span></span><br><span class=\"line\">cut -d: -f1-3 &lt; myfifo</span><br><span class=\"line\">root:x:0</span><br><span class=\"line\">bin:x:1</span><br></pre></td></tr></table></figure></p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"Linux命令","path":"api/categories/Linux命令.json"}],"tags":[{"name":"shell","path":"api/tags/shell.json"}]}