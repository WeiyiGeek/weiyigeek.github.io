{"title":"操作系统学习笔记(三).md","slug":"书籍笔记/计算机操作系统原理/操作系统学习笔记(四)","date":"2019-03-27T07:35:30.000Z","updated":"2022-03-29T05:39:06.313Z","url":"2019/3-27-28.html","path":"api/articles/2019/3-27-28.html.json","covers":["https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609185326.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609204040.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609211242.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609213859.png"],"content":"<h4 id=\"11-信号量与同步知识补充\"><a href=\"#11-信号量与同步知识补充\" class=\"headerlink\" title=\"11.信号量与同步知识补充\"></a>11.信号量与同步知识补充</h4><p>(1) 死锁问题与特征<br>(2) 死锁处理与避免<br>(3) 调度算法/实时调度/多处理器调度<br>(4) 优先级反转</p>\n<a id=\"more\"></a>\n<h5 id=\"11-1-死锁问题与特征\"><a href=\"#11-1-死锁问题与特征\" class=\"headerlink\" title=\"11.1 死锁问题与特征\"></a>11.1 死锁问题与特征</h5><p>在我们操作系统中非常容易出现死锁状态(类似于编译安装依赖),一组阻塞得进程持有一种资源等待获取另一个进程锁占有得一个资源,例如：</p>\n<ul>\n<li>系统有2个磁带驱动器;</li>\n<li>P1和P2各有一个,都需要另外一个;</li>\n</ul>\n<p>比如：桥的每一部分可以看作一个资源，流量只在一个方向上;<br>如果死锁可能通过一辆车倒退可以解决(抢占资源和回滚),也可能几辆车必须都倒退,可能发生饥饿;<br><figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609185326.png\" alt=\"WeiyiGeek.死锁模拟图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.死锁模拟图</p>\n            </figure></p>\n<p><em>为什么会出现死锁?</em><br>答：这个是由于系统进程并发执行导致的,当多个进程在一块运行得时候,这些资源是共享得大家都能去用,如果不加以约束大家都是抢占这份资源,就会导致死锁情况得发生;</p>\n<p><strong>(1) 系统模型</strong><br>系统资源类型：R1 / R2 / R3 … Rm, 如CPU cycles , memory space , I/O devices;<br>每个资源类型Ri有Wi得实例;<br>每个进程使用资源如下：</p>\n<ul>\n<li>request / get &lt;— free resource</li>\n<li>use / hold &lt;— requested / used resource </li>\n<li>release &lt;— free resource</li>\n</ul>\n<p><em>可重复使用得资源</em>:</p>\n<ul>\n<li>由多个进程都能共享访问得资源,进程获得资源并再使用之后进行释放资源(即创建与销毁的过程),使其能让其它得进程重用;</li>\n<li>如果每个进程拥有一个资源并请求其他资源死锁可能发生;再I/O缓冲区的中断/信号/消息/信息,如果接收消息阻塞可能会发生死锁,再可能少见的组合事件也会引起死锁;</li>\n<li>共享资源：<ul>\n<li>物理层面：CPU / I/O 通道 / 内存 / 外存储器等等设备</li>\n<li>软件层面：数据结构 / 文件 / 数据库 / 信号量</li>\n</ul>\n</li>\n</ul>\n<p>资源分配图一组顶点V和边E的集合,V 有两种类型：</p>\n<ul>\n<li>P = {P1,P2,P3…Pn} , 集合包括系统中的所有进程; requsting / claiming edge - directed edge Pi -&gt; Rj;</li>\n<li>R = {R1,R2,R3…Rn} , 集合包括系统中的所有资源类型; assigment / holding edge - directed edge Rj -&gt; Pi</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609204040.png\" alt=\"WeiyiGeek.资源分配图模型图\"></p>\n<p>R2 有一个资源分配给P1另外一个资源分配给了P2,R1的资源被P2正在占用但是需要请求R3资源,但是R3资源正在被P3占用;<br>资源分配例子：下面会导致死锁,由于P1请求R1的资源(仅仅存在一个资源)被P2占用,则已经造成了死锁;</p>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609211242.png\" alt=\"WeiyiGeek.资源分配例子\" title=\"\" class=\"\">\n                <p>WeiyiGeek.资源分配例子</p>\n            </figure>\n<p><em>基本总结：</em></p>\n<ul>\n<li>如果图中不包括循环则没有死锁;</li>\n<li>如果图种包括循环,如果每个资源类只有一个实例那么死锁,如果每个资源类有几个实例可能死锁;</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190609213859.png\" alt=\"WeiyiGeek.有循环的资源分配没有死锁\" title=\"\" class=\"\">\n                <p>WeiyiGeek.有循环的资源分配没有死锁</p>\n            </figure>\n<p>Deadlock处理方法：</p>\n<p>Deadlock Prevention (死锁预防)<br>Deadlock Avoidance (死锁避免)<br>Deadlock Detection (死锁检测)<br>Recovery from Deadlock (死锁恢复)</p>\n<p>外碎片 - 分配单元之间未使用的内存碎片</p>\n","comments":true,"excerpt":"11.信号量与同步知识补充(1) 死锁问题与特征<br>(2) 死锁处理与避免<br>(3) 调度算法/实时调度/多处理器调度<br>(4) 优先级反转","categories":[{"name":"计算机基础","path":"api/categories/计算机基础.json"}],"tags":[{"name":"OperatingSystem","path":"api/tags/OperatingSystem.json"}]}