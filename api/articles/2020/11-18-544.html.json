{"title":"网页性能优化浅谈与实践","slug":"基础知识/Web原理/网站优化/网页性能优化浅谈与实践","date":"2020-11-18T08:36:30.000Z","updated":"2022-03-29T05:39:06.313Z","url":"2020/11-18-544.html","path":"api/articles/2020/11-18-544.html.json","covers":["https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/1/20210402222333.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/1/20210402224929.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/1/20210402231433.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h2 id=\"0x00-前言简述\"><a href=\"#0x00-前言简述\" class=\"headerlink\" title=\"0x00 前言简述\"></a>0x00 前言简述</h2><h2 id=\"0x01-网页性能优化关键点\"><a href=\"#0x01-网页性能优化关键点\" class=\"headerlink\" title=\"0x01 网页性能优化关键点\"></a>0x01 网页性能优化关键点</h2><h3 id=\"数据缓存\"><a href=\"#数据缓存\" class=\"headerlink\" title=\"数据缓存\"></a>数据缓存</h3><p>描述: 当我们访问某一个网页时浏览器第一次加载网页时，会将页面资源存储在 HTTP缓存中。下次浏览器访问该页面时，它可以在高速缓存中查找以前获取的资源，然后从磁盘检索它们，其速度通常比从网络上下载它们的速度快。</p>\n<p>Tips: 虽然HTTP缓存是根据Internet工程任务组（IETF）规范进行标准化的 ，但浏览器可能具有多个缓存，这些缓存在获取，存储和保留内容的方式上有所不同。<br>Tips: 浏览器缓存实际上可能发生在原始服务器和客户端浏览器之间的任何中间站点，例如代理缓存或内容交付网络（CDN）缓存。</p>\n<h4 id=\"Cache-Control-Pragma-规则\"><a href=\"#Cache-Control-Pragma-规则\" class=\"headerlink\" title=\"Cache-Control | Pragma 规则\"></a>Cache-Control | Pragma 规则</h4><p>描述: 缓存头的两种主要类型分别是<code>cache -control</code> 和 <code>expires</code>，它们定义资源的缓存特征。</p>\n<p>通常 <code>cache-control</code> 被认为是一种比 <code>expires(到期)</code> 更现代，更灵活的方法，但是两个标头可以同时使用。</p>\n<p><strong>Q: 如何进行缓存?</strong></p>\n<blockquote>\n<p>答: 通过标识资源或资源类型（例如图像或CSS文件），然后使用所需的缓存选项指定资源的标头，来启用缓存。</p>\n</blockquote>\n<p><strong>Cache-Control</strong><br>说明: 在 HTTP1.1 引入了<code>Cathe-Control</code> 缓存控制具有许多选项（<code>通常称为指令</code>），可以将其设置为专门确定如何处理缓存请求。</p>\n<p>简单图示: 对 http 的 304 状态结合 max-age 设置缓存命中流程</p>\n<ul>\n<li>1.浏览器初次访问服务器，服务器返回200状态</li>\n<li>2.浏览器再次请求服务器时，浏览器会先判断max-age，如果到期则直接请求服务器，否则直接从缓存中取，</li>\n<li>3.服务器收到请求后，判断文件是否被修改过，若是则直接返回200，否则返回304并且浏览器将从缓存中获取文件。</li>\n<li>4.若同步刷新页面，则浏览器并不会先判断max-age，而是直接发送请求，服务器接收到请求后，判断文件是否有变化，若有则返回200，若没有则返回304<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/1/20210402222333.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n</ul>\n<p>从<code>缓存控制</code>和<code>缓存校验</code>两个角度来看http的缓存</p>\n<ul>\n<li>1.缓存控制：控制缓存的开关，用于标识请求或访问中是否开启了缓存，使用了哪种缓存方式。</li>\n<li>2.缓存校验：如何校验缓存，比如怎么定义缓存的有效期，怎么确保缓存是最新的。</li>\n</ul>\n<p>Tips ： Cache-Control 符合缓存策略时，服务器不会发送新的资源，但不是说客户端和服务器就没有会话了，客户端还是会发请求到服务器的。</p>\n<hr>\n<p><em>(1) 缓存控制</em><br>Tips : Cache-Control除了在响应中使用，在请求中也可以使用</p>\n<ul>\n<li><p>1.用开发者工具来模拟下请求时带上Cache-Control：勾选Disable cache，刷新页面，可以看到Request Headers中有个字段Cache-Control: no-cache。 </p>\n</li>\n<li><p>2.同时在Response Headers中也能到Cache-Control字段，它的值是must-revalidate，这是服务端设置的。</p>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/1/20210402224929.png\" alt=\"WeiyiGeek.Cache-Control的请求与响应\" title=\"\" class=\"\">\n                <p>WeiyiGeek.Cache-Control的请求与响应</p>\n            </figure>\n<p>Tips : 在 Cache-Control 中各键值可以自由组合如有多个值冲突，也是有优先级的而no-store优先级最高。</p>\n<ul>\n<li>1) 在nginx配置测试然后在<code>/opt/ms</code>下增加个文件type.css<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 88;</span><br><span class=\"line\">    root /opt/ms;</span><br><span class=\"line\">    index index.php index.html index.htm index.nginx-debian.html;   </span><br><span class=\"line\">    location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class=\"line\">        add_header Cache-Control no-store;</span><br><span class=\"line\">        add_header Cache-Control max-age=3600;</span><br><span class=\"line\">        add_header Cache-Control public;</span><br><span class=\"line\">        add_header Cache-Control only-if-cached;</span><br><span class=\"line\">        add_header Cache-Control no-cache;</span><br><span class=\"line\">        add_header Cache-Control must-revalidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>2) 配置好之后，reload下nginx在浏览器访问地址<a href=\"http://127.0.0.1:88/type.css可以看到响应头部包含nginx配置中的字段\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:88/type.css可以看到响应头部包含nginx配置中的字段</a></p>\n</li>\n<li><p>3) 重复刷新访问，会发现每次的状态码都是200，原因是<code>no-store的优先级最高</code>，本地不保存，每次都需要服务器发送资源。</p>\n</li>\n</ul>\n<p><strong>Q: public和private的选择?</strong></p>\n<blockquote>\n<p>如果采用CDN建议将<code>cache-control</code>的值为public，提升缓存命中率。<br>如果你的缓存命中率很低，而访问量很大的话，可以看下是不是设置了private，no-cache这类的值。<br>如果定义了max-age，可以不用再定义public，它们的意义是一样的。</p>\n</blockquote>\n<hr>\n<p><em>2) 缓存校验</em><br>描述: 在缓存中我们需要一个机制来验证缓存是否有效。比如服务器的资源更新了，客户端需要及时刷新缓存；又或者客户端的资源过了有效期，但服务器上的资源还是旧的，此时并不需要重新发送。<br>缓存校验就是用来解决这些问题的，在http 1.1 中我们主要关注下 <code>Last-Modified</code> 和 <code>etag</code> 这两个字段。</p>\n<p>Last-Modified 原理说明：</p>\n<ul>\n<li>1.服务端在返回资源时，会将该资源的最后更改时间通过Last-Modified字段返回给客户端。</li>\n<li>2.客户端下次请求时通过<code>If-Modified-Since</code>或者<code>If-Unmodified-Since</code>带上Last-Modified，服务端检查该时间是否与服务器的最后修改时间一致;</li>\n<li>3.如果一致，则返回304状态码，不返回资源；如果不一致则返回200和修改后的资源，并带上新的时间。</li>\n</ul>\n<p>Tips : If-Modified-Since和If-Unmodified-Since的区别是，前者告诉服务器如果时间一致，返回状态码304; 后者告诉服务器如果时间不一致，返回状态码412。</p>\n<p><br></p>\n<p>etag 原理说明:</p>\n<p>描述: 单纯的以修改时间来判断还是有缺陷，比如文件的最后修改时间变了，但内容没变。对于这样的情况我们可以使用etag来处理。</p>\n<p>服务器通过某个算法对资源进行计算，取得一串值(类似于文件的md5值)，之后将该值通过etag返回给客户端，客户端下次请求时通过<code>If-None-Match</code>或<code>If-Match</code>带上该值，服务器对该值进行对比校验：如果一致则不要返回资源。</p>\n<p>Tips : <code>If-None-Match</code>和<code>If-Match</code>的区别是,前者告诉服务器如果一致返回状态码304,而不一致则返回资源，后者告诉服务器如果不一致，返回状态码412</p>\n<hr>\n<p><strong>Pragma</strong><br>描述: 通过指定某些类型的文件的到期时间来启用缓存，该时间告诉浏览器在向服务器请求新副本之前使用缓存资源的时间;</p>\n<p>Pragma有两个字段<code>Pragma</code>和<code>Expires</code>。</p>\n<ul>\n<li>Pragma的值为no-cache时，表示禁用缓存，</li>\n<li>Expires的值是一个GMT时间，表示该缓存的有效时间。</li>\n</ul>\n<p>Tips : expires 标头只是设置内容应在将来的时间。此后对内容的请求必须返回到原始服务器。使用更新且更灵活的高速缓存控制标头<code>expires标头</code>通常用作备用。</p>\n<p>Tips : Pragma 是旧产物，已经逐步抛弃，有些网站为了向下兼容还保留了这两个字段。如果一个报文中同时出现Pragma和Cache-Control时，以Pragma为准。同时出现Cache-Control和Expires时，以Cache-Control为准。</p>\n<blockquote>\n<p>即优先级从高到低是 <code>Pragma -&gt; Cache-Control -&gt; Expires</code>;</p>\n</blockquote>\n<p><br/></p>\n<p><strong>基础示例:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Apache 的 .htaccess 配置缓存控制头和到期资源</span></span><br><span class=\"line\">&lt;filesMatch <span class=\"string\">\".(ico|jpg|jpeg|png|gif)$\"</span>&gt;</span><br><span class=\"line\"> Header <span class=\"built_in\">set</span> Cache-Control <span class=\"string\">\"max-age=2592000, public\"</span></span><br><span class=\"line\">&lt;/filesMatch&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## EXPIRES CACHING ##</span></span><br><span class=\"line\">ExpiresActive On</span><br><span class=\"line\">ExpiresByType image/jpg <span class=\"string\">\"access plus 1 year\"</span></span><br><span class=\"line\">ExpiresByType image/jpeg <span class=\"string\">\"access plus 1 year\"</span></span><br><span class=\"line\">ExpiresByType image/gif <span class=\"string\">\"access plus 1 year\"</span></span><br><span class=\"line\">ExpiresByType image/png <span class=\"string\">\"access plus 1 year\"</span></span><br><span class=\"line\">ExpiresByType text/css <span class=\"string\">\"access plus 1 month\"</span></span><br><span class=\"line\">ExpiresByType application/pdf <span class=\"string\">\"access plus 1 month\"</span></span><br><span class=\"line\">ExpiresByType text/x-javascript <span class=\"string\">\"access plus 1 month\"</span></span><br><span class=\"line\">ExpiresByType application/x-shockwave-flash <span class=\"string\">\"access plus 1 month\"</span></span><br><span class=\"line\">ExpiresByType image/x-icon <span class=\"string\">\"access plus 1 year\"</span></span><br><span class=\"line\">ExpiresDefault <span class=\"string\">\"access plus 2 days\"</span></span><br><span class=\"line\"><span class=\"comment\">## EXPIRES CACHING ##</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Nginx 的缓存配置</span></span><br><span class=\"line\">location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ &#123; </span><br><span class=\"line\">  add_header Cache-Control max-age=2592000;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 你会在响应头部看到一个etag字段，这是由于nginx默认开启，如果要关闭可以增加个配置etag off。（缓存校验字段）</span></span><br><span class=\"line\">location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ &#123; </span><br><span class=\"line\"> expires  30d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 请勿使用超过一年的有效期；如上所述这是max-age缓存控制下的最大值，是互联网上永远有效的。</p>\n<p>Tips : 缓存是提高页面加载速度并从而提高用户体验的可靠且省力的方法。它足够强大，可以为特定的内容类型提供细微差别，但是足够灵活，可以在网站内容发生更改时轻松进行更新。</p>\n<p><br></p>\n<p><strong>缓存总结</strong></p>\n<ul>\n<li>缓存开关是： pragma， cache-control。</li>\n<li>缓存校验有：Expires，Last-Modified，etag。</li>\n</ul>\n<p>从状态码的角度来看，它们的关系如下图1,cache-control的各个值关系如下图2<br><figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/1/20210402231433.png\" alt=\"WeiyiGeek.状态码与cache-control值\" title=\"\" class=\"\">\n                <p>WeiyiGeek.状态码与cache-control值</p>\n            </figure></p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"Development","path":"api/categories/Development.json"}],"tags":[{"name":"web","path":"api/tags/web.json"},{"name":"performance","path":"api/tags/performance.json"}]}