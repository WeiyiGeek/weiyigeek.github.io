{"title":"3.Docker学习之Dockerfile","slug":"虚拟云容/云容器/Docker/3.Docker学习之Dockerfile","date":"2019-06-05T06:36:30.000Z","updated":"2023-01-31T02:29:10.643Z","url":"2019/6-5-457.html","path":"api/articles/2019/6-5-457.html.json","covers":["https://img.weiyigeek.top/2019/20190521164839.png","https://img.weiyigeek.top/2019/20190520215706.png","https://img.weiyigeek.top/2019/20190521111923.png","https://img.weiyigeek.top/2019/20190522100951.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0x01-Dockerfile-镜像构建浅析与实践\"><a href=\"#0x01-Dockerfile-镜像构建浅析与实践\" class=\"headerlink\" title=\"0x01 Dockerfile 镜像构建浅析与实践\"></a>0x01 Dockerfile 镜像构建浅析与实践</h4><p>描述：Dockerfile是一个文本格式的配置文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,因此每一条指令的内容,就是描述该层应当如何构建。<br>用户可以使用Dockerfile快速创建自定义的镜像;通过它所支持的内部指令,以及使用它创建镜像的基本过程,Docker拥有”一点修改代替大量更新”的灵活之处;</p>\n<ul>\n<li>文本化的镜像生成操作让其方便版本管理和自动化部署;</li>\n<li>每条命令对应镜像的一层,细化操作后保证其可增量更新,复用镜像块减小镜像体积(后面您会体验到);</li>\n</ul>\n<p>总结为一点就是将每一层<code>修改、安装、构建、操作命令</code>都写入到一个脚本之中。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190521164839.png\" alt=\"WeiyiGeek.体系\" title=\"\" class=\"\">\n                <p>WeiyiGeek.体系</p>\n            </figure>\n<p>温馨提示: 一个镜像构建时不能超过 127 层，我们需要保证了稳定的变化的命令至于上层保证了每层打包出来的 Layer 能够尽可能的复用,而不会徒增镜像的大小，影响后续拉取镜像的速度;</p>\n<p><br/></p>\n<h5 id=\"1-基本结构\"><a href=\"#1-基本结构\" class=\"headerlink\" title=\"1.基本结构\"></a>1.基本结构</h5><p>Dockerfile分为四个部分：</p>\n<ul>\n<li>基础镜像信息：<code>FROM \\&lt;image\\&gt; 或者 FROM \\&lt;image\\&gt;:\\&lt;tag\\&gt;</code></li>\n<li>维护者信息: MAINTAINER <name>  （<code>建议使用LABEL标签进行替代,先已丢弃</code>）</li>\n<li>镜像标签信息: LABEL <tags></li>\n<li>镜像操作指令: RUN <COMMAND></li>\n<li>容器启动时执行指令: CMD <Program></li>\n</ul>\n<p>例如:在/opt/目录中利用dockerfile创建一个基于ubuntu的nginx容器与vnc服务;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Usage: docker build -t hub.weiyigeek.top/first_tag -f /opt/dockerfile .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#1.第一行必须指定基于的基础镜像</span></span><br><span class=\"line\">FROM ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.前期操作处理</span></span><br><span class=\"line\">MAINTAINER weiyigeek weiyigeek@qq.com <span class=\"comment\">#会影响实际仓库的拉取</span></span><br><span class=\"line\">LABEL version=<span class=\"string\">\"1.0\"</span> <span class=\"comment\">#容器元信息,帮助信息,Metadata,类似于代码注释</span></span><br><span class=\"line\">LABEL maintainer=<span class=\"string\">\"weiyigeek@163.com\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">WORKDIR /opt/demo  <span class=\"comment\">#切换工作空间(建议使用绝对路径)</span></span><br><span class=\"line\">ADD /opt/package /data/  <span class=\"comment\"># 把本地文件目录添加到镜像中</span></span><br><span class=\"line\"></span><br><span class=\"line\">ENV MYSQL_VERSION 5.6 <span class=\"comment\"># 设置一个mysql常量 环境变量,尽可能使用ENV增加可维护性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.镜像的操作命令</span></span><br><span class=\"line\"><span class=\"comment\">#RUN指令时对镜像执行跟随的命令,每运行一条RUN指令,镜像添加新的一层并提交;</span></span><br><span class=\"line\">RUN <span class=\"built_in\">echo</span> <span class=\"string\">\"deb http://archive.ubuntu.com/ubuntu/ raring main uiverse\"</span> &gt;&gt; /etc/apt/source.list</span><br><span class=\"line\">RUN apt-het update &amp;&amp; apt-get install -y nginx \\</span><br><span class=\"line\">    net-tools mysql-server=<span class=\"string\">\"<span class=\"variable\">$&#123;MYSQL_VERSION&#125;</span>\"</span></span><br><span class=\"line\">RUN <span class=\"built_in\">echo</span> <span class=\"string\">\"\\ndaemon off;\"</span> &gt;&gt; /etc/nginx/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4.镜像启动时候执行的命令</span></span><br><span class=\"line\">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190520215706.png\" alt=\"WeiyiGeek.dockerfile\" title=\"\" class=\"\">\n                <p>WeiyiGeek.dockerfile</p>\n            </figure></p>\n<p>在编写完成Dockerfile之后可以<code>通过docker build 命令来创建镜像</code>,该命令读取指定路径下(包括子目录)的dockerfile(实际上是构建上下文Context),并将该路径下的内容发送给Docker服务端由它创建镜像;</p>\n<p>因此一般建议放置Dockerfile的目录为空另外<code>可以通过dockerignore文件(每一行添加一条匹配模式</code>)会让Docker忽略路径下的目录和文件;</p>\n<p>docker 镜像生成常用命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build [选项]</span><br><span class=\"line\">- t ：指定标签信息</span><br><span class=\"line\">--build-arg &lt;参数名&gt;=&lt;值&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建镜像的几种方式:</span></span><br><span class=\"line\"><span class=\"comment\">#1) 指定的Dockfile所在路径为/tmp/docker_builder</span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> build -t [TAG/version] /tmp/docker_builder</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2) 支持从 URL 构建</span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> build https://github.com/twang2218/gitlab-ce-zh.git<span class=\"comment\">#:11.1 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3) 用给定的 tar 压缩包构建</span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> build http://server/context.tar.gz  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#4) 从标准输入中读取 Dockerfile 进行构建</span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> build - &lt; Dockerfile</span><br><span class=\"line\"><span class=\"variable\">$cat</span> Dockerfile | docker build -</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#5) 从标准输入中读取上下文压缩包进行构建</span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> build - &lt; context.tar.gz   <span class=\"comment\">#标准输入的文件格式还可以是 gzip、bzip2 以及 xz</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h5 id=\"2-指令浅析\"><a href=\"#2-指令浅析\" class=\"headerlink\" title=\"2.指令浅析\"></a>2.指令浅析</h5><p>Dockerfile指令参数(Instruction arguments)如下，可以参考Docker官方有关dockerfile指令介绍的详细文档。</p>\n<p><a href=\"https://docs.docker.com/engine/reference/builder\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/reference/builder</a></p>\n<h6 id=\"1-FROM-基础镜像信息\"><a href=\"#1-FROM-基础镜像信息\" class=\"headerlink\" title=\"1) FROM - 基础镜像信息\"></a>1) FROM - 基础镜像信息</h6><p>描述:尽可能使用官方镜像或者信任的镜像作为你构建镜像的基础设施,推荐使用<code>[Alpine](https://hub.docker.com/_/alpine/)</code>镜像，因为它被严格控制并保持最小尺寸（目前小于 6 MB），但它仍然是一个完整的发行版。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法</span></span><br><span class=\"line\">FROM &lt;image&gt; 或者 FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用案例</span></span><br><span class=\"line\">FROM alpine</span><br><span class=\"line\">FROM golang:1.9-alpine as builder <span class=\"comment\"># 注意：多阶段构建使用 as 来为某一阶段命名</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h6 id=\"2-LABEL-标签信息\"><a href=\"#2-LABEL-标签信息\" class=\"headerlink\" title=\"2) LABEL - 标签信息\"></a>2) LABEL - 标签信息</h6><p>描述: 可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等</p>\n<p>注意: 如果你的字符串包含空格，那么它必须被引用或者空格必须被转义。如果您的字符串包含内部引号字符（”），则也可以将其转义。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法:每个标签一行，由 LABEL 开头加上一个或多个标签对。</span></span><br><span class=\"line\">LABEL key=&lt;value&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用案例 </span></span><br><span class=\"line\"><span class=\"comment\"># Set one or more individual labels `#`开头的行是注释内容。</span></span><br><span class=\"line\">LABEL maintainer=<span class=\"string\">\"WeiyiGeek\"</span></span><br><span class=\"line\">LABEL vendor=<span class=\"string\">\"ACME Incorporated\"</span></span><br><span class=\"line\">LABEL version=1.1</span><br><span class=\"line\">LABEL com.example.version=<span class=\"string\">\"0.0.1-beta\"</span></span><br><span class=\"line\">LABEL com.example.release-date=<span class=\"string\">\"2015-02-12\"</span></span><br></pre></td></tr></table></figure>\n<p>Tips(1): 在 1.10 之前，建议将所有标签合并为一条<code>LABEL</code>指令，以防止创建额外的层，但是现在这个不再是必须的了，以上内容也可以写成下面这样:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class=\"line\">LABEL vendor=ACME\\ Incorporated \\</span><br><span class=\"line\">  version=1.1 \\ </span><br><span class=\"line\">  com.example.version=<span class=\"string\">\"0.0.1-beta\"</span> \\ </span><br><span class=\"line\">  com.example.release-date=<span class=\"string\">\"2015-02-12\"</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h6 id=\"3-MAINTAINER-维护者信息\"><a href=\"#3-MAINTAINER-维护者信息\" class=\"headerlink\" title=\"3)MAINTAINER - 维护者信息\"></a>3)MAINTAINER - 维护者信息</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法</span></span><br><span class=\"line\">MAINTAINER key=&lt;value&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用案例</span></span><br><span class=\"line\">MAINTAINER WeiyiGeek master@weiyigeek.top</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h6 id=\"4-RUN-镜像操作命令\"><a href=\"#4-RUN-镜像操作命令\" class=\"headerlink\" title=\"4)RUN - 镜像操作命令:\"></a>4)RUN - 镜像操作命令:</h6><p>描述:为了保持 Dockerfile 文件的可读性，以及可维护性，建议将长的或复杂的<code>RUN</code>指令用反斜杠<code>\\</code>分割成多行。</p>\n<p>RUN 指令最常见的用法是安装包用的<code>apt-get</code>,因为该指令会安装包，所以有几个问题需要注意。</p>\n<ul>\n<li><ol>\n<li>不要使用 <code>RUN apt-get upgrade 或 dist-upgrade</code> , 如果基础镜像中的某个包过时了，你应该联系它的维护者。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>如果你确定某个特定的包比如 foo 需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 foo 包。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>最好将 RUN 多条语句汇集成为一条 <code>apt-get update</code> 和 <code>apt-get install</code> 以及 <code>rm -rf /var/lib/apt/lists*</code> 组合成一条 RUN 声明</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法</span></span><br><span class=\"line\">RUN &lt;COMMAND&gt; 或者 RUN [<span class=\"string\">\"executable\"</span>,<span class=\"string\">\"param1\"</span>,<span class=\"string\">\"param2\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用案例</span></span><br><span class=\"line\">如：RUN [<span class=\"string\">\"/bin/bash\"</span>,<span class=\"string\">\"-c\"</span>,<span class=\"string\">\"echo Hello\"</span>],当命令较长时可以使用\\来换行;</span><br><span class=\"line\">RUN apt-get update;\\</span><br><span class=\"line\">    apt-get install -y nginx ;\\ </span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#展示了所有关于 apt-get 的建议</span></span><br><span class=\"line\"><span class=\"comment\">#其中 s3cmd 指令指定了一个版本号`1.1.*`。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 apt-get udpate 缓存失效并确保安装的是新版本。</span></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class=\"line\">    aufs-tools \\</span><br><span class=\"line\">    automake \\</span><br><span class=\"line\">    build-essential \\</span><br><span class=\"line\">    curl \\</span><br><span class=\"line\">    dpkg-sig \\</span><br><span class=\"line\">    libcap-dev \\</span><br><span class=\"line\">    libsqlite3-dev \\</span><br><span class=\"line\">    mercurial \\</span><br><span class=\"line\">    reprepro \\</span><br><span class=\"line\">    ruby1.9.1 \\</span><br><span class=\"line\">    ruby1.9.1-dev \\</span><br><span class=\"line\">    s3cmd=1.1.* \\</span><br><span class=\"line\"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure>\n<p><em>Tips(1):为何建议将RUN写在一行目录之中?</em></p>\n<ul>\n<li>1.比如假设你有一个 Dockerfile 文件：将 apt-get update 放在一条单独的 RUN 声明中会导致缓存问题以及后续的 apt-get install 失败。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:18.04</span><br><span class=\"line\">RUN apt-get update</span><br><span class=\"line\">RUN apt-get install -y curl</span><br></pre></td></tr></table></figure></li>\n<li>2.构建镜像后所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:18.04</span><br><span class=\"line\">RUN apt-get update</span><br><span class=\"line\">RUN apt-get install -y curl nginx</span><br></pre></td></tr></table></figure></li>\n<li>3.Docker 发现修改后的 RUN apt-get update 指令和之前的完全一样。所以<code>apt-get update</code>不会执行，而是使用之前的缓存镜像。因为 apt-get update 没有运行后面的 <code>apt-get install</code> 可能安装的是过时的 curl 和 nginx 版本。</li>\n</ul>\n<p>解决办法:采用cache busting(缓存破坏)的方式进行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#方式1.使用`RUN apt-get update &amp;&amp; apt-get install -y` 可以确保你的`Dockerfiles`每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#方式2.固定版本会迫使构建过程检索特定的版本来达到 `cache-busting`目的，而不管缓存中有什么，该项技术也可以减少因所需包中未预料到的变化而导致的失败。</span></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class=\"line\">    package-bar \\</span><br><span class=\"line\">    package-baz \\</span><br><span class=\"line\">    package-foo=1.3.*</span><br></pre></td></tr></table></figure></p>\n<p><em>Tips(2):</em> 清理掉 apt 缓存 <code>rm -rf /var/lib/apt/lists/*</code> 可以减小镜像大小,因为 RUN 指令的开头为 <code>apt-get udpate</code>包缓存总是会在 <code>apt-get install</code> 之前刷新。</p>\n<ul>\n<li>注意:官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</li>\n</ul>\n<p><br></p>\n<p><em>Tips(3):</em> 挂载docker的设置的secret文件到指定目录文件中，</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从默认的secret的路径显示指定名称的secret。</span></span><br><span class=\"line\">RUN --mount=<span class=\"built_in\">type</span>=secret,id=mysecret cat /run/secrets/mysecre</span><br><span class=\"line\"><span class=\"comment\"># 从自定义的secret的路径显示指定名称的secret。</span></span><br><span class=\"line\">RUN --mount=<span class=\"built_in\">type</span>=secret,id=mysecret,dst=/foobar cat /foobar</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h6 id=\"5-CMD-容器启动时执行指令\"><a href=\"#5-CMD-容器启动时执行指令\" class=\"headerlink\" title=\"5)CMD- 容器启动时执行指令\"></a>5)CMD- 容器启动时执行指令</h6><p>描述:指令用于执行目标镜像中包含的软件和任何参数, 实际上为容器提供一个默认的执行命令。</p>\n<ul>\n<li>在Dockerfile中CMD被用来为ENTRYPOINT指令提供参数，则CMD和ENTRYPOINT指令都应该使用exec格式</li>\n<li>当基于镜像的容器运行时将会自动执行CMD指令, 并且如果在docker run命令中指定了参数，这些参数将会覆盖在CMD指令中设置的参数。</li>\n</ul>\n<p>多数情况下CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 CMD [“perl”, “-de0”]，或者 CMD [“PHP”, “-a”]。使用这种形式意味着，当你执行类似<code>docker run -it python</code>时，你会进入一个准备好的 shell 中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基础语法</span></span><br><span class=\"line\"><span class=\"comment\">#CMD指令有如下三种格式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#exec格式</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"executable\"</span>,<span class=\"string\">\"param1\"</span>,<span class=\"string\">\"param2\"</span>] </span><br><span class=\"line\"><span class=\"comment\">#为ENTRYPOINT提供参数</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"param1\"</span>,<span class=\"string\">\"param2\"</span>]</span><br><span class=\"line\"><span class=\"comment\">#shell格式,在/bin/bash中执行提供给需要交互的应用</span></span><br><span class=\"line\">CMD <span class=\"built_in\">command</span> param1 param2  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基础示例</span></span><br><span class=\"line\"><span class=\"comment\">#(1)如果创建镜像的目的是为了部署某个服务(比如 Apache)</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"apache2\"</span>, <span class=\"string\">\"-DFOREGROUND\"</span>]</span><br><span class=\"line\"><span class=\"comment\">#(2)如果使用 shell 格式的话,实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：</span></span><br><span class=\"line\">CMD <span class=\"built_in\">echo</span> <span class=\"variable\">$HOME</span> <span class=\"comment\">#在实际执行中,会将其变更为： CMD [ \"sh\", \"-c\", \"echo $HOME\" ]</span></span><br></pre></td></tr></table></figure>\n<p>注意事项:</p>\n<ul>\n<li>(1)如果用户启动容器指定了运行命令则会覆盖掉CMD指定命令,注意每个Dockerfile只能有一条CMD命令,如果指定了多条命令只有最后一条执行;</li>\n<li>(2)CMD 在极少的情况下才会以 CMD [“param”, “param”] 的形式与<code>ENTRYPOINT</code>协同使用，除非你和你的镜像使用者都对 ENTRYPOINT 的工作方式十分熟悉。</li>\n</ul>\n<p><br></p>\n<h6 id=\"6-EXPOSE-端口映射指令\"><a href=\"#6-EXPOSE-端口映射指令\" class=\"headerlink\" title=\"6)EXPOSE - 端口映射指令\"></a>6)EXPOSE - 端口映射指令</h6><p>描述:<code>EXPOSE</code>指令用于指定容器将要监听的端口即默认向外部的暴露的服务端口。因此你应该为你的应用程序使用常见的端口。<br>对于外部访问，用户可以在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基础语法</span></span><br><span class=\"line\">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#基础示例</span></span><br><span class=\"line\"><span class=\"comment\"># (1) 告诉dokcer服务端容器暴露的端口号,供互联系统使用; 也就是 docker run -P 时会自动随机映射 EXPOSE 的端口。</span></span><br><span class=\"line\">EXPOSE 22 80 8443 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2) 例如提供 Apache web 服务的镜像应该使用 80，而提供 MongoDB 服务的镜像使用 27017 </span></span><br><span class=\"line\">EXPOSE 80 27017</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (3) 指定一个范围</span></span><br><span class=\"line\">EXPOSE 30000-40000</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h6 id=\"7-ENV-修改环境变量指令\"><a href=\"#7-ENV-修改环境变量指令\" class=\"headerlink\" title=\"7)ENV - 修改环境变量指令\"></a>7)ENV - 修改环境变量指令</h6><p>描述:为了方便新程序运行，你可以使用<code>ENV</code>来为容器中安装的程序更新 PATH 环境变量。例如使用<code>ENV PATH /usr/local/nginx/bin:$PATH</code>来确保<code>CMD [&quot;nginx&quot;]</code>能正确运行。类似于程序中的常量，该方法可以让你只需改变 ENV 指令来自动的改变容器中的软件版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法</span></span><br><span class=\"line\">ENV &lt;key&gt; &lt;value&gt;   <span class=\"comment\">#会被后续的RUN指令使用,并在容器运行时保持;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基础示例</span></span><br><span class=\"line\"><span class=\"comment\">#方式1: 如RUN还是运行时的应用，都可以直接使用这里定义的环境变量。</span></span><br><span class=\"line\">ENV PG_MAJOR 9.3</span><br><span class=\"line\">ENV PATH /usr/<span class=\"built_in\">local</span>/postgres-\\<span class=\"variable\">$PG_MAJOR</span>/bin:<span class=\"variable\">$PATH</span>  </span><br><span class=\"line\">RUN curl -SL http://example.com/postgre-<span class=\"variable\">$PG_MAJOR</span>.tar.xz  &amp;&amp; ENV PATH /usr/<span class=\"built_in\">local</span>/postgres-<span class=\"variable\">$PG_MAJOR</span>/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#方式2: 将所有的环境变量定义在一条ENV语句中</span></span><br><span class=\"line\">ENV VERSION=1.0 DEBUG=on \\</span><br><span class=\"line\">    NAME=<span class=\"string\">\"Happy Feet\"</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h6 id=\"8-ARG-构建参数\"><a href=\"#8-ARG-构建参数\" class=\"headerlink\" title=\"8)ARG - 构建参数\"></a>8)ARG - 构建参数</h6><p>描述:构建参数和 ENV 的效果一样都是设置环境变量不同点<code>就是容器构建完成则失效</code>;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ARG &lt;参数名&gt; [=&lt;默认值&gt;] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用方式与Shell中一致</span></span><br><span class=\"line\"><span class=\"variable\">$&#123;IMG_PATH&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h6 id=\"9-ADD-添加指定目录文件到镜像指令\"><a href=\"#9-ADD-添加指定目录文件到镜像指令\" class=\"headerlink\" title=\"9)ADD - 添加指定目录文件到镜像指令\"></a>9)ADD - 添加指定目录文件到镜像指令</h6><p>描述:该命令将复制指定的源文件<code>&lt;src&gt;</code>到镜像内中的目标文件<code>&lt;dest&gt;</code>,其中<code>&lt;src&gt;</code>可以是在Dockerfile所在的目录的一个相对路径(文件或者目录)/URL/tar文件（<code>本地 tar 提取和远程 URL 支持</code>）;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法</span></span><br><span class=\"line\">ADD &lt;src&gt; &lt;dest&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基础示例</span></span><br><span class=\"line\"><span class=\"comment\"># (1)最佳用例是将本地tar文件自动提取到镜像中</span></span><br><span class=\"line\">ADD rootfs.tar.xz</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2)下载后的文件权限自动设置为 600 这个自动解压缩的功能非常有用；</span></span><br><span class=\"line\">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz </span><br><span class=\"line\">ADD --chown=55:mygroup files* /mydir/</span><br><span class=\"line\">ADD <span class=\"variable\">$PWD</span> /opt/blog/  <span class=\"comment\">#复制到目录之中</span></span><br></pre></td></tr></table></figure>\n<p>注意事项:</p>\n<ul>\n<li>(1)为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层</span></span><br><span class=\"line\"><span class=\"comment\">#比如尽量避免下面的用法：</span></span><br><span class=\"line\">ADD http://example.com/big.tar.xz /usr/src/things/</span><br><span class=\"line\">RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span><br><span class=\"line\">RUN make -C /usr/src/things all</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#而是应该使用下面这种方法：由于使用的管道操作，所以没有中间文件需要删除。</span></span><br><span class=\"line\">RUN mkdir -p /usr/src/things \\</span><br><span class=\"line\">    &amp;&amp; curl -SL http://example.com/big.tar.xz \\</span><br><span class=\"line\">    | tar -xJC /usr/src/things \\</span><br><span class=\"line\">    &amp;&amp; make -C /usr/src/things all</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h6 id=\"10-COPY-复制指定文件或者目录到容器中\"><a href=\"#10-COPY-复制指定文件或者目录到容器中\" class=\"headerlink\" title=\"10)COPY - 复制指定文件或者目录到容器中\"></a>10)COPY - 复制指定文件或者目录到容器中</h6><p>描述:COPY只支持简单将本地文件拷贝到镜像中它比 ADD 更透明,所以<code>ADD</code>和<code>COPY</code>功能类似但一般优先使用 COPY ;</p>\n<p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。</p>\n<p>当目标路径不存在时候自动创建,当使用本地目录作为源目录时候推荐使用COPY:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法</span></span><br><span class=\"line\">COPY &lt;src&gt; &lt;dest&gt;</span><br><span class=\"line\"><span class=\"comment\"># 选项</span></span><br><span class=\"line\">--from=多阶段构建的镜像名称 <span class=\"comment\">#FROM Alpine AS [名称]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 常规方式</span></span><br><span class=\"line\">COPY package.json /usr/src/app/</span><br><span class=\"line\"><span class=\"comment\">#&lt;源路径&gt; 可以是多个,甚至可以是通配符</span></span><br><span class=\"line\">COPY hom* /mydir/</span><br><span class=\"line\">COPY hom?.txt /mydir/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 选项来改变文件的所属用户及所属组。</span></span><br><span class=\"line\">COPY --chown=55:mygroup files* /mydir/</span><br><span class=\"line\">COPY --from=0 /go/src/github.com/go/helloworld/app .  <span class=\"comment\">#多阶段构建，从上一阶段的镜像中复制文件</span></span><br><span class=\"line\">COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf  <span class=\"comment\">#复制任意镜像中的文件（但需要指定镜像名称）</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips: </p>\n<ul>\n<li>对于其他不需要 ADD 的自动提取功能的文件或目录，你应该使用 COPY。</li>\n<li>采用CPOY –from 从上一个构建阶段拷贝文件时，使用的路径是相对于上一阶段的根目录的，此时建议复制成果时候采用绝对路径;</li>\n</ul>\n<p><br></p>\n<h6 id=\"11-ENTRYPOINT-配置容器启动进入后的执行命令-应用运行前的准备工作\"><a href=\"#11-ENTRYPOINT-配置容器启动进入后的执行命令-应用运行前的准备工作\" class=\"headerlink\" title=\"11)ENTRYPOINT - 配置容器启动进入后的执行命令-应用运行前的准备工作\"></a>11)ENTRYPOINT - 配置容器启动进入后的执行命令-应用运行前的准备工作</h6><p>描述: 该指令是设置镜像的主命令，其作用是允许将镜像当成命令本身来运行（使用终端提供默认选项）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础示例</span></span><br><span class=\"line\"><span class=\"comment\">#exec格式推荐的格式</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"executable\"</span>,<span class=\"string\">\"param1\"</span>,<span class=\"string\">\"param2\"</span>]</span><br><span class=\"line\"><span class=\"comment\">#shell格式:使用ENTRYPONT指令并不可被docker run提供的参数覆盖(与CMD不同之处)</span></span><br><span class=\"line\">ENTRYPOINT <span class=\"built_in\">command</span> param1 param2    <span class=\"comment\">#shell中执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 基础示例</span></span><br><span class=\"line\"><span class=\"comment\"># 1.例如下面的示例镜像提供了命令行工具 s3cmd:</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"s3cmd\"</span>]</span><br><span class=\"line\">CMD [<span class=\"string\">\"--help\"</span>]</span><br><span class=\"line\"><span class=\"comment\">#现在直接运行该镜像创建的容器会显示命令帮助: $ docker run s3cmd</span></span><br><span class=\"line\"><span class=\"comment\">#或者提供正确的参数来执行某个命令：$ docker run s3cmd ls s3://mybucket</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.使用ENTRYPOINT 的exec形式来设置相对稳定的默认命令和参数，然后使用任何形式的CMD指令来设置可能发生变化的参数。</span></span><br><span class=\"line\">FROM alpine</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"top\"</span>, <span class=\"string\">\"-b\"</span>]</span><br><span class=\"line\">CMD [<span class=\"string\">\"-c\"</span>]</span><br><span class=\"line\"><span class=\"comment\">#当运行容器是，可以看到只有一个top进程在运行：</span></span><br><span class=\"line\">$ docker run -it --rm --name alpine:<span class=\"built_in\">test</span> top -H</span><br><span class=\"line\">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">  1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top</span><br><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it alpine:<span class=\"built_in\">test</span> ps aux</span><br><span class=\"line\">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class=\"line\">root         1  2.6  0.1  19752  2352 ?        Ss+  08:24   0:00 top -b -H</span><br><span class=\"line\">root         7  0.0  0.1  15572  2164 ?        R+   08:25   0:00 ps aux</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.ENTRYPOINT指令的shell格式</span></span><br><span class=\"line\"><span class=\"comment\">#通过为ENTRYPOINT指定文本格式的参数，此参数将在`/bin /sh -c` 中进行执行</span></span><br><span class=\"line\"><span class=\"comment\">#该形式将使用shell处理而不是shell环境变量，并且将忽略任何的CMD或docker run运行命令行参数。</span></span><br><span class=\"line\">FROM alpine</span><br><span class=\"line\">ENTRYPOINT <span class=\"built_in\">exec</span> top -b</span><br></pre></td></tr></table></figure>\n<p>补充说明:</p>\n<ul>\n<li><ol>\n<li>ENTRYPOINT 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。<blockquote>\n<p>注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#例如:Postgres 官方镜像使用下面的脚本作为 ENTRYPOINT;</span></span><br><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e</span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span> = <span class=\"string\">'postgres'</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    chown -R postgres <span class=\"string\">\"<span class=\"variable\">$PGDATA</span>\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ -z <span class=\"string\">\"<span class=\"variable\">$(ls -A \"$PGDATA\")</span>\"</span> ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">        gosu postgres initdb</span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"built_in\">exec</span> gosu postgres <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> <span class=\"string\">\"<span class=\"variable\">$@</span>\"</span></span><br></pre></td></tr></table></figure>\n<p>该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY ./docker-entrypoint.sh /</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/docker-entrypoint.sh\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>该脚本可以让用户用几种不同的方式和 Postgres 交互<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run postgres</span><br><span class=\"line\">$ docker run postgres postgres --<span class=\"built_in\">help</span></span><br><span class=\"line\">$ docker run --rm -it postgres bash <span class=\"comment\">#启动另外一个完全不同的工具，比如 Bash：</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>2.通过ENTRYPOINT指令可以将容器设置作为可执行的文件<ul>\n<li>docker run <code>&lt;image&gt;</code>命令行参数将会被追加到exec格式的ENTRYPOINT所有元素之后，并将会覆盖使用CMD指定的所有元素,此时是允许将参数传递到入口点;<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#下面是是启动一个nginx的例子端口为80：</span></span><br><span class=\"line\">docker run -i -t --rm -p 80:80 nginx</span><br><span class=\"line\"><span class=\"comment\">#例如，docker run &lt;Image&gt; -d 将通过-d 参数传递到入口点</span></span><br><span class=\"line\"><span class=\"comment\">#例如，docker run –entrypoint 字段覆盖\"ENTRYPOINT \"指令</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>下面的Dockerfile显示使用ENTRYPOINT在前台运行Apache:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM debian:stable</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span><br><span class=\"line\">EXPOSE 80 443</span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/var/www\"</span>, <span class=\"string\">\"/var/log/apache2\"</span>, <span class=\"string\">\"/etc/apache2\"</span>]</span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"/usr/sbin/apache2ctl\"</span>, <span class=\"string\">\"-D\"</span>, <span class=\"string\">\"FOREGROUND\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>注意：当指定多个ENTRYPOINT时候只有最后一个生效;</p>\n<p><br></p>\n<h6 id=\"13-VOLUME-创建本地主机或其他主机挂载点-定义匿名卷\"><a href=\"#13-VOLUME-创建本地主机或其他主机挂载点-定义匿名卷\" class=\"headerlink\" title=\"13)VOLUME- 创建本地主机或其他主机挂载点-定义匿名卷\"></a>13)VOLUME- 创建本地主机或其他主机挂载点-定义匿名卷</h6><p>描述:指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME来管理镜像中的可变部分和用户可以改变的部分。</p>\n<ul>\n<li>VOLUME指令只是起到了声明了容器中的目录作为匿名卷，<code>但是并没有将匿名卷绑定到宿主机指定目录的功能</code>;</li>\n<li>镜像run了一个容器的时候，<code>docker会在安装目录下的指定目录下面生成一个目录来绑定容器的匿名卷</code>（这个指定目录不同版本的docker会有所不同）<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础示例:</span></span><br><span class=\"line\">VOLUME [<span class=\"string\">\"&lt;路径1&gt;\"</span>, <span class=\"string\">\"&lt;路径2&gt;\"</span>...] </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实际示例:</span></span><br><span class=\"line\"><span class=\"comment\">#一般用来存放数据和需要保持的数据等,在运行的时候我们就可以利用 -v /Store/data(宿主机):/date(容器),数据就可以直接存在在宿主机上面;</span></span><br><span class=\"line\">VOLUME [<span class=\"string\">\"/data\"</span>]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h6 id=\"13-USER-指定容器运行时名用户名或者UID\"><a href=\"#13-USER-指定容器运行时名用户名或者UID\" class=\"headerlink\" title=\"13)USER- 指定容器运行时名用户名或者UID\"></a>13)USER- 指定容器运行时名用户名或者UID</h6><p>描述:如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。</p>\n<p>注意事项：</p>\n<ul>\n<li>1.在镜像中用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。<br>如果要依赖确定的 UID/GID 你应该显示的指定一个 UID/GID。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方式1</span></span><br><span class=\"line\">RUN groupadd -r postgres -g 1001 &amp;&amp; useradd -r -g postgres postgres -u 1001</span><br><span class=\"line\"><span class=\"comment\"># 方式2</span></span><br><span class=\"line\">RUN useradd -r -u 1001 -U postgres</span><br></pre></td></tr></table></figure></li>\n<li>2.应该避免使用 sudo 命令因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（<code>例如以 root 权限初始化某个守护进程，以非 root 权限执行它</code>）你可以使用 gosu 命令; 最后为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础示例</span></span><br><span class=\"line\"><span class=\"comment\">#(1) 当服务不需要管理员权限时,可以通过该命令指定运行用户,并且可以在之前创建所需要的用户</span></span><br><span class=\"line\">USER daemon </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(2)要临时获取管理员权限可以使用gosu而不使用sudo;</span></span><br><span class=\"line\"><span class=\"comment\">#USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</span></span><br><span class=\"line\">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres  </span><br><span class=\"line\">USER postgres</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h6 id=\"14-WORKDIR-配置工作目录\"><a href=\"#14-WORKDIR-配置工作目录\" class=\"headerlink\" title=\"14) WORKDIR - 配置工作目录\"></a>14) WORKDIR - 配置工作目录</h6><p>描述:为了清晰性和可靠性，你应该总是在<code>WORKDIR</code>中使用绝对路径。另外你应该使用 WORKDIR 来替代类似于 RUN cd … &amp;&amp; do-something 的指令，后者难以阅读、排错和维护。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础示例</span></span><br><span class=\"line\"><span class=\"comment\">#(1)为后续的RUN CMD ENTRYPOINT 指令配置工作目录</span></span><br><span class=\"line\">WORKDIR /path/to/workdir  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(2)使用多个WORKDIR指令，如果后续命令参数是相对路径，则会基于首个绝对路径进行拼接。</span></span><br><span class=\"line\">WORKDIR /a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR C</span><br><span class=\"line\">RUN <span class=\"built_in\">pwd</span>  <span class=\"comment\">#最终路径是/a/b/c</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h6 id=\"15-ONBUILD-为他人做嫁衣裳\"><a href=\"#15-ONBUILD-为他人做嫁衣裳\" class=\"headerlink\" title=\"15)ONBUILD - 为他人做嫁衣裳\"></a>15)ONBUILD - 为他人做嫁衣裳</h6><p>描述:<code>ONBUILD</code>是一个特殊的指令在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像去构建下一级镜像的时候才会被执行。它后面跟的是其它指令比如 <code>RUN, COPY</code> 等</p>\n<p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。</p>\n<p>为了方便我们理解先来看一个示例:<br>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖然后再通过 npm start 来启动应用。</p>\n<p>Dockerfile<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:slim</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> mkdir /app</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /app</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> ./package.json /app</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> [ <span class=\"string\">\"npm\"</span>, <span class=\"string\">\"install\"</span> ]</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> . /app/</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [ <span class=\"string\">\"npm\"</span>, <span class=\"string\">\"start\"</span> ]</span></span><br></pre></td></tr></table></figure><br>把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。</p>\n<p><em>但是如果我们还有第二个 Node.js 项目也差不多呢？</em><br>好吧那就再把这个 Dockerfile 复制到第二个项目里那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题：如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。</p>\n<p><em>第一个项目没问题了，但是第二个项目呢？</em><br>虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。</p>\n<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？<br>答案是显而易见这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以让我们看看这样的结果。<br>那么上面的这个 Dockerfile 就会变为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM my-node</span><br><span class=\"line\">RUN mkdir /app</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\">CMD [ <span class=\"string\">\"npm\"</span>, <span class=\"string\">\"start\"</span> ]</span><br></pre></td></tr></table></figure><br>现在把相关构建的指令拿出来放在子项目里面，此时假如<code>基础镜像名称为my-node</code>各个项目内的自己Dockerfile变成如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM node:slim</span><br><span class=\"line\">COPY ./package.json /app</span><br><span class=\"line\">RUN [ <span class=\"string\">\"npm\"</span>, <span class=\"string\">\"install\"</span> ]</span><br><span class=\"line\">COPY . /app/</span><br></pre></td></tr></table></figure><br>基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。</p>\n<p>那么，问题解决了么？<br>没有准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>\n<p>完整解决Dockerfile<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#当我们需要在一个镜像中操作添加更新然后打包放在子项目中，在以后的日子里都以此镜像来更新创建容器，为了方便版本控制所以引入了ONBUILD指令</span></span><br><span class=\"line\">FROM node:slim</span><br><span class=\"line\">RUN mkdir /app</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\">ONBUILD COPY ./package.json /app</span><br><span class=\"line\">ONBUILD RUN [ <span class=\"string\">\"npm\"</span>, <span class=\"string\">\"install\"</span> ]</span><br><span class=\"line\">ONBUILD COPY . /app/</span><br><span class=\"line\">CMD [ <span class=\"string\">\"npm\"</span>, <span class=\"string\">\"start\"</span> ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#在构建基础镜像的时候 -t my-node，这三行ONBUILD并不会被执行，然后各个项目的 Dockerfile 就变成了简单地：</span></span><br><span class=\"line\"><span class=\"comment\"># 例如，执行docker build 并不会执行ONBUILD ，只有在使用my-node-onbuild:latest 作为基础镜像时才触发。</span></span><br><span class=\"line\">Docker build -t weiyigeek/my-node-onbuild:latest .</span><br><span class=\"line\"></span><br><span class=\"line\">FROM my-node</span><br><span class=\"line\"><span class=\"comment\">#当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h6 id=\"16-STOPSIGNAL-指定所创建镜像启动的容器接收退出的信号值\"><a href=\"#16-STOPSIGNAL-指定所创建镜像启动的容器接收退出的信号值\" class=\"headerlink\" title=\"16)STOPSIGNAL - 指定所创建镜像启动的容器接收退出的信号值:\"></a>16)STOPSIGNAL - 指定所创建镜像启动的容器接收退出的信号值:</h6><p>描述: 该指令设置将发送到的系统调用信号容器退出，如果不定义信号名称默认是 SIGTERM。<br>此信号可以是格式中的 <code>SIG &lt;NAME&gt;</code>, 例如 SIGKILL，或与 例如内核的系统调用表 9.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际示例</span></span><br><span class=\"line\">STOPSIGNAL signal</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h6 id=\"17-SHELL-指定其他命令执行时默认使用shell的类型\"><a href=\"#17-SHELL-指定其他命令执行时默认使用shell的类型\" class=\"headerlink\" title=\"17)SHELL - 指定其他命令执行时默认使用shell的类型\"></a>17)SHELL - 指定其他命令执行时默认使用shell的类型</h6><p>描述: 该指令允许使用 shell 形式覆盖命令, Linux中默认的Shell是<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>，而在Windows中<br>默认的Shell是<code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>, 如果Linux中还存在备用的shell例如（<code>zsh、csh、tcsh</code>），我们也可以采用此种方法指定。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实际示例</span></span><br><span class=\"line\">SHELL [<span class=\"string\">\"/bin/sh\"</span>,<span class=\"string\">\"-c\"</span>] </span><br><span class=\"line\">SHELL [<span class=\"string\">\"powershell\"</span>,<span class=\"string\">\"-command\"</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实践使用示例</span></span><br><span class=\"line\">FROM microsoft/nanoserver</span><br><span class=\"line\">SHELL [<span class=\"string\">\"powershell\"</span>,<span class=\"string\">\"-command\"</span>]</span><br><span class=\"line\">RUN New-Item -ItemType Directory C:\\Example</span><br><span class=\"line\">ADD Execute-MyCmdlet.ps1 c:\\example\\</span><br><span class=\"line\">RUN c:\\example\\Execute-MyCmdlet -sample <span class=\"string\">'hello world'</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h6 id=\"18-HEALTHCHECK-健康检查\"><a href=\"#18-HEALTHCHECK-健康检查\" class=\"headerlink\" title=\"18)HEALTHCHECK - 健康检查\"></a>18)HEALTHCHECK - 健康检查</h6><p>描述:该命令设置检查容器健康状况的命令,它与 kubernetes 中的 Pod 探针类似</p>\n<p>在没有 <code>HEALTHCHECK</code> 指令前Docker 引擎只可以通过<code>容器内主进程是否退</code>出来判断容器是否状态异常。很多情况下这没问题，<code>但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出</code>，但是该容器已经无法提供服务了。</p>\n<ul>\n<li>在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</li>\n<li>从 Docker 1.12 引入该指令<code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，从而比较真实的反应容器实际状态。</li>\n</ul>\n<p>当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，<code>在 HEALTHCHECK 指令检查成功后变为 healthy</code>，如果连续一定次数失败，则会变为 unhealthy。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 基础语法</span></span><br><span class=\"line\"><span class=\"comment\">#命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。</span></span><br><span class=\"line\">HEALTHCHECK [选项] CMD &lt;命令&gt;</span><br><span class=\"line\"><span class=\"comment\"># 选项：</span></span><br><span class=\"line\">--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；</span><br><span class=\"line\">--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间本次健康检查就被视为失败默认 30 秒；</span><br><span class=\"line\">--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span></span><br><span class=\"line\">HEALTHCHECK NONE</span><br></pre></td></tr></table></figure>\n<p>基础示例:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Dockerfile 示例</span></span><br><span class=\"line\"><span class=\"comment\"># (1) 设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败</span></span><br><span class=\"line\"><span class=\"comment\"># 并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。</span></span><br><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\">HEALTHCHECK --interval=5s --timeout=3s --retries=5 \\</span><br><span class=\"line\">  CMD curl -fs http://localhost/ || <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2) 使用 docker build 来构建这个镜像并启动;</span></span><br><span class=\"line\">docker build -t myweb:v1 .</span><br><span class=\"line\">$ docker run -d --name web -p 80:80 myweb:v1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (3) 最初的状态为 (health: starting)在等待几秒钟后，再次 docker container ls 就会看到健康状态变化为了 (healthy);</span></span><br><span class=\"line\"><span class=\"comment\"># 如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。</span></span><br><span class=\"line\">$ docker container ls</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class=\"line\">03e28eb00bd0        myweb:v1            <span class=\"string\">\"nginx -g 'daemon off\"</span>   18 seconds ago      Up 16 seconds (healthy)   80/tcp, 443/tcp     web</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (4) 健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看</span></span><br><span class=\"line\">$ docker inspect --format <span class=\"string\">'&#123;&#123;json .State.Health&#125;&#125;'</span> web | python -m json.tool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"FailingStreak\"</span>: 0,</span><br><span class=\"line\">    <span class=\"string\">\"Log\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"string\">\"End\"</span>: <span class=\"string\">\"2019-12-30T14:35:37.940957051Z\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"ExitCode\"</span>: 0,</span><br><span class=\"line\">        <span class=\"string\">\"Output\"</span>: <span class=\"string\">\"&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\n&lt;head&gt;\\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;....\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"Start\"</span>: <span class=\"string\">\"2019-12-30T14:35:37.780192565Z\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"Status\"</span>: <span class=\"string\">\"healthy\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h5 id=\"3-补充知识\"><a href=\"#3-补充知识\" class=\"headerlink\" title=\"3.补充知识\"></a>3.补充知识</h5><p><em>Q:ADD与COPY之间的比较?</em><br>答：优先使用COPY命令,而ADD除了COPY功能还有解压功能(在多数情况下显得多余)<br>注意:ADD 指令会令镜像构建缓存失效从而可能会令镜像构建变得比较缓慢。</p>\n<p><br></p>\n<p><em>Q:RUN and CMD and ENTRYPOINT之间的差别？</em></p>\n<ul>\n<li>区别在于 RUN 是在镜像构建过程中执行的,而 CMD/ENTRYPOINT 是在镜像生成实例的时候执行的<br>RUN：执行命令并创建新的Image Layer<br>CMD：设置容器启动后默认执行的命令和参数(如果定义多个CMD,只有最后一个执行)<br>ENTRYPOINT：设置容器启动时运行的命令,让容器以应用程序或服务形式运行</li>\n</ul>\n<p>补充重点:前面我们说过CMD和ENTRYPOINT指令都可以定义容器运行时所执行的命令，下面是它们之间协调的一些规则：</p>\n<ul>\n<li>在Dockerfile至少需要设置一条CMD或者ENTRYPOINT指令；</li>\n<li>当将容器作为可执行文件使用时，建议定义ENTRYPOINT指令；</li>\n<li>CMD作为为ENTRYPOINT命令定义默认参数的一种方式；</li>\n<li>当使用带有参数的命令运行容器时 CMD将会被覆盖。</li>\n</ul>\n<p>下表是显示了不同的<code>ENTRYPOINT / CMD</code>指令组合的命令执行情况：<br>|                                |       No ENTRYPOINT        | ENTRYPOINT exec_entry p1_entry |     ENTRYPOINT [“exec_entry”, “p1_entry”]      |<br>| :—————————-: | :————————: | :—————————-: | :——————————————–: |<br>|           <em>No CMD**          | </em>报错，这种情况不运行出现<em> | /bin/sh -c exec_entry p1_entry |              exec_entry p1_entry               |<br>| </em>CMD [“exec_cmd”, “p1_cmd”]<em> |      exec_cmd p1_cmd       | /bin/sh -c exec_entry p1_entry |      exec_entry p1_entry exec_cmd p1_cmd       |<br>|  </em>CMD [“p1_cmd”, “p2_cmd”]<em>  |       p1_cmd p2_cmd        | /bin/sh -c exec_entry p1_entry |       exec_entry p1_entry p1_cmd p2_cmd        |<br>|    </em>CMD exec_cmd p1_cmd*     | /bin/sh -c exec_cmd p1_cmd | /bin/sh -c exec_entry p1_entry | exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd |</p>\n<p><br></p>\n<p><em>Q:命令指令的（<code>shell 与 exec</code>）不同格式异同？;</em><br>描述：通过shell格式去运行命令会读取$name变量,而exec格式是仅仅的执行一个命令而不是shell指令；<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN/CMD/ENTRYPOINT yum install -y vim  <span class=\"comment\">#Shell格式  如$PWD $LANG 宿主机</span></span><br><span class=\"line\">RUN/CMD/ENTRYPOINT [<span class=\"string\">\"apt-get\"</span>,<span class=\"string\">\"install\"</span>,<span class=\"string\">\"-y\"</span>,<span class=\"string\">\"vim\"</span>] <span class=\"comment\">#EXEC格式</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><em>Q:ARG与ENV之间的区别？</em><br>答：ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的,但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。<br>而ENV会将变量通过镜像的entrypoint指令与容器中的应用传值;</p>\n<p><br></p>\n<p><em>Q:Docker前后台执行浅析问题？</em><br>描述:提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题(<code>初学者常出现的一个混淆</code>)</p>\n<p>Docker不是虚拟机在容器中的应用都应该以前台执行,而不是像虚拟机、物理机里面那样,<code>用 systemd 去启动后台服务, 而容器内没有后台服务的概念</code>。<br>对于容器而言,启动程序就是容器应用进程,容器就是为了主进程而存在的,主进程退出容器就失去了存在的意义从而退出,其它辅助进程不是它需要关心的东西。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#错误的形式</span></span><br><span class=\"line\">CMD service nginx start  <span class=\"comment\">#发现容器执行后就立即退出了</span></span><br><span class=\"line\"><span class=\"comment\">#会被理解为 </span></span><br><span class=\"line\">CMD [ <span class=\"string\">\"sh\"</span>, <span class=\"string\">\"-c\"</span>, <span class=\"string\">\"service nginx start\"</span>] </span><br><span class=\"line\"><span class=\"comment\">#因此主进程实际上是 sh。那么当 service nginx start 命令结束后,sh 也就结束了,sh 作为主进程退出了,自然就会令容器退出。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</span></span><br><span class=\"line\">CMD [<span class=\"string\">\"nginx\"</span>, <span class=\"string\">\"-g\"</span>, <span class=\"string\">\"daemon off;\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><em>那么什么是上下文路径呢？</em><br>首先我们要理解 docker build 的工作原理,由于Docker是C/S设计架构,Dockerclient通过这组 API 与 Docker 引擎交互,从而完成各种功能;<br>因此,虽然表面上我们好像是在本机执行各种 docker 功能,但实际上一切都是使用的远程调用形式在服务端（Docker 引擎）完成。<br>当我们进行镜像构建的时候,并非所有定制都会通过 RUN 指令完成,经常会需要将一些本地文件复制进镜像,比如通过 COPY 指令、ADD 指令等。</p>\n<p>而 docker build 命令构建镜像,其实并非在本地构建,而是在服务端也就是 Docker 引擎中构建的;用户会指定构建镜像上下文的路径,docker build 命令得知这个路径后,会将路径下的所有内容打包,然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后,展开就会获得构建镜像所需的一切文件。</p>\n<p>一般来说,应该会将 Dockerfile 置于一个空目录下,或者项目根目录下。如果该目录下没有所需文件,那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎,那么可以用 .gitignore 一样的语法写一个 .dockerignore,该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY /opt/package.json /app/  <span class=\"comment\">#上下文路径错误或导致构造失败</span></span><br><span class=\"line\">COPY ./package.json /app/  <span class=\"comment\">#COPY 这类指令中的源文件的路径都是相对路</span></span><br><span class=\"line\"><span class=\"comment\">#这并不是要复制执行 docker build 命令所在的目录下的 package.json,也不是复制 Dockerfile 所在目录下的 package.json,而是复制 上下文（context） 目录下的 package.json。</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><em>下列指令可以支持环境变量展开：</em><br>ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。</p>\n<p>注意：对于Windows系统建议Dockerfile开头添加#escape=<code>来指定转义信息</code></p>\n<p><br></p>\n<h5 id=\"4-基础实战\"><a href=\"#4-基础实战\" class=\"headerlink\" title=\"4.基础实战\"></a>4.基础实战</h5><p>描述: 确保app.py和dockerfile在同一个目录<br>1.准备好app.py的flask程序<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># cat app.py</span></span><br><span class=\"line\">from flask import Flask</span><br><span class=\"line\">app=Flask(__name__)</span><br><span class=\"line\">@app.route(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">def hello():</span><br><span class=\"line\">    <span class=\"built_in\">return</span> <span class=\"string\">\"hello docker\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    app.run(host=<span class=\"string\">'0.0.0.0'</span>,port=8080)</span><br><span class=\"line\"></span><br><span class=\"line\">[root@master home]<span class=\"comment\"># ls</span></span><br><span class=\"line\">    app.py  Dockerfile</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190521111923.png\" alt=\"WeiyiGeek.app.py测试\" title=\"\" class=\"\">\n                <p>WeiyiGeek.app.py测试</p>\n            </figure></p>\n<p>2.编写dockerfile<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM python:2.7</span><br><span class=\"line\">LABEL version=<span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">LABEL maintainer=<span class=\"string\">\"weiyigeek\"</span></span><br><span class=\"line\">RUN pip install flask</span><br><span class=\"line\">COPY app.py /app/</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\">EXPOSE 8080</span><br><span class=\"line\">CMD [<span class=\"string\">\"python\"</span>,<span class=\"string\">\"app.py\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>使用.dockerignore文件(每一行添加一条匹配模式)来让Docker忽略匹配模式路径下的目录和文件;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#comment</span></span><br><span class=\"line\">*/temp*</span><br><span class=\"line\">*/*/temp*</span><br><span class=\"line\">tmp?</span><br><span class=\"line\">~*</span><br></pre></td></tr></table></figure>\n<p>3.构建镜像image找到当前目录的dockerfile开始构建<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t weiyigeek/flask-hello-docker .</span><br><span class=\"line\">docker image ls  <span class=\"comment\">#.查看创建好的images</span></span><br></pre></td></tr></table></figure></p>\n<p>4.启动此flask-hello-docker容器,映射一个端口供外部访问(检查运行的容器)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 8080:8080 weiyigeek/flask-hello-docker</span><br><span class=\"line\">docker container ls</span><br></pre></td></tr></table></figure></p>\n<p>5.提交修改并推送到我们的私有仓库中<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag weiyigeek/flask-hello-docker   192.168.11.37:5000/peng-flaskweb</span><br><span class=\"line\">docker push 192.168.11.37:5000/peng-flaskweb</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h5 id=\"5-Dockerfile-编写构建示例\"><a href=\"#5-Dockerfile-编写构建示例\" class=\"headerlink\" title=\"5.Dockerfile 编写构建示例\"></a>5.Dockerfile 编写构建示例</h5><h6 id=\"示例0-自定义-Debian-镜像安装中文编码支持\"><a href=\"#示例0-自定义-Debian-镜像安装中文编码支持\" class=\"headerlink\" title=\"示例0.自定义 Debian 镜像安装中文编码支持\"></a>示例0.自定义 Debian 镜像安装中文编码支持</h6><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Tomcat]# docker build -t weiyigeek/tomcat:7.0.85-jre8-gbk18030 .</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> weiyigeek/tomcat:<span class=\"number\">7.0</span>.<span class=\"number\">85</span>-jre8</span><br><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> WeiyiGeek &lt;master@WeiyiGeek.top&gt;</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> wget -O /etc/apt/sources.list  http://192.168.10.206:8080/sources.list \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; apt clean &amp;&amp; apt update &amp;&amp; apt install -y locales \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; sed -i <span class=\"string\">'s/# zh_CN.GB18030/zh_CN.GB18030/g'</span> /etc/locale.gen \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; locale-gen \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; locale -a \\</span></span><br><span class=\"line\"><span class=\"bash\">    &amp;&amp; rm -rf /var/cache/apt/*</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> LANG=zh_CN.gb18030</span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"catalina.sh\"</span> <span class=\"string\">\"run\"</span>]</span></span><br></pre></td></tr></table></figure>\n<h6 id=\"示例1-Docker-Webp-Server-Go\"><a href=\"#示例1-Docker-Webp-Server-Go\" class=\"headerlink\" title=\"示例1.Docker - Webp Server Go\"></a>示例1.Docker - Webp Server Go</h6><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> golang:alpine as builder</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> IMG_PATH=/opt/pics</span><br><span class=\"line\"><span class=\"keyword\">ARG</span> EXHAUST_PATH=/opt/exhaust</span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apk update ;\\</span></span><br><span class=\"line\"><span class=\"bash\">    apk add alpine-sdk ;\\</span></span><br><span class=\"line\"><span class=\"bash\">    git <span class=\"built_in\">clone</span> https://github.com/webp-sh/webp_server_go /build ;\\</span></span><br><span class=\"line\"><span class=\"bash\">    <span class=\"built_in\">cd</span> /build ;\\</span></span><br><span class=\"line\"><span class=\"bash\">    sed -i <span class=\"string\">\"s|.\\/pics|<span class=\"variable\">$&#123;IMG_PATH&#125;</span>|g\"</span> config.json ;\\</span></span><br><span class=\"line\"><span class=\"bash\">    sed -i <span class=\"string\">\"s|\\\"\\\"|\\\"<span class=\"variable\">$&#123;EXHAUST_PATH&#125;</span>\\\"|g\"</span> config.json ;\\</span></span><br><span class=\"line\"><span class=\"bash\">    sed -i <span class=\"string\">'s/127.0.0.1/0.0.0.0/g'</span> config.json</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /build</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> go build -o webp-server .</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> alpine</span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> --from=builder /build/webp-server  /usr/bin/webp-server</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> --from=builder /build/config.json /etc/config.json</span></span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /opt</span></span><br><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"bash\"> /opt/exhaust</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> [<span class=\"string\">\"/usr/bin/webp-server\"</span>, <span class=\"string\">\"--config\"</span>, <span class=\"string\">\"/etc/config.json\"</span>]</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意事项</strong>:在 RUN 指令的每行结尾我使用的是 ;\\ 来接下一行 shell 而不是 &amp;&amp; 其中缘由相信读者也猜到一二了吧(提高容错性),两则本质区别是 <code>;</code>运行失败时会继续运行而 <code>&amp;&amp;</code> 运行成功则继续执行; 笔者也逛了一圈 docker hub 官方镜像中用<code>;</code>较多一些，个人觉得是因为<code>;</code>比<code>&amp;&amp;</code>要美观一些</p>\n<p><br></p>\n<h6 id=\"示例2-进行dockerfile编写并生成自定义hexo博客环境的镜像\"><a href=\"#示例2-进行dockerfile编写并生成自定义hexo博客环境的镜像\" class=\"headerlink\" title=\"示例2.进行dockerfile编写并生成自定义hexo博客环境的镜像\"></a>示例2.进行dockerfile编写并生成自定义hexo博客环境的镜像</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基础镜像</span></span><br><span class=\"line\">FROM mhart/alpine-node:latest</span><br><span class=\"line\"><span class=\"comment\">#作者描述</span></span><br><span class=\"line\">LABEL maintainer=<span class=\"string\">\"weiyigeek &lt;weiygeek@qq.com&gt;\"</span></span><br><span class=\"line\">LABEL description=<span class=\"string\">\"weiyigeek blog\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换工作目录</span></span><br><span class=\"line\">WORKDIR /opt/web/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#更新alpine软件源和下载git</span></span><br><span class=\"line\">RUN apk update \\ </span><br><span class=\"line\"> &amp;&amp; apk add git \\</span><br><span class=\"line\"> &amp;&amp; git <span class=\"built_in\">clone</span> https://gitee.com/WeiyiGeek/blog.git</span><br><span class=\"line\"></span><br><span class=\"line\">ENV LANG=en_US.UTF-8 \\</span><br><span class=\"line\">  LANGUAGE=en_US:en \\</span><br><span class=\"line\"> LC_ALL=en_US.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 重要不能采用cd进行切换</span></span><br><span class=\"line\">WORKDIR /opt/web/blog/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下载博客hexo框架与依赖</span></span><br><span class=\"line\">RUN npm install -g hexo-cli --save \\</span><br><span class=\"line\">    &amp;&amp; npm install --production --registry=https://registry.npmmirror.com --save</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#对外暴露的端口</span></span><br><span class=\"line\">EXPOSE 4000 30000-40000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#容器建立好运行的命令</span></span><br><span class=\"line\">ENTRYPOINT [<span class=\"string\">\"hexo\"</span>, <span class=\"string\">\"server\"</span>]</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190522100951.png\" alt=\"WeiyiGeek.hexoblog-dockerfile\" title=\"\" class=\"\">\n                <p>WeiyiGeek.hexoblog-dockerfile</p>\n            </figure>\n<p>执行完成后将会在docker iamges 中显示我们设置仓库名称:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$docker</span> run -d -p 80:4000 --name blog weiyigeek/blog</span><br><span class=\"line\">c6059fc19891792ce03304bcf943dccd708e5b8c7565fe86159d3407e23e7530</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$docker</span> ps -a</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class=\"line\">c6059fc19891        weiyigeek/blog      <span class=\"string\">\"hexo server\"</span>       7 seconds ago       Up 5 seconds        0.0.0.0:80-&gt;4000/tcp   blog</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h6 id=\"示例3-Dockerfile多阶段构建实践\"><a href=\"#示例3-Dockerfile多阶段构建实践\" class=\"headerlink\" title=\"示例3.Dockerfile多阶段构建实践\"></a>示例3.Dockerfile多阶段构建实践</h6><p><strong>构建docker容器的多种方式：</strong><br>方式1：将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程<br>产生的问题：</p>\n<ul>\n<li>镜像层次多，镜像体积较大，部署时间变长</li>\n<li>源代码存在泄露的风险</li>\n</ul>\n<p>优点：管理方便简单</p>\n<p><br></p>\n<p>方式2：将项目及其依赖库编译测试打包好后，再将编译好的可执行文件拷贝到运行环境中<br>产生的问题：部署过程较复杂<br>优点：生成的镜像大小相比较于方式1较小</p>\n<p>比如,参照下面的多阶段构建<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\">#该方式构建需要shell文件来进行打包融合</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Building gcc/helloworld:build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#进行编译环境搭建并编译环境</span></span><br><span class=\"line\">docker build -t gcc/helloworld:build . -f Dockerfile.build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#创建编译的容器</span></span><br><span class=\"line\">docker create --name extract go/helloworld:builder</span><br><span class=\"line\">docker cp extract:/gcc/demo/<span class=\"built_in\">test</span> ./<span class=\"built_in\">test</span></span><br><span class=\"line\">docker rm -f extract</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Building gcc/helloworld:runner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#构建运行时环境</span></span><br><span class=\"line\">docker build --no-cache -t gcc/helloworld:2 . -f Dockerfile.copy</span><br><span class=\"line\">rm ./<span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure><br><br></p>\n<p>方式3：Docker v17.05 开始支持多阶段构建 (multistage builds),此种方法综合和方式1和2并且解决了他们响应的问题;</p>\n<p>比如，我们要编译.c文件分为两步进行,编译c再运行</p>\n<p>步骤01.test.c 文件内容如下<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World! Dockerfile!\\n\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>步骤02.编写Dockerfile，此处使用多阶段构建<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#编译阶段-Dockerfile.build</span></span><br><span class=\"line\">FROM alpine as builder</span><br><span class=\"line\">MAINTAINER weiyigeek &lt;weiyigeek@q.com&gt;</span><br><span class=\"line\">RUN apk update &amp;&amp; apk --no-cache add gcc g++</span><br><span class=\"line\">WORKDIR /gcc/demo/</span><br><span class=\"line\">COPY test.c .</span><br><span class=\"line\">RUN gcc test.c -o <span class=\"built_in\">test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#运行阶段-Dockerfile.run</span></span><br><span class=\"line\">FROM alpine-c as runer</span><br><span class=\"line\">WORKDIR /gcc/demo/</span><br><span class=\"line\"><span class=\"comment\">#复制 builder 阶段成果二进制文件test到 当前镜像之中</span></span><br><span class=\"line\">COPY --from=0 /gcc/demo/<span class=\"built_in\">test</span> . </span><br><span class=\"line\"><span class=\"comment\"># 或者 COPY --from=builder /gcc/demo/test . </span></span><br><span class=\"line\">CMD [<span class=\"string\">\"./test\"</span>]</span><br></pre></td></tr></table></figure></p>\n<p>步骤03.进行镜像构建操作<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 项目结构</span></span><br><span class=\"line\"><span class=\"variable\">$ls</span></span><br><span class=\"line\">mutilDockerfile  test.c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建镜像</span></span><br><span class=\"line\"><span class=\"variable\">$docker</span> build -t weiyigeek/hello:1  -f mutilDockerfile .  <span class=\"comment\">#注意上下文</span></span><br><span class=\"line\">Sending build context to Docker daemon  3.072kB</span><br><span class=\"line\">Step 1/10 : FROM alpine as builder</span><br><span class=\"line\"> ---&gt; 055936d39205</span><br><span class=\"line\">Step 2/10 : MAINTAINER weiyigeek &lt;weiyigeek@q.com&gt;</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 59097e3a8120</span><br><span class=\"line\">Removing intermediate container 59097e3a8120</span><br><span class=\"line\"> ---&gt; 8e796c96a921</span><br><span class=\"line\">Step 3/10 : RUN apk update &amp;&amp; apk --no-cache add gcc g++</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 89fca19b761d</span><br></pre></td></tr></table></figure></p>\n<p>步骤04.最后运行构建的镜像<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$docker</span> run --name hello weiyigeek/hello:1</span><br><span class=\"line\">Hello World! Dockerfile!</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h4 id=\"0x02-Docker-镜像构建最佳实践浅析\"><a href=\"#0x02-Docker-镜像构建最佳实践浅析\" class=\"headerlink\" title=\"0x02 Docker 镜像构建最佳实践浅析\"></a>0x02 Docker 镜像构建最佳实践浅析</h4><p>描述: Docker拥有自己的操作系统,完全基于于 Docker 的Linux发行版CoreOS。<br>目前常用的Linux发行版主要包括Debian/Ubuntu系列和CentOS/Fedora系列。</p>\n<ul>\n<li>前者以自带软件包版本较新而出名</li>\n<li>后者则宣称运行更稳定一些</li>\n</ul>\n<h5 id=\"1-Dockerfile-指令最佳实践\"><a href=\"#1-Dockerfile-指令最佳实践\" class=\"headerlink\" title=\"1.Dockerfile 指令最佳实践\"></a>1.Dockerfile 指令最佳实践</h5><ul>\n<li>FROM：尽可能使用当前官方仓库作为你构建镜像的基础</li>\n<li>LABEL: 一个镜像可以包含多个标签但建议将多个标签放入到一个 LABEL 指令中</li>\n<li>RUN：将长的或复杂的 RUN 指令用反斜杠 \\ 分割成多行 （不要使用 RUN apt-get upgrade 或 dist-upgrade，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级，而且建议使用指定版本的形式）</li>\n<li>CMD：用于执行目标镜像中包含的软件可以包含参数</li>\n<li>EXPOSE：在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口</li>\n<li>ENV: 为了方便新程序运行，你可以使用 ENV 来为容器中安装的程序更新 PATH 环境变量</li>\n<li>ADD 和 COPY(优先使用它),了让镜像尽量小最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget</li>\n<li>ENTRYPOINT: 最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 CMD 提供默认选项）。</li>\n<li>VOLUME: 强烈建议使用它来管理镜像中的可变部分和用户可以改变的部分。</li>\n<li>USER：如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户(你应该避免使用 sudo),同时也避免频繁地使用USER来回切换用户。<ul>\n<li>使用类似 RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 的指令创建用户和用户组。</li>\n</ul>\n</li>\n<li>WORKDIR：为了清晰性和可靠性建议都使用结对路径;</li>\n</ul>\n<p><br></p>\n<h5 id=\"2-Dockerfile-编写最佳实践\"><a href=\"#2-Dockerfile-编写最佳实践\" class=\"headerlink\" title=\"2.Dockerfile 编写最佳实践\"></a>2.Dockerfile 编写最佳实践</h5><p>描述: 容器应该是短暂的，短暂意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的;</p>\n<p>下面列出了Dockerfile最佳实践的一些要素方法：</p>\n<ul>\n<li>1.学习Docker的hub中官方仓库中镜像和对应的Dockerfile编写方法与习惯;</li>\n<li>2.提高构建镜像的效率使用<code>.dockerignore</code>文件来要忽略的文件和目录与指定上下文环境, .dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。(<code>Dockerfile目录尽量为空,然后将构建镜像所需要的文件添加到该目录中</code>);</li>\n<li>3.使用精简镜像(选择体积较小的基础镜像), 比如 <code>alpine 或者  debian:buster-slim</code>;<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">debian                      buster-slim         e1af56d072b8        4 days ago          69.2MB</span><br><span class=\"line\">alpine                      latest              cc0abc535e36        8 days ago          5.59MB </span><br><span class=\"line\"><span class=\"comment\">#注意:Alpine的C库是musl libc 而不是正统的 glic;</span></span><br></pre></td></tr></table></figure></li>\n<li>4.网络环境受限的情况下，需将默认的软件源更换为国内的软件源镜像站，目前国内稳定可靠的镜像站主要有，<code>华为云、阿里云、腾讯云、163</code>等，其中华为云的镜像站速度最快，平均 10MB/s，峰值可达到 20MB/s，极大的能加快构建镜像的速度。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 备注:其他基础镜像可以通过 sed 命令替换软件源配置文件中的默认域名;</span></span><br><span class=\"line\"><span class=\"comment\"># 对于 alpine 基础镜像修改软件源</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"http://mirrors.huaweicloud.com/alpine/latest-stable/main/\"</span> &gt; /etc/apk/repositories ;\\</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"http://mirrors.huaweicloud.com/alpine/latest-stable/community/\"</span> &gt;&gt; /etc/apk/repositories ;\\</span><br><span class=\"line\">apk update ;\\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debian 基础镜像修改默认软件源</span></span><br><span class=\"line\">sed -i <span class=\"string\">'s/deb.debian.org/mirrors.huaweicloud.com/g'</span> /etc/apt/sources.list ;\\</span><br><span class=\"line\">sed -i <span class=\"string\">'s|security.debian.org/debian-security|mirrors.huaweicloud.com/debian-security|g'</span> /etc/apt/sources.list ;\\</span><br></pre></td></tr></table></figure></li>\n<li><p>4.减少镜像层数则要尽量合并指令(调整合理的指令顺序),例如多个RUN指令可以利用<code>反斜杠符号 \\</code>合并为一条;</p>\n</li>\n<li><p>5.避免安装不必要的包(<code>指定软件版本号</code>)来减少所构建镜像的大小(实际需要将各层安装的东西尽量最小),降低复杂性、减少依赖、节约构建时间 (<code>别使用yum upgrade / apt-get upgrade / dist-upgrade 来更新依赖应用</code>）;</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt update &amp;&amp; apt-get --no-install-recommends install -y \\</span></span><br><span class=\"line\"><span class=\"bash\">    package-bar \\</span></span><br><span class=\"line\"><span class=\"bash\">    package-foo=1.3.* &amp;&amp; \\</span></span><br></pre></td></tr></table></figure></li>\n<li><p>6.分阶段构建在 Docker 17.05 以上版本中可以采用此种方式来减少所构建镜像的大小。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(1)比如我们现在有一个最简单的 golang 服务，需要构建一个最小的`Docker` 镜像，源码如下：</span></span><br><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">    <span class=\"string\">\"github.com/gin-gonic/gin\"</span></span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\">    router.GET(<span class=\"string\">\"/ping\"</span>, func(c *gin.Context) &#123;</span><br><span class=\"line\">        c.String(http.StatusOK, <span class=\"string\">\"PONG\"</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    router.Run(<span class=\"string\">\":8080\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(2)使用多阶段构建，你可以在一个 `Dockerfile` 中使用多个 FROM 语句;</span></span><br><span class=\"line\"><span class=\"comment\">#每个 FROM 指令都可以使用不同的基础镜像，并表示开始一个新的构建阶段。</span></span><br><span class=\"line\"><span class=\"comment\">#你可以很方便的将一个阶段的文件复制到另外一个阶段，在最终的镜像中保留下你需要的内容即可。</span></span><br><span class=\"line\">FROM golang AS build-env</span><br><span class=\"line\">ADD . /go/src/app</span><br><span class=\"line\">WORKDIR /go/src/app</span><br><span class=\"line\">RUN go get -u -v github.com/kardianos/govendor</span><br><span class=\"line\">RUN govendor sync</span><br><span class=\"line\">RUN GOOS=linux GOARCH=386 go build -v -o /go/src/app/app-server</span><br><span class=\"line\"></span><br><span class=\"line\">FROM alpine</span><br><span class=\"line\">RUN apk add -U tzdata</span><br><span class=\"line\">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br><span class=\"line\">COPY --from=build-env /go/src/app/app-server /usr/<span class=\"built_in\">local</span>/bin/app-server</span><br><span class=\"line\">EXPOSE 8080</span><br><span class=\"line\">CMD [ <span class=\"string\">\"app-server\"</span> ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(3)现在我们就把两个镜像的文件最终合并到一个镜像里面了。</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>6.增加可读性将多行参数排序, 建议在反斜杠符号 \\ 之前添加一个空格 ，并且只要有可能，就将<code>多行参数按字母顺序排序</code>（比如要安装多个包时）,帮助你避免重复包含同一个包，更新包列表时也更容易，也更容易阅读和审查;</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">LABEL</span><span class=\"bash\"> Version=<span class=\"string\">\"1.1\"</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">      Author=<span class=\"string\">\"WeiyiGeek\"</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">      InnerVersion=<span class=\"string\">\"0.1\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#来自buildpack-deps 镜像的例子</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> apt-get update &amp;&amp; apt-get install -y \\</span></span><br><span class=\"line\"><span class=\"bash\">  bzr \\</span></span><br><span class=\"line\"><span class=\"bash\">  cvs \\</span></span><br><span class=\"line\"><span class=\"bash\">  git \\</span></span><br><span class=\"line\"><span class=\"bash\">  mercurial \\</span></span><br><span class=\"line\"><span class=\"bash\">  subversion</span></span><br></pre></td></tr></table></figure></li>\n<li>7.时区设置由于绝大多数 docker 镜像都是默认采用的 UTC 的时区，与北京时间相差 8 个小时，这将会导致容器内的时钟与北京时间不一致，因而会对一些应用造成一些影响，以及影响容器内日志和监控的数据;<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#方式1.可以通过环境变量设置容器内的时区，在启动的时候可以通过设置环境变量-e TZ=Asia/Shanghai 来设定容器内的时区</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#方式2.但对于 alpine 镜像无法通过环境变量的方式设定时区，需要安装 tzdata 来配置时区。</span></span><br><span class=\"line\">apk add --no-cache tzdata ;\\</span><br><span class=\"line\">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime ;\\</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Asia/Shanghai\"</span> &gt; /etc/timezone ;\\</span><br><span class=\"line\">apk del tzdata ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#方式3.对于 debian 基础镜像，可通过复制时区文件设定容器内时区</span></span><br><span class=\"line\">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime ;\\</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"Asia/shanghai\"</span> &gt; /etc/timezone ;\\</span><br></pre></td></tr></table></figure></li>\n<li>8.尽量使用 URL 添加源码，对于需要在容器内进行编译的项目，最好通过git 或者 wegt 的方式将源码打入到镜像内，而非采用 ADD 或者 COPY ，因为源码编译完成之后源码就不需要可以删掉了，<code>而通过 ADD 或者 COPY 添加进去的源码已经用在下一层镜像中了无法被删除掉</code>。这种方法缺点就是网络可能受限下载缓慢<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN <span class=\"built_in\">set</span> -x \\</span><br><span class=\"line\">    &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://mirrors.aliyun.com/alpine/latest-stable/main/\"</span> &gt; /etc/apk/repositories \\</span><br><span class=\"line\">    &amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://mirrors.aliyun.com/alpine/latest-stable/community/\"</span> &gt;&gt; /etc/apk/repositories \\</span><br><span class=\"line\">    &amp;&amp; apk update \\</span><br><span class=\"line\">    &amp;&amp; apk add --no-cache --virtual .build-deps gcc libc-dev make perl-dev openssl-dev pcre-dev zlib-dev git \\</span><br><span class=\"line\">    &amp;&amp; mkdir -p /usr/<span class=\"built_in\">local</span>/src \\</span><br><span class=\"line\">    &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src \\</span><br><span class=\"line\">    &amp;&amp; git <span class=\"built_in\">clone</span> https://github.com/happyfish100/libfastcommon.git --depth 1 \\</span><br><span class=\"line\">    &amp;&amp; git <span class=\"built_in\">clone</span> https://github.com/happyfish100/fastdfs.git --depth 1    \\</span><br><span class=\"line\">    &amp;&amp; git <span class=\"built_in\">clone</span> https://github.com/happyfish100/fastdfs-nginx-module.git --depth 1  \\</span><br><span class=\"line\">    &amp;&amp; wget http://nginx.org/download/nginx-1.15.4.tar.gz \\</span><br><span class=\"line\">    &amp;&amp; tar -xf nginx-1.15.4.tar.gz \\</span><br><span class=\"line\">    &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/libfastcommon \\</span><br><span class=\"line\">    &amp;&amp; ./make.sh \\</span><br><span class=\"line\">    &amp;&amp; ./make.sh install \\</span><br><span class=\"line\">    &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/fastdfs/ \\</span><br><span class=\"line\">    &amp;&amp; ./make.sh \\</span><br><span class=\"line\">    &amp;&amp; ./make.sh install \\</span><br><span class=\"line\">    &amp;&amp; <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/src/nginx-1.15.4/ \\</span><br><span class=\"line\">    &amp;&amp; ./configure --add-module=/usr/<span class=\"built_in\">local</span>/src/fastdfs-nginx-module/src/ \\</span><br><span class=\"line\">    &amp;&amp; make &amp;&amp; make install \\</span><br><span class=\"line\">    &amp;&amp; apk del .build-deps \\</span><br><span class=\"line\">    &amp;&amp; apk add --no-cache pcre-dev bash \\</span><br><span class=\"line\">    &amp;&amp; mkdir -p /home/dfs  \\</span><br><span class=\"line\">    &amp;&amp; mv /usr/<span class=\"built_in\">local</span>/src/fastdfs/docker/dockerfile_network/fastdfs.sh /home \\</span><br><span class=\"line\">    &amp;&amp; mv /usr/<span class=\"built_in\">local</span>/src/fastdfs/docker/dockerfile_network/conf/* /etc/fdfs \\</span><br><span class=\"line\">    &amp;&amp; chmod +x /home/fastdfs.sh \\</span><br><span class=\"line\">    &amp;&amp; rm -rf /usr/<span class=\"built_in\">local</span>/src*</span><br><span class=\"line\"><span class=\"comment\"># 构建之后的对比确实比较明显</span></span><br><span class=\"line\"><span class=\"comment\"># 使用项目默认的 Dockerfile 进行构建的话，镜像大小接近 500MB ，而经过一些的优化，将所有的 RUN 指令合并为一条，最终构建出来的镜像大小为 30MB 。</span></span><br><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">fastdfs             alpine              e855bd197dbe        10 seconds ago      29.3MB</span><br><span class=\"line\">fastdfs             debian              e05ca1616604        20 minutes ago      103MB</span><br><span class=\"line\">fastdfs             centos              c1488537c23c        30 minutes ago      483MB</span><br></pre></td></tr></table></figure></li>\n<li>10.使用虚拟编译环境，对于只在编译过程中使用到的依赖，我们可以将这些依赖安装在虚拟环境中，编译完成之后可以一并删除这些依赖<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#(1) 比如 alpine 中可以使用 `apk add --no-cache --virtual .build-deps` 后面加上需要安装的相关依赖即可;</span></span><br><span class=\"line\">apk add --no-cache --virtual .build-deps gcc libc-dev make perl-dev openssl-dev pcre-dev zlib-dev git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(2) 构建完成之后可以使用 `apk del .build-deps` 命令，一并将这些编译依赖全部删除。需要注意的是 `.build-deps` 后面接的是编译时以来的软件包，不要把运行时的依赖包接在后面，最好单独 add 一下</span></span><br></pre></td></tr></table></figure></li>\n<li>容器应该是短暂的通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短），意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。们可以查看下[12 Factor(12要素)应用程序方法]的进程部分，可以让我们理解这种无状态方式运行容器的动机。</li>\n<li><p>建立上下文，在执行docker build命令时所在工作目录被称为构建上下文，默认情况下，Dockerfile 就位于该路径下，当然您也可以使用-f参数来指定不同的位置，此时无论 Dockerfile 在什么地方，当前目录中的所有文件内容都将作为构建上下文发送到 Docker 守护进程中去。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例1.为构建上下文创建一个目录并 cd 放入其中。</span></span><br><span class=\"line\"><span class=\"comment\">#(1)将“hello”写入一个文本文件hello，然后并创建一个`Dockerfile`并运行`cat`。从构建上下文（.）中构建图像：</span></span><br><span class=\"line\">mkdir myproject &amp;&amp; <span class=\"built_in\">cd</span> myproject</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"hello\"</span> &gt; hello</span><br><span class=\"line\"><span class=\"built_in\">echo</span> -e <span class=\"string\">\"FROM busybox\\nCOPY /hello /\\nRUN cat /hello\"</span> &gt; Dockerfile</span><br><span class=\"line\">docker build -t helloapp:v1 .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(2)现在移动 Dockerfile 和 hello 到不同的目录，并建立了图像的第二个版本（不依赖于缓存中的最后一个版本）。</span></span><br><span class=\"line\"><span class=\"comment\">#使用`-f`指向 Dockerfile 并指定构建上下文的目录：</span></span><br><span class=\"line\">mkdir -p dockerfiles context</span><br><span class=\"line\">mv Dockerfile dockerfiles &amp;&amp; mv hello context</span><br><span class=\"line\">docker build --no-cache -t helloapp:v2 -f dockerfiles/Dockerfile context</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#(3)在构建的时候包含不需要的文件会导致更大的构建上下文和更大的镜像大小。这会增加构建时间，拉取和推送镜像的时间以及容器的运行时间大小。要查看您的构建环境有多大，请在构建您的系统时查找这样的消息;</span></span><br><span class=\"line\">Dockerfile：</span><br><span class=\"line\">Sending build context to Docker daemon  187.8MB</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>11.精简生成镜像的大小及时删除临时文件和缓存文件，特别是在执行apt-get指令后 <code>/var/cache/apt</code> 和 <code>/var/lib/apt/lists</code>下面会缓存一些安装包;</p>\n<ul>\n<li>删除中间文件：比如下载的压缩包</li>\n<li>删除临时文件：如果命令产生了临时文件，也要及时删除<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#安装完软件包清楚 `/var/lib/apt/list/` 缓存</span></span><br><span class=\"line\">rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\">rm -rf /var/cache/apt</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>12.构建缓存查找是否已经存在可重用的镜像，如果有就使用现存的镜像不再重复创建 ， 在开启缓存的情况下，内容不变的指令尽量放在前面；当然如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用<code>--no-cache=true</code>选项;Docker中缓存遵循的基本规则如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 从基础镜像开始(即FROM指令指定)，下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。IF 不是 则缓存失效;</span><br><span class=\"line\">- 多数情况下简单地对比 Dockerfile 中的指令和子镜像，然而有些指令需要更多的检查和解释；</span><br><span class=\"line\">- 对于 ADD 和 COPY 指令镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验值；在缓存的查找过程中会将这些校验和和已存在镜像中的文件校验值进行对比，如果文件有任何改变，比如内容和元数据则缓存失效。</span><br><span class=\"line\">- 缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配，例如当执行完 `RUN apt-get -y update` 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下只有指令字符串本身被用来匹配缓存。</span><br><span class=\"line\">- 一旦缓存失效所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>13.不要在 Dockerfile 中单独修改文件的权限, 因为 docker 镜像是分层的，任何修改都会新增一个层，修改文件或者目录权限也是如此, 如果有一个命令单独修改大文件或者目录的权限，会把这些文件复制一份这样很容易导致镜像很大。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#解决方案</span></span><br><span class=\"line\">- 在添加到 Dockerfile 之前就把文件的权限和用户设置好；</span><br><span class=\"line\">- 在容器启动脚本（entrypoint）做这些修改，或者拷贝文件和修改权限放在一起做（最终也只是增加一层）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>14.保证容器的横向扩展和复用, 一个容器只运行一个进程将多个应用解耦到不同容器中（<code>类似于微服务-K8s表现得淋漓精致</code>）</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t <span class=\"built_in\">test</span>:v1.1 .</span><br><span class=\"line\">Sending build context to Docker daemon   2.56kB</span><br><span class=\"line\">Step 1/6 : FROM alpine</span><br><span class=\"line\">latest: Pulling from library/alpine</span><br><span class=\"line\">df20fa9351a1: Pull complete</span><br><span class=\"line\">Digest: sha256:185518070891758909c9f839cf4ca393ee977ac378609f700f60a771a2dfe321</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> alpine:latest</span><br><span class=\"line\"> ---&gt; a24bb4013296</span><br><span class=\"line\">Step 2/6 : LABEL Author=<span class=\"string\">\"WeiyiGeek\"</span>       Description=<span class=\"string\">\"Test Dockerfile\"</span></span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 88827d239060</span><br><span class=\"line\">Removing intermediate container 88827d239060</span><br><span class=\"line\"> ---&gt; 11d6ad764d64</span><br><span class=\"line\">Step 3/6 : MAINTAINER WeiyiGeek master@WeiyiGeek.top</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 5c939c83df34</span><br><span class=\"line\">Removing intermediate container 5c939c83df34</span><br><span class=\"line\"> ---&gt; 3fcdbc7bd1d8</span><br><span class=\"line\">Step 4/6 : RUN <span class=\"built_in\">echo</span> <span class=\"string\">\"http://mirrors.huaweicloud.com/alpine/latest-stable/main/\"</span> &gt; /etc/apk/repositories ;    <span class=\"built_in\">echo</span> <span class=\"string\">\"http://mirrors.huaweicloud.com/alpine/latest-stable/community/\"</span> &gt;&gt; /etc/apk/repositories ;    apk update ;     apk add --no-cache tzdata ;    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime ;    <span class=\"built_in\">echo</span> <span class=\"string\">\"Asia/Shanghai\"</span> &gt; /etc/timezone ;    apk del tzdata ;</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 2879a08f5f04</span><br><span class=\"line\">fetch http://mirrors.huaweicloud.com/alpine/latest-stable/main/x86_64/APKINDEX.tar.gz</span><br><span class=\"line\">fetch http://mirrors.huaweicloud.com/alpine/latest-stable/community/x86_64/APKINDEX.tar.gz</span><br><span class=\"line\">v3.12.0-74-gb8f92cf12a [http://mirrors.huaweicloud.com/alpine/latest-stable/main/]</span><br><span class=\"line\">v3.12.0-77-ge186c138b6 [http://mirrors.huaweicloud.com/alpine/latest-stable/community/]</span><br><span class=\"line\">OK: 12734 distinct packages available</span><br><span class=\"line\">fetch http://mirrors.huaweicloud.com/alpine/latest-stable/main/x86_64/APKINDEX.tar.gz</span><br><span class=\"line\">fetch http://mirrors.huaweicloud.com/alpine/latest-stable/community/x86_64/APKINDEX.tar.gz</span><br><span class=\"line\">(1/1) Installing tzdata (2020a-r0)</span><br><span class=\"line\">Executing busybox-1.31.1-r16.trigger</span><br><span class=\"line\">OK: 9 MiB <span class=\"keyword\">in</span> 15 packages</span><br><span class=\"line\">(1/1) Purging tzdata (2020a-r0)</span><br><span class=\"line\">Executing busybox-1.31.1-r16.trigger</span><br><span class=\"line\">OK: 6 MiB <span class=\"keyword\">in</span> 14 packages</span><br><span class=\"line\">Removing intermediate container 2879a08f5f04</span><br><span class=\"line\"> ---&gt; afed82abd763</span><br><span class=\"line\">Step 5/6 : ENTRYPOINT [<span class=\"string\">\"top\"</span>,<span class=\"string\">\"-b\"</span>]</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> ce8bc0f98fca</span><br><span class=\"line\">Removing intermediate container ce8bc0f98fca</span><br><span class=\"line\"> ---&gt; c5fe50376063</span><br><span class=\"line\">Step 6/6 : CMD [<span class=\"string\">\"d2\"</span>]</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> d6bbe5535a87</span><br><span class=\"line\">Removing intermediate container d6bbe5535a87</span><br><span class=\"line\"> ---&gt; fe57118d688c</span><br><span class=\"line\">Successfully built fe57118d688c</span><br><span class=\"line\">Successfully tagged <span class=\"built_in\">test</span>:v1.1</span><br></pre></td></tr></table></figure>","comments":true,"excerpt":"[TOC]","categories":[{"name":"Containers","path":"api/categories/Containers.json"},{"name":"OperationTools","path":"api/categories/OperationTools.json"}],"tags":[{"name":"Docker","path":"api/tags/Docker.json"}]}