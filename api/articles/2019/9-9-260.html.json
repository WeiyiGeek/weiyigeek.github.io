{"title":"LVS负载均衡高可用解决方案","slug":"系统运维/系统架构/负载均衡/LVS负载均衡高可用解决方案","date":"2019-09-09T06:34:30.000Z","updated":"2023-01-31T02:29:10.467Z","url":"2019/9-9-260.html","path":"api/articles/2019/9-9-260.html.json","covers":["https://img.weiyigeek.top/2019/1/20190916221311.png","https://img.weiyigeek.top/2019/1/20190916222755.png","https://img.weiyigeek.top/2019/1/20190916223246.png","https://img.weiyigeek.top/2019/1/20190916224145.png","https://img.weiyigeek.top/2019/1/20190916224732.png","https://img.weiyigeek.top/2019/1/20190916231317.png","https://img.weiyigeek.top/2019/1/20190916231406.png","https://img.weiyigeek.top/2019/1/20190916231343.png","https://img.weiyigeek.top/2019/1/20190916231714.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0X00-前言介绍\"><a href=\"#0X00-前言介绍\" class=\"headerlink\" title=\"0X00 前言介绍\"></a>0X00 前言介绍</h4><p><em>问:什么是LVS？</em><br>答:Linux 虚拟服务器(Linux Virtual Server)其实它是一种集群(Cluster)技术，<code>采用IP负载均衡技术</code>和基于<code>内容请求分发技术</code>可以将其看做是一个调度器;</p>\n<p>调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障(<em>防止单点机器故障</em>)，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。</p>\n<p>LVS整个服务器集群的结构<code>对客户端是透明的无感知的</code>，而且<code>无需修改客户端和服务器端的程序</code>。</p>\n<p>当前大多数的互联网系统都使用了服务器集群技术，集群是将相同服务部署在多台服务器上构成一个集群整体对外提供服务，这些集群可以是 Web 应用服务器集群，也可以是数据库服务器集群，还可以是分布式缓存服务器集群等等。</p>\n<p>设计考虑系统四个特性:</p>\n<ul>\n<li>透明性</li>\n<li>可伸缩性</li>\n<li>高可用性</li>\n<li>易管理性</li>\n</ul>\n<p>LVS集群采用三层结构，其体系结构如图所示：</p>\n<ul>\n<li>(1) 最前端的负载均衡层，用 Load Balancer 表示</li>\n<li>(2) 中间的服务器集群层，用 Server Array 表示</li>\n<li>(3) 最底端的数据共享存储层，用 Shared Storage 表示<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916221311.png\" alt=\"WeiyiGeek.LVS集群的体系结构\" title=\"\" class=\"\">\n                <p>WeiyiGeek.LVS集群的体系结构</p>\n            </figure>\n</li>\n</ul>\n<p>LVS主要组成部分:</p>\n<ul>\n<li>负载调度器（load balancer / Director），它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个IP地址（我们可称之为虚拟IP地址）上的。</li>\n<li>服务器池（server pool / Realserver），是一组真正执行客户请求的服务器，执行的服务一般有WEB、MAIL、FTP和DNS等。</li>\n<li>共享存储（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。</li>\n</ul>\n<p>补充说明:<br>LVS、Nginx、HAProxy 是目前使用最广泛的三种软件负载均衡软件。</p>\n<p>网站架构一般比较合理流行的架构方案</p>\n<ul>\n<li>Web 前端采用 Nginx/HAProxy+Keepalived 作负载均衡器；</li>\n<li>后端采用 MySQL数据库一主多从和读写分离，采用 LVS+Keepalived 的架构。</li>\n</ul>\n<p>LVS负载均衡方式:</p>\n<ul>\n<li>1.Virtual Server via Network Address Translation NAT（VS/NAT）是一种最简单的方式，所有的RealServer只需要将自己的网关指向Director即可;</li>\n</ul>\n<p>客户端可以是任意操作系统，但此方式下一个Director能够带动的RealServer比较有限。<br>在VS/NAT的方式下，Director也可以兼为一台RealServer。</p>\n<p>VS/NAT的体系结构如图所示:<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916222755.png\" alt=\"WeiyiGeek.VS/NAT的体系结构\" title=\"\" class=\"\">\n                <p>WeiyiGeek.VS/NAT的体系结构</p>\n            </figure></p>\n<ul>\n<li>2.Virtual Server via IP Tunneling(VS/TUN) IP隧道（IP tunneling）是<code>将一个IP报文封装在另一个IP报文的技术</code>，可以使得目标为一个IP地址的数据报文能被封装和转发到另一个IP地址。<br>IP隧道技术亦称为IP封装技术（IP encapsulation）。<br>IP隧道主要用于<code>移动主机</code>和<code>虚拟私有网络（Virtual Private Network）</code>，在其中隧道都是静态建立的，隧道一端有一个IP地址，另一端也有唯一的IP地址。</li>\n</ul>\n<p>它的连接调度和管理与VS/NAT中的一样，只是它的报文转发方法不同;<br>调度器根据各个服务器的负载情况，动态地选择一台服务器，将请求报文封装在另一个IP报文中，再将封装后的IP报文转发给选出的服务器；<br>服务器收到报文后，先将报文解封获得原来目标地址为 VIP 的报文，服务器发现VIP地址被配置在本地的IP隧道设备上，所以就处理这个请求，然后根据路由表将响应报文直接返回给客户。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916223246.png\" alt=\"WeiyiGeek.VS/TUN的体系结构\" title=\"\" class=\"\">\n                <p>WeiyiGeek.VS/TUN的体系结构</p>\n            </figure>\n<ul>\n<li>3.Virtual Server via Direct Routing(VS/DR)方式是通过改写请求报文中的MAC地址部分来实现的;<br>Director和RealServer必需在物理上有一个网卡通过不间断的局域网相连。<br>RealServer上绑定的VIP配置在各自Non-ARP的网络设备上(如lo或tunl),Director的VIP地址对外可见，而RealServer的VIP对外是不可见的。<br>RealServer的地址即可以是内部地址，也可以是真实地址。<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916224145.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n</ul>\n<p>VS/DR的工作流程：它的连接调度和管理与VS/NAT和VS/TUN中的一样，它的报文转发方法又有不同，将报文直接路由给目标服务器。在VS/DR中调度器根据各个服务器的负载情况，动态地选择一台服务器，不修改也不封装IP报文，而是将数据帧的MAC地址改为选出服务器的MAC地址，再将修改后的数据帧在与服务器组的局域网上发送。因为数据帧的MAC地址是选出的服务器，所以服务器肯定可以收到这个数据帧，从中可以获得该IP报文。当服务器发现报文的目标地址VIP是在本地的网络设备上，服务器处理这个报文，然后根据路由表将响应报文直接返回给客户。<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916224732.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p><strong>三种负载均衡方式比较</strong></p>\n<ul>\n<li>Virtual Server via NAT<br>VS/NAT 的优点是服务器可以运行任何支持TCP/IP的操作系统，它只需要一个IP地址配置在调度器上，服务器组可以用私有的IP地址。缺点是它的伸缩能力有限，当服务器结点数目升到20时，调度器本身有可能成为系统的新瓶颈，因为在VS/NAT中请求和响应报文都需要通过负载调度器。我们在Pentium166 处理器的主机上测得重写报文的平均延时为60us，性能更高的处理器上延时会短一些。假设TCP报文的平均长度为536 Bytes，则调度器的最大吞吐量为8.93 MBytes/s. 我们再假设每台服务器的吞吐量为800KBytes/s，这样一个调度器可以带动10台服务器。（注：这是很早以前测得的数据）</li>\n</ul>\n<p>基于 VS/NAT的的集群系统可以适合许多服务器的性能要求。如果负载调度器成为系统新的瓶颈，可以有三种方法解决这个问题：混合方法、VS/TUN和 VS/DR。在DNS混合集群系统中，有若干个VS/NAT负调度器，每个负载调度器带自己的服务器集群，同时这些负载调度器又通过RR-DNS组成简单的域名。</p>\n<p>但VS/TUN和VS/DR是提高系统吞吐量的更好方法。</p>\n<p>对于那些将IP地址或者端口号在报文数据中传送的网络服务，需要编写相应的应用模块来转换报文数据中的IP地址或者端口号。这会带来实现的工作量，同时应用模块检查报文的开销会降低系统的吞吐率。</p>\n<ul>\n<li>Virtual Server via IP Tunneling</li>\n</ul>\n<p>在VS/TUN 的集群系统中，负载调度器只将请求调度到不同的后端服务器，后端服务器将应答的数据直接返回给用户。这样，负载调度器就可以处理大量的请求，它甚至可以调度百台以上的服务器（同等规模的服务器），而它不会成为系统的瓶颈。即使负载调度器只有100Mbps的全双工网卡，整个系统的最大吞吐量可超过 1Gbps。所以，VS/TUN可以极大地增加负载调度器调度的服务器数量。VS/TUN调度器可以调度上百台服务器，而它本身不会成为系统的瓶颈，可以用来构建高性能的超级服务器。VS/TUN技术对服务器有要求，即所有的服务器必须支持“IP Tunneling”或者“IP Encapsulation”协议。目前，VS/TUN的后端服务器主要运行Linux操作系统，我们没对其他操作系统进行测试。因为“IP Tunneling”正成为各个操作系统的标准协议，所以VS/TUN应该会适用运行其他操作系统的后端服务器。</p>\n<ul>\n<li>Virtual Server via Direct Routing</li>\n</ul>\n<p>跟VS/TUN方法一样，VS/DR调度器只处理客户到服务器端的连接，响应数据可以直接从独立的网络路由返回给客户。这可以极大地提高LVS集群系统的伸缩性。跟VS/TUN相比，这种方法没有IP隧道的开销，但是要求负载调度器与实际服务器都有一块网卡连在同一物理网段上，服务器网络设备（或者设备别名）不作ARP响应，或者能将报文重定向（Redirect）到本地的Socket端口上。</p>\n<p>三种LVS负载均衡技术的优缺点归纳以下表：<br>系统\\方式 | VS/NAT | VS/TUN | VS/DR<br>—|—|—|—<br>服务器操作系统| 任意 | 支持隧道 | 多少(支持Noe-arp)<br>服务器网络 | 私有网络 | 局域网/广域网 | 局域网<br>服务器数目(100M网络) | 10~20 | 100 | &gt;100<br>服务器网关 | 负载均衡 | 自己路由器 | 自己的路由<br>效率| 一般| 高|最高</p>\n<p>注：以上三种方法所能支持最大服务器数目的估计是假设调度器使用100M网卡，调度器的硬件配置与后端服务器的硬件配置相同，而且是对一般Web服务。使 用更高的硬件配置（如千兆网卡和更快的处理器）作为调度器，调度器所能调度的服务器数量会相应增加。当应用不同时，服务器的数目也会相应地改变。所以，以上数据估计主要是为三种方法的伸缩性进行量化比较。</p>\n<h5 id=\"LVS负载调度算法\"><a href=\"#LVS负载调度算法\" class=\"headerlink\" title=\"LVS负载调度算法\"></a>LVS负载调度算法</h5><p>在内核中的连接调度算法上，IPVS已实现了以下八种调度算法：</p>\n<p>◆一 轮叫调度（Round Robin Schedul ing   ）</p>\n<p>轮叫调度（Round Robin Scheduling）算法就是以轮叫的方式依次将请求调度不同的服务器，即每次调度执行i=(i+1)mod n，并选出第i台服务器。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。</p>\n<p>◆二 加权轮叫调度（Weighted Round Robin Scheduling   ）</p>\n<p>加权轮叫调度 （Weighted Round Robin Scheduling）算法可以解决服务器间性能不一的情况，它用相应的权值表示服务器的处理性能，服务器的缺省权值为1。假设服务器A的权值为1，B的权值为2，则表示服务器B的处理性能是A的两倍。</p>\n<p>加权轮叫调度算法是按权值的高 低和轮叫方式分配请求到各服务器。权值高的服务器先收到的连接，权值高的服 务器比权值低的服务器处理更多的连接，相同权值的服务器处理相同数目的连接数。</p>\n<p>◆三 最小连接调度（Least Connect ion Schedul ing   ）</p>\n<p>最小连接调度（Least  Connect ion Scheduling）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态调度算法，它通过服务器当前所活跃的连接数来估计服务器的负载情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中止或超时，其连接数减一。</p>\n<p>◆四 加权最小连接调度（Weighted Least Connectio n Scheduling）</p>\n<p>加权最小连接调 度（Weighted Least Connectio n Scheduling）算法是最小连接调度的超集，各个服务器用相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。</p>\n<p>◆五 基于局部性的最少链接（Locality Based Least Connections Schedulin g   ）</p>\n<p>基于局部性的最少链接调度（Locality Based Least Connections Scheduling，以下简称为LBLC）算法是针对请求报文的目标IP地址的负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群中客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和主存Cache命中率，从而整个集群系统的处理能力。</p>\n<p>LBLC调度算法先根据请求的目标IP   地址 找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于其一半的工 作负载，则用“最少链接”的原则选出一个可用的服务器，将请求发送到该服务器。</p>\n<p>◆六 带复制的基于局部性最少链接（Locality Based Least Connectio ns with Replication Scheduling）</p>\n<p>带复制的基于局部性最少链接调度（Locality Based Least Connectio ns with Replication Scheduling，以下简称为LBLCR）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。</p>\n<p>它与LBLC算法的不同之处是它要 维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。对于一个“热门”站点的服务请求，一台Cache 服务器可能会忙不过来处理这些请求。这时，LBLC调度算法会从所有的Cache服务器中按“最小连接”原则选出一台Cache服务器，映射该“热门”站点到这台Cache服务器，很快这台Cache服务器也会超载，就会重复上述过程选出新的Cache服务器。</p>\n<p>这样，可能会导致该“热门”站点的映像会出现 在所有的Cache服务器上，降低了Cache服务器的使用效率。LBLCR调度算法将“门站”点映射到一组Cache服务器（服务器集合），当该“热门”站点的请求负载增加时，会增加集合里的Cache服务器，来处理不断增长的负载；当该“热门”站点的请求负载降低时，会减少集合里的Cache服务器 数目。这样，该热门站点的映像不可能出现在所有的Cache服务器上，从而提供Cache集群系统的使用效率。</p>\n<p>LBLCR算法先根据请求的目标IP 地址找出该目标IP地址对应的服务器组；按“最小连接”原则从该服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载；则按“最小连接”原则从整个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服 务器从服务器组中删除，以降低复制的程度。</p>\n<p>◆七 目标地址散列调度（Destinat ion Hashing Scheduling   ）</p>\n<p>目标地址散列调度 （Destinat ion Hashing Scheduling）算法也是针对目标IP地址的负载均衡，但它是一种静态映射算法，通过一个散列（Hash）函数将一个目标IP地址映射到一台服务器。目标地址散列调度算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>\n<p>◆八 源地址散列调度（Source Hashing Scheduling）</p>\n<p>源地址散列调度（Source Hashing Scheduling）算法正好与目标地址散列调度算法相反，它根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法 的相同。它的算法流程与目标地址散列调度算法的基本相似，除了将请求的目标IP地址换成请求的源IP   地址，所以这里不一一叙述。在实际应用中，源地址散列 调度和目标地址散列调度可以结合使用在防火墙集群中，它们可以保证整个系统的唯一出入口。</p>\n<h4 id=\"负载均衡机制对比\"><a href=\"#负载均衡机制对比\" class=\"headerlink\" title=\"负载均衡机制对比\"></a>负载均衡机制对比</h4><p>LVS 负载均衡机制</p>\n<p>LVS 不像 HAProxy 等七层软负载面向的是 HTTP 包，所以七层负载可以做的 URL 解析等工作，LVS 无法完成。</p>\n<p>LVS 是四层负载均衡，也就是说建立在 OSI 模型的第四层——传输层之上，传输层上有我们熟悉的 TCP/UDP，LVS 支持 TCP/UDP 的负载均衡。因为 LVS 是四层负载均衡，因此它相对于其它高层负载均衡的解决办法，比如 DNS 域名轮流解析、应用层负载的调度、客户端的调度等，它的效率是非常高的。</p>\n<p>所谓四层负载均衡 ，也就是主要通过报文中的目标地址和端口。七层负载均衡 ，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容。<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916231317.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p>LVS 的转发主要通过修改 IP 地址（NAT 模式，分为源地址修改 SNAT 和目标地址修改 DNAT）、修改目标 MAC（DR 模式）来实现。<br>NAT 模式：网络地址转换</p>\n<p>NAT（Network Address Translation）是一种外网和内网地址映射的技术。</p>\n<p>NAT 模式下，网络数据报的进出都要经过 LVS 的处理。LVS 需要作为 RS（真实服务器）的网关。</p>\n<p>当包到达 LVS 时，LVS 做目标地址转换（DNAT），将目标 IP 改为 RS 的 IP。RS 接收到包以后，仿佛是客户端直接发给它的一样。RS 处理完，返回响应时，源 IP 是 RS IP，目标 IP 是客户端的 IP。这时 RS 的包通过网关（LVS）中转，LVS 会做源地址转换（SNAT），将包的源地址改为 VIP，这样，这个包对客户端看起来就仿佛是 LVS 直接返回给它的。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916231406.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n<p>DR 模式：直接路由</p>\n<p>DR 模式下需要 LVS 和 RS 集群绑定同一个 VIP（RS 通过将 VIP 绑定在 loopback 实现），但与 NAT 的不同点在于：请求由 LVS 接受，由真实提供服务的服务器（RealServer，RS）直接返回给用户，返回的时候不经过 LVS。</p>\n<p>详细来看，一个请求过来时，LVS 只需要将网络帧的 MAC 地址修改为某一台 RS 的 MAC，该包就会被转发到相应的 RS 处理，注意此时的源 IP 和目标 IP 都没变，LVS 只是做了一下移花接木。RS 收到 LVS 转发来的包时，链路层发现 MAC 是自己的，到上面的网络层，发现 IP 也是自己的，于是这个包被合法地接受，RS 感知不到前面有 LVS 的存在。而当 RS 返回响应时，只要直接向源 IP（即用户的 IP）返回即可，不再经过 LVS。<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916231343.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p>DR 负载均衡模式数据分发过程中不修改 IP 地址，只修改 mac 地址，由于实际处理请求的真实物理 IP 地址和数据请求目的 IP 地址一致，所以不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。因此，DR 模式具有较好的性能，也是目前大型网站使用最广泛的一种负载均衡手段。</p>\n<p>LVS 的优点</p>\n<p>抗负载能力强、是工作在传输层上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和 cpu 资源消耗比较低。<br>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。<br>工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如 LVS + Keepalived。<br>无流量，LVS 只分发请求，而流量并不从它本身出去，这点保证了均衡器 IO 的性能不会受到大流量的影响。<br>应用范围比较广，因为 LVS 工作在传输层，所以它几乎可以对所有应用做负载均衡，包括 http、数据库、在线聊天室等等。<br>LVS 的缺点</p>\n<p>软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是 Nginx、HAProxy + Keepalived 的优势所在。<br>如果是网站应用比较庞大的话，LVS/DR + Keepalived 实施起来就比较复杂了，相对而言，Nginx / HAProxy + Keepalived 就简单多了。</p>\n<p>Nginx<br>Nginx 是一个强大的 Web 服务器软件，用于处理高并发的 HTTP 请求和作为反向代理服务器做负载均衡。具有高性能、轻量级、内存消耗少，强大的负载均衡能力等优势。</p>\n<p>Nignx 的架构设计</p>\n<p>相对于传统基于进程或线程的模型（Apache就采用这种模型）在处理并发连接时会为每一个连接建立一个单独的进程或线程，且在网络或者输入/输出操作时阻塞。这将导致内存和 CPU 的大量消耗，因为新起一个单独的进程或线程需要准备新的运行时环境，包括堆和栈内存的分配，以及新的执行上下文，当然，这些也会导致多余的 CPU 开销。最终，会由于过多的上下文切换而导致服务器性能变差。</p>\n<p>反过来，Nginx 的架构设计是采用模块化的、基于事件驱动、异步、单线程且非阻塞。</p>\n<p>Nginx 大量使用多路复用和事件通知，Nginx 启动以后，会在系统中以 daemon 的方式在后台运行，其中包括一个 master 进程，n(n&gt;=1) 个 worker 进程。所有的进程都是单线程（即只有一个主线程）的，且进程间通信主要使用共享内存的方式。</p>\n<p>其中，master 进程用于接收来自外界的信号，并给 worker 进程发送信号，同时监控 worker 进程的工作状态。worker 进程则是外部请求真正的处理者，每个 worker 请求相互独立且平等的竞争来自客户端的请求。请求只能在一个 worker 进程中被处理，且一个 worker 进程只有一个主线程，所以同时只能处理一个请求。（原理同 Netty 很像）<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190916231714.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p>Nginx 负载均衡</p>\n<p>Nginx 负载均衡主要是对七层网络通信模型中的第七层应用层上的 http、https 进行支持。</p>\n<p>Nginx 是以反向代理的方式进行负载均衡的。反向代理（Reverse Proxy）方式是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>\n<p>Nginx 实现负载均衡的分配策略有很多，Nginx 的 upstream 目前支持以下几种方式：</p>\n<p>轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。<br>weight：指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。<br>ip_hash：每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。<br>fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>url_hash（第三方）：按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。<br>Nginx 的优点</p>\n<p>跨平台：Nginx 可以在大多数 Unix like OS编译运行，而且也有 Windows 的移植版本<br>配置异常简单：非常容易上手。配置风格跟程序开发一样，神一般的配置<br>非阻塞、高并发连接：官方测试能够支撑5万并发连接，在实际生产环境中跑到2～3万并发连接数<br>事件驱动：通信机制采用 epoll 模型，支持更大的并发连接<br>Master/Worker 结构：一个 master 进程，生成一个或多个 worker 进程<br>内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个 Nginx 进程才消耗150M 内存（15M*10=150M）<br>内置的健康检查功能：如果 Nginx 代理的后端的某台 Web 服务器宕机了，不会影响前端访问<br>节省带宽：支持 GZIP 压缩，可以添加浏览器本地缓存的 Header 头<br>稳定性高：用于反向代理，宕机的概率微乎其微<br>Nginx 的缺点</p>\n<p>Nginx 仅能支 持http、https 和 Email 协议，这样就在适用范围上面小些，这个是它的缺点<br>对后端服务器的健康检查，只支持通过端口来检测，不支持通过 ur l来检测。不支持 Session 的直接保持，但能通过 ip_hash 来解决<br>HAProxy<br>HAProxy 支持两种代理模式 TCP（四层）和HTTP（七层），也是支持虚拟主机的。</p>\n<p>HAProxy 的优点能够补充 Nginx 的一些缺点，比如支持 Session 的保持，Cookie 的引导；同时支持通过获取指定的 url 来检测后端服务器的状态。</p>\n<p>HAProxy 跟 LVS 类似，本身就只是一款负载均衡软件；单纯从效率上来讲 HAProxy 会比 Nginx 有更出色的负载均衡速度，在并发处理上也是优于 Nginx 的。</p>\n<p>HAProxy 支持 TCP 协议的负载均衡转发，可以对 MySQL 读进行负载均衡，对后端的 MySQL 节点进行检测和负载均衡，大家可以用 LVS+Keepalived 对 MySQL 主从做负载均衡。</p>\n<p>HAProxy 负载均衡策略非常多：Round-robin（轮循）、Weight-round-robin（带权轮循）、source（原地址保持）、RI（请求URL）、rdp-cookie（根据cookie）。</p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"系统架构","path":"api/categories/系统架构.json"},{"name":"运维基础","path":"api/categories/运维基础.json"}],"tags":[{"name":"LVS","path":"api/tags/LVS.json"}]}