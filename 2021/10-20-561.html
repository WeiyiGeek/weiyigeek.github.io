<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="content-language" content="zh-CN"/>
    <meta name="author" content="WeiyiGeek" />
    <meta name="msvalidate.01" content="5C552FB1D885E0E11D2957EC958C8018" />
    <meta name="shenma-site-verification" content="4c655e91c76be0a93c1b6954c666c9d6_1649049085"/>
    <meta name="bytedance-verification-code" content="lKs4FqwCHSJ3A/c5tT7X" />
    <meta name="sogou_site_verification" content="OC65iET6Bk" />
    
    <title>🌐 Go语言开发规范实践指南|WeiyiGeek Blog|唯一极客Geek-IT网络安全运维开发技术知识分享-博客站点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
    <meta name="keywords" content="Go">
    <meta name="Description" content="WeiyiGeek-唯一极客博客站点,关注于网络安全运维,Web安全开发,IOT物联网安全开发,应用开发,分享技术学习知识与入坑解决,提升网络安全技术与自身技术能力,立志维护大众网络安全为己任,做一个对国家有用的人,为实现中华民族伟大复兴的中国梦不懈奋斗">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/jquery/3.5.2-jquery.fancybox.min.css?v=1.6.6" />
    <link rel="stylesheet" href="/css/style.css?v=1.6.6">
    <!--  -->
     <script type="text/javascript" src="/js/custom/articlecost.js?v=1.6.6"></script> 
    <link rel="stylesheet" href="/css/third-party/gitalk.css?v=1.6.6"> 
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9134434519967436" crossorigin="anonymous"></script>    
    <script type="text/javascript">
        // Data Center
        var DC = {
          reward:	true,
          lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
          v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}')
        };
    </script>
    <script type="text/javascript">window.lazyScripts=[];</script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="WeiyiGeek Blog" type="application/atom+xml">
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg" alt="WeiyiGeek-backgroud">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg" alt="WeiyiGeek-头像">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">WeiyiGeek</h5>
          <a href="mailto:master@weiyigeek.top" title="master@weiyigeek.top" class="mail">
            <span>m</span><span>a</span><span>s</span><span>t</span><span>e</span><span>r</span><span>@</span><span>w</span><span>e</span><span>i</span><span>y</span><span>i</span><span>g</span><span>e</span><span>e</span><span>k</span><span>.</span><span>t</span><span>o</span><span>p</span>
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://weiyigeek.top/img/wechat-search.png" target="_blank">
                  <i class="icon icon-lg icon-wechat"></i>
                </a>
              </li>
            
              <li>
                <a href="https://github.com/weiyigeek" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://t.me/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-telegram"></i>
                </a>
              </li>
            
              <li>
                <a href="https://twitter.com/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-twitter"></i>
                </a>
              </li>
            
              <li>
                <a href="https://weibo.com/615643678" target="_blank">
                  <i class="icon icon-lg icon-weibo"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                首页
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                文章分类
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                文章标签
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章归档
              </a>
            </li>
        
            <li class="">
              <a href="/books"  >
                <i class="icon icon-lg icon-book"></i>
                学习书籍
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于作者
              </a>
            </li>
        
            <li class="">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                站点导航
              </a>
            </li>
        
            <li class="">
              <a href="/img/share-wechat.jpg" target="_blank" >
                <i class="icon icon-lg icon-wechat"></i>
                公众账号
              </a>
            </li>
        
            <li class="">
              <a href="https://space.bilibili.com/385802642" target="_blank" >
                <i class="icon icon-lg icon-youtube-play"></i>
                哔哩哔哩
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/weiyigeek" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="">
              <a href="https://twitter.com/WeiyiGeek" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
            <li class="">
              <a href="https://weibo.com/615643678" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>Go语言开发规范实践指南</span>
            
        </div>

        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        

        
            <a href="/atom.xml" class="header-icon pull-right waves-effect waves-circle waves-light">
                <i class="icon icon-lg icon-rss"></i>
            </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg" alt="文章头部背景">
    <div class="container fade-scale">
        <h1 class="title">Go语言开发规范实践指南</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-10-20T03:16:58.000Z" itemprop="datePublished" class="page-time">
  2021-10-20
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/">Development</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/Programming/">Programming</a></li></ul></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
  <article id="post-编程世界/Go/Go语言开发规范实践指南"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">Go语言开发规范实践指南</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-10-20 11:16:58" datetime="2021-10-20T03:16:58.000Z"  itemprop="datePublished">2021-10-20</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/">Development</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/Programming/">Programming</a></li></ul></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>[TOC]</p>
<a id="more"></a>
<h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p>本章主要对 Go 语言开发规范进行记录与实践, 便于养成良好的开发习惯也可叫做规则（不至于进入一些大厂而因为开发习惯没养成而痛苦），规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能.</p>
<p>在Go语言为我们提供众多的工具来检测我们开发规范, 例如所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。</p>
<p>Go 编程语言规范  (<a href="https://golang.org/ref/spec" target="_blank" rel="noopener">https://golang.org/ref/spec</a>)   版本 Jul 26， 2021</p>
<p>Go 的通用准则可查看官方提供的参考指南:</p>
<ol>
<li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a></li>
<li><a href="https://github.com/golang/go/wiki/CommonMistakes" target="_blank" rel="noopener">Go Common Mistakes</a></li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">Go Code Review Comments</a></li>
</ol>
<p>第三方公司Go开发规范参考: <a href="https://github.com/uber-go/" target="_blank" rel="noopener">https://github.com/uber-go/</a></p>
<p><br/></p>
<hr>
<h2 id="0x01-Go开发规范"><a href="#0x01-Go开发规范" class="headerlink" title="0x01 Go开发规范"></a>0x01 Go开发规范</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>只可以使用字母、下划线、数字</li>
<li>大写字母开头，可以<code>被包外部引用</code>（需要先导入包）</li>
<li>小写字母开头，只可以<code>被包内部调用</code></li>
</ul>
<h4 id="目录-amp-package-包命名"><a href="#目录-amp-package-包命名" class="headerlink" title="目录&amp;package 包命名"></a>目录&amp;package 包命名</h4><p>尽量保持package的名字和目录一致，采取有意义的包（简短而简洁）名，<strong>包名使用小写，不要使用下划线和大写字母</strong>，不用复数，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// package [按照类别命名]</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 表示这个是字符串编码的包，即该.go文件应该包含在 strencode 目录下。</span><br><span class="line">// 包命名名称最好不加s复数，即不能strencodes</span><br><span class="line">package strencode</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="go-文件命名"><a href="#go-文件命名" class="headerlink" title=".go 文件命名"></a>.go 文件命名</h4><p>使用小写字母，可以用下划线分割，如果是测试文件或示例文件应该以<code>_test.go</code>结尾<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 打印功能实现文件</span><br><span class="line">print.go</span><br><span class="line">// 单元测试或基准测试文件</span><br><span class="line">print_test.go</span><br><span class="line">// 示例文件</span><br><span class="line">example_print_test.go</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="constant-常亮命名"><a href="#constant-常亮命名" class="headerlink" title="constant-常亮命名"></a>constant-常亮命名</h4><p>全部大写，并以_分割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单一常量声明</span><br><span class="line">const PI &#x3D; 3.1415926535898</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 批量常量声明</span><br><span class="line">const (</span><br><span class="line">  USER_NAME &#x3D; &quot;WeiyiGeek&quot;</span><br><span class="line">  USER_ADDR &#x3D; &quot;ChongQing.China&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h4 id="variable-变量命名"><a href="#variable-变量命名" class="headerlink" title="variable-变量命名"></a>variable-变量命名</h4><p>一般为驼峰命名，遵循以下规则</p>
<ul>
<li>变量为私有，首字母小写</li>
<li>变量为公有。首字母大写</li>
<li>单词为特有名次，而且是首个单词，则特有名词小写</li>
</ul>
<p>若变量为布尔类型，则名称一般以”Has”、”Is”、”Can”、”Allow”开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公用 (类型推导)</span></span><br><span class="line"><span class="keyword">var</span> Public = <span class="string">"public"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有</span></span><br><span class="line"><span class="keyword">var</span> private  = <span class="string">"private"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定变量的类型</span></span><br><span class="line"><span class="keyword">var</span> userName <span class="keyword">string</span> = <span class="string">"weiyigeek"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短变量声明(只能在函数内部)</span></span><br><span class="line">briefCount := <span class="number">65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量变量声明(函数外是全局，函数内是局部)</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  userName <span class="keyword">string</span></span><br><span class="line">  userAge <span class="keyword">int8</span></span><br><span class="line">  user_sex <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="function-函数命名"><a href="#function-函数命名" class="headerlink" title="function-函数命名"></a>function-函数命名</h4><p>采用驼峰命名法，注意特殊的匿名函数，以及单元测试函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部私有函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">(id <span class="keyword">int</span>)</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部公共可调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetAge</span><span class="params">(id <span class="keyword">int</span>)</span><span class="params">(age <span class="keyword">uint8</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span><span class="title">Printf</span><span class="params">(id <span class="keyword">int</span>)</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;fmt.Println(<span class="string">"匿名函数无函数名称"</span>)&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了对相关的测试用例进行分组，函数名可能包含下划线，如：</span></span><br><span class="line">fun TestMyFunction_WhatIsBeingTested(t *test.T)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="struct-结构体命名"><a href="#struct-结构体命名" class="headerlink" title="struct-结构体命名"></a>struct-结构体命名</h4><p>采用驼峰命名法，struct 声明和初始化用多行，特别注意匿名结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部包，多行声明</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">  Username <span class="keyword">string</span></span><br><span class="line">  Email    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部包</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span>&#123;</span><br><span class="line">  Username <span class="keyword">string</span></span><br><span class="line">  Email    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行初始化</span></span><br><span class="line">u := User&#123;</span><br><span class="line">  Username: <span class="string">"ada"</span></span><br><span class="line">  Email:    <span class="string">"dsfgsdfg"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line"><span class="keyword">type</span> anonymousStr <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username <span class="keyword">string</span></span><br><span class="line">    Email    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="interface-接口命名"><a href="#interface-接口命名" class="headerlink" title="interface-接口命名"></a>interface-接口命名</h4><p>命名规范基本和结构体一致, 但是单个函数习惯以”er”为后缀。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span>&#123;</span><br><span class="line">  Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span> ,err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>Go语言中注释符号如下:</p>
<h4 id="单行-注释文本"><a href="#单行-注释文本" class="headerlink" title="单行: // 注释文本"></a>单行: <code>// 注释文本</code></h4><h4 id="多行-注释文本"><a href="#多行-注释文本" class="headerlink" title="多行: /* 注释文本 */"></a>多行: <code>/* 注释文本 */</code></h4><p><br/></p>
<p>Tips: 多行注释中可以嵌套单行注释。</p>
<p>Tips: 注释符<code>//</code> 后面要加空格, 例如:<code>// 注释文本</code>   ，并且有效的关键字注释不应该超过<code>3</code> 行      </p>
<p>Tips: 如果当前包目录下包含多个 <code>Package</code> 注释的 <a href="http://www.codercto.com/category/go.html" target="_blank" rel="noopener">go</a> 文件(包括<code>doc.go</code> ), 那么按照  <code>文件名的字母数序</code> 优先显示</p>
<p>Tips:  <code>Package</code> 的注释会出现在godoc的 <a href="https://link.jianshu.com?t=https://golang.org/pkg/" target="_blank" rel="noopener">包列表</a> 中, 但只能展示大约523字节的长度      </p>
<p><br/></p>
<p>注释使用的范围:</p>
<ul>
<li>包注释</li>
<li>接口注释</li>
<li>方法注释</li>
<li>代码逻辑注释</li>
</ul>
<p>注释示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package Notes 包: 实现 xxxx  </span></span><br><span class="line"><span class="keyword">package</span> notes</span><br><span class="line"></span><br><span class="line"><span class="comment">// Const XXY 常量: 定义 xxxx</span></span><br><span class="line"><span class="keyword">const</span> XYZ = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// Variable xyz 变量：定义 xxxx</span></span><br><span class="line"><span class="keyword">var</span> xyz = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct Abc 结构体: 描述 xxxx </span></span><br><span class="line"><span class="keyword">type</span> Abc <span class="keyword">struct</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function Bcd 函数: 功能 xxxx</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bcd</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在无效注释中以 BUG(who) 开头的注释, 将被识别为已知bug, 显示在 bugs 区域,</span></span><br><span class="line"><span class="comment">// 如果 bug注释 和 关键字注释 中间无换行, 那么 混合的注释 将被显示在 bugs 和 godoc列表 两个区域内</span></span><br><span class="line"><span class="comment">// BUG(who): 我是bug说明 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface Abcer 接口: 包含 xxxxx (PKG注释)</span></span><br><span class="line"><span class="keyword">type</span> Abcer <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">多行注释 &amp;&amp; 嵌套单行注释</span></span><br><span class="line"><span class="comment">示例函数实现godoc自动生成example示例</span></span><br><span class="line"><span class="comment">	此处是预格式化需要缩进。</span></span><br><span class="line"><span class="comment">// 此函数将被展示在OverView区域</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_notes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello OverView"</span>)</span><br><span class="line">  <span class="comment">// Output:</span></span><br><span class="line">  <span class="comment">// Hello OverView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips ：注释中的URL将会变成HTML链接。</p>
<hr>
<h3 id="样式规范"><a href="#样式规范" class="headerlink" title="样式规范"></a>样式规范</h3><h4 id="缩进与括号"><a href="#缩进与括号" class="headerlink" title="缩进与括号"></a>缩进与括号</h4><ul>
<li>go语言默认每一行都会加一个<code>;</code>所以前置大括号不能单独一样</li>
<li>go可以使用go自带的fmt工具格式化代码，vscode 可以直接安装go项目工具，在你保存时将会自动格式化。</li>
<li>尽量使用<code>Tab</code>，而不是空格</li>
</ul>
<p><br></p>
<h4 id="代码一致性"><a href="#代码一致性" class="headerlink" title="代码一致性"></a>代码一致性</h4><p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p>
<p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p>
<p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）相似的声明放在一组,适用于常量、变量和类型声明：</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="keyword">float64</span></span><br><span class="line">  Volume <span class="keyword">float64</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）非常注意: 仅将相关的声明放在一组。不要将不相关的声明放在一组。</span></span><br><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> EnvVar = <span class="string">"MY_ENV"</span>  <span class="comment">// 没有关联的变量单放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）分组使用的位置没有限制，例如：你可以在函数内部使用它们：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">    green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="Import-包导入"><a href="#Import-包导入" class="headerlink" title="Import (包导入)"></a>Import (包导入)</h4><p>引入多个包时，按照三中类型区分，标准包，程序内部包，第三方包，建议写的时候有顺序的导入你的包。</p>
<p>默认情况下，这是 goimports 应用的分组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>导入别名</strong></p>
<p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime/trace"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line"><span class="comment">// _表示，导入不使用包中的方法，但是会加载init初始化</span></span><br><span class="line">  _ <span class="string">"net/http/pprof"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</span></span><br><span class="line">  client <span class="string">"example.com/client-go"</span></span><br><span class="line">  trace <span class="string">"example.com/trace/v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function (函数)"></a>Function (函数)</h4><p><strong>(1) 函数分组与顺序</strong></p>
<p> 在进行Go语言时函数应按粗略的调用顺序排序，同一文件中的函数应按接收者分组。</p>
<p>因此，导出的函数应先出现在文件中，放在<code>struct, const, var</code>定义的后面。</p>
<p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个<code>newXYZ()/NewXYZ()</code></p>
<p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照顺序</span></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 普通工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><strong>(2) 减少不必要的嵌套以及else</strong></p>
<p>描述: 代码应通过尽可能先<code>处理错误情况/特殊情况</code>并尽早返回或继续循环来减少嵌套，减少嵌套多个级别的代码的代码量。</p>
<p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p>
<figure class="image-box">
                <a rel=Go语言开发规范实践指南 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211201143732.png" target="_blank" title="WeiyiGeek.减少不必要的嵌套以及else" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211201143732.png" alt="WeiyiGeek.减少不必要的嵌套以及else" title="" class=""></a>
                <p>WeiyiGeek.减少不必要的嵌套以及else</p>
            </figure>
<p><br/></p>
<h2 id="0x02-指导原则"><a href="#0x02-指导原则" class="headerlink" title="0x02 指导原则"></a>0x02 指导原则</h2><h4 id="Variable-变量"><a href="#Variable-变量" class="headerlink" title="Variable (变量)"></a>Variable (变量)</h4><h5 id="顶层变量声明"><a href="#顶层变量声明" class="headerlink" title="顶层变量声明"></a>顶层变量声明</h5><p>描述: 在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 不推荐的方式</span><br><span class="line">var _s string &#x3D; F()</span><br><span class="line">func F() string &#123; return &quot;A&quot; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 推荐方式,由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型, 还是那种类型</span><br><span class="line">var _s &#x3D; F()</span><br><span class="line">func F() string &#123; return &quot;A&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>如果表达式的类型与所需的<code>类型不完全匹配，请指定类型</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type myError struct&#123;&#125;</span><br><span class="line">func (myError) Error() string &#123; return &quot;error&quot; &#125;</span><br><span class="line">func F() myError &#123; return myError&#123;&#125; &#125;</span><br><span class="line">var _e error &#x3D; F()</span><br><span class="line">&#x2F;&#x2F; F 返回一个 myError 类型的实例，但是我们要 error 类型</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="对于未导出的顶层常量和变量，使用-作为前缀"><a href="#对于未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="对于未导出的顶层常量和变量，使用_作为前缀"></a>对于未导出的顶层常量和变量，使用_作为前缀</h5><p>描述: 在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p>
<p>例外：未导出的错误值，应以<code>err</code>开头。</p>
<p>基本依据：顶级变量和常量具有包范围作用域，使用通用名称可能很容易在其他文件中意外使用错误的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="本地变量声明"><a href="#本地变量声明" class="headerlink" title="本地变量声明"></a>本地变量声明</h5><p>描述: 如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>) ，例如<code>s := &quot;foo&quot;</code>。</p>
<p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="缩小变量作用域"><a href="#缩小变量作用域" class="headerlink" title="缩小变量作用域"></a>缩小变量作用域</h5><p>描述: 如果有可能，尽量缩小变量作用范围，除非它与 <a href="https://www.cnblogs.com/failymao/p/14922047.html#减少嵌套" target="_blank" rel="noopener">减少嵌套</a> 的规则冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err :&#x3D; ioutil.WriteFile(name, data, 0644); err !&#x3D; nil &#123;</span><br><span class="line"> return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="避免可变全局变量"><a href="#避免可变全局变量" class="headerlink" title="避免可变全局变量"></a>避免可变全局变量</h5><p>描述: 使用选择依赖注入方式避免改变全局变量，既适用于函数指针又适用于其他值类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign.go</span></span><br><span class="line"><span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;</span><br><span class="line">  now <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">newSigner</span><span class="params">()</span> *<span class="title">signer</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span> <span class="title">Sign</span><span class="params">(msg <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  <span class="keyword">return</span> signWithTime(msg, now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sign_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSigner</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="避免使用内置名称"><a href="#避免使用内置名称" class="headerlink" title="避免使用内置名称"></a>避免使用内置名称</h5><p>在Go语言规范概述了几个内置的 ,不应在Go项目中使用的名称标识(<a href="https://go.dev/ref/spec#Identifiers" target="_blank" rel="noopener">Go 编程语言规范 - go.dev</a>)</p>
<p>例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # 以下关键字是保留的，不能用作标识符。</span></span><br><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="function"><span class="title">case</span>         <span class="title">defer</span>        <span class="title">go</span>           <span class="title">map</span>          <span class="title">struct</span></span></span><br><span class="line"><span class="function"><span class="title">chan</span>         <span class="title">else</span>         <span class="title">goto</span>         <span class="title">package</span>      <span class="title">switch</span></span></span><br><span class="line"><span class="function"><span class="title">const</span>        <span class="title">fallthrough</span>  <span class="title">if</span>           <span class="title">range</span>        <span class="title">type</span></span></span><br><span class="line"><span class="function"><span class="title">continue</span>     <span class="title">for</span>          <span class="title">import</span>       <span class="title">return</span>       <span class="title">var</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// # 预先声明的标识符,以下标识符在宇宙块中隐式声明：</span></span><br><span class="line"><span class="function"><span class="title">Types</span>:</span></span><br><span class="line"><span class="function">	<span class="title">bool</span> <span class="title">byte</span> <span class="title">complex64</span> <span class="title">complex128</span> <span class="title">error</span> <span class="title">float32</span> <span class="title">float64</span></span></span><br><span class="line"><span class="function">	<span class="title">int</span> <span class="title">int8</span> <span class="title">int16</span> <span class="title">int32</span> <span class="title">int64</span> <span class="title">rune</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">	<span class="title">uint</span> <span class="title">uint8</span> <span class="title">uint16</span> <span class="title">uint32</span> <span class="title">uint64</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Constants</span>:</span></span><br><span class="line"><span class="function">	<span class="title">true</span> <span class="title">false</span> <span class="title">iota</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Zero</span> <span class="title">value</span>:</span></span><br><span class="line"><span class="function">	<span class="title">nil</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Functions</span>:</span></span><br><span class="line"><span class="function">	<span class="title">append</span> <span class="title">cap</span> <span class="title">close</span> <span class="title">complex</span> <span class="title">copy</span> <span class="title">delete</span> <span class="title">imag</span> <span class="title">len</span></span></span><br><span class="line"><span class="function">	<span class="title">make</span> <span class="title">new</span> <span class="title">panic</span> <span class="title">print</span> <span class="title">println</span> <span class="title">real</span> <span class="title">recover</span></span></span><br></pre></td></tr></table></figure>
<p>根据上下文的不同，将这些标识符作为名称重复使用，将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。</p>
<p>在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 示例1</span><br><span class="line">var errorMessage string  &#x2F;&#x2F; 不要使用关键字 error 作用域将被隐式覆盖</span><br><span class="line">  &#x2F;&#x2F; 此时 &#96;errorMessage&#96; 指向内置的非覆盖</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">func handleErrorMessage(msg string) &#123;</span><br><span class="line">    &#x2F;&#x2F; 此时 &#96;errorMessage&#96; 指向内置的非覆盖</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 示例2</span><br><span class="line">type Foo struct &#123;</span><br><span class="line">    &#x2F;&#x2F; &#96;error&#96; and &#96;string&#96; 现在是明确的。</span><br><span class="line">    err error  &#x2F;&#x2F; 不要使用 error 名称作为结构体元素</span><br><span class="line">    str string &#x2F;&#x2F; 不要使用 string 名称作为结构体元素</span><br><span class="line">&#125;</span><br><span class="line">func (f Foo) Error() error &#123;</span><br><span class="line">    return f.err</span><br><span class="line">&#125;</span><br><span class="line">func (f Foo) String() string &#123;</span><br><span class="line">    return f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，编译器在使用预先分隔的标识符时不会生成错误，但是诸如<code>go gofmt 与go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p>
<p><br/></p>
<h5 id="使用原始字符串字面值，避免转义"><a href="#使用原始字符串字面值，避免转义" class="headerlink" title="使用原始字符串字面值，避免转义"></a>使用原始字符串字面值，避免转义</h5><p>描述: Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit" target="_blank" rel="noopener">原始字符串字面值</a>，也就是 “ ` “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p>
<p>例如，可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:"test"`</span> <span class="comment">// 而非 `"unknown name:\"test\""`</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Struct-结构体"><a href="#Struct-结构体" class="headerlink" title="Struct (结构体)"></a>Struct (结构体)</h4><p><br/></p>
<h5 id="使用字段名初始化结构体"><a href="#使用字段名初始化结构体" class="headerlink" title="使用字段名初始化结构体"></a>使用字段名初始化结构体</h5><p>描述: 初始化结构体时，应该指定字段名称，现在由 <a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>go vet</code></a> 强制执行。</p>
<p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">"add"</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">"subtract"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>省略结构中的零值字段</strong></p>
<p>描述: 初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零的字段。<br>也就是，让我们自动将这些设置为零值，这有助于通过省略该上下文中的默认值来减少阅读的障碍，只指定有意义的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user :&#x3D; User&#123;</span><br><span class="line">  FirstName: &quot;John&quot;,</span><br><span class="line">  LastName: &quot;Doe&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在字段名提供有意义上下文的地方包含零值。例如，<a href="https://www.cnblogs.com/failymao/p/14922047.html#表驱动测试" target="_blank" rel="noopener">表驱动测试</a> 中的测试用例可以受益于字段的名称，即使它们是零值的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests :&#x3D; []struct&#123;</span><br><span class="line">  got string &#x2F;&#x2F; give</span><br><span class="line">  want int</span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;got: &quot;0&quot;, want: 0&#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><strong>对零值结构使用 <code>var</code></strong></p>
<p>描述: 如果在声明中省略了结构的所有字段，请使用 <code>var</code> 声明结构,例如<code>var user User</code>。</p>
<p>这将零值结构与那些具有类似于为[初始化 Maps]创建的,区别于非零值字段的结构区分开来，并与我们更喜欢的 <a href="https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices" target="_blank" rel="noopener">declare empty slices</a> 方式相匹配。</p>
<p><br/></p>
<p><strong>初始化 Struct 引用</strong></p>
<p>描述: 在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">"bar"</span>&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h5 id="结构体中的嵌入"><a href="#结构体中的嵌入" class="headerlink" title="结构体中的嵌入"></a>结构体中的嵌入</h5><p>描述: 嵌入式类型（<code>例如 mutex</code>）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p>
<p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能，它应该在对用户不利影响的情况下完成这项工作。</p>
<p><strong>结构体中的嵌入不应该是以下几个方面:</strong></p>
<ul>
<li>纯粹是为了美观或方便。</li>
<li>使外部类型更难构造或使用。</li>
<li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li>
<li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li>
<li>公开未导出的类型。</li>
<li>影响外部类型的复制形式。</li>
<li>更改外部类型的API或类型语义。</li>
<li>嵌入内部类型的非规范形式。</li>
<li>公开外部类型的实现详细信息。</li>
<li>允许用户观察或控制类型内部。</li>
<li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li>
</ul>
<p><br/></p>
<p>简单地说，有意识地和有目的地嵌入，一种很好的测试体验是，”是否所有这些导出的内部方法/字段都将直接添加到外部类型”。<br>如果: 答案是<code>some</code>或<code>no</code>，不要嵌入内部类型而是使用字段。</p>
<p><a rel=Go语言开发规范实践指南 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211201145904.png" target="_blank" title="WeiyiGeek.结构体嵌入" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211201145904.png" alt="WeiyiGeek.结构体嵌入"></a></p>
<h5 id="避免在公共结构中嵌入类型"><a href="#避免在公共结构中嵌入类型" class="headerlink" title="避免在公共结构中嵌入类型"></a>避免在公共结构中嵌入类型</h5><p>描述: 嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p>
<p>假设，您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。</p>
<p>相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐操作:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ConcreteList 是一个实体列表。</span><br><span class="line">type ConcreteList struct &#123;</span><br><span class="line">  list *AbstractList   &#x2F;&#x2F; 避免在具体的列表实现中嵌入</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 添加将实体添加到列表中。</span><br><span class="line">func (l *ConcreteList) Add(e Entity) &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 移除从列表中移除实体。</span><br><span class="line">func (l *ConcreteList) Remove(e Entity) &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 允许 <a href="https://golang.org/doc/effective_go.html#embedding" target="_blank" rel="noopener">类型嵌入</a> 作为继承和组合之间的折衷，外部类型获取嵌入类型的方法的隐式副本。</p>
<p>默认情况下，这些方法委托给嵌入实例的同一方法，结构还获得与类型同名的字段，所以，如果嵌入的类型是 public，那么字段是 public。</p>
<p>为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型, 很少需要嵌入类型，这是一种方便，可以帮助您避免编写冗长的委托方法。</p>
<p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcreteList 是一个实体列表。</span></span><br><span class="line"><span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加将实体添加到列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Add</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除从列表中移除实体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span> <span class="title">Remove</span><span class="params">(e Entity)</span></span> &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.</p>
<ul>
<li>向嵌入式接口添加方法是一个破坏性的改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p>
<p><br/></p>
<h5 id="功能选项"><a href="#功能选项" class="headerlink" title="功能选项"></a>功能选项</h5><p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Open creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">type options struct &#123;</span><br><span class="line">  cache  bool</span><br><span class="line">  logger *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type Option interface &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type cacheOption bool</span><br><span class="line"> </span><br><span class="line">func (c cacheOption) apply(opts *options) &#123;</span><br><span class="line">  opts.cache &#x3D; bool(c)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func WithCache(c bool) Option &#123;</span><br><span class="line">  return cacheOption(c)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type loggerOption struct &#123;</span><br><span class="line">  Log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (l loggerOption) apply(opts *options) &#123;</span><br><span class="line">  opts.logger &#x3D; l.Log</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func WithLogger(log *zap.Logger) Option &#123;</span><br><span class="line">  return loggerOption&#123;Log: log&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Open creates a connection.</span><br><span class="line">func Open(</span><br><span class="line">  addr string,</span><br><span class="line">  opts ...Option,</span><br><span class="line">) (*Connection, error) &#123;</span><br><span class="line">  options :&#x3D; options&#123;</span><br><span class="line">    cache:  defaultCache,</span><br><span class="line">    logger: zap.NewNop(),</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  for _, o :&#x3D; range opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p>
<p><br/></p>
<h4 id="Function-函数-1"><a href="#Function-函数-1" class="headerlink" title="Function (函数)"></a>Function (函数)</h4><h5 id="避免使用-init"><a href="#避免使用-init" class="headerlink" title="避免使用 init()"></a>避免使用 <code>init()</code></h5><p>在Go语言开发应该避免使用init()，当必须要使用其时，代码应先尝试：</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他init()函数的顺序或副作用。虽然init()顺序是明确的，但代码可以更改，因此init()函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。</li>
<li>避免I/O，包括文件系统、网络和系统调用。</li>
</ol>
<p>Tips : 不能满足上述这些要求的代码可能属于要作为<code>main()</code>调用的一部分（或程序生命周期中的其他地方），<br>或者作为<code>main()</code>本身的一部分写入。</p>
<p>特别是，打算由其他程序使用的库应该特别注意完全确定性，而不是执行“init magic”</p>
<p><a rel=Go语言开发规范实践指南 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211201095046.png" target="_blank" title="WeiyiGeek.避免使用init" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211201095046.png" alt="WeiyiGeek.避免使用init"></a></p>
<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li>不能表示为单个赋值的复杂表达式。</li>
<li>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</li>
<li>对<a href="https://cloud.google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations" target="_blank" rel="noopener">Google Cloud Functions</a>和其他形式的确定性预计算的优化。</li>
</ul>
<p><br/></p>
<h5 id="避免参数语义不明确-Avoid-Naked-Parameters"><a href="#避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="避免参数语义不明确(Avoid Naked Parameters)"></a>避免参数语义不明确(Avoid Naked Parameters)</h5><p>描述: 函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure>
<p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（<code>true/false</code>）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="keyword">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h5 id="优雅退出方式-Exit"><a href="#优雅退出方式-Exit" class="headerlink" title="优雅退出方式 Exit"></a>优雅退出方式 <code>Exit</code></h5><p>Go程序使用<a href="https://golang.org/pkg/os/#Exit" target="_blank" rel="noopener"><code>os.Exit</code></a> 或者 <a href="https://golang.org/pkg/log/#Fatal" target="_blank" rel="noopener"><code>log.Fatal*</code></a> 立即退出 (使用<code>panic</code>不是退出程序的好方法，请参照下面错误处理 <a href="https://www.cnblogs.com/failymao/p/14922047.html#不要-panic" target="_blank" rel="noopener">don’t panic</a>.)</p>
<p><strong>仅在<code>main（）</code></strong>中调用其中一个 <code>os.Exit</code> 或者 <code>log.Fatal*</code>。所有其他函数应将错误返回到信号失败中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  body, err :&#x3D; readFile(path)</span><br><span class="line">  if err !&#x3D; nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func readFile(path string) (string, error) &#123;</span><br><span class="line">  f, err :&#x3D; os.Open(path)</span><br><span class="line">  if err !&#x3D; nil &#123;</span><br><span class="line">    return &quot;&quot;, err</span><br><span class="line">  &#125;</span><br><span class="line">  b, err :&#x3D; ioutil.ReadAll(f)</span><br><span class="line">  if err !&#x3D; nil &#123;</span><br><span class="line">    return &quot;&quot;, err</span><br><span class="line">  &#125;</span><br><span class="line">  return string(b), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原则上：退出的具有多种功能的程序存在一些问题：</p>
<ul>
<li>不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。</li>
<li>难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 <code>go test</code> 尚未运行的其他测试的风险。</li>
<li>跳过清理：当函数退出程序时，会跳过已经进入<code>defer</code>队列里的函数调用。这增加了跳过重要清理任务的风险。</li>
</ul>
<p>如果可能的话，你的<code>main（）</code>函数中<strong>最多一次</strong> 调用 <code>os.Exit</code>或者<code>log.Fatal</code>。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。</p>
<p>这会缩短 <code>main()</code>函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  args := os.Args[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) != <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"missing file"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[<span class="number">0</span>]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><br></p>
<h4 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface (接口)"></a>Interface (接口)</h4><h5 id="1-指向-interface-的指针"><a href="#1-指向-interface-的指针" class="headerlink" title="1.指向 interface 的指针"></a>1.指向 interface 的指针</h5><p>您几乎不需要指向接口类型的指针，您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p>
<p>接口实质上在底层用两个字段表示：</p>
<ul>
<li>一个指向某些特定类型信息的指针,您可以将其视为”type”。</li>
<li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li>
</ul>
<p>如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 F = S1&#123;&#125; <span class="comment">// f1.f()无法修改底层数据</span></span><br><span class="line"><span class="keyword">var</span> f2 F = &amp;S2&#123;&#125; <span class="comment">// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h5 id="2-Interface-合理性验证"><a href="#2-Interface-合理性验证" class="headerlink" title="2.Interface 合理性验证"></a>2.Interface 合理性验证</h5><p>在编译时验证接口的符合性。这包括：</p>
<ul>
<li>将实现特定接口的导出类型作为接口API 的一部分进行检查</li>
<li>实现同一接口的(导出和非导出)类型属于实现类型的集合</li>
<li>任何违反接口合理性检查的场景,都会终止编译,并通知给用户</li>
</ul>
<p>补充: 上面3条是编译器对接口的检查机制,大体意思是错误使用接口会在编译期报错.所以可以利用这个机制让部分问题在编译期暴露。</p>
<figure class="image-box">
                <a rel=Go语言开发规范实践指南 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211126224009.png" target="_blank" title="WeiyiGeek.Bad&Good" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20211126224009.png" alt="WeiyiGeek.Bad&Good" title="" class=""></a>
                <p>WeiyiGeek.Bad&Good</p>
            </figure>
<p>例如，右边Good的代码块中，如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配,<br>那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过.</p>
<p>Tips: 赋值的右边应该是断言类型的零值。<br>对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；<br>对于结构类型，这是空结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type LogHandler struct &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line">var _ http.Handler &#x3D; LogHandler&#123;&#125;  &#x2F;&#x2F; 关键点 ，看LogHandler 接口是否实现 http.Handler 接口类型。</span><br><span class="line">func (h LogHandler) ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h5 id="3-接口与接收器-receiver"><a href="#3-接口与接收器-receiver" class="headerlink" title="3.接口与接收器 (receiver)"></a>3.接口与接收器 (receiver)</h5><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p>
<p>带指针接收器的方法只能通过指针或 <a href="https://golang.org/ref/spec#Method_values" target="_blank" rel="noopener">addressable values</a>调用.</p>
<p>例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Write</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) map 类型实例化S结构体</span></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="keyword">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 你只能通过值调用 Read</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"><span class="comment">// 这不能编译通过：</span></span><br><span class="line"><span class="comment">//  sVals[1].Write("test")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) map 类型实例化S结构体指针</span></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="keyword">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 通过指针既可以调用 Read，也可以调用 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>
<p>类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;  <span class="comment">// # 关键点</span></span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"><span class="comment">// i = s2Val 代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span></span><br></pre></td></tr></table></figure>
<p><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">pointers vs. values</a> 的精彩讲解.</p>
<ul>
<li>一个类型可以有值接收器方法集和指针接收器方法集,<code>值接收器方法集</code>是指针接收器方法集的子集,反之不是就是像上面所说一个类型为指针接收器方法集时，就不能进行值传递。<ul>
<li>值对象只可以使用值接收器方法集</li>
<li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li>
</ul>
</li>
</ul>
<p>接口的匹配(或者叫实现), 类型实现了接口的所有方法叫匹配；具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口</p>
<p>具体的匹配分两种:</p>
<ul>
<li>值方法集和接口匹配: 给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集.</li>
<li>指针方法集和接口匹配: 只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配.</li>
</ul>
<p>如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)<br>为啥 i = s2Val 会报错,因为值方法集和接口不匹配,必须要指针方法集才匹配.</p>
<p><br/></p>
<h4 id="Slices-或-Maps-切片和字典"><a href="#Slices-或-Maps-切片和字典" class="headerlink" title="Slices 或 Maps (切片和字典)"></a>Slices 或 Maps (切片和字典)</h4><h5 id="初始化-Maps"><a href="#初始化-Maps" class="headerlink" title="初始化 Maps"></a>初始化 Maps</h5><p>描述: 对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的，这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: 声明和初始化看起来非常相似的。</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good: 声明和初始化看起来差别非常大。</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Tips: 所以，在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="https://www.cnblogs.com/failymao/p/14922047.html#指定Map容量提示" target="_blank" rel="noopener">指定Map容量提示</a>。</p>
<p>另外，如果 map 包含固定的元素列表，则使用 <code>map literals(map 初始化列表)</code> 初始化映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Bad</span><br><span class="line">m :&#x3D; make(map[T1]T2, 3)</span><br><span class="line">m[k1] &#x3D; v1</span><br><span class="line">m[k2] &#x3D; v2</span><br><span class="line">m[k3] &#x3D; v3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Good</span><br><span class="line">m :&#x3D; map[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p>
<p><br/></p>
<h5 id="在边界处拷贝-Slices-和-Maps"><a href="#在边界处拷贝-Slices-和-Maps" class="headerlink" title="在边界处拷贝 Slices 和 Maps"></a>在边界处拷贝 Slices 和 Maps</h5><p>描述: slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p>
<p><strong>接收 Slices 和 Maps</strong></p>
<p>当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))  <span class="comment">// 关键点</span></span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure>
<p><strong>map 或 slice 的修改</strong></p>
<p>同样请注意用户对暴露内部状态的 map 或 slice 的修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex            <span class="comment">// 同步锁</span></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>  <span class="comment">// 字典</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters)) <span class="comment">// 内存申请</span></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;  <span class="comment">// 遍历 counters</span></span><br><span class="line">    result[k] = v   <span class="comment">// 将 counters 字典值分贝赋予 k,v =&gt; result 字典变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure>
<h5 id="追加时优先指定切片容量"><a href="#追加时优先指定切片容量" class="headerlink" title="追加时优先指定切片容量"></a>追加时优先指定切片容量</h5><p>描述: 在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值，你可以在性能的那一章节中看见使用make可以减少切片在循环追加时对于内存分配的次数（<code>增加执行效率</code>）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BenchmarkGood-4   100000000    0.21s</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h5 id="nil-是一个有效的-slice"><a href="#nil-是一个有效的-slice" class="headerlink" title="nil 是一个有效的 slice"></a>nil 是一个有效的 slice</h5><p>描述: <code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，您不应明确返回长度为零的切片而是应该返回<code>nil</code> 来代替。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// return []int&#123;&#125;  // 不推荐方式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 推荐方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>,而非 <code>nil</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func isEmpty(s []string) bool &#123;</span><br><span class="line">&#x2F;&#x2F; return s &#x3D;&#x3D; nil</span><br><span class="line">  return len(s) &#x3D;&#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var nums []int</span><br><span class="line">if add1 &#123;nums &#x3D; append(nums, 1)&#125;</span><br><span class="line">if add2 &#123;nums &#x3D; append(nums, 2)&#125;</span><br></pre></td></tr></table></figure>
<p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（<code>一个为nil，另一个不是</code>），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p>
<p><br/></p>
<h4 id="Defer-资源释放"><a href="#Defer-资源释放" class="headerlink" title="Defer (资源释放)"></a>Defer (资源释放)</h4><p>描述: 在Go语言中，常常使用 defer 释放资源，诸如文件和锁。</p>
<p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做，使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。</p>
<p>尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="Sync-同步包"><a href="#Sync-同步包" class="headerlink" title="Sync (同步包)"></a>Sync (同步包)</h4><p>描述: 零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的, 所以指向 <code>mutex</code> 的指针基本是不必要的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐方式</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>
<p>如果你使用<code>结构体指针</code>，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。</p>
<p>如果是<code>私有结构体类型</code>或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.为私有类型或需要实现互斥接口的类型嵌入。</span></span><br><span class="line"><span class="comment">// 最好的方式是直接嵌入到结构体中</span></span><br><span class="line"><span class="keyword">type</span> smap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex   <span class="comment">// only for unexported types（仅适用于非导出类型）</span></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSMap</span><span class="params">()</span> *<span class="title">smap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;smap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *smap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.对于导出的 (公共的方式) 类型，请使用专用字段。</span></span><br><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex <span class="comment">// 对于导出类型，请使用私有锁</span></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.mu.Lock()  			<span class="comment">// 读写锁</span></span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()   <span class="comment">// 程序结束后接锁</span></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="ErrorHandling-错误处理"><a href="#ErrorHandling-错误处理" class="headerlink" title="ErrorHandling (错误处理)"></a>ErrorHandling (错误处理)</h4><p><strong>Go 中有多种声明错误（Error) 的选项：</strong></p>
<ul>
<li><a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 对于简单静态字符串的错误</li>
<li><a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 用于格式化的错误字符串</li>
<li><code>Error()</code> 方法实现的自定义类型</li>
<li><a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> 的 Wrapped errors</li>
</ul>
<p><strong>返回错误时，请考虑以下因素以确定最佳选择：</strong></p>
<p>这是一个不需要额外信息的简单错误吗？</p>
<blockquote>
<p>如果是这样，<a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 足够了。</p>
</blockquote>
<p>客户需要检测并处理此错误吗？</p>
<blockquote>
<p>如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</p>
</blockquote>
<p>您是否正在传播下游函数返回的错误？</p>
<blockquote>
<p>如果是这样，请查看本文后面有关错误包装 <a href="https://www.cnblogs.com/failymao/p/14922047.html#错误包装" target="_blank" rel="noopener">section on error wrapping</a> 部分的内容。</p>
</blockquote>
<p>否则 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 就可以了。</p>
<p>Tips: 错误处理原则是不能丢弃有返回err的调用，不能用_丢弃，必须全部处理尽早 return，采用独立的错误流处理。</p>
<hr>
<h5 id="1-错误声明-Error-Declare"><a href="#1-错误声明-Error-Declare" class="headerlink" title="1.错误声明 (Error Declare)"></a>1.错误声明 (Error Declare)</h5><p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a>，请使用一个错误变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo (包)</span></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar (调用)，返回错误的对象。</span></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 错误，是否是 ErrCouldNotOpen</span></span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    <span class="comment">// 输出 error handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型，即<code>Error()</code>方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义错误结构体</span></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回错误结构体对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 指定在open函数输入信息。</span></span><br><span class="line">  <span class="keyword">if</span> err := open(<span class="string">"testfile.txt"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 返回指定的错误信息</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分，<code>最好公开匹配器功能以检查错误</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否找到错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar ：指定在open函数输入信息</span></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"foo"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// 输出指定错误信息 handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="2-错误包装-Error-Wrapping"><a href="#2-错误包装-Error-Wrapping" class="headerlink" title="2.错误包装 (Error Wrapping)"></a>2.错误包装 (Error Wrapping)</h5><p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p>
<ul>
<li>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</li>
<li>添加上下文，使用<code>&quot;pkg/errors&quot;.Wrap</code> 以便错误消息提供更多上下文 ,<code>&quot;pkg/errors&quot;.Cause</code>可用于提取原始错误。</li>
<li>如果调用者不需要检测或处理的特定错误情况，使用 <code>fmt.Errorf</code>。</li>
</ul>
<p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p>
<p>在将上下文添加到返回的错误时，请<code>避免使用“failed to”之类的短语</code>以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"new store: %v"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x: y: <span class="built_in">new</span> store: the error</span><br></pre></td></tr></table></figure>
<p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p>
<p>另请参见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just check errors, handle them gracefully</a>. 不要只是检查错误，要优雅地处理错误</p>
<p><br></p>
<h5 id="3-处理类型断言失败"><a href="#3-处理类型断言失败" class="headerlink" title="3.处理类型断言失败"></a>3.处理类型断言失败</h5><p>描述: <a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="noopener">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此请始终使用<code>“comma ok”</code>的惯用法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h5 id="4-避免使用-panic"><a href="#4-避免使用-panic" class="headerlink" title="4.避免使用 panic"></a>4.避免使用 panic</h5><p>描述: 在生产环境中运行的代码必须避免出现 panic。</p>
<p>panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank" rel="noopener">cascading failures</a> 级联失败的主要根源 ，如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"an argument is required"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)  <span class="comment">// 如果错误就退出程序</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>panic/recover</code> 不是错误处理策略，仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。</p>
<p>程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var _statusTemplate &#x3D; template.Must(template.New(&quot;name&quot;).Parse(&quot;_statusHTML&quot;))</span><br></pre></td></tr></table></figure>
<p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"> </span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="5-go-uber-org-atomic"><a href="#5-go-uber-org-atomic" class="headerlink" title="5.go.uber.org/atomic"></a>5.go.uber.org/atomic</h5><p>使用 <a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener">sync/atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p><a href="https://godoc.org/go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type foo struct &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (f *foo) start() &#123;</span><br><span class="line">  if f.running.Swap(true) &#123;</span><br><span class="line">     &#x2F;&#x2F; already running…</span><br><span class="line">     return</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; start the Foo</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func (f *foo) isRunning() bool &#123;</span><br><span class="line">  return f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel  (通道)"></a>Channel  (通道)</h4><p>描述: channel 通常 size 应为 1 或是无缓冲的。</p>
<p>默认情况下，channel 是无缓冲的，其 size 为零，任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。</p>
<p>(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="iota-枚举"><a href="#iota-枚举" class="headerlink" title="iota  (枚举)"></a>iota  (枚举)</h4><p>描述: 在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 int 类型别名</span></span><br><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span> <span class="comment">// 0 + 1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure>
<p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 int 类型别名</span></span><br><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span>  <span class="comment">// 0</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<h4 id="Unit-单元测试"><a href="#Unit-单元测试" class="headerlink" title="Unit (单元测试)"></a>Unit (单元测试)</h4><p>单元测试必须导入testing包,已经编程文件必须以<code>_test.go</code>结尾，并且测试函数命名也有要求，单元测试必须<code>以Test开头后接测试函数名（注意首字母大写）</code>,而基准（性能）测试必须<code>以Benchmark开头后接函数名</code>, 而示例函数必须<code>以Example开头后接函数名称</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单元测试</span><br><span class="line">func TestSplitStr(t *testing.T)&#123;...code...&#125;</span><br><span class="line">func Test_SplitStr(t *testing.T)&#123;...code...&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 基准测试</span><br><span class="line">func TestSplitStr(b *testing.B)&#123;...code...&#125;</span><br><span class="line">func Test_SplitStr(b *testing.B)&#123;...code...&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 示例函数</span><br><span class="line">func ExampleSplitStr()&#123;...code...&#125;</span><br><span class="line">func Example_SplitStr()&#123;...code...&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><strong>组测试</strong></p>
<p>当测试逻辑是重复的时候，通过 <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;  <span class="comment">// 此种初始值得学习</span></span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:8000"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:http"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"http"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">":8000"</span>,</span><br><span class="line">    wantHost: <span class="string">""</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"1:8"</span>,</span><br><span class="line">    wantHost: <span class="string">"1"</span>,</span><br><span class="line">    wantPort: <span class="string">"8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p>
<p>我们遵循这样的约定：将结构体切片称为<code>tests</code>， 每个测试用例称为<code>tt</code>。</p>
<p>此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p>
<p><br/></p>
<h4 id="Performance-性能提升"><a href="#Performance-性能提升" class="headerlink" title="Performance (性能提升)"></a>Performance (性能提升)</h4><p>描述: 性能方面的特定准则只适用于高频场景。</p>
<h5 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h5><p>优先使用 strconv 而不是 fmt，将原语转换为字符串或从字符串转换时，strconv速度比fmt快。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  <span class="comment">// s := fmt.Sprint(rand.Int()) // 不推荐类型转换</span></span><br><span class="line">  s := strconv.Itoa(rand.Int()) <span class="comment">// 推荐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h5 id="避免字符串到字节的转换"><a href="#避免字符串到字节的转换" class="headerlink" title="避免字符串到字节的转换"></a>避免字符串到字节的转换</h5><p>描述: 不要反复从固定字符串创建字节 slice, 相反请执行一次转换并捕获结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data :&#x3D; []byte(&quot;Hello world&quot;) &#x2F;&#x2F; 推荐</span><br><span class="line">for i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data) &#x2F;&#x2F; 推荐</span><br><span class="line">  &#x2F;&#x2F;  w.Write([]byte(&quot;Hello world&quot;))  &#x2F;&#x2F; 不推荐类型转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="指定容器容量"><a href="#指定容器容量" class="headerlink" title="指定容器容量"></a>指定容器容量</h5><p>描述: 尽可能指定容器容量，以便为容器预先分配内存，这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p>
<p><strong>指定Map容量：</strong></p>
<p>在尽可能的情况下，在使用 make() 初始化的时候提供容量信息<code>make(map[T1]T2, hint)</code>,向<code>make()</code>提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。</p>
<p>注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。<br>因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo)</span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// m 是有大小提示创建的；在运行时可能会有更少的分配。</span></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo, <span class="built_in">len</span>(files)) <span class="comment">// 关键点</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><strong>指定切片容量：</strong></p>
<p>描述: 在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时 <code>make([]T, length, capacity)</code>。</p>
<p>与maps不同，<code>slice capacity</code>不是一个提示：编译器将为提供给<code>make()</code>的slice的容量分配足够的内存，<br>这意味着后续的<code>append()</code>操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, size)</span><br><span class="line">  <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; size; k++&#123;</span><br><span class="line">    data = <span class="built_in">append</span>(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Time-时间处理"><a href="#Time-时间处理" class="headerlink" title="Time (时间处理)"></a>Time (时间处理)</h4><p>Go语言中为我们处理时间提供一个强大的内置包<code>time</code>,它有助于以更安全、更准确的方式处理这些不正确的假设。</p>
<p>关于时间的错误假设通常包括以下几点:<code>一天有 24 小时、一小时有 60 分钟、一周有七天、一年 365 天</code></p>
<p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p>
<p>Tips : Go 语言的格式化字符串为”2006-01-02 15:04:06”</p>
<h5 id="使用-time-Time-表达瞬时时间"><a href="#使用-time-Time-表达瞬时时间" class="headerlink" title="使用 time.Time 表达瞬时时间"></a>使用 <code>time.Time</code> 表达瞬时时间</h5><p> 描述: 在处理时间的瞬间时使用 <a href="https://golang.org/pkg/time/#Time" target="_blank" rel="noopener"><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐方法 , 内置的时间比较方法 相比于比较运算符更精确。</span><br><span class="line">func isActive(now, start, stop time.Time) bool &#123;</span><br><span class="line">&#x2F;&#x2F;   return start &lt;&#x3D; now &amp;&amp; now &lt; stop &#x2F;&#x2F; 不推荐</span><br><span class="line">  return (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="使用-time-Duration-表达时间段"><a href="#使用-time-Duration-表达时间段" class="headerlink" title="使用 time.Duration 表达时间段"></a>使用 <code>time.Duration</code> 表达时间段</h5><p>先看示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(<span class="number">10</span>*time.Second) <span class="comment">// 更加直观，让使用者自定义设定是妙或者毫秒</span></span><br></pre></td></tr></table></figure>
<p>回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。</p>
<p>如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 <a href="https://golang.org/pkg/time/#Time.AddDate" target="_blank" rel="noopener"><code>Time.AddDate</code></a>。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 <a href="https://golang.org/pkg/time/#Time.Add" target="_blank" rel="noopener"><code>Time.Add</code></a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newDay :&#x3D; t.AddDate(0 &#x2F;* years *&#x2F;, 0 &#x2F;* months *&#x2F;, 1 &#x2F;* days *&#x2F;)</span><br><span class="line">maybeNewDay :&#x3D; t.Add(24 * time.Hour)</span><br></pre></td></tr></table></figure>
<p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p>
<ul>
<li>Command-line 标志: <a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></li>
<li>JSON: <a href="https://golang.org/pkg/encoding/json/" target="_blank" rel="noopener"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON" target="_blank" rel="noopener"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串</li>
<li>SQL: <a href="https://golang.org/pkg/database/sql/" target="_blank" rel="noopener"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</li>
<li>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2" target="_blank" rel="noopener"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &#123;&quot;intervalMillis&quot;: 2000&#125;</span><br><span class="line"></span><br><span class="line">type Config struct &#123;</span><br><span class="line">  IntervalMillis int &#96;json:&quot;intervalMillis&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 <a href="https://tools.ietf.org/html/rfc3339" target="_blank" rel="noopener">RFC 3339</a> 中定义的格式时间戳。</p>
<p>默认情况下，<a href="https://golang.org/pkg/time/#Time.UnmarshalText" target="_blank" rel="noopener"><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 <a href="https://golang.org/pkg/time/#RFC3339" target="_blank" rel="noopener"><code>time.RFC3339</code></a> 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p>
<p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a href="https://github.com/golang/go/issues/8728" target="_blank" rel="noopener">Issue-8728</a>），也不在计算中考虑闰秒（<a href="https://github.com/golang/go/issues/15190" target="_blank" rel="noopener">Issue-15190</a>）。</p>
<p>如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<p><br/></p>
<h4 id="String-字符串处理"><a href="#String-字符串处理" class="headerlink" title="String (字符串处理)"></a>String (字符串处理)</h4><h5 id="字符串-string-format-变量"><a href="#字符串-string-format-变量" class="headerlink" title="字符串 string format 变量"></a>字符串 string format 变量</h5><p>描述: 如果你在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量，此有助于<code>go vet</code>对格式字符串执行静态分析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">msg := <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><strong>命名 Printf 样式的函数</strong></p>
<p>描述: 声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p>
<p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go vet -printfuncs&#x3D;wrapf,statusf</span><br><span class="line">&#x2F;&#x2F; “go.vetFlags”: [“printfuncs&#x3D;wrapf”]</span><br></pre></td></tr></table></figure>
<p><br/></p>
<h2 id="0x03-规范辅助工具"><a href="#0x03-规范辅助工具" class="headerlink" title="0x03 规范辅助工具"></a>0x03 规范辅助工具</h2><h3 id="Linting-相关工具"><a href="#Linting-相关工具" class="headerlink" title="Linting 相关工具"></a>Linting 相关工具</h3><p>比任何 “blessed” linter 集更重要的是，lint在一个代码库中始终保持一致。</p>
<p>我们建议至少使用以下linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p>
<ul>
<li><a href="https://github.com/kisielk/errcheck" target="_blank" rel="noopener">errcheck</a> 以确保错误得到处理</li>
<li><a href="https://godoc.org/golang.org/x/tools/cmd/goimports" target="_blank" rel="noopener">goimports</a> 格式化代码和管理 imports</li>
<li><a href="https://github.com/golang/lint" target="_blank" rel="noopener">golint</a> 指出常见的文体错误</li>
<li><a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener">govet</a> 分析代码中的常见错误</li>
<li><a href="https://staticcheck.io/" target="_blank" rel="noopener">staticcheck</a> 各种静态分析检查</li>
</ul>
<p><br/></p>
<p>Lint Runners</p>
<p>描述: 我们推荐 <a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a> 作为go-to lint的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个repo有一个示例配置文件<a href="https://github.com/uber-go/guide/blob/master/.golangci.yml" target="_blank" rel="noopener">.golangci.yml</a>和推荐的linter设置。</p>
<p>golangci-lint 有<a href="https://golangci-lint.run/usage/linters/" target="_blank" rel="noopener">various-linters</a>可供使用。建议将上述linters作为基本set，我们鼓励团队添加对他们的项目有意义的任何附加linters。</p>

        </div>
        <!-- Google 广告 -->
        
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-9134434519967436" data-ad-slot="7905848205"></ins>
  

        
<hr/>
<div style="text-align: center;font-weight: bold;">
  <p> 欢迎各位志同道合的朋友一起学习交流，如文章有误请在下方留下您宝贵的经验知识，个人邮箱地址<b style="color:#ff654e"><code>【master#weiyigeek.top】</code></b>或者个人公众号<b style="color:#ff654e"><code>【WeiyiGeek】</code></b>联系我。 </p>
  <p> 更多文章来源于<b style="color:#03a9f4">【WeiyiGeek Blog - 为了能到远方，脚下的每一步都不能少】</b>, 个人首页地址( <a style="color: #03a9f4;" href="https://weiyigeek.top" target="_blank"> https://weiyigeek.top </a> )</p>
<!-- 

  <ul style="font-weight: bolder;">
    <li>
      <p><span style="color: #03a9f4">echo&nbsp;&nbsp;"【点个赞】，动动你那粗壮的拇指或者芊芊玉手，亲！"</span></p>
    </li>
    <li>
      <p><span style="color: #ff9201">printf("%s",&nbsp;"【投个币】，万水千山总是情，投个硬币行不行，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #02a2ff">fmt.Printf("【收个藏】，阅后即焚不吃灰，亲！")&nbsp;&nbsp;</span></p>
    </li>
    <li>
      <p><span style="color:red">console.info("【转个发】，让更多的志同道合的朋友一起学习交流，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #ff654e">System.out.println("【关个注】，后续浏览查看不迷路哟，亲！")</span></p>
    </li>
  </ul> -->
  <div>
    <img src="/img/share-wechat.jpg" class="img-responsive" alt="扫描Follow(关注)WeiyiGeek公众号与Visit(浏览)极客全栈修炼小程序" >
    <p>专栏书写不易，如果您觉得这个专栏还不错的，请给这篇专栏 <b style="color: red;">【点个赞、投个币、收个藏、关个注、转个发、赞个助】</b>，这将对我的肯定，我将持续整理发布更多优质原创文章！。</p>
    <img src="/img/weiyigeek.jpg" class="img-responsive" alt="WeiyiGeek-banner">
  </div>
</div>
  <hr>
  

  <blockquote class="post-copyright">
    <div class="content">
      
        
<span class="post-time">
    最后更新时间：<time datetime="2022-03-29T05:39:06.304Z" itemprop="dateUpdated">2022-03-29 13:39:06</time>
</span><br>


        <span>文章原始路径：<a href="https://github.com/WeiyiGeek/blog/edit/master/source/_posts/编程世界/Go/Go语言开发规范实践指南.md" target="_blank" rel="noopener noreferrer">_posts/编程世界/Go/Go语言开发规范实践指南.md</a></span><br>
         <span class="copy-copyright">转载注明出处，原文地址：<a href="/2021/10-20-561.html" target="_blank" rel="external">https://blog.weiyigeek.top/2021/10-20-561.html</a></span><br>本站文章内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a> 
    </div>
    <footer>
      <a href="https://blog.weiyigeek.top">
        <img src="/img/avatar.jpg" alt="WeiyiGeek">
        WeiyiGeek
      </a>
    </footer>
  </blockquote>


        
            <div class="page-reward">
  <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-rectangle waves-light">☕️ 请作者喝杯咖啡!</a>
</div>
            
        
        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2021/10-20-561.html&title=《Go语言开发规范实践指南》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2021/10-20-561.html&title=《Go语言开发规范实践指南》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2021/10-20-561.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Go语言开发规范实践指南》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2021/10-20-561.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2021/10-20-561.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
          <!-- 评论组件 -->


<div id="gitalk-container"></div>
<script type="text/javascript" src="/js/plugins/gitalk.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/custom/gitalk.init.js?v=1.6.6"></script>
        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2021/11-1-632.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Websocket待补充</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2021/8-3-651.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">ElasticStack日志采集监控搭建实践案例</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x00-前言简述"><span class="post-toc-number">1.</span> <span class="post-toc-text">0x00 前言简述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x01-Go开发规范"><span class="post-toc-number">2.</span> <span class="post-toc-text">0x01 Go开发规范</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#命名规范"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">命名规范</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#目录-amp-package-包命名"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">目录&amp;package 包命名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#go-文件命名"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">.go 文件命名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#constant-常亮命名"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">constant-常亮命名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#variable-变量命名"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">variable-变量命名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#function-函数命名"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">function-函数命名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#struct-结构体命名"><span class="post-toc-number">2.1.6.</span> <span class="post-toc-text">struct-结构体命名</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#interface-接口命名"><span class="post-toc-number">2.1.7.</span> <span class="post-toc-text">interface-接口命名</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注释规范"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">注释规范</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#单行-注释文本"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">单行: &#x2F;&#x2F; 注释文本</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多行-注释文本"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">多行: &#x2F;* 注释文本 *&#x2F;</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#样式规范"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">样式规范</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缩进与括号"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">缩进与括号</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#代码一致性"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">代码一致性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Import-包导入"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">Import (包导入)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Function-函数"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">Function (函数)</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x02-指导原则"><span class="post-toc-number">3.</span> <span class="post-toc-text">0x02 指导原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Variable-变量"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">Variable (变量)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Struct-结构体"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">Struct (结构体)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Function-函数-1"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">Function (函数)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Interface-接口"><span class="post-toc-number">3.0.4.</span> <span class="post-toc-text">Interface (接口)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Slices-或-Maps-切片和字典"><span class="post-toc-number">3.0.5.</span> <span class="post-toc-text">Slices 或 Maps (切片和字典)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Defer-资源释放"><span class="post-toc-number">3.0.6.</span> <span class="post-toc-text">Defer (资源释放)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Sync-同步包"><span class="post-toc-number">3.0.7.</span> <span class="post-toc-text">Sync (同步包)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ErrorHandling-错误处理"><span class="post-toc-number">3.0.8.</span> <span class="post-toc-text">ErrorHandling (错误处理)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Channel-通道"><span class="post-toc-number">3.0.9.</span> <span class="post-toc-text">Channel  (通道)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#iota-枚举"><span class="post-toc-number">3.0.10.</span> <span class="post-toc-text">iota  (枚举)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Unit-单元测试"><span class="post-toc-number">3.0.11.</span> <span class="post-toc-text">Unit (单元测试)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Performance-性能提升"><span class="post-toc-number">3.0.12.</span> <span class="post-toc-text">Performance (性能提升)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Time-时间处理"><span class="post-toc-number">3.0.13.</span> <span class="post-toc-text">Time (时间处理)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#String-字符串处理"><span class="post-toc-number">3.0.14.</span> <span class="post-toc-text">String (字符串处理)</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#0x03-规范辅助工具"><span class="post-toc-number">4.</span> <span class="post-toc-text">0x03 规范辅助工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Linting-相关工具"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Linting 相关工具</span></a></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    


    <!-- 支付宝微信文章赞赏 -->
    
      <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        如果此篇文章对您有帮助，就请作者喝杯 Coffee ☕️☕️!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardwechat" src="/img/reward-wechat.jpg" height="250" height="250" alt="微信打赏二维码">
            <img id="rewardalipay" src="/img/reward-alipay.png" height="250" height="250" alt="支付宝打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <!-- <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.png"> -->
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

      

    <!-- 微信公众号关注/文章版权复制 -->
    
      <div id="btw-mask" style="position: fixed; top: 0px; right: 0px; bottom: 0px; left: 0px; opacity: 0.7; z-index: 999; background: rgb(0, 0, 0); display:none"></div>
<div id="btw-modal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 360px; text-align: center; font-size: 13px; background: rgb(255, 255, 255); border-radius: 10px; z-index: 9999; font-family: PingFangSC-Regular, sans-serif;display:none">
<span id="btw-modal-close-btn" style="position: absolute; top: 5px; right: 15px; line-height: 1.8; font-size: 15px; cursor: pointer; opacity: 0.2; z-index: 9999; color: rgb(0, 0, 0); background: none; border: none; outline: none;">X</span>
<p id="btw-modal-header" style="margin-top: 40px; line-height: 1.8; font-size: 13px; ">
<b style="color:#6190e8;">你好朋友,可以关个注吗? ❤ <br> 这将是我持续更新文章的动力源泉，谢谢支持！(๑′ᴗ‵๑) </b> <br> 如不想关注请点击右上角的【X】<br>
<br>Method 1.Please visit <strong><a href="https://twitter.com/WeiyiGeek" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【My Twitter】</a></strong>. There is an article verification code in the homepage.
<br>方式2.请访问本博主的B站<strong><a href="https://space.bilibili.com/385802642" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【WeiyiGeek】</a></strong>首页关注UP主,<br>将自动随机获取解锁验证码。
<br>方式3.扫一扫下方二维码，关注本站<strong>官方公众号</strong><br>
回复：<strong style="color: rgb(240, 65, 52);">验证码</strong>
将获取<strong style="color: rgb(240, 65, 52);">解锁(有效期7天)</strong>本站所有技术文章哟!</p>
<img src="/img/wechat-search.png" style="width: 300px; margin-top: 10px;">
<div id="btw-modal-input-code" style="margin-top: 20px; background: rgb(255, 255, 255);">
  <input id="btw-modal-input" type="number" minlength="4" maxlength="4" placeholder="请输入验证码|Verification Code"
    style="width: 165px; height: 32px; line-height: 32px; padding: 0px 10px; margin: 0px 10px; font-size: 13px; text-rendering: auto; text-transform: none; cursor: text; outline: none; box-sizing: border-box; border: 1px solid rgb(221, 221, 221); -webkit-appearance: textfield; background-color: white; -webkit-rtl-ordering: logical;"/>
  <button id="btw-submit-btn" onclick="yzm_vertify()"
    style="padding: 0px 20px; height: 32px; font-size: 14px; outline: none; border: none; color: rgb(255, 255, 255); background: rgb(222, 104, 109); cursor: pointer;">提
    交</button> </div>
<p id="btw-footer" style="margin: 40px 0px 20px; color: rgb(153, 153, 153);">@WeiyiGeek - 为了能到远方，脚下的每一步都不能少</p>
</div>
        
</article>
</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://weiyigeek.top" target="_blank">https://weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.weiyigeek.top" target="_blank">https://blog.weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://weiyigeek.top/img/wechat-search.png" target="_blank">公众账号</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://space.bilibili.com/385802642/article" target="_blank">哔哩哔哩专栏</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/weiyigeek" target="_blank">个人Github</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://gitee.com/WeiyiGeek" target="_blank">个人Gitee</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.zhihu.com/people/weiyiSec" target="_blank">个人知乎</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.cnblogs.com/WeiyiGeek" target="_blank">博客园</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://my.oschina.net/weiyigeek" target="_blank">OSCHINA</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAqcPSoMqfctaEqJpGSF775eeCjWkrop4AOyLITdMx-L78F5iXzfQcSRM5sY4dq3wR" target="_blank">今日头条</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.csdn.net/u013072756?type=lately" target="_blank">CSDN</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.jianshu.com/u/5199a1104739" target="_blank">简书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cloud.tencent.com/developer/user/1389665/articles" target="_blank">腾讯云+云社区</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cuttlefish.baidu.com/shop/75c5dbd8d15abe23482f4d40" target="_blank">百度文库</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://author.baidu.com/home?from=blog&app_id=1726736601523415" target="_blank">IT极客知识分享</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.51cto.com/weiyigeek" target="_blank">51CTO博客</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://juejin.cn/user/122767337595934" target="_blank">掘金</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://weibo.com/a/hot/7622022703618049_1.html" target="_blank">微博文章</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.xiaohongshu.com/user/profile/627c98bb000000001000e7ba" target="_blank">小红书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://segmentfault.com/u/weiyigeek" target="_blank">Segmentfault</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.douyin.com/user/MS4wLjABAAAAMSBdMja6XLsdmzafb0RNbFeBemIOk38K1PaOClZeI1Q" target="_blank">抖音主页</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.kuaishou.com/profile/3xfbrsrhd2i69x9" target="_blank">快手主页</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
      <p>
        <span>WeiyiGeek &copy; 2018 - 2022 <a href="https://weiyigeek.top" target="_blank" rel="noopener">weiyigeek.top</a> All rights reserved.唯一极客IT知识分享 版权所有 </span>
        
        <span>
          Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/weiyigeek" target="_blank">mellow</a>
        </span>
        
        <br/>访问统计
        <span><a href="/sitemap.xml" target="_blank" rel="Sitemaps-站点地图">Sitemaps</a> </span>
        <span><a href="/baidusitemap.xml" target="_blank" rel="baidusitemaps-百度站点地图">站点地图</a> </span>
        <!-- 
  -->
        <br/>ICP备案号<span><a href="https://beian.miit.gov.cn" target="_blank">渝ICP备2022003447号</a></span>
        <br/>
        <div id="cc-myssl-id">
          <a href="https://myssl.com/blog.weiyigeek.top?from=mysslid" target="_blank" rel="noopener"><img src="https://static.myssl.com/res/images/myssl-id1.png" alt="MySSL安全认证" style="max-height:50px;display:block;margin:0 auto"></a>
        </div>
      </p>
    </div>
</footer>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2021/10-20-561.html&title=《Go语言开发规范实践指南》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2021/10-20-561.html&title=《Go语言开发规范实践指南》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2021/10-20-561.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Go语言开发规范实践指南》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2021/10-20-561.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2021/10-20-561.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACI0lEQVR42u3aMW7DMAwF0Nz/0u6aIXY+STeApaepMOxITwMrkXy94nG8jfcn+ftn71S/Gg0MDIzHMo7Lcf1O8svJEs82KFkbBgbGPoz8p88myL+ah3UMDAyMahBMfqe3RAwMDIw5oxoukwCNgYGBMbnEVvHVrfnRXRwDA+OBjDzr/vu//6W+gYGB8SjGURxJ0r8XLo/BwMDAWJuRB7hkodXU/yTgYmBg7MPohbZeqI12tFX4xMDAWJsxaXqoYvIyZ6+EgIGBsTajelnNU3K9y3C+3xgYGDsweim2anjNn/TWgIGBsTYjD5pR5K7m+eKAXm6wwMDAWIiRp9Wq191q6j8BnH6FgYGxDeN6gkkgzrej2o6GgYGxD6N3ikzKk/ceOqOGMAwMjOUYk8+qZYBJKG/ewjEwMJZg9NJbvaJjtXmiELIxMDCWZlRTXdUS4yRV96oODAyMRRm9BP0kmPZ4X1aIgYGxNCO5svaWnhc487majRcYGBhLMO5qPJ2k7aoX2g/PMTAwNmBUE2p5GXKSkivAMDAwNmDkh7ZqQ0ZvC6rJQQwMjFUZR3FMCgkT8JetxMDAWJpRDXPzloikFJEsfVTsxMDAeCBjcjTML6W9q2/yJgYGxj6M5LhWnfL6ee8/wOmMGBgYGHGT1qR1bPI+BgYGRm+a/HCZlzBvDrgYGBiPYiSX2Hzp1cNf7yKNgYGxD2PSNpE3UkwKBrcVMjEwMJ7H+AOSZbJQ+2xEBQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="/js/jquery/2.1.0-jquery.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/jquery/3.5.2-jquery.fancybox.min.js?v=1.6.6"></script>
<!--  //cdn.bootcss.com/node-waves/0.7.4/waves.min.js -->
<script type="text/javascript" src="/js/node-waves/0.7.4-waves.min.js?v=1.6.6"></script> 

<script type="text/javascript" src="/js/method.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/blog.js?v=1.6.6"></script>

<!-- third-party -->
<script type="text/javascript" src="/js/plugins/local_search.js?v=1.6.6"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) { search_path = "search.xml";}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script> 

<script> (adsbygoogle = window.adsbygoogle || []).push({});</script>    


<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> --> 


  


<script>
  var _hmt = _hmt || [];
  (function() {
    // 百度统计
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?53923c4b5560739bc0ed61e183be6acf";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>
 


<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.staticfile.org/mathjax/2.7.9/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
<script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = 'WeiyiGeek Blog-关注于网络安全_物联网安全开发_网络安全运维-学习心得分享';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)咦!又好了!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>
 

     <script type="text/javascript" src="/js/custom/copytips.js?v=1.6.6"></script> 
</body>
</html>