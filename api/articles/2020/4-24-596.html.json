{"title":"7.Go编程快速入门学习","slug":"编程世界/Go/7.Go编程快速入门学习","date":"2020-04-24T03:16:58.000Z","updated":"2022-03-11T03:22:01.612Z","url":"2020/4-24-596.html","path":"api/articles/2020/4-24-596.html.json","covers":null,"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h2 id=\"0X00-Go语言基础之反射\"><a href=\"#0X00-Go语言基础之反射\" class=\"headerlink\" title=\"0X00 Go语言基础之反射\"></a>0X00 Go语言基础之反射</h2><p>我们在进行讲解Go反射概念和使用前，先来复习了解变量的内在机制。</p>\n<p>Go语言中的变量(Variables)是分为两部分的:</p>\n<ul>\n<li>类型信息：预先定义好的元信息。</li>\n<li>值信息：程序运行过程中可动态变化的。</li>\n</ul>\n<p><br/></p>\n<p><strong>反射应用:</strong></p>\n<ul>\n<li>Json 数据解析</li>\n<li>ORM 框架工具</li>\n</ul>\n<p><br/></p>\n<h3 id=\"1-基础介绍\"><a href=\"#1-基础介绍\" class=\"headerlink\" title=\"1.基础介绍\"></a>1.基础介绍</h3><p>描述: 反射是指在程序<code>运行期</code>对程序本身进行<code>访问和修改</code>的能力。即支持反射的语言可以在程序编译期将变量的反射信息，如<code>字段名称、类型信息、结构体信息</code>等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>\n<p><br/></p>\n<p><strong>程序运行期说明:</strong></p>\n<ul>\n<li>程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。</li>\n<li>在运行程序时，程序无法获取自身的信息。</li>\n</ul>\n<p><br/></p>\n<p>前面我们介绍空接口可以存储任意类型的变量，那我们如何知道这个空接口保存的数据是什么呢？</p>\n<blockquote>\n<p>答: Go程序在运行期使用r eflect包访问程序的反射信息，我们可以利用反射在运行时动态的获取一个变量的类型信息和值信息。<br>接口类型的变量底层分为两个部分: <code>动态类型</code> 和 <code>动态值</code>。</p>\n</blockquote>\n<p><br/></p>\n<p><strong>reflect包说明</strong></p>\n<blockquote>\n<p>答: 在Go语言的反射机制中，任何接口值都由是一个<code>具体类型</code>和<code>具体类型的值</code>两部分组成的。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由<code>reflect.Type</code>和<code>reflect.Value</code>两部分组成，并且reflect包提供了<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>两个函数来获取任意对象的Value和Type。</p>\n</blockquote>\n<p><br></p>\n<p><strong>示例1.Go如何做到解析JSON字符串到对象属性中的。</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Id   <span class=\"keyword\">int</span>    <span class=\"string\">`json:\"id\"`</span></span><br><span class=\"line\">    Name <span class=\"keyword\">string</span> <span class=\"string\">`json:\"name\"`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p person</span><br><span class=\"line\">  strJson := <span class=\"string\">`&#123;\"id\": 1024,\"name\": \"WeiyiGeek\"&#125;`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1.反序列化将JSON字符串绑定到对象对应属性之中.(他为何可以根据JSON字符串对应的key解析到对象属性之中)</span></span><br><span class=\"line\">  json.Unmarshal([]<span class=\"keyword\">byte</span>(strJson), &amp;p)</span><br><span class=\"line\">  <span class=\"comment\">// 2.输出对象属性值进行验证</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"Id = \"</span>, p.Id, <span class=\"string\">\",Name = \"</span>, p.Name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 调用执行结果</span></span><br><span class=\"line\">Id =  <span class=\"number\">1024</span> ,Name =  WeiyiGeek</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"2-类型对象-reflect-Type\"><a href=\"#2-类型对象-reflect-Type\" class=\"headerlink\" title=\"2.类型对象-reflect.Type\"></a>2.类型对象-reflect.Type</h3><p>描述: 在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>\n<p>在反射中关于类型(<code>reflect.TypeOf</code>)还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>，即我们常说的<code>reflect.TypeOf</code>返回的t对象如<code>t.Name()、 t.Kind()</code>方法获取的信息。</p>\n<ul>\n<li>在Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。</li>\n<li>在Go语言中我们可以使用type关键字构造很多自定义类型，而种类（Kind）就是指底层的类型，但在反射中，当需要<code>区分指针、结构体、类型别名</code>等大品种的类型时，就会用到种类（Kind）。</li>\n</ul>\n<p><br></p>\n<p>在reflect包中定义的Kind类型如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Kind <span class=\"keyword\">uint</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">  Invalid Kind = <span class=\"literal\">iota</span>  <span class=\"comment\">// 非法类型</span></span><br><span class=\"line\">  Bool                 <span class=\"comment\">// 布尔型</span></span><br><span class=\"line\">  Int                  <span class=\"comment\">// 有符号整型</span></span><br><span class=\"line\">  Int8                 <span class=\"comment\">// 有符号8位整型</span></span><br><span class=\"line\">  Int16                <span class=\"comment\">// 有符号16位整型</span></span><br><span class=\"line\">  Int32                <span class=\"comment\">// 有符号32位整型</span></span><br><span class=\"line\">  Int64                <span class=\"comment\">// 有符号64位整型</span></span><br><span class=\"line\">  Uint                 <span class=\"comment\">// 无符号整型</span></span><br><span class=\"line\">  Uint8                <span class=\"comment\">// 无符号8位整型</span></span><br><span class=\"line\">  Uint16               <span class=\"comment\">// 无符号16位整型</span></span><br><span class=\"line\">  Uint32               <span class=\"comment\">// 无符号32位整型</span></span><br><span class=\"line\">  Uint64               <span class=\"comment\">// 无符号64位整型</span></span><br><span class=\"line\">  Uintptr              <span class=\"comment\">// 指针</span></span><br><span class=\"line\">  Float32              <span class=\"comment\">// 单精度浮点数</span></span><br><span class=\"line\">  Float64              <span class=\"comment\">// 双精度浮点数</span></span><br><span class=\"line\">  Complex64            <span class=\"comment\">// 64位复数类型</span></span><br><span class=\"line\">  Complex128           <span class=\"comment\">// 128位复数类型</span></span><br><span class=\"line\">  Array                <span class=\"comment\">// 数组</span></span><br><span class=\"line\">  Chan                 <span class=\"comment\">// 通道</span></span><br><span class=\"line\">  Func                 <span class=\"comment\">// 函数</span></span><br><span class=\"line\">  Interface            <span class=\"comment\">// 接口</span></span><br><span class=\"line\">  Map                  <span class=\"comment\">// 映射</span></span><br><span class=\"line\">  Ptr                  <span class=\"comment\">// 指针</span></span><br><span class=\"line\">  Slice                <span class=\"comment\">// 切片</span></span><br><span class=\"line\">  String               <span class=\"comment\">// 字符串</span></span><br><span class=\"line\">  Struct               <span class=\"comment\">// 结构体</span></span><br><span class=\"line\">  UnsafePointer        <span class=\"comment\">// 底层指针</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> myInt <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reflectType</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  v := reflect.TypeOf(x)</span><br><span class=\"line\">  k := v.Kind()   <span class=\"comment\">// 获取的是反射对象的类型 (注意与下面 reflect.ValueOf(x).Kind() 的区别)</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Reflect Type = %v, Name Type : %v,Kind : %s (%d)\\n\"</span>, v, v.Name(), k, k)  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a <span class=\"keyword\">int64</span> = <span class=\"number\">100</span>    <span class=\"comment\">// 整形</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b <span class=\"keyword\">float32</span> = <span class=\"number\">3.14</span> <span class=\"comment\">// 浮点型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c <span class=\"keyword\">rune</span>           <span class=\"comment\">// 类型别名</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> d myInt = <span class=\"number\">1024</span>   <span class=\"comment\">// 自定义类型</span></span><br><span class=\"line\">  <span class=\"keyword\">type</span> person <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">// 结构体</span></span><br><span class=\"line\">    name <span class=\"keyword\">string</span></span><br><span class=\"line\">    age  <span class=\"keyword\">int</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">type</span> book <span class=\"keyword\">struct</span>&#123; title <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> e = person&#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">    age:  <span class=\"number\">18</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = book&#123;title: <span class=\"string\">\"《跟WeiyiGeek学Go语言》\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用查看反射类型</span></span><br><span class=\"line\">  reflectType(a)</span><br><span class=\"line\">  reflectType(b)</span><br><span class=\"line\">  reflectType(c)</span><br><span class=\"line\">  reflectType(d)</span><br><span class=\"line\">  reflectType(e)</span><br><span class=\"line\">  reflectType(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  demo1()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reflect Type = <span class=\"keyword\">int64</span>, Name Type : <span class=\"keyword\">int64</span>,Kind : <span class=\"keyword\">int64</span> (<span class=\"number\">6</span>)</span><br><span class=\"line\">Reflect Type = <span class=\"keyword\">float32</span>, Name Type : <span class=\"keyword\">float32</span>,Kind : <span class=\"keyword\">float32</span> (<span class=\"number\">13</span>)</span><br><span class=\"line\">Reflect Type = <span class=\"keyword\">int32</span>, Name Type : <span class=\"keyword\">int32</span>,Kind : <span class=\"keyword\">int32</span> (<span class=\"number\">5</span>)</span><br><span class=\"line\">Reflect Type = main.myInt, Name Type : myInt,Kind : <span class=\"keyword\">int</span> (<span class=\"number\">2</span>)</span><br><span class=\"line\">Reflect Type = main.person, Name Type : person,Kind : <span class=\"keyword\">struct</span> (<span class=\"number\">25</span>)</span><br><span class=\"line\">Reflect Type = main.book, Name Type : book,Kind : <span class=\"keyword\">struct</span> (<span class=\"number\">25</span>)</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"3-类型对象值-reflect-Value\"><a href=\"#3-类型对象值-reflect-Value\" class=\"headerlink\" title=\"3.类型对象值-reflect.Value\"></a>3.类型对象值-reflect.Value</h3><p>描述: <code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息,reflect.Value与原始值之间可以互相转换。</p>\n<ul>\n<li><p>通过反射获取值 , reflect.Value 类型提供的获取原始值的方法如下:</p>\n<ul>\n<li><code>Interface() interface {}</code>    : 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</li>\n<li><code>Int() int64</code>    :     将值以 int 类型返回，所有有符号整型均可以此方式返回</li>\n<li><code>Uint() uint64</code>    :     将值以 uint 类型返回，所有无符号整型均可以此方式返回</li>\n<li><code>Float() float64</code>    :     将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</li>\n<li><code>Bool() bool</code>    :     将值以 bool 类型返回</li>\n<li><code>Bytes() []bytes</code>    :     将值以字节数组 []bytes 类型返回</li>\n<li><code>String() string</code>    :     将值以字符串类型返回</li>\n</ul>\n</li>\n<li><p>通过反射设置变量的值。</p>\n<ul>\n<li>在函数中通过反射修改变量的值，如果传递非变量地址值则会报<code>panic: reflect: reflect.Value.Type using unaddressable value</code>错误。</li>\n<li>在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值,而反射中使用专有的Elem()方法来获取指针对应的值。</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<p>例如，下述我们分别采用反射的ValueOf方法获取的相关信息进行获取值与设置值.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过反射获取变量的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reflectTypeValue</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  t := reflect.TypeOf(x)</span><br><span class=\"line\">  v := reflect.ValueOf(x)</span><br><span class=\"line\">  k := v.Kind()   <span class=\"comment\">// 获取的是值的种类</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> k &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> reflect.Int64:</span><br><span class=\"line\">    <span class=\"comment\">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"type is int64, value is %d\\n\"</span>, <span class=\"keyword\">int64</span>(v.Int()))</span><br><span class=\"line\">  <span class=\"keyword\">case</span> reflect.Float32:</span><br><span class=\"line\">    <span class=\"comment\">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"type is float32, value is %f\\n\"</span>, <span class=\"keyword\">float32</span>(v.Float()))</span><br><span class=\"line\">  <span class=\"keyword\">case</span> reflect.Float64:</span><br><span class=\"line\">    <span class=\"comment\">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"type is float64, value is %f\\n\"</span>, <span class=\"keyword\">float64</span>(v.Float()))</span><br><span class=\"line\">  <span class=\"keyword\">case</span> reflect.Bool:</span><br><span class=\"line\">    <span class=\"comment\">// v.Bool()从反射中获取布尔型的原始值，然后通过Bool()强制类型转换</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"type is bool, value is %v\\n\"</span>, <span class=\"keyword\">bool</span>(v.Bool()))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Reflect Type = %v, Reflect Value = %v, Name : %v, Kind : %s (%d)\\n\\n\"</span>, t, v, t.Name(), v.Kind(), v.Kind())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过反射设置变量的值(此种方式会报错)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reflectSetValue1</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  t := reflect.TypeOf(x)</span><br><span class=\"line\">  v := reflect.ValueOf(x)</span><br><span class=\"line\">  <span class=\"comment\">// 使用默认方式修改的是副本，reflect包会引发panic</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class=\"line\">    v.SetInt(<span class=\"number\">200</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type %v, Value %v\\n\"</span>, t, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过反射设置变量的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reflectSetValue2</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  t := reflect.TypeOf(x)</span><br><span class=\"line\">  v := reflect.ValueOf(x)</span><br><span class=\"line\">  <span class=\"comment\">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class=\"line\">    v.Elem().SetInt(<span class=\"number\">200</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type %v, Value %v\\n\"</span>, t, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 将常规类型初始化并设置值，然后通过反射获取值</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a <span class=\"keyword\">int</span> = <span class=\"number\">1024</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b <span class=\"keyword\">float32</span> = <span class=\"number\">3.14</span></span><br><span class=\"line\">  reflectTypeValue(a)</span><br><span class=\"line\">  reflectTypeValue(b)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class=\"line\">  c := reflect.ValueOf(<span class=\"number\">10</span>)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type c : %T, Value c : %v\\n\"</span>, c, c)</span><br><span class=\"line\">  reflectTypeValue(c)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 通过反射设置变量的值（两种方法）</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> d <span class=\"keyword\">int64</span> = <span class=\"number\">65535</span></span><br><span class=\"line\">  <span class=\"comment\">// reflectSetValue1(d) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class=\"line\">  reflectSetValue2(&amp;d) <span class=\"comment\">// 修改是的指针指向的值</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"通过反射设置变量(d)的值: \"</span>, d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  demo2()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reflect Type = <span class=\"keyword\">int</span>, Reflect Value = <span class=\"number\">1024</span>, Name : <span class=\"keyword\">int</span>, Kind : <span class=\"keyword\">int</span> (<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> is <span class=\"keyword\">float32</span>, value is <span class=\"number\">3.140000</span></span><br><span class=\"line\">Reflect Type = <span class=\"keyword\">float32</span>, Reflect Value = <span class=\"number\">3.14</span>, Name : <span class=\"keyword\">float32</span>, Kind : <span class=\"keyword\">float32</span> (<span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> is <span class=\"keyword\">bool</span>, value is <span class=\"literal\">true</span></span><br><span class=\"line\">Reflect Type = <span class=\"keyword\">bool</span>, Reflect Value = <span class=\"literal\">true</span>, Name : <span class=\"keyword\">bool</span>, Kind : <span class=\"keyword\">bool</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Type c : reflect.Value, Value c : <span class=\"number\">10</span></span><br><span class=\"line\">Reflect Type = reflect.Value, Reflect Value = &lt;<span class=\"keyword\">int</span> Value&gt;, Name : Value, Kind : <span class=\"keyword\">struct</span> (<span class=\"number\">25</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Type *<span class=\"keyword\">int64</span>, Value <span class=\"number\">0xc0000ba040</span></span><br><span class=\"line\">通过反射设置变量(d)的值:  <span class=\"number\">200</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"4-反射值判断\"><a href=\"#4-反射值判断\" class=\"headerlink\" title=\"4.反射值判断\"></a>4.反射值判断</h3><p>Go中常用的反射值是否为空以及是否有效常常使用以下两种方法<code>isNil()</code>和<code>isValid()</code>：</p>\n<ul>\n<li><code>func (v Value) IsNil() bool</code>: 常被用于判断指针是否为空, 返回v持有的值是否为nil,且分类必须是<code>通道、函数、接口、映射、指针、切片</code>之一；否则IsNil函数会导致panic。</li>\n<li><code>func (v Value) IsValid() bool</code>: 常被用于判定返回值是否有效, 返回v是否持有一个值。如果v是Value零值会返回假，此时v除了<code>IsValid、String、Kind</code>之外的方法都会导致panic。。</li>\n</ul>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"reflect\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> b <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *b)</span> <span class=\"title\">Demo</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  fmt.Print(<span class=\"string\">\"我是通过Call调用的Demo方法，\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1024</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// (1) *int类型空指针 : 必须是通道、函数、接口、映射、指针、切片之一</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> a *<span class=\"keyword\">int</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"var a *int IsNil:\"</span>, reflect.ValueOf(a).IsNil())</span><br><span class=\"line\">  <span class=\"comment\">// (2) nil值 : 除了IsValid、String、Kind之外的方法都会导致panic。</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"nil IsValid:\"</span>, reflect.ValueOf(<span class=\"literal\">nil</span>).IsValid())</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (3) 实例化一个匿名结构体</span></span><br><span class=\"line\">  b1 := <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\">  b2 := <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    abc <span class=\"keyword\">string</span></span><br><span class=\"line\">  &#125;&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (4) 实例化一个结构体</span></span><br><span class=\"line\">  b3 := <span class=\"built_in\">new</span>(b)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 尝试从结构体中查找\"abc\"字段</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"b1是否存在的结构体成员 abc ? :\"</span>, reflect.ValueOf(b1).FieldByName(<span class=\"string\">\"abc\"</span>).IsValid()) <span class=\"comment\">// 不存在</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"b2是否存在的结构体成员 abc ? :\"</span>, reflect.ValueOf(b2).FieldByName(<span class=\"string\">\"abc\"</span>).IsValid()) <span class=\"comment\">// 存在</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 尝试从结构体中查找\"demo\"方法</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"b1是否存在的结构体方法 Demo ? :\"</span>, reflect.ValueOf(b1).MethodByName(<span class=\"string\">\"Demo\"</span>).IsValid())            <span class=\"comment\">//不存在</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"b3是否存在的结构体方法 Demo ? :\"</span>, reflect.ValueOf(b3).MethodByName(<span class=\"string\">\"Demo\"</span>).IsValid())            <span class=\"comment\">//存在</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"b3结构体Demo方法返回值类型: \"</span>, reflect.ValueOf(b3).MethodByName(<span class=\"string\">\"Demo\"</span>).Call([]reflect.Value&#123;&#125;)) <span class=\"comment\">//输出执行其方法以及返回值的类型 （特别注意，先执行调用后返回类型，并输出）</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (4) map \t尝试从map中查找一个不存在的键</span></span><br><span class=\"line\">  c := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">  c[<span class=\"string\">\"WeiyiGeek\"</span>] = <span class=\"number\">1024</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"map中是否存在WeiyiGeek的键：\"</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class=\"string\">\"WeiyiGeek\"</span>)).IsValid())</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"map中是否存在Geek的键：\"</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class=\"string\">\"Geek\"</span>)).IsValid())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a *<span class=\"keyword\">int</span> IsNil: <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">nil</span> IsValid: <span class=\"literal\">false</span></span><br><span class=\"line\">b1是否存在的结构体成员 abc ? : <span class=\"literal\">false</span></span><br><span class=\"line\">b2是否存在的结构体成员 abc ? : <span class=\"literal\">true</span></span><br><span class=\"line\">b1是否存在的结构体方法 Demo ? : <span class=\"literal\">false</span></span><br><span class=\"line\">b3是否存在的结构体方法 Demo ? : <span class=\"literal\">true</span></span><br><span class=\"line\">我是通过Call调用的Demo方法，b3结构体Demo方法返回值类型:  [&lt;<span class=\"keyword\">int</span> Value&gt;]</span><br><span class=\"line\"><span class=\"keyword\">map</span>中是否存在WeiyiGeek的键： <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"keyword\">map</span>中是否存在Geek的键： <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"5-结构体反射实践\"><a href=\"#5-结构体反射实践\" class=\"headerlink\" title=\"5.结构体反射实践\"></a>5.结构体反射实践</h3><p>描述: 下面讲解与结构体相关的反射知识，当任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过<code>反射值对象（reflect.Type）</code>的<code>NumField()方法</code>和<code>Field()方法</code>获得结构体成员的详细信息。</p>\n<p><strong>结构体成员相关信息获取方法</strong></p>\n<p>如下表所示<code>reflect.Type</code>中与获取结构体成员相关的方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NumField() <code>int</code></td>\n<td>返回结构体成员字段数量。</td>\n</tr>\n<tr>\n<td>Field(i int) <code>StructField</code></td>\n<td>根据索引，返回索引对应的结构体字段的信息。</td>\n</tr>\n<tr>\n<td>FieldByName(name string) <code>(StructField, bool)</code></td>\n<td>根据给定字符串返回字符串对应的结构体字段的信息。</td>\n</tr>\n<tr>\n<td>FieldByIndex(index []int) <code>StructField</code></td>\n<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td>\n</tr>\n<tr>\n<td>FieldByNameFunc(match func(string) bool) <code>(StructField,bool)</code></td>\n<td>根据传入的匹配函数匹配需要的字段。</td>\n</tr>\n<tr>\n<td>NumMethod() <code>int</code></td>\n<td>返回该类型的方法集中方法的数目</td>\n</tr>\n<tr>\n<td>Method(int) <code>Method</code></td>\n<td>返回该类型方法集中的第i个方法</td>\n</tr>\n<tr>\n<td>MethodByName(string) <code>(Method, bool)</code></td>\n<td>根据方法名返回该类型方法集中的方法</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<p><strong>StructField 类型</strong><br>描述: StructField类型用来描述结构体中的一个字段的信息,<code>StructField</code> 的定义如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StructField <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Name    <span class=\"keyword\">string</span>      <span class=\"comment\">// 字段的名字。</span></span><br><span class=\"line\">  PkgPath <span class=\"keyword\">string</span>      <span class=\"comment\">// 非导出字段的包路径，对导出字段该字段为\"\"。参见 http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class=\"line\">  Type      Type      <span class=\"comment\">// 字段的类型</span></span><br><span class=\"line\">  Tag       StructTag <span class=\"comment\">// 字段的标签</span></span><br><span class=\"line\">  Offset    <span class=\"keyword\">uintptr</span>   <span class=\"comment\">// 字段在结构体中的字节偏移量</span></span><br><span class=\"line\">  Index     []<span class=\"keyword\">int</span>     <span class=\"comment\">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class=\"line\">  Anonymous <span class=\"keyword\">bool</span>      <span class=\"comment\">// 是否匿名字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>实践案例:</strong><br>示例说明, 当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息，以及通过索引获取方法信息和调用执行该索引指定的方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"reflect\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> student <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Name  <span class=\"keyword\">string</span> <span class=\"string\">`json:\"name\" person:\"weiyigeek\"`</span> <span class=\"comment\">// 可以有多个Tag</span></span><br><span class=\"line\">  Score <span class=\"keyword\">int</span>    <span class=\"string\">`json:\"score\" person:\"geek\"`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s student)</span> <span class=\"title\">Study</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  msg := <span class=\"string\">\"[Study] 好好学习，天天向上。\"</span></span><br><span class=\"line\">  fmt.Println(msg)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> msg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s student)</span> <span class=\"title\">Sleep</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  msg := <span class=\"string\">\"[Sleep] 好好睡觉，快快长大。\"</span></span><br><span class=\"line\">  fmt.Println(msg)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> msg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构体反射示例演示方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Reflectstruct</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// (2) 获取 stu1 对象反射类型信息,输出对象名称以及对象种类</span></span><br><span class=\"line\">  t := reflect.TypeOf(x)</span><br><span class=\"line\">  v := reflect.ValueOf(x)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"reflect.TypeOf -&gt;\"</span>, t.Name(), t.Kind()) <span class=\"comment\">// student struct</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"reflect.ValueOf -&gt;\"</span>, v, v.Kind())       <span class=\"comment\">// &#123;WeiyiGeek 90&#125; struct</span></span><br><span class=\"line\">  fmt.Println()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (3) 通过for循环遍历结构体的所有字段信息(方式1)</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class=\"line\">    field := t.Field(i)</span><br><span class=\"line\">    <span class=\"comment\">//fmt.Print(v.Field(i).Call([]reflect.Value&#123;&#125;))</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"name:%s index:%d type:%v json tag: %v  person tag:%v , Field Anonymous: %v\\n\"</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class=\"string\">\"json\"</span>), field.Tag.Get(<span class=\"string\">\"person\"</span>), field.Anonymous)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (4) 通过字段名获取指定结构体字段信息(方式2)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> scoreField, ok := t.FieldByName(<span class=\"string\">\"Score\"</span>); ok &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"\\nname:%s index:%d type:%v json tag:%v , Field Anonymous: %v\\n\"</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class=\"string\">\"json\"</span>), scoreField.Anonymous)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (5) 通过for循环遍历结构体的所有方法信息</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"reflect.TypeOf NumMethod-&gt;\"</span>, t.NumMethod())</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"reflect.ValueOf NumMethod-&gt;\"</span>, v.NumMethod())</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class=\"line\">    methodType := v.Method(i).Type()</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"method name:% s，method: %s\\n\"</span>, t.Method(i).Name, methodType)</span><br><span class=\"line\">    <span class=\"comment\">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = []reflect.Value&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 相当于依次调用结构体中的方法</span></span><br><span class=\"line\">    v.Method(i).Call(args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (6) 通过方法名获取指定的结构体方法并执行</span></span><br><span class=\"line\">  methodSleep := v.MethodByName(<span class=\"string\">\"Sleep\"</span>)</span><br><span class=\"line\">  methodSleepType := methodSleep.Type()</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Reflect Method ptr:%v，method Type: %v\\n\"</span>, methodSleep, methodSleepType)</span><br><span class=\"line\">  <span class=\"comment\">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = []reflect.Value&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 相当调用 结构体的 Sleep() 方法</span></span><br><span class=\"line\">  methodSleep.Call(args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// (1) 实例化 student 结构体</span></span><br><span class=\"line\">  stu := student&#123;</span><br><span class=\"line\">    Name:  <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">    Score: <span class=\"number\">90</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Reflectstruct(stu)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reflect.TypeOf -&gt; student <span class=\"keyword\">struct</span></span><br><span class=\"line\">reflect.ValueOf -&gt; &#123;WeiyiGeek <span class=\"number\">90</span>&#125; <span class=\"keyword\">struct</span></span><br><span class=\"line\"></span><br><span class=\"line\">name:Name index:[<span class=\"number\">0</span>] <span class=\"keyword\">type</span>:<span class=\"keyword\">string</span> json tag: name  person tag:weiyigeek , Field Anonymous: <span class=\"literal\">false</span></span><br><span class=\"line\">name:Score index:[<span class=\"number\">1</span>] <span class=\"keyword\">type</span>:<span class=\"keyword\">int</span> json tag: score  person tag:geek , Field Anonymous: <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">name:Score index:[<span class=\"number\">1</span>] <span class=\"keyword\">type</span>:<span class=\"keyword\">int</span> json tag:score , Field Anonymous: <span class=\"literal\">false</span></span><br><span class=\"line\">reflect.TypeOf NumMethod-&gt; <span class=\"number\">2</span></span><br><span class=\"line\">reflect.ValueOf NumMethod-&gt; <span class=\"number\">2</span></span><br><span class=\"line\">method name:Sleep，method: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\">[<span class=\"title\">Sleep</span>] 好好睡觉，快快长大。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">method</span> <span class=\"title\">name</span>:<span class=\"title\">Study</span>，<span class=\"title\">method</span>: <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\">[<span class=\"title\">Study</span>] 好好学习，天天向上。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Reflect</span> <span class=\"title\">Method</span> <span class=\"title\">ptr</span>:0<span class=\"title\">x4ae080</span>，<span class=\"title\">method</span> <span class=\"title\">Type</span>: <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"title\">string</span></span></span><br><span class=\"line\"><span class=\"function\">[<span class=\"title\">Sleep</span>] 好好睡觉，快快长大。</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>反射使用总结:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//# (1) 反射得到传递对象的类型 (类型相关使用)</span></span><br><span class=\"line\">t := reflect.TypeOf(d)</span><br><span class=\"line\">fmt.Println(<span class=\"string\">\"参数校验:\"</span>, t, t.Kind(), t.Elem().Kind())  <span class=\"comment\">// # 参数校验 *main.Config ptr struct</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; t.Elem().NumField(); i++ &#123; <span class=\"comment\">// #  t.Elem() 拿取指针中的元素属性相关信息</span></span><br><span class=\"line\">  field := t.Elem().Field(i)   <span class=\"comment\">// 遍历单个元素字段信息指定index。</span></span><br><span class=\"line\">  tag := field.Tag.Get(<span class=\"string\">\"ini\"</span>)  <span class=\"comment\">// 获取单个元素字段中 ini tag 属性值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//# (2) 反射得到传递对象的值  (值相关使用)</span></span><br><span class=\"line\">v := reflect.ValueOf(d)</span><br><span class=\"line\">sValue := v.Elem().FieldByName(structName) <span class=\"comment\">// 此处反射得到嵌套结构体指定字段名称值信息</span></span><br><span class=\"line\">sType := sValue.Type()                     <span class=\"comment\">// 此处反射得到嵌套结构体类型信息</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; sValue.NumField(); i++ &#123;   <span class=\"comment\">// 字段名称值信息也可获取字段数量，同上面一致</span></span><br><span class=\"line\">    field := sType.Field(i) <span class=\"comment\">// 反射类型信息中存储了嵌套结构体中的Tag信息</span></span><br><span class=\"line\">    fieldType = field       <span class=\"comment\">// 反射类型信息中存储了嵌套结构体中的filed信息以供后续值类型判断使用&#125;</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"0x01-Go语言基础之并发和通道\"><a href=\"#0x01-Go语言基础之并发和通道\" class=\"headerlink\" title=\"0x01 Go语言基础之并发和通道\"></a>0x01 Go语言基础之并发和通道</h2><p>描述: 在Go语言中最大的特点就是其在语言层面天生支持并发，这也是众多开发者喜欢它的原因。其次是随着服务器硬件迭代升级，配置也越来越高，为充分利用服务器资源，并发编程也变的越来越重要。</p>\n<p>在开始之前，需要了解一下<code>并发(concurrency)</code>和<code>并行(parallesim)</code>以及<code>进程(Process)和线程(Thread)</code>的区别（重点）。</p>\n<h3 id=\"1-基础概念\"><a href=\"#1-基础概念\" class=\"headerlink\" title=\"1.基础概念\"></a>1.基础概念</h3><p><strong>Go语言的并发</strong><br>描述； Go语言并发是通过<code>goroutine</code> (<code>go [ruːˈtiːn]</code>)【轻量级线程】实现的，其类似于线程，属于用户态的线程（<code>比内核态线程更轻量级</code>）, 我们可以根据需要创建成千上万个 goroutine 并发工作。它是由Go语言的<code>运行时（runtime）</code>调度完成（自己编写的线程调度），而<code>线程</code>是由<code>操作系统调度</code>完成。</p>\n<p>除此之外Go语言还提供channel在多个goroutine间进行通信。所以<code>goroutine</code>和<code>channel</code> 是 Go 语言秉承的<code>CSP（Communicating Sequential Process-通信顺序过程）并发模式</code>的重要实现基础。</p>\n<p><strong>并发 (concurrency):</strong> 逻辑上具有处理多个同时性任务的能力。（<code>某段时间里你在用微信和两个女朋友聊天</code>）</p>\n<p><strong>并行 (parallesim):</strong> 物理上同一时刻执行多个并发任务。（<code>这一刻你和你朋友都在用微信和女朋友聊天</code>）</p>\n<p><strong>进程 (Process):</strong> 是操作系统中某数据集合操作的一个程序运行的资源，进程是资源分配的最小单位。(<code>车辆生产的某一整条流水线作业，例如从零件装配到整车完备</code>)</p>\n<p><strong>线程 (Thread):</strong> 是运行的进程任务中的某一条执行流程，在进程中的更小的运行单位，线程是CPU调度的最小单位。(<code>流水线中某一个流水作业岗位，比如外观包装岗位工</code>)</p>\n<p><strong>用户态:</strong> 由程序员自己定义的线程调度。</p>\n<p><strong>内核态:</strong> 由操作系统预定义的线程调度。</p>\n<p><br></p>\n<h3 id=\"2-Goroutine-入门\"><a href=\"#2-Goroutine-入门\" class=\"headerlink\" title=\"2.Goroutine 入门\"></a>2.Goroutine 入门</h3><p>描述: 在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。</p>\n<p>Q: 那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p>\n<blockquote>\n<p>答: 那当然是有的，即Go语言中的 goroutine 就是这样一种机制，其概念<code>类似于</code>线程,但 goroutine是由Go的运行时（runtime）调度和管理的, Go程序会<code>智能地</code>将 goroutine 中的任务<code>合理地分配</code>给每个CPU。<br>这就是为何Go语言之被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>\n</blockquote>\n<p><strong>如何使用 goroutine（并发）?</strong><br>描述: Go语言中使用goroutine非常简单,将需要并发执行的任务包装成为一个函数,并在调用函数的时候前面加上go关键字,此时便可以开启一个Goroutine去执行该函数的任务。<br>非常注意，一个goroutine必定对应一个函数，但可以创建多个goroutine去执行相同的函数。</p>\n<p><br></p>\n<h4 id=\"示例1-启动单个Goroutine\"><a href=\"#示例1-启动单个Goroutine\" class=\"headerlink\" title=\"示例1.启动单个Goroutine\"></a>示例1.启动单个Goroutine</h4><p>描述：启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个go关键字，即可。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"Hello Goroutine!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">go</span>\thello()               <span class=\"comment\">// 在调用hello函数前面加上关键字go，即启动一个goroutine去执行hello这个函数。</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"main goroutine done!\"</span>)</span><br><span class=\"line\"> \ttime.Sleep(time.Second) <span class=\"comment\">// 如果不加此延时，则执行结果只打印了main goroutine done!，并不会打印Hello Goroutine!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br/></p>\n<p><em>Q: 为什么在未加延时函数的情况下执行结果只打印了main goroutine done!？</em></p>\n<blockquote>\n<p>答: 因为在程序启动时，Go程序就会为 <code>main()</code> 函数创建一个<code>默认的goroutine</code>。<br>当 main() 函数返回的时候该goroutine就结束了，所有在 main() 函数中启动的 goroutine 会一同结束。<br>例如 main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。<br>所以为了让main函数等一等hello函数，最简单粗暴的方式就是使用<code>time.Sleep()</code>，不过后续还要更好的解决办法那就是<code>采用 sync.WaitGroup</code>来等待goroutine任务执行完毕。</p>\n</blockquote>\n<p><br></p>\n<h4 id=\"示例2-启动多个Goroutine\"><a href=\"#示例2-启动多个Goroutine\" class=\"headerlink\" title=\"示例2.启动多个Goroutine\"></a>示例2.启动多个Goroutine</h4><p>描述: 在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。</p>\n<p>此处我将解决示例1中的延时阻塞问题，如何监测 Goroutine 什么时候结束?</p>\n<blockquote>\n<p>1.Goroutine 在对应调用函数运行完成时结束，其次是main函数执行完成时，由main函数创建的那些goroutine都结束。<br>2.此处我们这里使用<code>sync.WaitGroup</code>来实现goroutine的同步执行结束检测。<br>wg.Add(1) : <code>goroutine 任务执行计数器+1</code><br>wg.Done() : <code>goroutine 任务执行完毕计数器-1</code><br>wg.Wait() : <code>当前 goroutine 任务执行全部完毕后且计数器为0,等待结束退出Main函数</code></p>\n</blockquote>\n<p>代码示例:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done() <span class=\"comment\">// goroutine结束就登记-1</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"Hello Goroutine!\"</span>, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>) <span class=\"comment\">// 启动一个goroutine就登记+1</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> hello(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait() <span class=\"comment\">// 等待所有登记的goroutine都结束</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 执行上述代码您会发现每次打印的数字的顺序都不一致，这是由于10个goroutine是并发执行的，而goroutine的调度是随机的。</p>\n<p><br></p>\n<p><strong>实践演示(1).常规方式以及匿名函数方式并发调度</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// 方式1，常规函数方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">(count <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"欢迎你第 %d 次\\n\"</span>, count)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> hello(i) <span class=\"comment\">// 开启一个单独的goroutine去执行hello函数(任务)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2.匿名函数方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(count <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">      fmt.Printf(<span class=\"string\">\"第 %d 次欢迎你\\n\"</span>, count)</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 程序启动之后会创建一个主Goroutine去执行。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"[*] main start\"</span>)</span><br><span class=\"line\">  demo1()</span><br><span class=\"line\">  demo2()</span><br><span class=\"line\">  time.Sleep(time.Second)  <span class=\"comment\">// 最暴力简单的延时函数</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"[-] main end\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 如果main函数结束了，则由main启动的goroutine也结束了。</span></span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] main start</span><br><span class=\"line\">第 4 次欢迎你</span><br><span class=\"line\">欢迎你第 0 次</span><br><span class=\"line\">欢迎你第 1 次</span><br><span class=\"line\">欢迎你第 2 次</span><br><span class=\"line\">欢迎你第 3 次</span><br><span class=\"line\">欢迎你第 4 次</span><br><span class=\"line\">第 0 次欢迎你</span><br><span class=\"line\">第 1 次欢迎你</span><br><span class=\"line\">第 2 次欢迎你</span><br><span class=\"line\">第 3 次欢迎你  <span class=\"comment\"># 你会发现输出完此行时，会有卡顿。这是由于未到延时时间代码便执行完毕，所以终端处于阻塞模式，等待延时时间得到来。</span></span><br><span class=\"line\">[-] main end</span><br></pre></td></tr></table></figure></p>\n<p>上面的方式在实际的开发工作不会这样使用，一般会利用sync.WaitGroup对象，在函数中当goroutine全部执行完毕后，将会自动结束运行, 可以参考下述实践示例2。</p>\n<p><br></p>\n<p><strong>实践演示(2).使用sync.WaitGroup对线下等待并发线程执行完毕</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 优雅的使用 goroutine 并行调度。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"math/rand\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">  <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// 实例化结构体得到对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"comment\">// goroutine 将调用的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done() <span class=\"comment\">// goroutine结束就登记-1</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"输出的随机数：\"</span>, rand.Intn(<span class=\"number\">10</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 当main函数任务中所有的goroutine都结束了，才结束main函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"Start Main\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">// goroutine 调用</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    rand.Seed(time.Now().Unix()) <span class=\"comment\">// 随机数种子传入的是一个int64类型</span></span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>)  <span class=\"comment\">// 启动一个goroutine就登记+1</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> f1()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait() \t<span class=\"comment\">// 监听并等待main中的goroutine是否都运行结束(等待wg组为0时)。</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"End Main\"</span>)  <span class=\"comment\">// 输出再也没有卡顿了</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Start Main</span><br><span class=\"line\">输出的随机数： <span class=\"number\">2</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">2</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">8</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">2</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">1</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">7</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">6</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">2</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">7</span></span><br><span class=\"line\">输出的随机数： <span class=\"number\">0</span></span><br><span class=\"line\">End Main   <span class=\"comment\">// 此处输出再也没有卡顿了。</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"3-Goroutine-特性\"><a href=\"#3-Goroutine-特性\" class=\"headerlink\" title=\"3.Goroutine 特性\"></a>3.Goroutine 特性</h3><h4 id=\"1-Goroutine-可增长的栈\"><a href=\"#1-Goroutine-可增长的栈\" class=\"headerlink\" title=\"(1) Goroutine 可增长的栈\"></a>(1) Goroutine 可增长的栈</h4><p>描述: OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次性创建十万左右的goroutine也是可以的。</p>\n<p>Tips : 总结 goroutine 初始栈大小为2k，其大小可以按照需要扩容缩。</p>\n<p><br/></p>\n<h4 id=\"2-Goroutine-调度模型\"><a href=\"#2-Goroutine-调度模型\" class=\"headerlink\" title=\"(2) Goroutine 调度模型\"></a>(2) Goroutine 调度模型</h4><p>描述:GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程，它比起OS的调度更轻量级些。</p>\n<p><strong>goroutine GMP模型:</strong></p>\n<ul>\n<li>G 其就是个goroutine里面除了存放本goroutine信息外，还存放与所在P的绑定等信息。</li>\n<li>P 管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（<code>函数指针，堆栈地址及地址边界</code>），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>\n<li>M (machine) 是Go运行时（runtime）对操作系统内核线程的虚拟，M与内核线程(Kernel Thread)一般是一一映射的关系，一个groutine最终是要放到M上执行的；</li>\n</ul>\n<p><br/></p>\n<p><strong>P与M的关系</strong><br>描述: P与M通常是一一对应的,他们关系是P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G挂载在新建的M上，当旧的G阻塞完成或者认为其已经死掉时则回收旧的M。</p>\n<p>P的个数是通过 <code>runtime.GOMAXPROCS</code>设定（最大256 核），Go1.5版本之后默认为物理线程数。在并发量大的时候会增加一些P和M，但不会太多，切换上下文太频繁的话得不偿失。</p>\n<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>\n<p>Tips: goroutine 组最终是要放在M(内核态)中执行，不过在此之前goroutine已经将任务进行排好队列（底层实现线程池），然后等待分别到操作系统之中。</p>\n<p>课外扩展: <a href=\"https://www.cnblogs.com/sunsky303/p/9705727.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sunsky303/p/9705727.html</a></p>\n<p><br></p>\n<h4 id=\"3-Goroutine-线程数\"><a href=\"#3-Goroutine-线程数\" class=\"headerlink\" title=\"(3) Goroutine 线程数\"></a>(3) Goroutine 线程数</h4><p>描述: Go运行时的调度器使用<code>GOMAXPROCS参数</code>来设置使用多少个OS线程来同时执行Go代码，其默认值是机器上的CPU核心数。</p>\n<p>Go语言中可以通过<code>runtime.GOMAXPROCS(NUMBER)</code>函数, 设置当前程序并发时占用的CPU逻辑核心数。并可以通过 <code>runtime.NumCPU()</code> 与 <code>runtime.NumGoroutine()</code> 分别查看机器中的逻辑CPU数和当前存在的goroutine数。</p>\n<p>Tips: Go1.5版本之前，默认使用的是单核心执行。<br>Tips: Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>\n<p>例如，在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（<code>GOMAXPROCS是m:n调度中的n</code>）。</p>\n<p><br/></p>\n<p><strong>Q: 什么是M:N?</strong><br>答: <code>M:N</code> 即把m个goroutine任务分配给n个操作系统线程去执行。</p>\n<p><br/></p>\n<p><strong>Go语言中的操作系统线程和goroutine的关系：</strong></p>\n<ul>\n<li>一个操作系统线程对应用户态的多个goroutine。</li>\n<li>go语言程序可以同时使用多个操作系统线程。</li>\n<li>go语言中的goroutine与OS线程是多对多的关系，即 m:n 的关系。</li>\n</ul>\n<p><br/></p>\n<p><strong>实践案例:</strong><br>例如: 我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"runtime\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">a</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println</span>(<span class=\"string\">\"Func A() :\"</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">b</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println</span>(<span class=\"string\">\"Func B() :\"</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"[*] Main Start\"</span>)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"当前机器的 CPU 核心数:\"</span>, runtime.NumCPU()) <span class=\"comment\">// NumCPU返回当前进程可用的逻辑CPU数量。</span></span><br><span class=\"line\">  runtime.GOMAXPROCS(<span class=\"number\">2</span>)  <span class=\"comment\">// 占用cpu的两个核</span></span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> a() <span class=\"comment\">// 并发调用a函数（后输出）</span></span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> b() <span class=\"comment\">// 并发调用a函数（先输出）                   </span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"当前机器的 goroutine 数:\"</span>, runtime.NumGoroutine()) <span class=\"comment\">// NumGoroutine返回当前存在的goroutine数。</span></span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"[*] Main End\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] Main Start</span><br><span class=\"line\">当前机器的 CPU 核心数: <span class=\"number\">4</span></span><br><span class=\"line\">当前机器的 goroutine 数: <span class=\"number\">3</span></span><br><span class=\"line\">[*] Main End</span><br><span class=\"line\">Func B() : <span class=\"number\">0</span></span><br><span class=\"line\">Func B() : <span class=\"number\">1</span></span><br><span class=\"line\">Func B() : <span class=\"number\">2</span></span><br><span class=\"line\">Func B() : <span class=\"number\">3</span></span><br><span class=\"line\">Func B() : <span class=\"number\">4</span></span><br><span class=\"line\">Func B() : <span class=\"number\">5</span></span><br><span class=\"line\">Func A() : <span class=\"number\">0</span></span><br><span class=\"line\">Func A() : <span class=\"number\">1</span></span><br><span class=\"line\">Func A() : <span class=\"number\">2</span></span><br><span class=\"line\">Func A() : <span class=\"number\">3</span></span><br><span class=\"line\">Func A() : <span class=\"number\">4</span></span><br><span class=\"line\">Func A() : <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"comment\">// 结果说明:  Mac 可以复现成功，而Linux与Windows还是一个goroutine任务做完后再做另外一个goroutine任务,其结果如上。</span></span><br><span class=\"line\"><span class=\"comment\">// 当两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 </span></span><br><span class=\"line\"><span class=\"comment\">// 当将逻辑核心数设为2，此时两个任务并行执行，即理想的状态是做一个任务a再做一个任务b，进行交叉执行。</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"4-Channel-通道\"><a href=\"#4-Channel-通道\" class=\"headerlink\" title=\"4.Channel 通道\"></a>4.Channel 通道</h3><p>描述: 上面章节介绍了Goroutine的基本使用，但是您会发现单纯地将函数并发执行是没有意义的，函数与函数间需要交换数据才能体现并发执行函数的意义。</p>\n<p><strong>背景说明</strong><br>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题，所以为了保证数据交换的正确性，就必须使用互斥量对内存进行加锁，但是这种做法势必造成性能方面的问题。</p>\n<p><strong>解决办法</strong><br>为了解决上述问题,Go语言的并发模型采用得是<code>(CSP-Communicating Sequential Processes)</code>, 它提倡通过通信共享内存而不是通过共享内存而实现通信,其引入了channel的概念。</p>\n<p><strong>基础介绍</strong><br>如果说 goroutine是Go程序并发的执行体，而 channel (<code>英 [ˈtʃænl]</code>) 就是它们之间的连接通道, channel 是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p>\n<p>简单的说: 即通过Channel实现多个goroutine之间的通信。</p>\n<p><br></p>\n<p>Go 语言中的通道（channel）是一种<code>特殊的类型</code>, 通道像一个传送带或者队列，总是<code>遵循先入先出（First In First Out）的规则</code>，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是<code>声明channel的时候需要为其指定元素类型</code>。</p>\n<p><br></p>\n<h4 id=\"1-channel-类型\"><a href=\"#1-channel-类型\" class=\"headerlink\" title=\"1.channel 类型\"></a>1.channel 类型</h4><p>描述: channel是特殊类型(一种引用类型), 其声明通道类型的格式如下：<code>var 变量 chan 元素类型</code></p>\n<p><strong>示例说明:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch1 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>   <span class=\"comment\">// 声明一个传递整型的通道</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ch2 <span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>  <span class=\"comment\">// 声明一个传递布尔型的通道</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ch3 <span class=\"keyword\">chan</span> []<span class=\"keyword\">int</span> <span class=\"comment\">// 声明一个传递int切片的通道</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"2-channel-创建\"><a href=\"#2-channel-创建\" class=\"headerlink\" title=\"2.channel 创建\"></a>2.channel 创建</h4><p>描述: 创建 channel 的格式如下：<code>make(chan 元素类型, [缓冲大小])</code>, channel的缓冲大小是可选的。</p>\n<p>Tips: 由于通道是引用类型, 声明的通道后需要使用make函数初始化之后才能使用，并且需要注意<code>通道类型的空值是nil</code>。<br>Tips: Slice、Map、Channel 需要make函数初始化后方能使用。</p>\n<p><strong>示例说明:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ch <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">fmt.Println(ch)   <span class=\"comment\">// 未初始返回 &lt;nil&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch4 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// 必须用make函数初始化之后才能使用</span></span><br><span class=\"line\">ch5 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">ch6 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> []<span class=\"keyword\">int</span>,<span class=\"number\">10</span>)  <span class=\"comment\">// 带缓冲区的</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips: 声明时指定通道中元素类型,定义使用时通道必须使用make函数初始化才能使用。</p>\n<p><br></p>\n<h4 id=\"3-channel-操作\"><a href=\"#3-channel-操作\" class=\"headerlink\" title=\"3.channel 操作\"></a>3.channel 操作</h4><p>描述: 通道有<code>发送(send) 、接收 (receive) 和 关闭(close)</code> 三种操作, 但值得注意的是发送和接收都使用<code>&lt;-</code>符号。</p>\n<ul>\n<li>send ：将一个值发送到通道中。</li>\n<li>receive : 从一个通道中接收值。</li>\n<li>close : 我们通过调用内置的close函数来关闭通道,也可以不用关闭通道,因为通道是引用类型的变量,所以它会在程序结束后自动给GC(<code>垃圾回收</code>)。</li>\n</ul>\n<p><br/></p>\n<p><strong>示例说明</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个通道(初始化通道)</span></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送 send</span></span><br><span class=\"line\">ch &lt;- <span class=\"number\">10</span> <span class=\"comment\">// 把10发送到ch中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接收 receive</span></span><br><span class=\"line\">x := &lt;-ch  <span class=\"comment\">// 从ch中接收值并赋值给变量x</span></span><br><span class=\"line\">&lt;-ch       <span class=\"comment\">// 从ch中接收值，忽略结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭 close</span></span><br><span class=\"line\"><span class=\"built_in\">close</span>(x)</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<p><strong>温馨提示:</strong></p>\n<ul>\n<li>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。</li>\n<li>通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</li>\n<li>通道关闭后的特点如下<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 对一个关闭的通道再发送值就会导致panic。</span><br><span class=\"line\">* 对一个关闭的通道进行接收会一直获取值直到通道为空。</span><br><span class=\"line\">* 对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span><br><span class=\"line\">* 关闭一个已经关闭的通道会导致panic。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br/></p>\n<h4 id=\"4-channel-缓冲\"><a href=\"#4-channel-缓冲\" class=\"headerlink\" title=\"4.channel 缓冲\"></a>4.channel 缓冲</h4><p>描述: 我们可以为 channel 设置缓冲或者不设置缓冲区，其两者概念和区别如下。</p>\n<ul>\n<li>无缓冲的通道: 又称为阻塞的通道(必须有接收才能发送)。</li>\n<li>有缓冲的通道: 为解决无缓冲的通道存在的问题孕育而生。</li>\n</ul>\n<p><br/></p>\n<p><strong>无缓冲的通道</strong></p>\n<p>描述: 使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化,因此无缓冲通道也被称为<code>同步通道</code>。</p>\n<p>废话不多说,先看引入的示例代码。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  ch &lt;- <span class=\"number\">10</span>  <span class=\"comment\">// 代码会阻塞在 ch &lt;- 10这一行代码形成死锁</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"发送成功\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面这段代码能够通过编译，但是执行的时候会出现以下错误：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal error: all goroutines are asleep - deadlock!</span><br><span class=\"line\">goroutine <span class=\"number\">1</span> [<span class=\"keyword\">chan</span> send]:</span><br><span class=\"line\">main.main()</span><br><span class=\"line\">.../src/github.com/main.<span class=\"keyword\">go</span>:<span class=\"number\">8</span> +<span class=\"number\">0x50</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<p>Q: 为什么会出现deadlock错误呢？</p>\n<blockquote>\n<p>答: 因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。<br>例如: 就像你住的小区如果没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是<code>无缓冲的通道必须有接收才能发送</code>。</p>\n</blockquote>\n<p><br/></p>\n<p>Q: 那如何解决这个问题呢？</p>\n<blockquote>\n<p>答: 一种方法是启用一个goroutine去接收值，另外一种方式就是采用带缓冲的通道（后续介绍）。</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recv</span><span class=\"params\">(c <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  ret := &lt;-c</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"接收成功\"</span>, ret)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> recv(ch) <span class=\"comment\">// 启用goroutine从通道接收值</span></span><br><span class=\"line\">  ch &lt;- <span class=\"number\">10</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"发送成功\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips: 在无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。<br>Tips: 在无缓冲通道上的如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p>\n<p><br></p>\n<p><strong>有缓冲的通道</strong><br>描述: 使用有缓冲区的通道可以解决无缓冲的通道阻塞问题, 我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">1</span>) <span class=\"comment\">// 创建一个容量为1的有缓冲区通道</span></span><br><span class=\"line\">  ch &lt;- <span class=\"number\">10</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"发送成功\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量, 就像你小区的快递柜只有那么个多格子，格子满了就装不下了就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>\n<p>同时我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。</p>\n<p><br/></p>\n<p><strong>实践案例:</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// make 函数申请内存空间的传入对象（实例化三种类型）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s []<span class=\"keyword\">int</span>          <span class=\"comment\">// slice 切片</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> m <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span> <span class=\"comment\">// map 字典映射</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>       <span class=\"comment\">// 指定通道中元素的类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义全局的waitGroup</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无缓冲的通道示例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">noBuffer</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(c)      <span class=\"comment\">// 未初始化的通道返回 nil （未向内存中申请空间）</span></span><br><span class=\"line\">  c := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// 不带缓冲区通道的初始化 （但必须有对应的接收）</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"将 10 发生到 channel c 之中\"</span>)</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">// 并行任务的顺序非常重要，此处不能放在 c &lt;- 10 后否则终端将会一直处于阻塞状态</span></span><br><span class=\"line\">    <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">    x := &lt;-c</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Backgroup Goroutine 从 channel c 中取得 %v \\n\\n\"</span>, x)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  c &lt;- <span class=\"number\">10</span> <span class=\"comment\">// 将 10 发生到 channel c 之中（注意此行放的顺序）</span></span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(c) <span class=\"comment\">// 关闭通道</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有缓冲的通道示例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">useBuffer</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(c)        <span class=\"comment\">// 未初始化的通道返回 nil （未向内存中申请空间）</span></span><br><span class=\"line\">  c = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 带缓冲区通道的初始化</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"通道缓冲数量（发送前）:\"</span>, <span class=\"built_in\">len</span>(c))</span><br><span class=\"line\">  c &lt;- <span class=\"number\">10</span>                                <span class=\"comment\">// 将 10 发生到 channel c 之中</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"同样将 10 发生到 channel c 之中\"</span>) <span class=\"comment\">// 此处将不会阻塞</span></span><br><span class=\"line\">  c &lt;- <span class=\"number\">20</span>                                <span class=\"comment\">// 将 10 发生到 channel c 之中</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"然后将 20 发生到 channel c 之中\"</span>) <span class=\"comment\">// 如何缓冲区通道初始化为1，则此处将阻塞,如果初始化通道缓冲区大于等于2将会不阻塞</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"通道缓冲数量（发送后）:\"</span>, <span class=\"built_in\">len</span>(c))</span><br><span class=\"line\">  x := &lt;-c</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"第一次，从channel c中取到了 %v\\n\"</span>, x)</span><br><span class=\"line\">  x = &lt;-c</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"第二次，从channel c中取到了 %v\\n\"</span>, x)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"channel c ptr = %p \\n\"</span>, c)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(c) <span class=\"comment\">// 关闭通道</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  noBuffer()</span><br><span class=\"line\">  useBuffer()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"literal\">nil</span>&gt;</span><br><span class=\"line\">将 <span class=\"number\">10</span> 发生到 channel c 之中</span><br><span class=\"line\">Backgroup Goroutine 从 channel c 中取得 <span class=\"number\">10</span> </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;<span class=\"literal\">nil</span>&gt;</span><br><span class=\"line\">通道缓冲数量: <span class=\"number\">0</span></span><br><span class=\"line\">同样将 <span class=\"number\">10</span> 发生到 channel c 之中</span><br><span class=\"line\">然后将 <span class=\"number\">20</span> 发生到 channel c 之中</span><br><span class=\"line\">通道缓冲数量: <span class=\"number\">2</span></span><br><span class=\"line\">第一次，从channel c中取到了 <span class=\"number\">10</span></span><br><span class=\"line\">第二次，从channel c中取到了 <span class=\"number\">20</span></span><br><span class=\"line\">channel c ptr = <span class=\"number\">0xc0000240e0</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h4 id=\"5-channel-遍历\"><a href=\"#5-channel-遍历\" class=\"headerlink\" title=\"5.channel 遍历\"></a>5.channel 遍历</h4><p>描述: 当一个通道发送到通道队列里有多个值时, 此时我们想取出通道队列的所有值时，我们可以使用<code>for range</code> 遍历通道，并且当通道被关闭的时候就会退出<code>for range</code>遍历。</p>\n<p>当向通道中发送完数据时，我们可以通过close函数来关闭通道，如果此时再往该通道发送值会引发panic，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。</p>\n<p><br></p>\n<p><strong>Q: 那如何判断一个通道是否被关闭了呢？</strong></p>\n<blockquote>\n<p>第一种方法<code>&lt;-ch</code>, 第二种方法<code>for range</code>遍历通道。</p>\n</blockquote>\n<p><strong>实践案例:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// channel 遍历实践操作</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>) <span class=\"comment\">// 不带缓冲区</span></span><br><span class=\"line\">  ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 开启goroutine将1~9的数发送到ch1中</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">      ch1 &lt;- i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch1) <span class=\"comment\">// 关闭通道 ch2 （此时只能读不能写）</span></span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"comment\">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">      i, ok := &lt;-ch1 <span class=\"comment\">// 通道关闭后再取值到末尾时，ok=false 【关键点值得学习】</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ch2 &lt;- i * i <span class=\"comment\">// 同样求取通道的平方</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch2) <span class=\"comment\">// 关闭通道 ch2 （此时只能读不能写）</span></span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  <span class=\"comment\">// 在主goroutine中从ch2中接收值打印</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"方式1:\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ch2 &#123; <span class=\"comment\">// 通道关闭后会退出for range循环</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%d \"</span>, i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 负责将10～19发送到ch1中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">(ch1 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">10</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</span><br><span class=\"line\">    ch1 &lt;- i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(ch1) <span class=\"comment\">// 关闭通道 ch1 （此时只能读不能写）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 负责将接收ch1值的值进行平方运算</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">(ch1, ch2 <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> num := <span class=\"keyword\">range</span> ch1 &#123;   【关键点】</span><br><span class=\"line\">    ch2 &lt;- num * num</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(ch2) <span class=\"comment\">// 关闭通道 ch2 （此时只能读不能写）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 带缓冲区</span></span><br><span class=\"line\">  ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">  <span class=\"comment\">// goroutine 等待组数量设置</span></span><br><span class=\"line\">  wg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 开启 goroutine</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> f1(ch1)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> f2(ch1, ch2)</span><br><span class=\"line\">  <span class=\"comment\">// 等待全部 goroutine 任务执行完毕</span></span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"方式2:\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 通道关闭后会退出for range循环</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ret := <span class=\"keyword\">range</span> ch2 &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%d \"</span>, ret)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 匿名函数</span></span><br><span class=\"line\">  method1()</span><br><span class=\"line\">  fmt.Println()</span><br><span class=\"line\">  <span class=\"comment\">// 常规函数</span></span><br><span class=\"line\">  method2()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭.</p>\n<p><br></p>\n<h4 id=\"6-单向通道\"><a href=\"#6-单向通道\" class=\"headerlink\" title=\"6.单向通道\"></a>6.单向通道</h4><p>描述: 有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如<code>限制通道在函数中只能发送或只能接收</code>。</p>\n<p>所以在这样场景下Go语言中提供了单向通道来处理这种情况。</p>\n<ul>\n<li><code>out chan&lt;- int</code> 是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作;</li>\n<li><code>in  &lt;-chan int</code> 是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作;</li>\n</ul>\n<p>Tips: 在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p>\n<p>例如，我们把上面的例子改造如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数参数 out： 一个只写单向通道。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counter</span><span class=\"params\">(out <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++ &#123;</span><br><span class=\"line\">    out &lt;- i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数参数 out： 一个只写单向通道,函数参数 in: 一个只读单向通道。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">squarer</span><span class=\"params\">(out <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> in &#123;</span><br><span class=\"line\">    out &lt;- i * i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(out)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数参数 in : 一个只读单向通道。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printer</span><span class=\"params\">(in &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> in &#123;</span><br><span class=\"line\">    fmt.Println(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> counter(ch1) <span class=\"comment\">// ch1 此时只写</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> squarer(ch2, ch1) <span class=\"comment\">// ch2 此时只写，ch1 此时只读</span></span><br><span class=\"line\">  printer(ch2) <span class=\"comment\">// ch2 此时只读</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>实践案例</strong><br>描述: 请传入通道中浮点数类型的三次方。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unidirectional channel</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通道只写操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">(ch1 <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    ch1 &lt;- <span class=\"keyword\">float64</span>(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">close</span>(ch1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通道只写与只读操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">(ch2 <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">float64</span>, ch1 &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> ch1 &#123;</span><br><span class=\"line\">    ch2 &lt;- math.Pow(i, <span class=\"number\">3</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 确保某个操作只执行一次，防止因为通道关闭而其他并发(进程)不能读取</span></span><br><span class=\"line\">  anonymousefun := (<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch2)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  once.Do(anonymousefun)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">float64</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 带缓冲区的通道</span></span><br><span class=\"line\">  ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">float64</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 带缓冲区的通道</span></span><br><span class=\"line\">  wg.Add(<span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> f1(ch1)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> f2(ch2, ch1) <span class=\"comment\">// 多次 goroutine 同一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> f2(ch2, ch1)</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  <span class=\"comment\">// 循环遍历，直到读取到末尾</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    x, ok := &lt;-ch2</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%.0f \"</span>, x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果: <code>0 1 8 27 64 125 216 343 512 729</code></p>\n<p><br></p>\n<h4 id=\"7-通道总结\"><a href=\"#7-通道总结\" class=\"headerlink\" title=\"7.通道总结\"></a>7.通道总结</h4><p>描述: channel 常见的异常总结,非常注意<code>关闭已经关闭的channel也会引发panic</code>，如下表：</p>\n<table>\n<thead>\n<tr>\n<th>Channel</th>\n<th>Nil</th>\n<th>非空</th>\n<th>空的</th>\n<th>满了</th>\n<th>没满</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>发送(Send)</td>\n<td>阻塞</td>\n<td>发送值</td>\n<td>发送值</td>\n<td>阻塞</td>\n<td>发送值</td>\n<td></td>\n</tr>\n<tr>\n<td>接收(Receive)</td>\n<td>阻塞</td>\n<td>接收值</td>\n<td>阻塞</td>\n<td>接收值</td>\n<td>接收值</td>\n<td></td>\n</tr>\n<tr>\n<td>关闭(Close)</td>\n<td>panic</td>\n<td>关闭成功,读完数据后返回零值</td>\n<td>关闭成功,返回零值</td>\n<td>关闭成功,读完数据后返回零值</td>\n<td>关闭成功,返回零值</td>\n<td>关闭成功,读完数据后返回零值</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<h3 id=\"5-Goroutine-池\"><a href=\"#5-Goroutine-池\" class=\"headerlink\" title=\"5.Goroutine 池\"></a>5.Goroutine 池</h3><p>描述: 在工作中我们通常会使用可以指定启动的<code>goroutine</code>数量以<code>worker pool模式</code>,并且利用控制 goroutine的数量，来防止goroutine泄漏和暴涨等问题。</p>\n<p>简单描述：就是预定义一定数量的Goroutine去执行任务(函数)。</p>\n<p><strong>实践案例1:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// goroutine 同步等待组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">var</span> one sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker</span><span class=\"params\">(id <span class=\"keyword\">int</span>, jobs &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, results <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> jobs &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"worker:%d start job:%d\\n\"</span>, id, j)  <span class=\"comment\">// start</span></span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)            <span class=\"comment\">// 延时500s查看效果比较明显</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"worker:%d end job:%d\\n\"</span>, id, j)    <span class=\"comment\">// end</span></span><br><span class=\"line\">    results &lt;- j * <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 保证调用的函数只执行一次 (关键点)</span></span><br><span class=\"line\">  one.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(results)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 五个任务给3给goroutine池执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  jobs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">  results := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">  <span class=\"comment\">// goroutine 池(此处3个goroutine组成)</span></span><br><span class=\"line\">  wg.Add(<span class=\"number\">3</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt;= <span class=\"number\">3</span>; w++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> worker(w, jobs, results) <span class=\"comment\">// 当执行到第五的一个任务后将介绍（所以一共会打印10次）</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 设置5个任务</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> j := <span class=\"number\">1</span>; j &lt;= <span class=\"number\">5</span>; j++ &#123;</span><br><span class=\"line\">    jobs &lt;- j</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 保证调用的函数只执行一次 (关键点)</span></span><br><span class=\"line\">  one.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(jobs)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  <span class=\"comment\">// 输出结果</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"results channle length: \"</span>, <span class=\"built_in\">len</span>(results)) <span class=\"comment\">// 长度为 5</span></span><br><span class=\"line\">  <span class=\"comment\">// 方式1,打印后阻塞(会一直从channel中取数)</span></span><br><span class=\"line\">  <span class=\"comment\">// for &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// \tx, ok := &lt;-results  // results 通道被关闭时ok=False。</span></span><br><span class=\"line\">  <span class=\"comment\">// \tif !ok &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// \t\tfmt.Println(ok)</span></span><br><span class=\"line\">  <span class=\"comment\">// \t\tbreak</span></span><br><span class=\"line\">  <span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// \tfmt.Println(ok, x)</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 方式2,打印后阻塞(会一直从channel中取数)</span></span><br><span class=\"line\">  <span class=\"comment\">// for i := range results &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// \tfmt.Println(i)</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 此种方式不会阻塞</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> a := <span class=\"number\">1</span>; a &lt;= <span class=\"number\">5</span>; a++ &#123;</span><br><span class=\"line\">    &lt;-results</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker:<span class=\"number\">3</span> start job:<span class=\"number\">1</span></span><br><span class=\"line\">worker:<span class=\"number\">2</span> start job:<span class=\"number\">3</span></span><br><span class=\"line\">worker:<span class=\"number\">1</span> start job:<span class=\"number\">2</span></span><br><span class=\"line\">worker:<span class=\"number\">1</span> end job:<span class=\"number\">2</span></span><br><span class=\"line\">worker:<span class=\"number\">1</span> start job:<span class=\"number\">4</span></span><br><span class=\"line\">worker:<span class=\"number\">2</span> end job:<span class=\"number\">3</span></span><br><span class=\"line\">worker:<span class=\"number\">2</span> start job:<span class=\"number\">5</span></span><br><span class=\"line\">worker:<span class=\"number\">3</span> end job:<span class=\"number\">1</span></span><br><span class=\"line\">worker:<span class=\"number\">1</span> end job:<span class=\"number\">4</span></span><br><span class=\"line\">worker:<span class=\"number\">2</span> end job:<span class=\"number\">5</span></span><br><span class=\"line\">results channle length:  <span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>实践案例2:针对上述示例进行优化，优化并发流程,利用信号变量通知goroutine任务结束关闭通道.</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker</span><span class=\"params\">(id <span class=\"keyword\">int</span>, jobs &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, results <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">int</span>, notify <span class=\"keyword\">chan</span>&lt;- <span class=\"keyword\">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> j := <span class=\"keyword\">range</span> jobs &#123;</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)          <span class=\"comment\">// 延时500s查看效果比较明显</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"worker:%d end job:%d\\n\"</span>, id, j) <span class=\"comment\">// end</span></span><br><span class=\"line\">    results &lt;- j * <span class=\"number\">2</span></span><br><span class=\"line\">    notify &lt;- <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125; <span class=\"comment\">// 任务执行信号标识,实例化匿名结构体,如此使用非常节省空间.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1.初始化通道</span></span><br><span class=\"line\">  jobs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">  results := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">100</span>)</span><br><span class=\"line\">  notify := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;, <span class=\"number\">5</span>) <span class=\"comment\">// 作为信号使用,通道类型采用匿名结构体,占用的系统资源较少(常用值得学习),此处作为并发任务执行完毕通知.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2.生成五个任务</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">      jobs &lt;- i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(jobs) <span class=\"comment\">// 给通道传递完值后关闭</span></span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3.开启三个Goroutine (并发池)</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> w := <span class=\"number\">1</span>; w &lt;= <span class=\"number\">3</span>; w++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> worker(w, jobs, results, notify)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 4.通过信号变量,验证五个任务是否执行完毕,如果晚报则关闭results通道</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环五次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">      &lt;-notify</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭通道，如果不关闭将一直阻塞</span></span><br><span class=\"line\">    <span class=\"built_in\">close</span>(results)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.遍历已关闭的通道值</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> res := <span class=\"keyword\">range</span> results &#123;</span><br><span class=\"line\">    fmt.Println(res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker:<span class=\"number\">2</span> end job:<span class=\"number\">2</span></span><br><span class=\"line\">worker:<span class=\"number\">3</span> end job:<span class=\"number\">3</span></span><br><span class=\"line\">worker:<span class=\"number\">1</span> end job:<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">worker:<span class=\"number\">2</span> end job:<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">worker:<span class=\"number\">3</span> end job:<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"6-Goroutine-多路复用\"><a href=\"#6-Goroutine-多路复用\" class=\"headerlink\" title=\"6.Goroutine 多路复用\"></a>6.Goroutine 多路复用</h3><p>描述: 在某些场景下我们需要同时从多个通道接收数据, 通道在接收数据时, 如果没有数据可以接收将会发生阻塞。</p>\n<p>你也许会写出如下代码使用遍历的方式来实现, 但此种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。所以为了应对这种场景，<code>Go内置了select关键字</code>，可以同时响应多个通道的操作。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 尝试从ch1接收值</span></span><br><span class=\"line\">  data, ok := &lt;-ch1</span><br><span class=\"line\">  <span class=\"comment\">// 尝试从ch2接收值</span></span><br><span class=\"line\">  data, ok := &lt;-ch2</span><br><span class=\"line\">  …</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>select 关键字</code>使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句。</p>\n<p><strong>语法格式：</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ch1:</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"keyword\">case</span> data := &lt;-ch2:</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"keyword\">case</span> ch3&lt;-data:</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      默认操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><br/></p>\n<p><strong>示例演示:</strong><br>Goroutine Select 多路复用<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 示例1</span></span><br><span class=\"line\">  ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"// 示例 1\t\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> x := &lt;-ch1:</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"index : %d , x = %d\\n\"</span>, i, x) <span class=\"comment\">// 通道缓冲区为1时,结果时可以预测的.</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> ch1 &lt;- i: <span class=\"comment\">// 将会把(变量i)偶数值传给ch1通道</span></span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"index : %d , default\\n\"</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 示例2</span></span><br><span class=\"line\">  ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"// 示例 2\"</span>)</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    wg.Done()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">      ch2 &lt;- i + i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(ch2)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> j := &lt;-ch2:</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">\"case 1: \"</span>, i, j) <span class=\"comment\">// 通道缓冲区为大于1时,结果是不可以预测的.</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> ch2 &lt;- i:</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">\"case 2: ch2 &lt;- i\"</span>, i)</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">\"默认执行\"</span>, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例 1\t</span></span><br><span class=\"line\">index : <span class=\"number\">1</span> , x = <span class=\"number\">0</span></span><br><span class=\"line\">index : <span class=\"number\">3</span> , x = <span class=\"number\">2</span></span><br><span class=\"line\">index : <span class=\"number\">5</span> , x = <span class=\"number\">4</span></span><br><span class=\"line\">index : <span class=\"number\">7</span> , x = <span class=\"number\">6</span></span><br><span class=\"line\">index : <span class=\"number\">9</span> , x = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"comment\">// 示例 2</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>:  <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>:  <span class=\"number\">2</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">2</span>: ch2 &lt;- i <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>:  <span class=\"number\">4</span> <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>:  <span class=\"number\">5</span> <span class=\"number\">3</span>  <span class=\"comment\">// 注意通道是先进先出类似于队列结构。</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>总结说明</strong><br>使用select语句能提高代码的可读性。</p>\n<ul>\n<li>可处理<code>一个或多个channel</code>的发送/接收操作。</li>\n<li>如果多个case同时满足，select会随机选择一个。</li>\n<li>对于没有case的<code>select{}</code>会一直等待，可用于<code>阻塞main函数</code>。</li>\n</ul>\n<p><br></p>\n<h3 id=\"7-Goroutine-并发安全-锁\"><a href=\"#7-Goroutine-并发安全-锁\" class=\"headerlink\" title=\"7.Goroutine 并发安全(锁)\"></a>7.Goroutine 并发安全(锁)</h3><p>描述: 有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。</p>\n<p>类比现实生活中的例子有十字路口被各个方向的的汽车竞争, 还有火车上的卫生间被车厢里的人竞争, 针对十字路口我们可以采用红绿灯进行各个方向依次放行，针对火车上的卫生间我们可以上锁让外部人员知道厕所有人且无法进入。</p>\n<p>所以针对于Go语言中并发时资源竞态问题，其采用锁Lock机制进行解决，保证在线程在并发执行时的安全(不被其它线程干扰)。</p>\n<p><strong>举个例子:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++ &#123;</span><br><span class=\"line\">    x = x + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> add()  <span class=\"comment\">// 两个 goroutine 执行add任务</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> add() </span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(x) <span class=\"comment\">// 由于数据竞争的影响，可能导致最后的结果与期待的不符。输出: 5702 理想为10000</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个goroutine在访问和修改x变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p>\n<p><br></p>\n<h4 id=\"1-互斥锁\"><a href=\"#1-互斥锁\" class=\"headerlink\" title=\"1.互斥锁\"></a>1.互斥锁</h4><p>描述: 互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine可以访问共享资源。</p>\n<p>Tips: Go语言中使用<code>sync包</code>的<code>Mutex类型</code>来实现互斥锁。</p>\n<p>此处我们使用互斥锁来修复上面代码的问题：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">var</span> lock sync.Mutex</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5000</span>; i++ &#123;</span><br><span class=\"line\">    lock.Lock() <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    x = x + <span class=\"number\">1</span></span><br><span class=\"line\">    lock.Unlock() <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设置两个goroutine池进行执行add任务</span></span><br><span class=\"line\">  poolCount := <span class=\"number\">2</span></span><br><span class=\"line\">  wg.Add(poolCount)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; poolCount; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> add()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(x)  <span class=\"comment\">// 输出值为预期相同 10000</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p>\n<p><br/></p>\n<h4 id=\"2-读写互斥锁\"><a href=\"#2-读写互斥锁\" class=\"headerlink\" title=\"2.读写互斥锁\"></a>2.读写互斥锁</h4><p>描述: 互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，所以在这种场景下使用读写锁是更好的一种选择。</p>\n<p>Tips: Go语言中使用<code>sync包</code>的<code>RWMutex类型</code>来实现读写互斥锁，所以读写锁分为两种<code>读锁</code>和<code>写锁</code>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 加、解 读锁</span></span><br><span class=\"line\">rwlock.RLock()       <span class=\"comment\"># 对读操作进行锁定        </span></span><br><span class=\"line\">rwlock.RUnlock()     <span class=\"comment\"># 对读锁定进行解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加、解 写锁</span></span><br><span class=\"line\">sync.RWMutex.Lock()   <span class=\"comment\"># 对写操作进行锁定</span></span><br><span class=\"line\">sync.RWMutex.Unlock() <span class=\"comment\"># 对写锁定进行解锁</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips: 当一个<code>goroutine</code>获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p>\n<p><strong>读写锁使用示例:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  x      <span class=\"keyword\">int64</span></span><br><span class=\"line\">  wg     sync.WaitGroup</span><br><span class=\"line\">  rwlock sync.RWMutex</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">write</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  rwlock.Lock() <span class=\"comment\">// 加写锁</span></span><br><span class=\"line\">  x = x + <span class=\"number\">1</span></span><br><span class=\"line\">  time.Sleep(<span class=\"number\">10</span> * time.Millisecond) <span class=\"comment\">// 假设写操作耗时10毫秒</span></span><br><span class=\"line\">  rwlock.Unlock()                   <span class=\"comment\">// 解写锁</span></span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">read</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  rwlock.RLock()               <span class=\"comment\">// 加读锁</span></span><br><span class=\"line\">  time.Sleep(time.Millisecond) <span class=\"comment\">// 假设读操作耗时1毫秒</span></span><br><span class=\"line\">  rwlock.RUnlock()             <span class=\"comment\">// 解读锁</span></span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  start := time.Now()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> write()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> read()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  end := time.Now()</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"耗费时间 ：%v, x = %d \\n\"</span>, end.Sub(start), x) </span><br><span class=\"line\">  <span class=\"comment\">// 执行结果 =&gt; 耗费时间 ：104.906297ms, x = 10 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。<br>Tips: 在某些场景中也可能使用sync包中Map,它是一个开箱即用(不需要Make初始化)的并发安全的Map。如:<code>Sync.Map.Store(key,value)、Ssync.Map.Load(Key)、sync.Map.LoadOrstore、sync.Map.Delete()、sync.Map.Range()</code></p>\n<p><br></p>\n<h4 id=\"3-原子操作\"><a href=\"#3-原子操作\" class=\"headerlink\" title=\"3.原子操作\"></a>3.原子操作</h4><p>描述: 在上面的示例中我们通过锁操作来实现线程<code>(协程)</code>同步,而实际上锁机制的底层是基于原子操作的，其一般直接通过CPU指令实现。</p>\n<p>在Go语言中内置了对基本数据类型的一些并发安全操作，例如<code>atomic</code>包中的方法来实现协程同步，它提供了底层的原子级内存操作。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改内存地址中值为delta并返回新值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddInt64</span><span class=\"params\">(addr *<span class=\"keyword\">int64</span>, delta <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(<span class=\"built_in\">new</span> <span class=\"keyword\">int64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">// 读取内存地址中的值并返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">LoadInt64</span><span class=\"params\">(addr *<span class=\"keyword\">int64</span>)</span> <span class=\"params\">(val <span class=\"keyword\">int64</span>)</span></span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<p><strong>实践示例:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接口声明</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Counter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Inc()</span><br><span class=\"line\">  Load() <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 普通版</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> CommonCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  counter <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *CommonCounter)</span> <span class=\"title\">Inc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c.counter++ <span class=\"comment\">// 写</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *CommonCounter)</span> <span class=\"title\">Load</span><span class=\"params\">()</span> <span class=\"title\">int64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c.counter <span class=\"comment\">// 读</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 互斥锁版</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MutexCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  counter <span class=\"keyword\">int64</span></span><br><span class=\"line\">  lock    sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *MutexCounter)</span> <span class=\"title\">Inc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  m.lock.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> m.lock.Unlock()</span><br><span class=\"line\">  m.counter++  <span class=\"comment\">// 写</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *MutexCounter)</span> <span class=\"title\">Load</span><span class=\"params\">()</span> <span class=\"title\">int64</span></span> &#123;</span><br><span class=\"line\">  m.lock.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> m.lock.Unlock() </span><br><span class=\"line\">  <span class=\"keyword\">return</span> m.counter  <span class=\"comment\">// 读</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原子操作版</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> AtomicCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  counter <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *AtomicCounter)</span> <span class=\"title\">Inc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  atomic.AddInt64(&amp;a.counter, <span class=\"number\">1</span>) <span class=\"comment\">// 写</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *AtomicCounter)</span> <span class=\"title\">Load</span><span class=\"params\">()</span> <span class=\"title\">int64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> atomic.LoadInt64(&amp;a.counter) <span class=\"comment\">// 读</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span><span class=\"params\">(c Counter)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">  start := time.Now()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      c.Inc()</span><br><span class=\"line\">      wg.Done()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  end := time.Now()</span><br><span class=\"line\">  fmt.Println(c.Load(), end.Sub(start))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  c1 := CommonCounter&#123;&#125; <span class=\"comment\">// 非并发安全</span></span><br><span class=\"line\">  test(&amp;c1)</span><br><span class=\"line\">  c2 := MutexCounter&#123;&#125;  <span class=\"comment\">// 使用互斥锁实现并发安全</span></span><br><span class=\"line\">  test(&amp;c2)</span><br><span class=\"line\">  c3 := AtomicCounter&#123;&#125; <span class=\"comment\">// 并发安全且比互斥锁效率更高</span></span><br><span class=\"line\">  test(&amp;c3)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">943</span> <span class=\"number\">1.240583</span>ms</span><br><span class=\"line\"><span class=\"number\">1000</span> <span class=\"number\">1.514732</span>ms</span><br><span class=\"line\"><span class=\"number\">1000</span> <span class=\"number\">421.618</span>µs  <span class=\"comment\">// 可以看出其性能效率是最高的。</span></span><br></pre></td></tr></table></figure><br>Tips: atomic包对于同步算法的实现很有用, 但是这些函数必须谨慎地保证正确使用，除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"Development","path":"api/categories/Development.json"},{"name":"Programming","path":"api/categories/Programming.json"}],"tags":[{"name":"Go","path":"api/tags/Go.json"}]}