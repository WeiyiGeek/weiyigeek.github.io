<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="content-language" content="zh-CN"/>
    <meta name="author" content="WeiyiGeek" />
    <meta name="msvalidate.01" content="5C552FB1D885E0E11D2957EC958C8018" />
    <meta name="shenma-site-verification" content="4c655e91c76be0a93c1b6954c666c9d6_1649049085"/>
    <meta name="bytedance-verification-code" content="lKs4FqwCHSJ3A/c5tT7X" />
    <meta name="sogou_site_verification" content="OC65iET6Bk" />
    
    <title>🌐 2.Docker学习之基础使用|WeiyiGeek Blog|唯一极客Geek-IT网络安全运维开发技术知识分享-博客站点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
    <meta name="keywords" content="Docker">
    <meta name="Description" content="WeiyiGeek-唯一极客博客站点,关注于网络安全运维,Web安全开发,IOT物联网安全开发,应用开发,分享技术学习知识与入坑解决,提升网络安全技术与自身技术能力,立志维护大众网络安全为己任,做一个对国家有用的人,为实现中华民族伟大复兴的中国梦不懈奋斗">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/jquery/3.5.2-jquery.fancybox.min.css?v=1.6.6" />
    <link rel="stylesheet" href="/css/style.css?v=1.6.6">
    <!--  -->
     <script type="text/javascript" src="/js/custom/articlecost.js?v=1.6.6"></script> 
    <link rel="stylesheet" href="/css/third-party/gitalk.css?v=1.6.6"> 
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}')
        };
    </script>
    <script type="text/javascript">window.lazyScripts=[];</script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="WeiyiGeek Blog" type="application/atom+xml">
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg" alt="WeiyiGeek-backgroud">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg" alt="WeiyiGeek-头像">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">WeiyiGeek</h5>
          <a href="mailto:master@weiyigeek.top" title="master@weiyigeek.top" class="mail">
            <span>m</span><span>a</span><span>s</span><span>t</span><span>e</span><span>r</span><span>@</span><span>w</span><span>e</span><span>i</span><span>y</span><span>i</span><span>g</span><span>e</span><span>e</span><span>k</span><span>.</span><span>t</span><span>o</span><span>p</span>
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://weiyigeek.top/img/wechat-search.png" target="_blank">
                  <i class="icon icon-lg icon-wechat"></i>
                </a>
              </li>
            
              <li>
                <a href="https://github.com/weiyigeek" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://t.me/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-telegram"></i>
                </a>
              </li>
            
              <li>
                <a href="https://twitter.com/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-twitter"></i>
                </a>
              </li>
            
              <li>
                <a href="https://weibo.com/615643678" target="_blank">
                  <i class="icon icon-lg icon-weibo"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                首页
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                文章分类
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                文章标签
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章归档
              </a>
            </li>
        
            <li class="">
              <a href="/books"  >
                <i class="icon icon-lg icon-book"></i>
                学习书籍
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于作者
              </a>
            </li>
        
            <li class="">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                站点导航
              </a>
            </li>
        
            <li class="">
              <a href="https://weiyigeek.top/img/wechat-search.png" target="_blank" >
                <i class="icon icon-lg icon-wechat"></i>
                公众账号
              </a>
            </li>
        
            <li class="">
              <a href="https://space.bilibili.com/385802642" target="_blank" >
                <i class="icon icon-lg icon-youtube-play"></i>
                哔哩哔哩
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/weiyigeek" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="">
              <a href="https://twitter.com/WeiyiGeek" target="_blank" >
                <i class="icon icon-lg icon-twitter"></i>
                Twitter
              </a>
            </li>
        
            <li class="">
              <a href="https://weibo.com/615643678" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>2.Docker学习之基础使用</span>
            
        </div>

        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        

        
            <a href="/atom.xml" class="header-icon pull-right waves-effect waves-circle waves-light">
                <i class="icon icon-lg icon-rss"></i>
            </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg" alt="文章头部背景">
    <div class="container fade-scale">
        <h1 class="title">2.Docker学习之基础使用</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-05-21T06:36:30.000Z" itemprop="datePublished" class="page-time">
  2019-05-21
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/">Containers</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/OperationTools/">OperationTools</a></li></ul></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-虚拟云容/云容器/Docker/2.Docker学习之基础使用"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">2.Docker学习之基础使用</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-05-21 14:36:30" datetime="2019-05-21T06:36:30.000Z"  itemprop="datePublished">2019-05-21</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/">Containers</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Containers/OperationTools/">OperationTools</a></li></ul></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>[TOC]</p>
<a id="more"></a>
<hr>
<h4 id="0x01-Docker-数据管理"><a href="#0x01-Docker-数据管理" class="headerlink" title="0x01 Docker 数据管理"></a>0x01 Docker 数据管理</h4><p>Data Management,在使用Docker时候必然会在容器内产生数据,或者需要将容器内的数据进行备份,甚至多个容器之间进行数据共享,这时数据管理变得尤为重要;<br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190524110605.png" target="_blank" title="WeiyiGeek.数据管理" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190524110605.png" alt="WeiyiGeek.数据管理" title="" class=""></a>
                <p>WeiyiGeek.数据管理</p>
            </figure></p>
<p>容器中管理数据的主要有两种方式：</p>
<ul>
<li>数据卷：Data Volumns</li>
<li>数据卷容器：Data Volume  Dontainers</li>
</ul>
<p>数据管理共享的方式：</p>
<ul>
<li>使用数据卷容器在容器和主机</li>
<li>容器和容器之间共享数据</li>
</ul>
<p><br/></p>
<h5 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1.数据卷"></a>1.数据卷</h5><p>描述：是一个可供容器使用的数据目录,并且让文件系统提供很多有用的特性,数据卷的使用类似于Linux对目录或者文件进行mount操作;</p>
<p>数据卷特性：</p>
<ul>
<li>数据库可以在容器之间共享和重用</li>
<li>数据卷修改后会立马生效</li>
<li>对数据卷的更新不会影响镜像</li>
<li>卷会一直存在,即使容器被删除</li>
</ul>
<p><strong>Q:如何在容器内创建一个数据卷？</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### 创建一个web容器并创建一个数据卷挂载到容器的/webapp目录下(默认将宿主机/根映射到容器中webapp目录中)</span></span><br><span class="line">$ sudo docker run -d -P 5000 --name web(新建容器) -v /webapp(容器目录) training/webapp(镜像) python app.py</span><br><span class="line"><span class="comment"># --name 指定容器的名称</span></span><br><span class="line"><span class="comment"># -v:将镜像的存放位置放在本地指定的路径上.</span></span><br><span class="line"><span class="comment"># -P:是允许外部访问容器需要暴露的port</span></span><br><span class="line"><span class="comment"># -d:是容器的后台运行守护</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#cp 把容器文件copy到宿主机,或者把宿主机的文件copy到容器</span></span><br><span class="line"><span class="variable">$docker</span> cp 容器id或者name:/home/wwwroot/1.php /home/Lcy/ <span class="comment">#把容器的1.php拷贝到宿主机家目录</span></span><br><span class="line"><span class="variable">$docker</span> cp config.php 容器id或者name:/home/wwwroot/    <span class="comment">#把宿主机的config.php拷贝到容器</span></span><br></pre></td></tr></table></figure></p>
<p><br/></p>
<p><strong>Q:如何挂载主机目录/文件作为数据卷?</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#挂载一个主机目录作为数据卷 /src/webapp[主机目录]:/opt/webapp[容器目录]:rw (权限)</span></span><br><span class="line">$ sudo docker run -d -P --name web -v  /src/webapp:/opt/webapp:rw training/webapp python app.py</span><br><span class="line"><span class="comment"># Docker挂载数据卷的默认权限 rw,ro[只读]          //加入ro后数据卷的数据就无法修改了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载一个本地文件作为数据卷（注意再挂载文件得时候尽量设置ro自读,防止inode不一致报错）</span></span><br><span class="line">$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br><span class="line"><span class="comment"># --rm ：当它退出自动移除容器 即docker ps -aq 不能查询到</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="2-数据卷容器"><a href="#2-数据卷容器" class="headerlink" title="2.数据卷容器"></a>2.数据卷容器</h5><p>描述：IF用户需要在容器之间共享一些持续的数据,最简单的方式就是使用数据卷容器(实际上就是一个普通容器);<br>使用数据卷容器可以让用户在容器之间自由地升级和移动数据卷;</p>
<p><strong>Q: 如何创建一个数据卷容器?</strong><br>首先创建一个数据卷容器dbdata并在其中创建一个数据卷挂载到/dbdata上;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -it -v /dbdate --name dbdate ubuntu</span><br><span class="line"><span class="comment"># 然后在容器中进行使用 创建两个容器db1 / db2</span></span><br><span class="line">$ sudo docker run -it --volumes-from dbdate --name db1 ubuntu</span><br><span class="line">$ sudo docker run -it --volumes-from dbdate --name db2 ubuntu</span><br><span class="line"><span class="comment"># 使用--volumes-from参数所挂载数据卷的容器自身并不需要保持运行状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改目录中其中任何一个文件,其他容器的该目录都会改变</span></span><br><span class="line">$ sudo docker run -d --name db2 --volumes-from db1 tarining/postgresql      <span class="comment">#可以从已有挂载了容器卷的容器来挂载数据卷</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除挂载的容器(dbdata 、 db1 、db2)数据卷饼不会被自动的删除,必须在删除最后一个挂载着它容器时显示使用docker rm -v 命令来指定同时删除关联的容器；</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>Q: 如何删除容器及其数据卷?</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载</span></span><br><span class="line"><span class="variable">$docker</span> run --name web --rm -dit -v /opt:/opt/ centos /bin/bash</span><br><span class="line">5b3d35fe3305fb458e8b33f39d5fedfbd7d9cb1f6742bcf725cfbf2ecd0245fc</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line"><span class="variable">$docker</span> start -i 5b3</span><br><span class="line"><span class="comment"># 建立一个文件</span></span><br><span class="line">[root@5b3d35fe3305 opt]$ <span class="built_in">echo</span> <span class="string">'docker'</span> &gt; containerDokcer.txt</span><br><span class="line"><span class="comment"># 宿主机器目录查看</span></span><br><span class="line">[root@zabbix opt]$ cat containerDokcer.txt</span><br><span class="line">docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载单个文件</span></span><br><span class="line"><span class="variable">$docker</span> run --rm -it -v ~/.bash_history:/root/.bash_history centos /bin/bash</span><br><span class="line"><span class="variable">$docker</span> rm -vf web  <span class="comment">#删除容器和数据卷</span></span><br><span class="line"><span class="variable">$docker</span> ps -a  <span class="comment">#由于使用--rm参数则会在容器退出时候删除容器</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>Q: 数据卷容器如何迁移数据?</strong><br>描述: 可以利用数据卷容器对其中的数据卷进行备份、恢复以实现数据的迁移;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份: 创建一个worker容器 ,将本地当前目录挂载到容器中backup目录,进行选择数据目录备份压缩</span></span><br><span class="line">$ sudo docker run --volumes-from dbdata -v $(<span class="built_in">pwd</span>):/backup --name worker ubuntu tar cvf /backup/backup.tar /dbdate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复: 首先创建一个带有数据卷的容器dbdata2</span></span><br><span class="line">$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br><span class="line"><span class="comment"># 解压备份文件到挂载的数据卷中</span></span><br><span class="line">$ sudo docker run --volumes-from dbdata2 $(<span class="built_in">pwd</span>):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure></p>
<p><br/></p>
<p><strong>实践案例:</strong></p>
<ul>
<li>示例1.创建一个只有读取权限的数据卷到容器内部，此处利用–mount参数进行设置,实现启动一个挂载数据卷的容器,进行容器之间的资源共享;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> volume create myvol  <span class="comment"># 等同于 -&gt; docker volume create --driver local --name myvol</span></span><br><span class="line"><span class="variable">$docker</span> volume ls</span><br><span class="line"><span class="built_in">local</span>               myvol</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。</span></span><br><span class="line"><span class="variable">$docker</span> run -d -P \</span><br><span class="line">  --name web \</span><br><span class="line">  <span class="comment"># -v my-vol:/wepapp \</span></span><br><span class="line">  <span class="comment"># 挂载一个数据卷到容器之中（可读可写）</span></span><br><span class="line">  --mount <span class="built_in">source</span>=my-vol,target=/webapp \</span><br><span class="line">  <span class="comment"># 挂载一个本地主机文件作为数据卷 （只读）</span></span><br><span class="line">  --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history,<span class="built_in">readonly</span> \</span><br><span class="line">  training/webapp \</span><br><span class="line">  sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入webapp修改目录进行修改东文件，在其他容器中验证是否可以进行数据共享交互</span></span><br><span class="line"><span class="variable">$docker</span> run -it --name web2 -v myvol:/webapp centos sh  <span class="comment">#-v 与 --mount产生的效果差不多,只不过后者功能参数更加强大，可以直接挂nfs网络共享文件系统。</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sh</span>-4.2<span class="comment"># cat test.txt  #实现了资源共享</span></span><br><span class="line">asdasdasdasda:</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看数据卷的具体信息</span></span><br><span class="line"><span class="string">"Mounts"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"myvol"</span>,</span><br><span class="line">        <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/myvol/_data"</span>,</span><br><span class="line">        <span class="string">"Destination"</span>: <span class="string">"/webapp"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Mode"</span>: <span class="string">"z"</span>,</span><br><span class="line">        <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除数据卷(注意正在使用的不能删除)</span></span><br><span class="line">docker volume rm `docker volume ls -q`</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br/></p>
<ul>
<li>示例2.利用数据卷容器来备份、恢复、迁移数据卷。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#备份</span></span><br><span class="line"><span class="comment">#首先使用 --volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录</span></span><br><span class="line"><span class="comment">#容器启动后，使用了 tar 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 backup.tar 的文件。</span></span><br><span class="line">$ sudo docker run --volumes-from dbdata -v $(<span class="built_in">pwd</span>):/backup ubuntu -C <span class="string">"tar cvf /backup/backup.tar /dbdata"</span></span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">backup  dbdata  </span><br><span class="line"></span><br><span class="line"><span class="comment">#恢复</span></span><br><span class="line"><span class="comment">#首先创建一个带有空数据卷的容器 dbdata2</span></span><br><span class="line">sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br><span class="line"><span class="comment">#然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载的容器卷中。</span></span><br><span class="line">$ sudo docker run --volumes-from dbdata2 -v $(<span class="built_in">pwd</span>):/backup busybox tar xvf /backup/backup.tar</span><br><span class="line">-rw-r--r-- 1 root  root  5120 5月  24 15:02 dbdata.tar</span><br><span class="line"></span><br><span class="line"><span class="comment">#为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</span></span><br><span class="line">$ sudo docker run --volumes-from dbdata2 busybox /bin/ls /dbdata</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br/></p>
<p><strong>补充说明: -v 参数指定数据持久化目录后添加的<code>:Z</code>与<code>:z</code>的区别</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置selinux标签如果使用selinux，可以添加z或z选项来修改挂载到容器中的主机文件或目录的selinux标签</span></span><br><span class="line"><span class="comment">#:z选项 表示绑定挂载内容在多个容器之间共享。</span></span><br><span class="line"><span class="comment">#:Z选项 表示绑定挂载内容是私有和非共享的。</span></span><br><span class="line"><span class="comment">#重要:当使用绑定与服务挂载时，selinux标签(:z和:Z)以及:ro将被忽略,设置了z选项以指定多个容器可以共享绑定挂载的内容,此时不能使用——mount标记修改selinux标签</span></span><br><span class="line">docker run -d --restart=always --name app -v /disk/webapp/war/:/usr/<span class="built_in">local</span>/tomcat/webapps:z -p 4081:8080 -e JAVA_OPTS=-Dsome.property=value -e Xmx=1536m tomcat-base:6.0.85-jre8</span><br></pre></td></tr></table></figure></p>
<p><br/></p>
<p><strong>总结说明：</strong></p>
<ul>
<li>推荐直接挂载文件目录到容器中,如果直接挂载一个文件到容器中在使用文本编辑工具时候可能会报错;</li>
<li>可以多次使用–volumes-from参数从来多个容器挂载多个数据卷;锁挂载的容器自身并不需要保持在运行状态</li>
<li>推荐使用数据卷和数据容器之外的物理备份存储系统,如RAID或者分布式系统如Ceph,GPFS,HDFS等</li>
</ul>
<hr>
<h4 id="0x02-Docker-网络管理"><a href="#0x02-Docker-网络管理" class="headerlink" title="0x02 Docker 网络管理"></a>0x02 Docker 网络管理</h4><p>描述: 大量互联网服务包括多个服务组件往往需要多个容器之间进行网络通信相互配合,Docker目前提供了映射容器端口与宿主主机和容器互联机制来为容器提网络服务;并且采用Linux系统知道的网络系统来实现对网络服务的支持使之能提供稳定支持以及快速的高性能转发;</p>
<h5 id="1-容器网络原理"><a href="#1-容器网络原理" class="headerlink" title="1.容器网络原理"></a>1.容器网络原理</h5><p>描述: 当 Docker 启动时会自动在主机上创建一个 docker0 虚拟网桥，实际上它是 Linux 的一个 bridge (网桥)，可以理解为一个软件交换机，它会在挂载到它的网口之间进行转发。<br>同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口</p>
<ul>
<li>比如典型的 172.17.42.1，掩码为 255.255.0.0</li>
</ul>
<p>Docker 就创建了在主机和所有容器之间一个虚拟共享网络<br>当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）, 这对接口</p>
<ul>
<li>一端在容器内即 eth0；</li>
<li>另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）</li>
</ul>
<p>通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。<br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190524141116.png" target="_blank" title="WeiyiGeek.Docker网络" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190524141116.png" alt="WeiyiGeek.Docker网络" title="" class=""></a>
                <p>WeiyiGeek.Docker网络</p>
            </figure></p>
<p><br></p>
<p>例如, 当在一台未经过特殊网络配置的centos 或 ubuntu机器上安装完docker之后, 在宿主机上通过ifconfig命令可以看到多了一块名为docker0的网卡;不难想到docker0就不只是一个简单的网卡设备了而是一个网桥。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ifconfig</span></span><br><span class="line">docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255</span><br><span class="line"><span class="variable">$route</span> -n</span><br><span class="line">172.18.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line"></span><br><span class="line"><span class="comment">#下图即为Docker默认网络模式（bridge模式）下的网络环境拓扑图,创建了docker0网桥,并以eth pair连接各容器的网络,容器中的数据通过docker0网桥转发到eth0网卡上。</span></span><br><span class="line"><span class="comment">#网桥(等同于交换机)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在Linux中,可以使用brctl命令查看和管理网桥（需要安装bridge-utils软件包）,比如查看本机上的Linux网桥以及其上的端口：</span></span><br><span class="line"><span class="variable">$yum</span> install bridge-utils</span><br><span class="line"><span class="variable">$brctl</span> show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br-63791a62ad5a   8000.024258a66d6e       no        veth4ce6e0e</span><br><span class="line">                                                    vethe5abf0f</span><br><span class="line">br-6cde78afe495   8000.02420a2496c6       no      veth93e8dc0</span><br><span class="line">                                                  vethfda7b14</span><br><span class="line">docker0   8000.024216e63d3c       no</span><br><span class="line"></span><br><span class="line"><span class="comment">#docker0网桥是在Docker daemon启动时自动创建的,其IP默认为172.18.0.1/16,之后创建的Docker容器都会在docker0子网的范围内选取一个未占用的IP使用,并连接到docker0网桥上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#除了使用docker0网桥外,还可以使用自己创建的网桥,比如创建一个名为br0的网桥,配置IP：</span></span><br><span class="line">brctl  addbr br0</span><br><span class="line">ifconfig  br0 18.18.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#在Docker容器和外界通信的过程中,还涉及了数据包在多个网卡间的转发（如从docker0网卡转发到宿主机ens160网卡）</span></span><br><span class="line"><span class="comment">#需要内核将ip-forward功能打开即将ip_forward系统参数设1</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190512212737.png" target="_blank" title="WeiyiGeek.bridge模式图" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190512212737.png" alt="WeiyiGeek.bridge模式图" title="" class=""></a>
                <p>WeiyiGeek.bridge模式图</p>
            </figure></p>
<p><br></p>
<p>在Docker在1.9版本中network子命令和跨主机网络支持,为了标准化网络的驱动开发步骤和支持多种网络驱动,Docker公司在libnetwork中使用了CNM（Container Network Model）定义了构建容器虚拟化网络的模型。<br><em>libnetwork和Docker daemon及各个网络驱动的关系图：</em><br>Docker daemon通过调用libnetwork对外提供的API完成网络的创建和管理等功能,libnetwrok中则使用了CNM来完成网络功能的提供;<br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190512201625.png" target="_blank" title="WeiyiGeek." data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190512201625.png" alt="WeiyiGeek." title="" class=""></a>
                <p>WeiyiGeek.</p>
            </figure></p>
<p>CNM中主要有沙盒（sandbox）、端点（endpoint）、网络（network）3种组件:</p>
<ul>
<li>(1)Sandbox:包含了一个容器网络栈的信息,实现对容器的接口、路由和DNS设置等进行管理;</li>
<li>(2)Endpoint:它可以加入一个沙盒和一个网络,且一个端点只可以属于一个网络并且只属于一个沙盒;</li>
<li>(3)Network:可以直接互相联通的端点(包含多个端点),网络的实现可以是Linux bridge、VLAN等</li>
</ul>
<p>libnetwork共有5种内置驱动：bridge驱动、host驱动、overlay驱动、remote驱动、null驱动。</p>
<ul>
<li>(1)bridge驱动: Docker默认设置驱动,它可以将创建出来的Docker容器连接到Docker网桥常规方法能满足容器基础需求,然后在复杂场景下使用又诸多限制(使用NAT转发)</li>
<li>(2)host驱动：它将不为Docker容器创建网络协议栈(不会创建独立的network namespace),即容器于宿主机共用一个network namespace并使用宿主机的网卡/IP端口等等信息,该驱动适用于对于容器集群规模不大的场景;</li>
<li>(3)overlay驱动: 采用IETE标准的VXLAN方式,并且是VXLAN中被普遍认为最适合大规模的云计算虚拟化环境的SDN controller模式,使用时候需要额外的配置存储服务(例如Consul、etcd和zookeeper)</li>
<li>(4)remote驱动: 该驱动并未做真正的网络服务实现而是调用了用户自行实现的网络驱动插件,使libnetwork实现了驱动的可插件化,更好地满足了用户的多种需求</li>
<li>(5)null驱动: 容器拥有自己的网络命名空间,但并不为Docker容器进行任何网络配置;容器除了network namespace自带的loopback网卡名,没有其他任何网卡、IP、路由等信息(需要用户对齐配置)</li>
</ul>
<p><br/></p>
<h5 id="2-容器网络实践"><a href="#2-容器网络实践" class="headerlink" title="2.容器网络实践"></a>2.容器网络实践</h5><p><strong>(1)端口映射实现访问容器</strong><br>通过-P或者-p来指定端口,</p>
<ul>
<li>使用-P时候：会进行选择 49000 ~ 49900 端口随机分配映射;</li>
<li>使用-p时候：会让你您设置固定与容器映射的端口;</li>
</ul>
<p>支持的格式：</p>
<ul>
<li>hostPort:containerPort &lt; 映射到本地指定端口以及容器端口</li>
<li>ip:hostPort:containerPort &lt; 映射到本地指定地址以及本地指定端口和容器端口</li>
<li>ip::containerPort &lt; 映射本地指定IP的任意端口和容器端口 (注意此处是::)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#随机开启端口</span></span><br><span class="line"><span class="variable">$sudo</span> docker run -d -P centos python app.py </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看转发的端口</span></span><br><span class="line"><span class="variable">$docker</span> ps -l   </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看详细的日志信息</span></span><br><span class="line"><span class="variable">$sudo</span> docker logs -f [NAMES] </span><br><span class="line"></span><br><span class="line"><span class="comment">#1.映射所有接口地址 [将本地的5000端口映射到容器的5000端口]</span></span><br><span class="line"><span class="variable">$sudo</span> docker run -d -p 5000:5000 centos python app.py </span><br><span class="line"><span class="comment">#2.映射指定地址指定端口</span></span><br><span class="line"><span class="variable">$sudo</span> docker run -d -p 127.0.0.1:5000:5000 centos python app.py </span><br><span class="line"><span class="comment">#3.映射指定地址到的任意端口 还能使用tcp标记来指定udp端口</span></span><br><span class="line"><span class="variable">$sudo</span> docker run -d -p 127.0.0.1::5000/tcp centos python app.py </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看端口映射配置</span></span><br><span class="line"><span class="variable">$sudo</span> docker port [NAMES] 5000 <span class="comment">#容器Port</span></span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><strong>(2)实现容器间通信</strong><br>容器的链接(Linking)系统是除了端口映射外的另一种可以与容器中应用进行交换的方式;它会在源和接收容器之间创建一个隧道,接收容器可以看到源容器指定的信息;</p>
<p>Docker两种方式为容器公开连接信息:</p>
<ul>
<li>1.环境变量   </li>
<li>2.更新/etc/hosts</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先创建一个新的数据库容器,启动db容器的时候并没有使用-p与-P标记，避免了暴露数据库端口到外部网络上</span></span><br><span class="line"><span class="variable">$sudo</span> docker run -d --name db tranining/postgres</span><br><span class="line"></span><br><span class="line"><span class="comment">#使db容器与web容器建立互联关系;</span></span><br><span class="line"><span class="comment">#--link name:alias  其中namd是链接的容器的名称,alias是这个链接的别名.</span></span><br><span class="line">$ sudo docker run -d -P --name web --link db:db training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 docker ps 来查看容器的连接</span></span><br><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STAT</span><br><span class="line">US PORTS NAMES</span><br><span class="line">349169744e49 training/postgres:latest su postgres -c <span class="string">'/usr About a minute ago Up About a minute 5432/tcp db, web/db'</span></span><br><span class="line"><span class="comment">#web/db这表示web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用env命令来查看web容器的环境变量</span></span><br><span class="line"><span class="variable">$sudo</span> docker run --rm --name web1 --link db:db training/webapp env</span><br><span class="line"><span class="comment">#起点汇总DB_开头的环境变量是提供web容器连接到db使用,前缀采用大写的链接别名</span></span><br><span class="line">DB_NAME=/web2/db</span><br><span class="line">DB_PORT=tcp://172.17.0.5:5432</span><br><span class="line">DB_PORT_5000_TCP=tcp://172.17.0.5:5432</span><br><span class="line">DB_PORT_5000_TCP_PROTO=tcp</span><br><span class="line">DB_PORT_5000_TCP_PORT=5432</span><br><span class="line">DB_PORT_5000_TCP_ADDR=172.17.0.5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#同时Docker还添加host信息到父容器的/etc/hosts文件</span></span><br><span class="line"><span class="variable">$sudo</span> docker run -it --rm --link db:db training/webapp /bin/bash</span><br><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure>
<p>实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> pull nginx</span><br><span class="line"><span class="variable">$docker</span> run -d -p 80:80 --name web nginx</span><br><span class="line"><span class="variable">$docker</span> container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES</span><br><span class="line">16207d8f2291        nginx               <span class="string">"nginx -g 'daemon of…"</span>   19 seconds ago      Up 18 seconds       0.0.0.0:80-&gt;80/tcp   web</span><br><span class="line"><span class="comment">#容器有自己的内部网络和IP地址,使用docker inspect + 容器ID 可以获取所有的变量值;</span></span><br><span class="line"><span class="variable">$docker</span> inspect web</span><br><span class="line"><span class="string">"Gateway"</span>: <span class="string">"172.18.0.1"</span>,</span><br><span class="line"><span class="string">"IPAddress"</span>: <span class="string">"172.18.0.2"</span>,</span><br><span class="line"><span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:12:00:02"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后打开80端口进行访问采用logs打印访问</span></span><br><span class="line"><span class="variable">$docker</span> logs -f web</span><br><span class="line">218.x.x.xx - - [08/May/2019:15:00:11 +0000] <span class="string">"GET / HTTP/1.1"</span> 304 0 <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0"</span> <span class="string">"-"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进行link关联容器使之能进行正常通信</span></span><br><span class="line">[root@izwz9biz2m4sd3bb3k38pgz ~]<span class="variable">$docker</span> run -d --name web1 --link web:nginx_web alpine cat /etc/hosts</span><br><span class="line">ebe1df8c1fb00462b127d36201d558a9f62507c81faea1ce6c4bf4b5ea6075e3</span><br><span class="line"></span><br><span class="line">[root@izwz9biz2m4sd3bb3k38pgz ~]<span class="variable">$docker</span> run -d --name web2 --link web:nginx_web alpine env</span><br><span class="line">baa9dfe5f64519eb5ccbd122fc191e0f40118a4ee28385a818f7ffe6e2e03639</span><br><span class="line"></span><br><span class="line">[root@izwz9biz2m4sd3bb3k38pgz ~]<span class="variable">$docker</span> start -i web1</span><br><span class="line">172.18.0.2      nginx_web 16207d8f2291 web  <span class="comment">#成功添加web</span></span><br><span class="line">172.18.0.3      ebe1df8c1fb0</span><br><span class="line"></span><br><span class="line">[root@izwz9biz2m4sd3bb3k38pgz ~]<span class="variable">$docker</span> start -i web2</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=baa9dfe5f645</span><br><span class="line">NGINX_WEB_PORT=tcp://172.18.0.2:80  <span class="comment">#web2也成功添加web</span></span><br><span class="line">NGINX_WEB_PORT_80_TCP=tcp://172.18.0.2:80</span><br><span class="line">NGINX_WEB_PORT_80_TCP_ADDR=172.18.0.2</span><br><span class="line">NGINX_WEB_PORT_80_TCP_PORT=80</span><br><span class="line">NGINX_WEB_PORT_80_TCP_PROTO=tcp</span><br><span class="line">NGINX_WEB_NAME=/web2/nginx_web</span><br><span class="line">NGINX_WEB_ENV_NGINX_VERSION=1.15.12-1~stretch</span><br><span class="line">NGINX_WEB_ENV_NJS_VERSION=1.15.12.0.3.1-1~stretch</span><br></pre></td></tr></table></figure><br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190508230052.png" target="_blank" title="WeiyiGeek.访问容器映射出网站" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190508230052.png" alt="WeiyiGeek.访问容器映射出网站" title="" class=""></a>
                <p>WeiyiGeek.访问容器映射出网站</p>
            </figure></p>
<p><br></p>
<p><strong>(3)libnetwork库官方示例</strong></p>
<p>libnetwork官方示例图:<br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190512203038.png" target="_blank" title="WeiyiGeek.libnetwork" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190512203038.png" alt="WeiyiGeek.libnetwork" title="" class=""></a>
                <p>WeiyiGeek.libnetwork</p>
            </figure></p>
<p>执行流程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker内置的默认默认网卡是是无法使用docker network rm进行删除;</span></span><br><span class="line"><span class="variable">$docker</span> network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">f26c3ed5f7b0        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">fd3572aceb38        host                host                <span class="built_in">local</span></span><br><span class="line">01da6464c812        none                null                <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 1.创建名为backend、frontend两个网络</span></span><br><span class="line"><span class="variable">$docker</span> network create backend</span><br><span class="line">6cde78afe495a310bb27c5e1a50074b20e204bfa72e71bcaf6a4c37feb300b93</span><br><span class="line"><span class="variable">$docker</span> network create frontend</span><br><span class="line">63791a62ad5a5fe4aeb5926616b2ea1d65b490bb9fb718824b7cb1c408ae50c1</span><br><span class="line"><span class="variable">$docker</span> network create -d bridge <span class="built_in">test</span>-net</span><br><span class="line"><span class="comment">#-d：参数指定 Docker 网络类型，有 bridge、overlay/none。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 2. 将c1与c2的容器加入到backend网络中,将c3容器加入到frontend网络中</span></span><br><span class="line"><span class="variable">$docker</span> run -itd --name c1 --net backend alpine</span><br><span class="line">729f2abef71ceaf831999d66264d05f78674d9cd2c235f84481a14b366698adb</span><br><span class="line"><span class="variable">$docker</span> run -itd --name c2 --net backend alpine</span><br><span class="line">26d47af2d39a1b00f767c60a68cd5f61f1cf5f48652cdcbcb0216968a3185f5e</span><br><span class="line"><span class="variable">$docker</span> run -itd --name c3 --net frontend alpine</span><br><span class="line">9cb94f7c66955ba5a95c90d08ce314da0e477f6eddbcea0329309ec36ca5a711</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 3. 分别进入c1和c3容器使用ping命令测试其与c2的连通性,因为c1和c2都在backend网络中,所以两者可以连通。但是因为c3和c2不在一个网络中,所以两个容器之间不能连通：</span></span><br><span class="line"><span class="comment"># 使用docker inspect c3 查看IP信息：</span></span><br><span class="line">C1: 172.19.0.2</span><br><span class="line">C2: 172.19.0.3</span><br><span class="line">C3: <span class="string">"IPAddress"</span>: <span class="string">"172.20.0.2"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入c1容器ping c2通、ping c3不通。其它两个容器就不进入演示了,大家自己可以试一下：</span></span><br><span class="line"><span class="comment"># docker exec -it c1 sh</span></span><br><span class="line"><span class="comment"># ip addr</span></span><br><span class="line">18: eth0@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:13:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.2/16 brd 172.19.255.255 scope global eth0</span><br><span class="line"><span class="comment"># ping c2</span></span><br><span class="line">PING c2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.065 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.050 ms</span><br><span class="line">/ <span class="comment"># ping 172.20.0.2</span></span><br><span class="line">PING 172.20.0.2 (172.20.0.2): 56 data bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4. 将c2连接加入到front网络中,使用exec进入c2中查看网卡信息,测试c2与c3的连通性后,可以发现两者已经连通</span></span><br><span class="line"><span class="variable">$docker</span> network connect frontend c2</span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it c2 sh</span><br><span class="line">/ $ ip addr</span><br><span class="line">20: eth0@if21: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:13:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.19.0.3/16 brd 172.19.255.255 scope global eth0</span><br><span class="line">24: eth1@if25: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:14:00:03 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.20.0.3/16 brd 172.20.255.255 scope global eth1</span><br><span class="line"></span><br><span class="line">/ $ ping c3</span><br><span class="line">PING c3 (172.20.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.20.0.2: seq=0 ttl=64 time=0.100 ms</span><br></pre></td></tr></table></figure></p>
<p><br/></p>
<p><strong>(4) 跨主机实现互通</strong><br>描述: 此外我们还可以通过通过添加路由route的方式进行跨主机实现互通，但是通常情况下我们不会如此操作，只在特殊环境中使用测试。</p>
<p>比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker1: 172.18.0.1/24 --Gateways-- 192.168.1.99</span><br></pre></td></tr></table></figure></p>
<p>总结说明：</p>
<ul>
<li>用户可以链接多个子容器到父容器中比如连接多个web到db容器上;</li>
<li>学习额外的机制比如SDN(软件定义网络)或者NFV(网络功能虚拟化)的相关技术</li>
</ul>
<p><br></p>
<h5 id="3-高级网络配置"><a href="#3-高级网络配置" class="headerlink" title="3.高级网络配置"></a>3.高级网络配置</h5><p>描述: 容器互联 随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数</p>
<p><em>如何自定义配置容器的主机名和 DNS 呢？</em><br>答：Docker 会默认用主机上的 /etc/resolv.conf 来配置容器, 所以可以直接在宿主机上的resolv.conf文件中进行更改,也可以在/etc/docker/daemon.json 文件中增加DNS键值对是一个数组;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建网络</span></span><br><span class="line">docker network create -d bridge my-net</span><br><span class="line"><span class="comment">#分别启动两个容器(然后进入互ping查看)</span></span><br><span class="line"><span class="variable">$docker</span> run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line"><span class="variable">$docker</span> run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件,在容器中使用 mount 命令可以看到挂载信息</span></span><br><span class="line"><span class="comment">#可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。</span></span><br><span class="line">/dev/mapper/cl-root on /etc/resolv.conf <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">/dev/mapper/cl-root on /etc/hostname <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">/dev/mapper/cl-root on /etc/hosts <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line"><span class="comment">#Docker 1.2.0 开始支持在运行中的容器里编辑 /etc/hosts, /etc/hostname 和 /etc/resolv.conf 文件。</span></span><br><span class="line"><span class="comment">#但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 docker commit 提交。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#宿主机更改后立即生效(容器重新进入的时候)</span></span><br><span class="line"><span class="variable">$docker</span> start -i 81fa</span><br><span class="line">sh-4.2<span class="comment"># cat /etc/resolv.conf</span></span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 192.168.10.254</span><br><span class="line">nameserver 61.128.128.68</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure>
<p><br/></p>
<p><strong>容器访问控制</strong><br>容器的访问控制，主要通过 Linux 上的 iptables 防火墙来进行管理和实现.<br>容器访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sysctl</span> net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果在启动 Docker 服务的时候设定 --ip-forward=true, Docker 就会自动设定系统的 ip_forward 参数为 1。</span></span><br><span class="line"><span class="variable">$sysctl</span> -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure></p>
<p>容器之间访问需要两方面的支持：</p>
<ul>
<li>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 docker0 网桥上。</li>
<li>本地系统的防火墙软件 – iptables 是否允许通过。<br>动容器（docker run）时使用 –link=CONTAINER_NAME:ALIAS 选项,就会在宿主机上添加了 iptables 规则。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -nL</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80</span><br><span class="line">ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<ul>
<li>容器访问外部实现:容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址</li>
<li>外部访问容器实现:可以在 docker run 时候通过 -p 或 -P 参数来启用。</li>
</ul>
<p>不管用那种办法，其实也是在本地的 iptable 的 nat 表中添加相应的规则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> iptables -t nat -nL</span><br><span class="line"><span class="comment">#其中，上述规则将所有源地址在 172.17.0.0/16 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。</span></span><br><span class="line"><span class="comment">#MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</span></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用端口映射的时候</span></span><br><span class="line">chain DOCKER (2 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br></pre></td></tr></table></figure></p>
<p><br/></p>
<p><strong>docker 网桥</strong><br>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。<br>Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值,值都可以在服务启动的时候进行配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#由于目前 Docker 网桥是 Linux 网桥，用户可以使用 brctl show 来查看网桥和端口连接信息。</span></span><br><span class="line"><span class="variable">$brctl</span> show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.0242f0960e9f       no              veth4fe5b74</span><br><span class="line"></span><br><span class="line"><span class="comment">#每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关。</span></span><br><span class="line">$ sudo docker run -i -t --rm base /bin/bash</span><br><span class="line"><span class="variable">$ip</span> addr show eth0</span><br><span class="line"><span class="variable">$ip</span> route</span><br><span class="line">default via 172.17.42.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0  proto kernel  scope link  src 172.17.0.3</span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义网桥：</span></span><br><span class="line"><span class="comment">#用户也可以指定网桥来连接各个容器,在启动 Docker 服务的时候，使用 -b BRIDGE或--bridge=BRIDGE 来指定使用的网桥。</span></span><br><span class="line">1. 如果服务已经运行，那需要先停止服务，并删除旧的网桥。</span><br><span class="line">$ sudo systemctl stop docker</span><br><span class="line">$ sudo ip link <span class="built_in">set</span> dev docker0 down <span class="comment">#将网卡处于非工作状态</span></span><br><span class="line">$ sudo brctl delbr docker0   <span class="comment">#删除默认网桥</span></span><br><span class="line">$ sudo brctl addbr bridge0   <span class="comment">#然后创建一个网桥 bridge0。</span></span><br><span class="line">$ sudo ip addr add 192.168.5.1/24 dev bridge0</span><br><span class="line">$ sudo ip link <span class="built_in">set</span> dev bridge0 up  <span class="comment">#查看确认网桥创建并启动。</span></span><br></pre></td></tr></table></figure><br>注：brctl 命令在 Debian、Ubuntu /Centsos采用相同的包中可以使用 sudo apt-get install bridge-utils 来安装。</p>
<p><br></p>
<p><strong>实践案例：</strong><br>创建一个点到点连接,点到点链路不需要子网和子网掩码。<br>默认情况下，Docker 会将所有容器连接到由 docker0 提供的虚拟子网中,用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。<br>解决办法很简单：创建一对 peer 接口，分别放到两个容器中，配置成点到点链路类型即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> run -it --rm --net=none --name demo1 alpine sh</span><br><span class="line">39ca23ce4417</span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span> run -it --rm --net=none --name demo2 alpine sh</span><br><span class="line">d4b1311349c1</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到进程号，然后创建网络命名空间的跟踪文件。</span></span><br><span class="line"><span class="variable">$docker</span> inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> d4b</span><br><span class="line">6742</span><br><span class="line"><span class="variable">$docker</span> inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> 39c</span><br><span class="line">6807</span><br><span class="line"></span><br><span class="line">sudo mkdir -p /var/run/netns</span><br><span class="line">sudo ln -s /proc/6742/ns/net /var/run/netns/6742</span><br><span class="line">sudo ln -s /proc/6807/ns/net /var/run/netns/6807</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一对A B peer 接口，然后配置路由</span></span><br><span class="line">$ sudo ip link add A <span class="built_in">type</span> veth peer name B</span><br><span class="line"></span><br><span class="line">$ sudo ip link <span class="built_in">set</span> A netns 6742</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 6742 ip addr add 10.1.1.1/32 dev A</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 6742 ip link <span class="built_in">set</span> A up</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 6742 ip route add 10.1.1.2/32 dev A</span><br><span class="line"></span><br><span class="line">$ sudo ip link <span class="built_in">set</span> B netns 6807</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 6807 ip addr add 10.1.1.2/32 dev B</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 6807 ip link <span class="built_in">set</span> B up</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> 6807 ip route add 10.1.1.1/32 dev B</span><br><span class="line"></span><br><span class="line"><span class="comment">#现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</span></span><br><span class="line">容器$ ip addr</span><br></pre></td></tr></table></figure><br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190524150638.png" target="_blank" title="WeiyiGeek.点到点通信" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190524150638.png" alt="WeiyiGeek.点到点通信" title="" class=""></a>
                <p>WeiyiGeek.点到点通信</p>
            </figure></p>
<hr>
<h4 id="0x03-Registry-私有镜像仓库搭建实践"><a href="#0x03-Registry-私有镜像仓库搭建实践" class="headerlink" title="0x03 Registry 私有镜像仓库搭建实践"></a>0x03 Registry 私有镜像仓库搭建实践</h4><h5 id="1-前言简述"><a href="#1-前言简述" class="headerlink" title="1.前言简述"></a>1.前言简述</h5><p>描述: 镜像仓库主要是用来存储和分发镜像的，并对外提供一套 HTTP API V2。镜像仓库中的所有镜像，都是以数据块 (Blob) 的方式存储在文件系统中。 支持多种文件系统，主要包括filesystem，S3，Swift，OSS等。 </p>
<p>docker 的 registry 项目参考地址：<a href="https://docs.docker.com/registry/" target="_blank" rel="noopener">https://docs.docker.com/registry/</a></p>
<p><strong>产生原因:</strong><br>Docker hub是公开的其他人也是可以下载并不安全因此还可以使用docker registry官方提供的私有仓库;但是我们默认在机器上搭建的registry私有仓库是不需要验证的,因此我们需要进行安全配置仓库并加入认证;</p>
<p><strong>Docker Registry由三个部分组成:</strong></p>
<ul>
<li>index: 负责登录、负责认证、负责存储镜像信息和负责对外显示的外部实现.</li>
<li>registry: 负责存储镜像的内部实现.</li>
<li>registry client: 则是docker 客户端.</li>
</ul>
<p><br></p>
<h5 id="2-搭建使用"><a href="#2-搭建使用" class="headerlink" title="2.搭建使用"></a>2.搭建使用</h5><p>描述: registry 私有镜像仓库搭建流程如下所示。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.下载registry仓库并设置数据存放的目录(并生成认证账号密码)</span></span><br><span class="line">docker pull registry:2</span><br><span class="line"></span><br><span class="line">mkdir -vp /opt/data/auth   <span class="comment">#宿主机认证目录</span></span><br><span class="line">mkdir -vp /opt/data/registry  <span class="comment">#宿主机仓库目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用--entrypoint进行执行</span></span><br><span class="line">docker run --entrypoint htpasswd httpd:2 -Bbn  testuser testpassword &gt; auth/htpasswd</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.运行下载的仓库镜像(我们常常指定一个本地数据卷给容器)</span></span><br><span class="line">docker run -d -p 5000:5000 --name registry -v /opt/data/registry:/var/lib/registry registry:2  <span class="comment">#未认证</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 加入认证 (已失效)</span></span><br><span class="line">docker run -d -p 5000:5000 --restart=always --name docker-hub \</span><br><span class="line">  -v /opt/data/registry:/var/lib/registry \</span><br><span class="line">  -v /opt/data/auth:/auth \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd"</span> \</span><br><span class="line">  registry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制</span></span><br><span class="line"><span class="comment"># 3.修改docker的配置文件，让他支持http方式，上传私有镜像 （本地）</span></span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">    <span class="comment"># 写入如下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirror"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"10.10.107.221:5000"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.修改docker的服务配置文件(Ubuntu此步骤可以跳过)</span></span><br><span class="line">vim /lib/systemd/system/docker.service</span><br><span class="line"><span class="comment"># 找到[service]这一代码区域块，写入如下参数</span></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.重新加载docker服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.重启docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 注意:重启docker服务，所有的容器都会挂掉</span></span><br><span class="line">docker run -d -p 5000:5000 --name docker-registry -v /opt/data/registry:/var/lib/registry registry</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.修改本地镜像的tag标记，往自己的私有仓库推送</span></span><br><span class="line"><span class="comment">#docker tag weiyigeek/hello-world-docker 10.10.107.221:5000/weiyigeek  #对于修改名称的</span></span><br><span class="line"><span class="variable">$docker</span> commit -m <span class="string">"alpine-sh"</span> -a <span class="string">"weiyigeek"</span> a63 10.10.107.221:5000/alpine-sh</span><br><span class="line">sha256:b75ef26a9e1d92924914edcb841de8b7bdc0b336cea2c6cfbaaf6175e24472c6</span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span> login 10.10.107.221:5000</span><br><span class="line">Username: testuser</span><br><span class="line">Password:</span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/<span class="comment">#credentials-store</span></span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line"></span><br><span class="line"><span class="comment">#上传我们的镜像文件</span></span><br><span class="line"><span class="variable">$docker</span> push 10.10.107.221:5000/alpine-sh</span><br><span class="line">The push refers to repository [10.10.107.221:5000/alpine-sh]</span><br><span class="line">2a499f806f16: Pushed</span><br><span class="line">f1b5933fe4b5: Pushed</span><br><span class="line">latest: digest: sha256:6d13420cb9ce74095e2a71f565fc8c15ba17b40933e14534fc65775025eedd18 size: 735</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8.下载私有仓库的镜像(查看)</span></span><br><span class="line">docker pull 10.10.107.221:5000/weiyige</span><br><span class="line"><span class="comment"># http://10.10.107.221:5000/v2/_catalog  #查看仓库 需要进行认证</span></span><br><span class="line"><span class="comment"># http://10.10.107.221:5000/v2/[image_name]/tags/list #查看镜像版本列表</span></span><br><span class="line">curl -XGET  http://10.10.107.221:5000/v2/_catalog -u testuser:testpassword</span><br><span class="line">&#123;<span class="string">"repositories"</span>:[<span class="string">"alpine-sh"</span>]&#125;</span><br></pre></td></tr></table></figure><br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190521115237.png" target="_blank" title="WeiyiGeek.docker仓库" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190521115237.png" alt="WeiyiGeek.docker仓库" title="" class=""></a>
                <p>WeiyiGeek.docker仓库</p>
            </figure></p>
<p>可以从下图看到设置账号密码认证后直接访问Registry API将受到限制<br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190521155650.png" target="_blank" title="WeiyiGeek.regsitryLoginAuth" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190521155650.png" alt="WeiyiGeek.regsitryLoginAuth" title="" class=""></a>
                <p>WeiyiGeek.regsitryLoginAuth</p>
            </figure></p>
<p><br></p>
<h5 id="3-补充说明"><a href="#3-补充说明" class="headerlink" title="3.补充说明"></a>3.补充说明</h5><h6 id="1-对Registry镜像仓库与Harbor仓库特征说明"><a href="#1-对Registry镜像仓库与Harbor仓库特征说明" class="headerlink" title="(1) 对Registry镜像仓库与Harbor仓库特征说明"></a>(1) 对Registry镜像仓库与Harbor仓库特征说明</h6><p>描述: 通过 <code>Registry API</code> 获得的两个镜像仓库中<code>相同镜像的 manifest 信息的存储路径和内容完全相同</code>, 并且两个镜像仓库中相同镜像的 <code>blob 信息的存储路径和内容完全相同</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (1) Registry API</span></span><br><span class="line">/var/lib/registry</span><br><span class="line"><span class="comment"># (2) Harbor 本地目录中</span></span><br><span class="line">/data/harbor/registry/docker/registry/v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像 Manifest 对应的blob id</span></span><br><span class="line">$ cat repositories/release/cyclone-server/_manifests/tags/v0.5.0-beta.1/current/link</span><br><span class="line">sha256:6d47a9873783f7bf23773f0cf60c67cef295d451f56b8b79fe3a1ea217a4bf98</span><br><span class="line"><span class="comment"># 查看镜像 Manifest </span></span><br><span class="line">$ cat blobs/sha256/6d/6d47a9873783f7bf23773f0cf60c67cef295d451f56b8b79fe3a1ea217a4bf98/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Blob 数据的存储</span></span><br><span class="line"><span class="comment"># 查看镜像 blob 的位置和大小</span></span><br><span class="line">$ du -s blobs/sha256/71/7118e0a5b59500ceeb4c9686c952cae5e8bfe3e64e5afaf956c7098854a2390e/data</span><br><span class="line">7560 blobs/sha256/71/7118e0a5b59500ceeb4c9686c952cae5e8bfe3e64e5afaf956c7098854a2390e/data</span><br></pre></td></tr></table></figure><br><br></p>
<h6 id="2-为Registry私有镜像仓库配置auth认证与tls证书"><a href="#2-为Registry私有镜像仓库配置auth认证与tls证书" class="headerlink" title="(2) 为Registry私有镜像仓库配置auth认证与tls证书"></a>(2) 为Registry私有镜像仓库配置auth认证与tls证书</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建参数</span></span><br><span class="line">docker run -d \</span><br><span class="line">  -p 443:443 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name registry \</span><br><span class="line">  -v /app/registry/data:/var/lib/registry \</span><br><span class="line">  -v /app/registry/auth:/auth \</span><br><span class="line">  -v /app/registry/cert:/cert \</span><br><span class="line">  -e <span class="string">"REGISTRY_HTTP_ADDR=0.0.0.0:443"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_HTTP_TLS_CERTIFICATE=/cert/hub.weiyigeek.top.crt"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_HTTP_TLS_KEY=/cert/server.key"</span> \</span><br><span class="line">  registry:2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的registry 容器</span></span><br><span class="line">$ docker ps --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;"</span></span><br><span class="line">CONTAINER ID   NAMES      PORTS</span><br><span class="line">c8657bd20936   registry   0.0.0.0:443-&gt;443/tcp, 5000/tcp</span><br></pre></td></tr></table></figure>
<p><br></p>
<h6 id="3-登陆远程仓库时报证书签名错误及其解决办法"><a href="#3-登陆远程仓库时报证书签名错误及其解决办法" class="headerlink" title="(3) 登陆远程仓库时报证书签名错误及其解决办法"></a>(3) 登陆远程仓库时报证书签名错误及其解决办法</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~$ docker login hub.weiyigeek.top</span><br><span class="line">Login did not succeed, error: Error response from daemon: Get https://hub.weiyigeek.top/v2/: x509: certificate signed by unknown authority</span><br><span class="line">Username: WeiyiGeek</span><br><span class="line">Password: ********</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决办法:</span></span><br><span class="line"><span class="comment"># (1) 在 /etc/docker/daemon.json 中配置insecure-registries字段,表示允许不安全的仓库。</span></span><br><span class="line"><span class="string">"insecure-registries"</span>: [<span class="string">"192.168.12.111:5000"</span>,<span class="string">"hub.weiyigeek.top"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) 从官方文档可知客户端要使用tls与Harbor通信使用的还是`自签证书`，那么必须建立一个目录`/etc/docker/certs.d`</span></span><br><span class="line"><span class="comment"># 如果配置可能会出现 x509: certificate signed by unknown authority 错误提示。</span></span><br><span class="line">mkdir -vp /etc/docker/certs.d/hub.weiyigeek.top</span><br><span class="line">cp -a /deployapp/harbor/harbor.pem  /etc/docker/certs.d/hub.weiyigeek.top/harbor.crt</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="0x03-Docker-Compose-容器编排"><a href="#0x03-Docker-Compose-容器编排" class="headerlink" title="0x03 Docker-Compose 容器编排"></a>0x03 Docker-Compose 容器编排</h4><p>描述：Docker Compose 是使用 Python 开发的一款基于 Docker 容器进行编排的工具，定义和运行多容器的应用可以一条命令启动多个容器, 从提到的Docker-Machine种可以将用户在其他平台快速安装Docker，而Swarm可以让Docker容器在集群种高效运转，而Compose则可以让用户在集群中部署分布式应用。</p>
<p>从功能上看跟 OpenStack 中的 Heat 十分类似，Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。<br>简单的说: Docker Compose 属于一个应用层的服务，用户可以定义哪一个容器组运行那些应用，它支持动态改变应用并在需要时扩展;</p>
<p>产生原因：由于单纯的使用Dockerfile只能设置一个Docker镜像且采用多阶段构建的时候entrypoint指令只能存在一个,为了解决这个问题引入了Docker Compose机制;它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project），免去我们需要多次执行docker run命令的烦恼;</p>
<p>其代码目前在：<a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p>
<p><em>Docker Compose 优点：</em></p>
<ul>
<li>安装与使用非常简单的</li>
<li>能够帮我们处理容器的依赖关系，在每个容器中会将容器的 IP 和服务的名称使用 hosts 的方式绑定，这样我们就能在容器中直接使用服务名称来接入对应的容器了</li>
<li>使用 docker-compose.yaml 配置的形式将你需要启动的容器管理起来。</li>
</ul>
<p><em>使用Compose 基本上分为三步：</em></p>
<ul>
<li>Dockerfile 定义应用的运行环境</li>
<li>docker-compose.yml 定义组成应用的各服务</li>
<li>docker-compose up 启动整个应用</li>
</ul>
<p>Compose 中有两个重要的概念：</p>
<ul>
<li>服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li>
</ul>
<p>应用场景：最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>一个简单的docker-compose.yml配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"2"</span></span><br><span class="line">services:</span><br><span class="line">    nginx:</span><br><span class="line">        depends_on:</span><br><span class="line">          - <span class="string">"php"</span></span><br><span class="line">        image: <span class="string">"nginx:latest"</span></span><br><span class="line">        volumes:</span><br><span class="line">          - <span class="string">"<span class="variable">$PWD</span>/src/docker/conf:/etc/nginx/conf.d"</span></span><br><span class="line">          - <span class="string">"<span class="variable">$PWD</span>:/home/q/system/m_look_360_cn"</span></span><br><span class="line">        ports:</span><br><span class="line">          - <span class="string">"8082:80"</span></span><br><span class="line">        container_name: <span class="string">"m.look.360.cn-nginx"</span></span><br><span class="line">    php:</span><br><span class="line">        image: <span class="string">"lizheming/php-fpm-yaf"</span></span><br><span class="line">        volumes:</span><br><span class="line">            - <span class="string">"<span class="variable">$PWD</span>:/home/q/system/m_look_360_cn"</span></span><br><span class="line">        container_name: <span class="string">"m.look.360.cn-php"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例如下面这个 Nginx 配置中的php:9000就是利用了这个原理。</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name dev.m.look.360.cn;</span><br><span class="line">  charset utf-8;</span><br><span class="line">  root /home/q/system/m_look_360_cn/public;</span><br><span class="line">  index index.html index.htm index.php;</span><br><span class="line">  error_page 500 502 503 504 /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">    root html;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">  location ~ .php$ &#123;</span><br><span class="line">    <span class="comment">##在每个容器中会将容器的 IP 和服务的名称使用 hosts 的方式绑定</span></span><br><span class="line">    fastcgi_pass php:9000;</span><br><span class="line">    <span class="comment">#fastcgi_pass unix:/tmp/fcgi.sock;</span></span><br><span class="line">    fastcgi_index index.php;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h5 id="1-安装配置"><a href="#1-安装配置" class="headerlink" title="1.安装配置"></a>1.安装配置</h5><p>Compose 支持 Linux、macOS、Windows 10 三大平台。</p>
<p>安装方法与流程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pip方式安装</span></span><br><span class="line"><span class="variable">$sudo</span> pip install -U docker-compose</span><br><span class="line"><span class="comment">#采用yum方式安装</span></span><br><span class="line"><span class="variable">$yum</span> install -y docker-compose</span><br><span class="line"><span class="comment">#二进制包 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。</span></span><br><span class="line"><span class="variable">$sudo</span> curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="variable">$sudo</span> chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载</span></span><br><span class="line">sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose  <span class="comment">#如果是二进制包方式安装的，删除二进制文件即可。</span></span><br><span class="line">sudo pip uninstall docker-compose    <span class="comment">#如果是通过 pip 安装的，则执行如下命令即可删除。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装成功测试</span></span><br><span class="line"><span class="variable">$docker</span>-compose --version</span><br><span class="line">docker-compose version 1.18.0, build 8dd22a9</span><br></pre></td></tr></table></figure></p>
<p>容器中执行：Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/docker/compose/releases/download/1.8.0/run.sh &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">$ chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.23.2/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他安装方式</span></span><br><span class="line">[root@localhost ~]<span class="comment"># pip3 -V</span></span><br><span class="line">pip 9.0.3 from /usr/lib/python3.6/site-packages (python 3.6)</span><br><span class="line">[root@localhost ~]<span class="comment"># pip3 install docker-compose</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker-compose version</span></span><br><span class="line">docker-compose version 1.25.3, build unknown</span><br><span class="line">docker-py version: 4.1.0</span><br><span class="line">CPython version: 3.6.8</span><br><span class="line">OpenSSL version: OpenSSL 1.1.1c FIPS  28 May 2019</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="2-命令一览"><a href="#2-命令一览" class="headerlink" title="2.命令一览"></a>2.命令一览</h5><p>Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker命令的基本的使用格式是</span></span><br><span class="line">docker-compose [options] [COMMAND] [ARGS...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看帮助</span></span><br><span class="line">docker-compose [COMMAND] --<span class="built_in">help</span> 或者 docker-compose <span class="built_in">help</span> [COMMAND]</span><br></pre></td></tr></table></figure></p>
<p><strong>命令选项：</strong></p>
<ul>
<li>-f, –file FILE   指定使用的 Compose 模板文件，默认为 docker-compose.yml可以多次指定。</li>
<li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li>–x-networking 使用 Docker 的可拔插网络后端特性</li>
<li>–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</li>
<li>–verbose 输出更多调试信息。</li>
<li>-v, –version 打印版本并退出。</li>
</ul>
<p><strong>命令使用说明:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">build  <span class="comment">#构建（重新构建）项目中的服务容器，可以随时在项目目录下运行 docker-compose build 来重新构建服务。</span></span><br><span class="line">config <span class="comment">#验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</span></span><br><span class="line">up / down  <span class="comment">#此命令将会启动/停止 up命令所启动的容器(up是非常重要的)，并创建/移除网络</span></span><br><span class="line"><span class="built_in">exec</span>  <span class="comment">#进入指定的容器。</span></span><br><span class="line"><span class="built_in">help</span></span><br><span class="line">images  <span class="comment">#列出 Compose 文件中包含的镜像。</span></span><br><span class="line"><span class="built_in">kill</span>  <span class="comment">#通过发送 SIGKILL 信号来强制停止服务容器，支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</span></span><br><span class="line">logs  <span class="comment">#查看服务容器的输出以不同颜色来区分,可以通过 --no-color 来关闭颜色。</span></span><br><span class="line">port  <span class="comment">#打印某个容器端口所映射的公共端口。</span></span><br><span class="line">ps   <span class="comment">#列出项目中目前的所有容器。</span></span><br><span class="line">pull  <span class="comment">#拉取服务依赖的镜像。</span></span><br><span class="line">push  <span class="comment">#推送服务依赖的镜像到 Docker 镜像仓库。</span></span><br><span class="line">run   <span class="comment">#在指定服务上执行一个命令(重点)</span></span><br><span class="line">scale  <span class="comment">#设置指定服务运行的容器个数。</span></span><br><span class="line">start  <span class="comment">#启动已经存在的服务容器。</span></span><br><span class="line">pause  <span class="comment">#暂停一个服务容器。</span></span><br><span class="line">unpause <span class="comment">#恢复处于暂停状态中的服务。</span></span><br><span class="line">restart <span class="comment">#重启项目中的服务。</span></span><br><span class="line">stop  <span class="comment">#停止已经处于运行状态的容器，但不删除它。（可通过start启动）</span></span><br><span class="line">rm  <span class="comment">#删除所有（停止状态的）服务容器,推荐先执行stop</span></span><br><span class="line">top  <span class="comment">#查看各个服务容器内运行的进程。</span></span><br><span class="line">version</span><br></pre></td></tr></table></figure><br><br/></p>
<p><strong>常用命令详解：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build格式 docker-compose build [options] [SERVICE...]</span></span><br><span class="line">选项包括：</span><br><span class="line">  --force-rm 删除构建过程中的临时容器。</span><br><span class="line">  --no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。</span><br><span class="line">  --pull 始终尝试通过 pull 来获取更新版本的镜像。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#run格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。</span></span><br><span class="line">选项：</span><br><span class="line">  -d 后台运行容器。</span><br><span class="line">  --name NAME 为容器指定一个名字。</span><br><span class="line">  --entrypoint CMD 覆盖默认的容器启动指令。</span><br><span class="line">  -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</span><br><span class="line">  -u, --user=<span class="string">""</span> 指定运行容器的用户名或者 uid。</span><br><span class="line">  --no-deps 不自动启动关联的服务容器。</span><br><span class="line">  --rm 运行命令后自动删除容器，d 模式下将忽略该选项。</span><br><span class="line">  -p, --publish=[] 映射容器端口到本地主机。</span><br><span class="line">  --service-ports 配置服务端口并映射到本地主机。</span><br><span class="line">  -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="variable">$docker</span>-compose run ubuntu ping docker.com  <span class="comment">#将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#up格式 docker-compose up [options] [SERVICE...]  </span></span><br><span class="line"><span class="comment">#该up十分强大：它将尝试自动完成包括构建镜像build的工作，（重新）创建服务，启动服务run的工作，并关联服务相关容器的一系列操作。</span></span><br><span class="line">docker-compose up  <span class="comment">#前台启动,控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</span></span><br><span class="line">docker-compose up -d   <span class="comment">#后台启动，查看信息需要使用logs命令,般推荐生产环境下使用该选项。</span></span><br><span class="line">选项：</span><br><span class="line">  -d 在后台运行服务容器。</span><br><span class="line">  --no-color 不使用颜色来区分不同的服务的控制台输出。</span><br><span class="line">  --no-deps 不启动服务所链接的容器。</span><br><span class="line">  --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。</span><br><span class="line">  --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。</span><br><span class="line">  --no-build 不自动构建缺失的服务镜像。</span><br><span class="line">  -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#rm格式为 docker-compose rm [options] [SERVICE...]。</span></span><br><span class="line">选项：</span><br><span class="line">  -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项(使用前建议先stop)</span><br><span class="line">  -v 删除容器所挂载的数据卷。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#scale格式为 docker-compose scale [options] [SERVICE=NUM...]</span></span><br><span class="line"><span class="comment">#通过 service=num 的参数来设置数量。例如：</span></span><br><span class="line"><span class="variable">$docker</span>-compose scale web=3 db=2 <span class="comment">#将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</span></span><br></pre></td></tr></table></figure></p>
<p><em>注意：</em></p>
<ul>
<li>默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。</li>
<li>如果用户不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。</li>
<li>如果用户只想重新部署某个服务，可以使用 docker-compose up –no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</li>
<li>使用 docker-compose scale一般的当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之将停止容器。</li>
</ul>
<p><br/></p>
<p><strong>实际案例：</strong><br>建议在空目录中建立Dockerfile与docker-compose.yml,并运行docker-compose运行的时候建议在Dockerfile与docker-compose.yml 当前目录下运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span>-compose config   <span class="comment">#验证Dockerfile脚本-正确返回配置</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">  web:</span><br><span class="line">    build:</span><br><span class="line">      context: /opt/app</span><br><span class="line">    ports:</span><br><span class="line">    - 80:8080/tcp</span><br><span class="line">version: <span class="string">'3.0'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose -p FlaskApp build  <span class="comment">#构建容器</span></span><br><span class="line">Building web</span><br><span class="line">Step 1/5 : FROM python:3.6-alpine</span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose up -d  <span class="comment">#后台启动容灾</span></span><br><span class="line">Creating network <span class="string">"app_default"</span> with the default driver</span><br><span class="line">Building web</span><br><span class="line">Step 1/5 : FROM python:3.6-alpine</span><br><span class="line"> ---&gt; 35bb01a3d284</span><br><span class="line">Step 2/5 : ADD . /code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose images   <span class="comment">#显示构建运行后的容器</span></span><br><span class="line"> Container    Repository    Tag       Image Id      Size</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">app_redis_1   redis        alpine   72e76053ebb7   48.5 MB</span><br><span class="line">app_web_1     app_web      latest   e5024b7bdce1   86.1 MB</span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose ps   <span class="comment">#项目中目前的容器状态</span></span><br><span class="line">   Name                  Command               State          Ports</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">app_redis_1   docker-entrypoint.sh redis ...   Up      6379/tcp</span><br><span class="line">app_web_1     python app.py                    Up      0.0.0.0:80-&gt;8080/tcp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose logs   <span class="comment">#后台运行的容器信息</span></span><br><span class="line">Attaching to app_redis_1, app_web_1</span><br><span class="line">web_1    |  * Debug mode: on</span><br><span class="line">web_1    |  * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit)</span><br><span class="line">web_1    |  * Restarting with <span class="built_in">stat</span></span><br><span class="line">web_1    |  * Debugger is active!</span><br><span class="line">web_1    |  * Debugger PIN: 324-716-279</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose <span class="built_in">exec</span> web /bin/sh  <span class="comment">#进入web服务的容器中(前提是必须运行，退出不影响后台运行的容器)</span></span><br><span class="line">/code <span class="comment"># ls</span></span><br><span class="line">Dockerfile          app.py              docker-compose.yml</span><br><span class="line">/code <span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line">/code <span class="comment"># hostname</span></span><br><span class="line">2e10bc9c7618</span><br><span class="line">/code <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose stop    <span class="comment">#停止容器</span></span><br><span class="line">Stopping app_redis_1 ... <span class="keyword">done</span></span><br><span class="line">Stopping app_web_1   ... <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose rm -v  <span class="comment">#删除构建的容器</span></span><br><span class="line">Going to remove app_redis_1, app_web_1</span><br><span class="line">Are you sure? [yN] y</span><br><span class="line">Removing app_redis_1 ... <span class="keyword">done</span></span><br><span class="line">Removing app_web_1   ... <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$docker</span>-compose <span class="built_in">kill</span> -s SIGINT  <span class="comment">#通过发送 SIGKILL 信号来强制停止服务容器。</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="3-模板文件"><a href="#3-模板文件" class="headerlink" title="3.模板文件"></a>3.模板文件</h5><p>标准配置的docker-compose.yaml文件应该包含 version、services、networks 三大部分其中最关键的就是 services 和 networks 两个部分还有就是配置文件的格式</p>
<p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多，以下面的案例为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker-composer版本注意冒号后有个空格</span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户自定义服务名称</span></span><br><span class="line">  web:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#指定服务的镜像名称或镜像ID(先从本地拉取，如果没有找到则从从Docker Hub获取镜像)</span></span><br><span class="line">    image: ubuntu/ubuntu:18.04</span><br><span class="line"></span><br><span class="line">    <span class="comment">#服务除了可以基于指定的镜像，还可以基于一份 Dockerfile,在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径</span></span><br><span class="line">    build：/path/to/build/dir  <span class="comment">#方式1：存放dockerfile的可以是绝对路径也可以是相对路径</span></span><br><span class="line">    <span class="comment">#方式2：设定上下文根目录，然后以该目录为准指定 Dockerfile。</span></span><br><span class="line">    build:  </span><br><span class="line">      context: ../</span><br><span class="line">      dockerfile: path/of/Dockerfile  </span><br><span class="line">      <span class="comment">#在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。</span></span><br><span class="line">      args:  <span class="comment">#使用 arg 指令指定构建镜像时的变量。</span></span><br><span class="line">        buildno: 1</span><br><span class="line">      cache_from:  <span class="comment">#使用 cache_from 指定构建镜像的缓存</span></span><br><span class="line">        - alpine:latest</span><br><span class="line">        - corp/web_app:3.14</span><br><span class="line"></span><br><span class="line">    <span class="comment">#自定义容器命名格式是：&lt;项目名称&gt;&lt;服务名称&gt;&lt;序号&gt;</span></span><br><span class="line">    container_name: app</span><br><span class="line"></span><br><span class="line">    <span class="comment">#lables指令 向容器添加元数据，和Dockerfile的LABEL指令一个意思，格式如下：</span></span><br><span class="line">    labels:</span><br><span class="line">      - <span class="string">"com.example.author=weiyigeek"</span></span><br><span class="line">      - <span class="string">"com.example.description=Accounting webapp"</span></span><br><span class="line">      - <span class="string">"com.example.department=Finance"</span></span><br><span class="line">      - <span class="string">"com.example.lrelease=rc3 for v1.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#一般项目容器启动的顺序是有要求的， depends_on标签解决了容器的依赖、启动先后的问题。、</span></span><br><span class="line">    <span class="comment">#例如下面容器会先启动 redis 和 db 两个服务，最后才启动 web 服务：</span></span><br><span class="line">    depends_on:  <span class="comment">#定义了依赖关系</span></span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">    redis:</span><br><span class="line">      image: redis</span><br><span class="line">    db:</span><br><span class="line">      image: postgres</span><br><span class="line">    <span class="comment">#注意：web 服务不会等待 redis db 「完全启动」之后才启动。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#配置日志选项。</span></span><br><span class="line">    logging:</span><br><span class="line">      driver: syslog <span class="comment">#目前支持三种日志驱动类型,"none" / "json-file"</span></span><br><span class="line">      options: <span class="comment">#配置日志驱动的相关参数。</span></span><br><span class="line">        syslog-address: <span class="string">"tcp://192.168.0.42:123"</span></span><br><span class="line">        max-size: <span class="string">"200k"</span></span><br><span class="line">        max-file: <span class="string">"10"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#ports标签指定映射端口,使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。</span></span><br><span class="line">    ports:</span><br><span class="line">      - 8080   <span class="comment">#注意格式</span></span><br><span class="line">      - <span class="string">"49100:22"</span></span><br><span class="line">      - <span class="string">"127.0.0.1:8001:8001"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#管理全部服务的标签，比如设置全部服务的user标签值为USER，默认属性（用户、角色、类型、级别等）</span></span><br><span class="line">    security_opt:</span><br><span class="line">      - label:user:USER</span><br><span class="line">      - label:role:ROLE</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置另一个信号来停止容器，默认情况下是使用SIGTERM停止容器</span></span><br><span class="line">    stop_signal: SIGUSR1</span><br><span class="line"></span><br><span class="line">    <span class="comment">#配置容器连接的网络</span></span><br><span class="line">    networks:</span><br><span class="line">      - front-tier</span><br><span class="line">      - back-tier</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置网络模式使用和 docker run 的 --network 参数一样的值(在集群模式下无法使用)。</span></span><br><span class="line">    network_mode: <span class="string">"bridge"</span> <span class="comment"># "host"  "none" "service:[service name]" "container:[container name/id]"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#和 --dns 参数一样用途，格式如下：</span></span><br><span class="line">    dns: </span><br><span class="line">      - 8.8.8.8</span><br><span class="line">      - 9.9.9.9</span><br><span class="line">    <span class="comment">#此外 dns_search 的配置也类似</span></span><br><span class="line">    dns_search:</span><br><span class="line">      - dc1.example.com</span><br><span class="line">      - dc2.example.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">    <span class="comment">#tmpfs标签 挂载临时目录到容器内部(挂载一个 tmpfs 文件系统到容器),与 run 的参数一样效果：</span></span><br><span class="line">    tmpfs: /run  <span class="comment">#两种形式 单个和多个</span></span><br><span class="line">    tmpfs:</span><br><span class="line">      - /run</span><br><span class="line">      - /tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment">#env_file 标签指定.env 文件来存放设置的 Compose 的变量</span></span><br><span class="line">    <span class="comment">#如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。</span></span><br><span class="line">    env_file:</span><br><span class="line">      - ./common.env</span><br><span class="line">      - ./apps/web.env</span><br><span class="line">      - /opt/secrets.env</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#environment标签设置镜像变量，而且它可以保存变量到镜像/容器里面(类似 docker run -e 的效果)</span></span><br><span class="line">    <span class="comment">#如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。</span></span><br><span class="line">    environment:</span><br><span class="line">      - RACK_ENV=development</span><br><span class="line">      - SHOW=<span class="literal">true</span></span><br><span class="line">      - SESSION_SECRET</span><br><span class="line">      - MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</span><br><span class="line"></span><br><span class="line">    <span class="comment">#存储敏感数据，例如 mysql 服务密码，需要后面的配置</span></span><br><span class="line">    secrets:</span><br><span class="line">      - db_root_password</span><br><span class="line">      - my_other_secret</span><br><span class="line"></span><br><span class="line">    <span class="comment">#与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口（只是作为参考实际上常用ports指令）</span></span><br><span class="line">    expose:</span><br><span class="line">      - <span class="string">"6379"</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#links标签解决的是容器连接问题，与Docker client的--link一样效果，会连接到其它服务中的容器。</span></span><br><span class="line">    <span class="comment">#使用的别名将会自动在服务容器中的/etc/hosts里创建</span></span><br><span class="line">    links:</span><br><span class="line">      - web</span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用 command 可以覆盖容器启动后默认执行的命令。</span></span><br><span class="line">    <span class="built_in">command</span>: bundle <span class="built_in">exec</span> thin -p 3000</span><br><span class="line">    <span class="comment">#command: [bundle, exec, thin, -p, 3000]  #写成类似 Dockerfile 中的格式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用entrypoint标签 可以定义接入点</span></span><br><span class="line">    entrypoint: /code/entrypoint.sh</span><br><span class="line">    entrypoint:</span><br><span class="line">      - php</span><br><span class="line">      - -d</span><br><span class="line">      - zend_extension=/usr/<span class="built_in">local</span>/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class="line">      - -d</span><br><span class="line">      - memory_limit=-1</span><br><span class="line">      - vendor/bin/phpunit</span><br><span class="line"></span><br><span class="line">  lb:</span><br><span class="line">    image: dockercloud/haproxy</span><br><span class="line">    ports:</span><br><span class="line">      - 80:80</span><br><span class="line"></span><br><span class="line">    <span class="comment">#extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加下面的一些记录，与Docker client的--add-host类似：</span></span><br><span class="line">    extra_hosts:</span><br><span class="line">      - <span class="string">"somehost:162.242.195.82"</span></span><br><span class="line">      - <span class="string">"otherhost:50.31.209.229"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#让Compose项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。</span></span><br><span class="line">    <span class="comment">#链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。</span></span><br><span class="line">    external_links:</span><br><span class="line">      - redis_1</span><br><span class="line">      - project_db_1:mysql</span><br><span class="line">      - project_db_1:postgresql</span><br><span class="line"></span><br><span class="line">    links:</span><br><span class="line">      - web</span><br><span class="line"></span><br><span class="line">    <span class="comment">#指定父 cgroup 组，意味着将继承该组的资源限制。</span></span><br><span class="line">    cgroup_parent: cgroups_1  <span class="comment">#指定父 cgroup 组，意味着将继承该组的资源限制</span></span><br><span class="line">    network_mode: <span class="string">"host"</span>  <span class="comment"># 使用主机网络模式</span></span><br><span class="line">    <span class="comment">#加入指定网络,相同的服务可以在不同的网络有不同的别名。</span></span><br><span class="line">    networks:</span><br><span class="line">      - front-tier</span><br><span class="line">      - back-tier</span><br><span class="line"></span><br><span class="line">    <span class="comment">#挂载一个目录或者一个已存在的数据卷容器格式[HOSTPATH:CONTAINERPATH:ro]  #定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。</span></span><br><span class="line">    <span class="comment">#可以宿主机的 $PWD 常量</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock    <span class="comment">#使用绝对路径挂载数据卷</span></span><br><span class="line">      - ~/configs:/etc/configs/:ro  <span class="comment"># 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。</span></span><br><span class="line">      - datavolume:/var/lib/mysql     <span class="comment"># 已经存在的命名的数据卷。</span></span><br><span class="line">      - <span class="string">'./nginx/log:/var/log/nginx:rw'</span> <span class="comment"># 目录映射权限设置，例如此处的 :ro 是只读不能写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#从其它容器或者服务挂载数据卷可选的参数是 :ro或者 :rw(默认)</span></span><br><span class="line">    volumes_from:</span><br><span class="line">      - service_name</span><br><span class="line">      - service_name:ro</span><br><span class="line">      - container:container_name</span><br><span class="line">      - container:container_name:rw</span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加或删除容器的内核功能</span></span><br><span class="line">    cap_add:  <span class="comment">#指定容器的内核能力（capacity）分配。</span></span><br><span class="line">      - ALL</span><br><span class="line">    cap_drop:  <span class="comment">#去掉 NET_ADMIN 能力可以指定为：</span></span><br><span class="line">      - NET_ADMIN</span><br><span class="line">      - SYS_ADMIN</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设备映射列表</span></span><br><span class="line">    devices:</span><br><span class="line">      - <span class="string">"/dev/ttyUSB0:/dev/ttyUSB0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#通过命令检查容器是否健康运行</span></span><br><span class="line">    healthcheck:</span><br><span class="line">      <span class="built_in">test</span>: [<span class="string">"CMD"</span>, <span class="string">"curl"</span>, <span class="string">"-f"</span>, <span class="string">"http://localhost"</span>]</span><br><span class="line">      interval: 1m30s</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 3</span><br><span class="line"></span><br><span class="line">    <span class="comment">#跟主机系统共享进程命名空间。</span></span><br><span class="line">    <span class="comment">#打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</span></span><br><span class="line">    pid: <span class="string">"host"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#配置容器内核参数</span></span><br><span class="line">    sysctls:</span><br><span class="line">      - net.core.somaxconn=32768</span><br><span class="line">      - net.ipv4.tcp_syncookies=0</span><br><span class="line">      - net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line">    <span class="comment">#指定容器的 ulimits 限制值</span></span><br><span class="line">    <span class="comment">#例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</span></span><br><span class="line">    ulimits:</span><br><span class="line">      nproc: 65535</span><br><span class="line">      nofile:</span><br><span class="line">        soft: 20000</span><br><span class="line">        hard: 40000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 volumes 中绑定本地目录等同于`docker volume create --driver local --name esdata1`</span></span><br><span class="line">volumes:</span><br><span class="line">  esdata1:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">  datavolume:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">    driver_opts:</span><br><span class="line">      <span class="built_in">type</span>: none</span><br><span class="line">      device: <span class="variable">$PWD</span>/logs</span><br><span class="line">      o: <span class="built_in">bind</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  front-tier:</span><br><span class="line">    driver: bridge</span><br><span class="line">  back-tier:</span><br><span class="line">    driver: bridge</span><br><span class="line">      aliases:  <span class="comment"># 子标签aliases，这是一个用来设置服务别名的标签</span></span><br><span class="line">        - alias1</span><br><span class="line"><span class="comment"># 加入已存在的网络(docker network ls)</span></span><br><span class="line">networks:</span><br><span class="line">  mongocluster_default:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#放在最后</span></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">  my_other_secret:</span><br><span class="line">    external: <span class="literal">true</span></span><br></pre></td></tr></table></figure><br><br/></p>
<p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。<br>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br><span class="line">MONGO_VERSION=3.6</span><br><span class="line"></span><br><span class="line"><span class="comment">#例如，下面的 Compose 文件将从运行它的环境中读取变量 $&#123;MONGO_VERSION&#125; 的值，并写入执行的指令中。</span></span><br><span class="line">version: <span class="string">"3"</span></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: <span class="string">"mongo:<span class="variable">$&#123;MONGO_VERSION&#125;</span>"</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="4-使用案例"><a href="#4-使用案例" class="headerlink" title="4.使用案例"></a>4.使用案例</h5><p>使用案例1：docker-compose 配合Dockerfile构建容器,采用python的flask框架与redis<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#项目结构</span></span><br><span class="line">├── app.py</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment">###############app.py###############</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#每次刷新页面，计数就会加 1。</span></span><br><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=<span class="string">'redis'</span>, port=6379)</span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">'/'</span>)</span><br><span class="line">def hello():</span><br><span class="line">    count = redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="built_in">return</span> <span class="string">'Hello World! 该页面已被访问 &#123;&#125; 次。\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>,port=8080,debug=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########## Docker-compose.yml ##########    </span></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    <span class="comment">#存放了dockerfile目录</span></span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">"80:8080"</span></span><br><span class="line">  <span class="comment">#会进行自连接与网络通信关联-docker-compose的一大特色</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">"redis:alpine"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########## Dockerfile ##########  </span></span><br><span class="line">FROM python:3.6-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">RUN chown -R <span class="variable">$USER</span>:<span class="variable">$USER</span> .</span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br></pre></td></tr></table></figure><br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527153850.png" target="_blank" title="WeiyiGeek." data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527153850.png" alt="WeiyiGeek." title="" class=""></a>
                <p>WeiyiGeek.</p>
            </figure><br>访问我们构建的服务显示：<br><figure class="image-box">
                <a rel=2.Docker学习之基础使用 href="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527153814.png" target="_blank" title="WeiyiGeek." data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190527153814.png" alt="WeiyiGeek." title="" class=""></a>
                <p>WeiyiGeek.</p>
            </figure></p>
<p><br></p>
<p>使用案例2：采用docker-compose构建博客镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#宿主机直接git clone我的blog项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/WeiyiGeek/blog.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立入口执行shell文件</span></span><br><span class="line"><span class="variable">$nano</span> init.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">npm config <span class="built_in">set</span> unsafe-perm <span class="literal">true</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line">npm install -g hexo-cli --save</span><br><span class="line">npm install --save</span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立docker-compose.yml文件、</span></span><br><span class="line">version: <span class="string">"3.0"</span></span><br><span class="line">services:</span><br><span class="line">  blog:</span><br><span class="line">    image: <span class="string">"mhart/alpine-node:latest"</span></span><br><span class="line">    container_name: blog</span><br><span class="line">    labels:</span><br><span class="line">      - <span class="string">"com.example.author=weiyigeek"</span></span><br><span class="line">      - <span class="string">"com.example.description=my blog"</span></span><br><span class="line">      - <span class="string">"com.example.department=IT"</span></span><br><span class="line">      - <span class="string">"com.example.lrelease=v1.0"</span></span><br><span class="line">    ports: </span><br><span class="line">      - <span class="string">"80:4000"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"<span class="variable">$PWD</span>:/opt/blog/"</span></span><br><span class="line">    working_dir: /opt/blog/</span><br><span class="line">    entrypoint: /opt/blog/init.sh   <span class="comment">#设置的环境变量也由此初始化到脚本之中</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>注意事项</strong>：</p>
<ol>
<li><p>如果你同时指定了 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 后面的那个名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">image: webapp:tag</span><br><span class="line"></span><br><span class="line"><span class="comment">#Dockerfile 中的 ARG 指令它可以在构建过程中指定环境变量，但是在构建成功后取消，在 docker-compose.yml 文件中也支持这样的写法：</span></span><br><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  <span class="comment">#与 ENV 不同的是，ARG 是允许空值的。例如：</span></span><br><span class="line">  args:</span><br><span class="line">    - buildno=1</span><br><span class="line">    - password=secret</span><br><span class="line">    - version</span><br></pre></td></tr></table></figure>
</li>
<li><p>YAML 的布尔值（true, false, yes, no, on, off）必须要使用引号引起来（单引号、双引号均可），否则会当成字符串解析。</p>
</li>
<li><p>如果env_file指定.env文件有变量名称 与  environment 指令冲突则以后者为准。</p>
</li>
<li><p>注意env_file标签的使用,是这里所说的环境变量是对宿主机的 Compose 而言的:</p>
<ul>
<li>如果在配置文件中有 build 操作这些变量并不会进入构建过程中，</li>
<li>如果要在构建中使用变量还是首选前面刚讲的 arg 标签。</li>
</ul>
</li>
<li><p>补充标签与docker run参数一致</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">configs <span class="comment">#仅用于 Swarm mode</span></span><br><span class="line">deploy <span class="comment">#仅用于 Swarm mode</span></span><br><span class="line">cpu_shares: 73</span><br><span class="line">cpu_quota: 50000</span><br><span class="line">cpuset: 0,1</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器中运行应用的用户名</span></span><br><span class="line">user: postgresql</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器中工作目录</span></span><br><span class="line">working_dir: /code</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器中搜索域名、主机名、mac 地址等。</span></span><br><span class="line">domainname: foo.com</span><br><span class="line">hostname: foo</span><br><span class="line">ipc: host</span><br><span class="line">mac_address: 02:42:ac:11:65:43</span><br><span class="line"></span><br><span class="line"><span class="comment">#允许容器中运行一些特权命令。</span></span><br><span class="line">privileged: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。</span></span><br><span class="line">restart: always</span><br><span class="line"></span><br><span class="line"><span class="comment">#以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</span></span><br><span class="line">read_only: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shm_size: 64M</span><br><span class="line"><span class="comment">#打开标准输入，可以接受外部输入。</span></span><br><span class="line">stdin_open: <span class="literal">true</span></span><br><span class="line"><span class="comment">#模拟一个伪终端。</span></span><br><span class="line">tty: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">mem_limit: 1000000000</span><br><span class="line">memswap_limit: 2000000000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><br/></p>
<p>使用案例3：采用docker-compose构建 <code>MySQL / Redis / Adminer</code>;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3.1'</span></span><br><span class="line">services:</span><br><span class="line">  db8:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: mysql8.x</span><br><span class="line">    <span class="built_in">command</span>: --default-authentication-plugin=mysql_native_password</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: www.weiyigeek.top</span><br><span class="line">      MYSQL_DATABASE: <span class="built_in">test</span></span><br><span class="line">      MYSQL_USER: test8</span><br><span class="line">      MYSQL_PASSWORD: weiyigeek.top</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"/app/mysql8:/var/lib/mysql"</span></span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306</span><br><span class="line">    networks:</span><br><span class="line">      - database-net</span><br><span class="line">  db5:</span><br><span class="line">    image: mysql:5.7.29</span><br><span class="line">    container_name: mysql5.x</span><br><span class="line">    <span class="built_in">command</span>: --default-authentication-plugin=mysql_native_password</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: www.weiyigeek.top</span><br><span class="line">      MYSQL_DATABASE: <span class="built_in">test</span></span><br><span class="line">      MYSQL_USER: test5</span><br><span class="line">      MYSQL_PASSWORD: weiyigeek.top</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"/app/mysql5:/var/lib/mysql"</span></span><br><span class="line">    ports:</span><br><span class="line">      - 3305:3306</span><br><span class="line">    networks:</span><br><span class="line">      - database-net</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    container_name: redis</span><br><span class="line">    restart: always</span><br><span class="line">    <span class="built_in">command</span>: redis-server --requirepass weiyigeek.top</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"/app/redis:/data"</span></span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">  adminer:</span><br><span class="line">    image: adminer</span><br><span class="line">    container_name: MySQLManager</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8888:8080</span><br><span class="line">    networks:</span><br><span class="line">      - database-net</span><br><span class="line">    links:</span><br><span class="line">      - db8:mysql8.x</span><br><span class="line">      - db5:mysql5.7</span><br><span class="line">    depends_on:</span><br><span class="line">      - db8</span><br><span class="line">      - db5</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建（注意不在services中）它会自动创建以当前目录+database-net名称的docker网络名称。</span></span><br><span class="line"><span class="comment"># networks:</span></span><br><span class="line"><span class="comment">#   database-net:</span></span><br><span class="line"><span class="comment">#     driver: bridge</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定已存在的网络(推荐使用前必须进行创建否则报错)</span></span><br><span class="line"><span class="comment"># docker network create -d bridge mysql_database-net</span></span><br><span class="line">networks:</span><br><span class="line">  mysql_database-net:</span><br><span class="line">    external: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>Tips : 此时若还要docker容器间进行相互通讯需要进行配置防火墙<code>信任 docker 的 ip 地址</code>，比如:<code>firewall-cmd  --zone=trusted --add-source=172.17.0.1/16 --permanent</code>，如果部署iptable报错请重启docker;</p>
<p><br></p>
<h5 id="5-学习补充"><a href="#5-学习补充" class="headerlink" title="5.学习补充"></a>5.学习补充</h5><p><strong>1) Docker-compose 设置容器数据持久化的方式</strong><br>描述: 我常常利用 docker-compose 进行容器的创建，它有两种设置方式都是可以持久化的;</p>
<ul>
<li><p>第一种情况路径直接挂载到本地，比较直观，但需要管理本地的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo1:  </span><br><span class="line">  image: weiyigeek/nginx:latest</span><br><span class="line">  volumes:</span><br><span class="line">    - ./ghost/config.js:/var/lib/ghost/config.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种使用卷标的方式，比较简洁，但你不知道数据存在本地什么位置需要通过docker命令查看标卷。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line"> mysql:  </span><br><span class="line">  image: mysql</span><br><span class="line">  container_name: mysql</span><br><span class="line">  volumes:</span><br><span class="line">    - mysql:/var/lib/mysql</span><br><span class="line">...</span><br><span class="line">volumes:</span><br><span class="line"> mysql: &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Q: 如何查看docker的卷标?<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1) 查看所有卷标</span></span><br><span class="line">docker volume ls </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) 查看批量的卷标</span></span><br><span class="line">$ docker volume ls | grep mysql</span><br><span class="line"><span class="built_in">local</span>               vagrant_mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 查看具体的volume对应的真实地址</span></span><br><span class="line">$ docker volume inspect vagrant_mysql</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"Name"</span>: <span class="string">"vagrant_mysql"</span>,</span><br><span class="line">    <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">    <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/vagrant_mysql/_data"</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>

        </div>
        
  <hr>
  <p> 欢迎各位志同道合的朋友一起学习交流，如文章有误请在下方留下您宝贵的经验知识，个人邮箱地址<b style="color:#ff654e"><code>【master#weiyigeek.top】</code></b>或者个人公众号<b style="color:#ff654e"><code>【WeiyiGeek】</code></b>联系我。 </p>

  <p> 更多文章来源于<b style="color:#03a9f4">【WeiyiGeek Blog - 为了能到远方，脚下的每一步都不能少】</b>, 个人首页地址( <a style="color: #03a9f4;" href="https://weiyigeek.top" target="_blank"> https://weiyigeek.top </a> )</p>

  <p>专栏书写不易，如果您觉得这个专栏还不错的，请给这篇专栏 <b style="color: red;">【点个赞、投个币、收个藏、关个注，转个发】(人间五大情)</b>，这将对我的肯定，谢谢！。</p>

  <div>
    <img src="https://www.weiyigeek.top/img/weiyigeek.jpg" class="img-responsive" alt="WeiyiGeek-banner">
  </div>

  <ul style="font-weight: bolder;">
    <li>
      <p><span style="color: #03a9f4">echo&nbsp;&nbsp;"【点个赞】，动动你那粗壮的拇指或者芊芊玉手，亲！"</span></p>
    </li>
    <li>
      <p><span style="color: #ff9201">printf("%s",&nbsp;"【投个币】，万水千山总是情，投个硬币行不行，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #02a2ff">fmt.Printf("【收个藏】，阅后即焚不吃灰，亲！")&nbsp;&nbsp;</span></p>
    </li>
    <li>
      <p><span style="color:red">console.info("【转个发】，让更多的志同道合的朋友一起学习交流，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #ff654e">System.out.println("【关个注】，后续浏览查看不迷路哟，亲！")</span></p>
    </li>
  </ul>

  <div>
    <img src="https://www.weiyigeek.top/img/wechat-search.png" class="img-responsive" alt="扫描follow(关注)WeiyiGeek公众号"  width="328" height="149">
  </div>

  <hr>
  


  <blockquote class="post-copyright">
    <div class="content">
      
        
<span class="post-time">
    最后更新时间：<time datetime="2022-06-15T02:46:31.940Z" itemprop="dateUpdated">2022-06-15 10:46:31</time>
</span><br>


        <span>文章原始路径：<a href="https://github.com/WeiyiGeek/blog/edit/master/source/_posts/虚拟云容/云容器/Docker/2.Docker学习之基础使用.md" target="_blank" rel="noopener noreferrer">_posts/虚拟云容/云容器/Docker/2.Docker学习之基础使用.md</a></span><br>
         <span class="copy-copyright">转载注明出处，原文地址：<a href="/2019/5-21-456.html" target="_blank" rel="external">https://blog.weiyigeek.top/2019/5-21-456.html</a></span><br>本站文章内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a> 
    </div>
    <footer>
      <a href="https://blog.weiyigeek.top">
        <img src="/img/avatar.jpg" alt="WeiyiGeek">
        WeiyiGeek
      </a>
    </footer>
  </blockquote>


        
            <div class="page-reward">
  <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-rectangle waves-light">👍 钟意作者</a>
</div>
            
        
        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2019/5-21-456.html&title=《2.Docker学习之基础使用》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2019/5-21-456.html&title=《2.Docker学习之基础使用》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2019/5-21-456.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《2.Docker学习之基础使用》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2019/5-21-456.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2019/5-21-456.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
          <!-- 评论组件 -->


<div id="gitalk-container"></div>
<script type="text/javascript" src="/js/plugins/gitalk.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/custom/gitalk.init.js?v=1.6.6"></script>
        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/5-21-486.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">VMware虚拟化基础知识笔记</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/5-20-438.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">企业安全浅析与实践</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x01-Docker-数据管理"><span class="post-toc-number">1.</span> <span class="post-toc-text">0x01 Docker 数据管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x02-Docker-网络管理"><span class="post-toc-number">2.</span> <span class="post-toc-text">0x02 Docker 网络管理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x03-Registry-私有镜像仓库搭建实践"><span class="post-toc-number">3.</span> <span class="post-toc-text">0x03 Registry 私有镜像仓库搭建实践</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#0x03-Docker-Compose-容器编排"><span class="post-toc-number">4.</span> <span class="post-toc-text">0x03 Docker-Compose 容器编排</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

  <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        人间自有五大情【点赞、投币(赞赏)、收藏、关注，转发】, 谢谢看友支持!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardwechat" src="/img/reward-wechat.jpg" height="228" height="228" alt="打赏二维码">
            <img id="rewardalipay" src="/img/reward-alipay.png" height="228" height="228" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <!-- <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.png"> -->
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

  
 <!-- 微信公众号关注/文章版权复制 -->

  <div id="btw-mask" style="position: fixed; top: 0px; right: 0px; bottom: 0px; left: 0px; opacity: 0.7; z-index: 999; background: rgb(0, 0, 0); display:none"></div>
<div id="btw-modal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 360px; text-align: center; font-size: 13px; background: rgb(255, 255, 255); border-radius: 10px; z-index: 9999; font-family: PingFangSC-Regular, sans-serif;display:none">
<span id="btw-modal-close-btn" style="position: absolute; top: 5px; right: 15px; line-height: 1.8; font-size: 15px; cursor: pointer; opacity: 0.2; z-index: 9999; color: rgb(0, 0, 0); background: none; border: none; outline: none;">X</span>
<p id="btw-modal-header" style="margin-top: 40px; line-height: 1.8; font-size: 13px; ">
<b style="color:#6190e8;">你好朋友,可以关个注吗? ❤ <br> 这将是我持续更新文章的动力源泉，谢谢支持！(๑′ᴗ‵๑) </b> <br> 如不想关注请点击右上角的【X】<br>
<br>Method 1.Please visit <strong><a href="https://twitter.com/WeiyiGeek" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【My Twitter】</a></strong>. There is an article verification code in the homepage.
<br>方式2.请访问本博主的B站<strong><a href="https://space.bilibili.com/385802642" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【WeiyiGeek】</a></strong>首页关注UP主,<br>将自动随机获取解锁验证码。
<br>方式3.扫一扫下方二维码，关注本站<strong>官方公众号</strong><br>
回复：<strong style="color: rgb(240, 65, 52);">验证码</strong>
将获取<strong style="color: rgb(240, 65, 52);">解锁(有效期7天)</strong>本站所有技术文章哟!</p>
<img src="/img/wechat-search.png" style="width: 300px; margin-top: 10px;">
<div id="btw-modal-input-code" style="margin-top: 20px; background: rgb(255, 255, 255);">
  <input id="btw-modal-input" type="number" minlength="4" maxlength="4" placeholder="请输入验证码|Verification Code"
    style="width: 165px; height: 32px; line-height: 32px; padding: 0px 10px; margin: 0px 10px; font-size: 13px; text-rendering: auto; text-transform: none; cursor: text; outline: none; box-sizing: border-box; border: 1px solid rgb(221, 221, 221); -webkit-appearance: textfield; background-color: white; -webkit-rtl-ordering: logical;"/>
  <button id="btw-submit-btn" onclick="yzm_vertify()"
    style="padding: 0px 20px; height: 32px; font-size: 14px; outline: none; border: none; color: rgb(255, 255, 255); background: rgb(222, 104, 109); cursor: pointer;">提
    交</button> </div>
<p id="btw-footer" style="margin: 40px 0px 20px; color: rgb(153, 153, 153);">@WeiyiGeek - 为了能到远方，脚下的每一步都不能少</p>
</div>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://weiyigeek.top" target="_blank">https://weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.weiyigeek.top" target="_blank">https://blog.weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://weiyigeek.top/img/wechat-search.png" target="_blank">公众账号</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://space.bilibili.com/385802642/article" target="_blank">哔哩哔哩专栏</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/weiyigeek" target="_blank">个人Github</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://gitee.com/WeiyiGeek" target="_blank">个人Gitee</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.zhihu.com/people/weiyiSec" target="_blank">个人知乎</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.cnblogs.com/WeiyiGeek" target="_blank">博客园</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://my.oschina.net/weiyigeek" target="_blank">OSCHINA</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAqcPSoMqfctaEqJpGSF775eeCjWkrop4AOyLITdMx-L78F5iXzfQcSRM5sY4dq3wR" target="_blank">今日头条</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.csdn.net/u013072756?type=lately" target="_blank">CSDN</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.jianshu.com/u/5199a1104739" target="_blank">简书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cloud.tencent.com/developer/user/1389665/articles" target="_blank">腾讯云+云社区</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cuttlefish.baidu.com/shop/75c5dbd8d15abe23482f4d40" target="_blank">百度文库</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://author.baidu.com/home?from=blog&app_id=1726736601523415" target="_blank">IT极客知识分享</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.51cto.com/weiyigeek" target="_blank">51CTO博客</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://juejin.cn/user/122767337595934" target="_blank">掘金</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://weibo.com/a/hot/7622022703618049_1.html" target="_blank">微博文章</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.xiaohongshu.com/user/profile/627c98bb000000001000e7ba" target="_blank">小红书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://segmentfault.com/u/weiyigeek" target="_blank">Segmentfault</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.douyin.com/user/MS4wLjABAAAAMSBdMja6XLsdmzafb0RNbFeBemIOk38K1PaOClZeI1Q" target="_blank">抖音主页</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
      <p>
        <span>WeiyiGeek &copy; 2018 - 2022 <a href="https://weiyigeek.top" target="_blank" rel="noopener">weiyigeek.top</a> All rights reserved. IT唯一极客 版权所有 </span>
        
        <span>
          Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/weiyigeek" target="_blank">mellow</a>
        </span>
        
        <br/>访问统计
        <span><a href="/sitemap.xml" target="_blank" rel="Sitemaps-站点地图">Sitemaps</a> </span>
        <span><a href="/baidusitemap.xml" target="_blank" rel="baidusitemaps-百度站点地图">站点地图</a> </span>
        <!-- 
  -->
        <br/>ICP备案号<span><a href="https://beian.miit.gov.cn" target="_blank">渝ICP备2022003447号</a></span>
        <br/>
        <div id="cc-myssl-id">
          <a href="https://myssl.com/blog.weiyigeek.top?from=mysslid" target="_blank" rel="noopener"><img src="https://static.myssl.com/res/images/myssl-id1.png" alt="MySSL安全认证" style="max-height:50px;display:block;margin:0 auto"></a>
        </div>
      </p>
    </div>
</footer>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2019/5-21-456.html&title=《2.Docker学习之基础使用》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2019/5-21-456.html&title=《2.Docker学习之基础使用》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2019/5-21-456.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《2.Docker学习之基础使用》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2019/5-21-456.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2019/5-21-456.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACJUlEQVR42u3aQY6EMAxEUe5/aeYArcAvO4yU5LMadU8HHgsrrvi68HUPrt9vR/8/WnN0l+uLS4YMGcsy7sfr+QYcM3r00Tr82WTIkHEOgy/9XOt4meYvghRrGTJkyEgLYqcEy5AhQ8YsBi+O/c2lDBkyZPAmlodrJGjjr2ZyLy5DhowFGTx1//+/PznfkCFDxlKMO7w6j8U3jvFTyZAhY2sGL3CdQI03tLXnkSFDxt6M2ogDP5jsB3DoExkyZBzASOP49DCA/DY97HzZ4cqQIWMjRufo8bkU9g8secmWIUPGCQw+ksW/5TA+zBEcIciQIWM7Rqdl5UcIvMimL1eGDBlnMtIBiOKJBF4B/UqGDBmbMtKQqxbfk9aUfI5SQxkyZGzKSNtUEoTxDWinJUZvVIYMGYszakE/j9U6QVu69ZQhQ8aujHSci4du/SIeHH/KkCHjeEZnI5iuULuXDBky9mak0XzK7oylTtsmypAhYwsGb1zTW9Y2f+mIhgwZMmR0SjAf4yAv6AUjQ4aMwxikHU1/lTa9PKqTIUPGOQy+vePNJy+yE/I0GTJkbMq4w6u2sasVWXJfGTJknMBIyxwf7eLgWavJkCFjb0atyPaHOXhgh9aXIUPGAYx+BMYPINNRD7SaDBkyZIQDYZ0xDh7wyZAhQ0Yah9UKJS/ZL6vJkCHjAAZpYnlk1i+vH8ZtMmTIWJDRmdQgxZEHbXxDWTzIlCFDxnqMP+8EapgyjD6rAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="/js/jquery/2.1.0-jquery.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/jquery/3.5.2-jquery.fancybox.min.js?v=1.6.6"></script>
<!--  //cdn.bootcss.com/node-waves/0.7.4/waves.min.js -->
<script type="text/javascript" src="/js/node-waves/0.7.4-waves.min.js?v=1.6.6"></script> 

<script type="text/javascript" src="/js/method.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/blog.js?v=1.6.6"></script>

<!-- third-party -->
<script type="text/javascript" src="/js/plugins/local_search.js?v=1.6.6"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) { search_path = "search.xml";}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script> 

<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> --> 



  


<script>
  var _hmt = _hmt || [];
  (function() {
    // 百度统计
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?53923c4b5560739bc0ed61e183be6acf";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>
 


<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.staticfile.org/mathjax/2.7.9/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
<script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = 'WeiyiGeek Blog-关注于网络安全_物联网安全开发_网络安全运维-学习心得分享';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)咦!又好了!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>
 
     <script type="text/javascript" src="/js/custom/copytips.js?v=1.6.6"></script> 
</body>
</html>
