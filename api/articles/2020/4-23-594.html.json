{"title":"5.Go编程快速入门学习","slug":"编程世界/Go/5.Go编程快速入门学习","date":"2020-04-23T03:16:58.000Z","updated":"2023-01-31T02:29:10.672Z","url":"2020/4-23-594.html","path":"api/articles/2020/4-23-594.html.json","covers":["https://img.weiyigeek.top/2021/5/20210816203155.png","https://img.weiyigeek.top/2021/5/20210818152721.png","https://img.weiyigeek.top/2021/5/20210818152928.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h2 id=\"0x01-Go语言基础之错误处理\"><a href=\"#0x01-Go语言基础之错误处理\" class=\"headerlink\" title=\"0x01 Go语言基础之错误处理\"></a>0x01 Go语言基础之错误处理</h2><p>描述: Go语言中目前(1.16 版本中)是没有异常处理机制(<code>Tips ：说是在2.x版本中将会加入异常处理机制</code>)，但我们可以使用<code>error接口定义</code>以及<code>panic</code>/<code>recover</code>函数来进行异常错误处理。</p>\n<h3 id=\"1-error-接口定义\"><a href=\"#1-error-接口定义\" class=\"headerlink\" title=\"1.error 接口定义\"></a>1.error 接口定义</h3><p>描述: 在Golang中利用<code>error类型</code>实现了error接口，并且可以通过<code>errors.New</code>或者<code>fmt.Errorf</code>来快速创建错误实例。</p>\n<p>主要应用场景: 在 Go 语言中，错误是可以预期的，并且不是非常严重，不会影响程序的运行。对于这类问题可以用返回错误给调用者的方法，让调用者自己决定如何处理，通常采用 error 接口进行实现。</p>\n<p>error接口定义:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> error <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  Error() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Go语言的标准库代码包errors方法：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式1.在errors包中的New方法（Go 1.13 版本）。</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> errors</span><br><span class=\"line\"><span class=\"comment\">// go提供了errorString结构体，其则实现了error接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> errorString <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  text <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *errorString)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e.text</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在errors包中，还提供了New函数，来实例化errorString，如下：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(text <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;errorString&#123;text&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2.另一个可以生成error类型值的方法是调用fmt包中的Errorf函数(Go 1.13 版本以后)</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> fmt</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"errors\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Errorf</span><span class=\"params\">(format <span class=\"keyword\">string</span>, args ...<span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errors.New(Sprintf(format,args...))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>采用 errors 包中装饰一个错误;<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">errors.Unwrap(err error)\t<span class=\"comment\">//通过 errors.Unwrap 函数得到被嵌套的 error。\t</span></span><br><span class=\"line\">errors.Is(err, target error)\t<span class=\"comment\">//用来判断两个 error 是否是同一个\t</span></span><br><span class=\"line\">errors.As(err error, target <span class=\"keyword\">interface</span>&#123;&#125;)\t<span class=\"comment\">//error 断言</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>实际示例1:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"errors\"</span></span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"math\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误处理</span></span><br><span class=\"line\"><span class=\"comment\">// 1.Error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1.声明并初始化为error类型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> errNew error = errors.New(<span class=\"string\">\"# 错误信息来自 errors.New 方法。\"</span>)</span><br><span class=\"line\">  fmt.Println(errNew)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2.调用标准库中Errorf方法</span></span><br><span class=\"line\">  errorfFun := fmt.Errorf(<span class=\"string\">\"- %s\"</span>, <span class=\"string\">\"错误信息来自 fmt.Errorf 方法。\"</span>)</span><br><span class=\"line\">  fmt.Println(errorfFun)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3.实际案例</span></span><br><span class=\"line\">  result, err := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(a, b <span class=\"keyword\">float64</span>)</span> <span class=\"params\">(ret <span class=\"keyword\">float64</span>, err error)</span></span> &#123;</span><br><span class=\"line\">    err = <span class=\"literal\">nil</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      err = errors.New(<span class=\"string\">\"此处幂指数不能为0值,其结果都为1\"</span>)</span><br><span class=\"line\">      ret = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ret = math.Pow(a, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;(<span class=\"number\">5</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"# 输出错误信息:\"</span>, err)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"5 ^ 0 = %v\"</span>, result)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"5 ^ 2 = %v\"</span>, result)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  demo1()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 错误信息来自 errors.New 方法。</span><br><span class=\"line\">- 错误信息来自 fmt.Errorf 方法。</span><br><span class=\"line\"># 输出错误信息: 此处幂指数不能为<span class=\"number\">0</span>值,其结果都为<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">5</span> ^ <span class=\"number\">0</span> = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>实际示例2:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个 DivideError 结构 (值得学习)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> DivideError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  dividee <span class=\"keyword\">int</span></span><br><span class=\"line\">  divider <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 实现 `error` 接口 (值得学习)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(de *DivideError)</span> <span class=\"title\">Error</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  strFormat := <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  Cannot proceed, the divider is zero.</span></span><br><span class=\"line\"><span class=\"string\">  dividee: %d</span></span><br><span class=\"line\"><span class=\"string\">  divider: 0</span></span><br><span class=\"line\"><span class=\"string\">`</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义 `int` 类型除法运算的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Divide</span><span class=\"params\">(varDividee <span class=\"keyword\">int</span>, varDivider <span class=\"keyword\">int</span>)</span> <span class=\"params\">(result <span class=\"keyword\">int</span>, errorMsg <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> varDivider == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    dData := DivideError&#123;</span><br><span class=\"line\">            dividee: varDividee,</span><br><span class=\"line\">            divider: varDivider,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    errorMsg = dData.Error()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> varDividee / varDivider, <span class=\"string\">\"\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 正常情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> result, errorMsg := Divide(<span class=\"number\">100</span>, <span class=\"number\">10</span>); errorMsg == <span class=\"string\">\"\"</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"100/10 = \"</span>, result)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当除数为零的时候会返回错误信息</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> _, errorMsg := Divide(<span class=\"number\">100</span>, <span class=\"number\">0</span>); errorMsg != <span class=\"string\">\"\"</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"errorMsg is: \"</span>, errorMsg)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span>/<span class=\"number\">10</span> =  <span class=\"number\">10</span></span><br><span class=\"line\">errorMsg is:  </span><br><span class=\"line\">  Cannot proceed, the divider is zero.</span><br><span class=\"line\">  dividee: <span class=\"number\">100</span></span><br><span class=\"line\">  divider: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"2-panic-函数\"><a href=\"#2-panic-函数\" class=\"headerlink\" title=\"2.panic 函数\"></a>2.panic 函数</h3><p>描述: 当遇到某种严重的问题时需要直接退出程序时，应该调用panic函数从而引发的panic异常, 所以panic用于不可恢复的错误类似于Java的Error。</p>\n<p>具体流程：是当panic异常发生时，程序会中断运行，并立即执行在该goroutine，随后程序崩溃并输出日志信息。日志信息包括panic、以及value的函数调用的堆栈跟踪信息。</p>\n<p>panic 函数语法定义:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">panic</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>Tips : panic函数接受任何值作为参数</p>\n<p><br></p>\n<p><strong>示例1.数组越界会自动调用panic</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestA</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"func TestA&#123;&#125;\"</span>)\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestB</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a [<span class=\"number\">10</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\">  a[x] = <span class=\"number\">111</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestC</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"func TestC()\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">TestA()</span><br><span class=\"line\">TestB(<span class=\"number\">20</span>) <span class=\"comment\">//发生异常,中断程序</span></span><br><span class=\"line\">TestC()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; func TestA&#123;&#125;</span><br><span class=\"line\">panic: runtime error: index out of rang</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>示例2.调用panic函数引发的panic异常</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">A</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"我是A函数 - 正常执行\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">B</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"我是B函数 - 正在执行\"</span>)</span><br><span class=\"line\">  <span class=\"built_in\">panic</span>(<span class=\"string\">\"func B():panic\"</span>)</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"我是B函数 - 结束执行\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">C</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"我是c函数 - 正在执行\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  A()</span><br><span class=\"line\">  B() <span class=\"comment\">//发生异常,中断程序</span></span><br><span class=\"line\">  C()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我是A函数 - 正常执行</span><br><span class=\"line\">我是B函数 - 正在执行</span><br><span class=\"line\">发生异常: <span class=\"built_in\">panic</span></span><br><span class=\"line\"><span class=\"string\">\"func B():panic\"</span></span><br><span class=\"line\">Stack:</span><br><span class=\"line\">  <span class=\"number\">2</span>  <span class=\"number\">0x00000000004b69a5</span> in main.B</span><br><span class=\"line\">      at /home/weiyigeek/app/project/<span class=\"keyword\">go</span>/src/weiyigeek.top/studygo/Day02/<span class=\"number\">05</span>error.<span class=\"keyword\">go</span>:<span class=\"number\">47</span></span><br><span class=\"line\">  <span class=\"number\">3</span>  <span class=\"number\">0x00000000004b6a8a</span> in main.demo2</span><br><span class=\"line\">      at /home/weiyigeek/app/project/<span class=\"keyword\">go</span>/src/weiyigeek.top/studygo/Day02/<span class=\"number\">05</span>error.<span class=\"keyword\">go</span>:<span class=\"number\">57</span></span><br><span class=\"line\">  <span class=\"number\">4</span>  <span class=\"number\">0x00000000004b6ac5</span> in main.main</span><br><span class=\"line\">      at /home/weiyigeek/app/project/<span class=\"keyword\">go</span>/src/weiyigeek.top/studygo/Day02/<span class=\"number\">05</span>error.<span class=\"keyword\">go</span>:<span class=\"number\">63</span></span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2021/5/20210816203155.png\" alt=\"WeiyiGeek.panic异常\" title=\"\" class=\"\">\n                <p>WeiyiGeek.panic异常</p>\n            </figure></p>\n<p><strong>Q: 什么时候使用Error，什么时候使用Panic?</strong></p>\n<ul>\n<li>对于真正意外的情况，那些表示不可恢复的程序错误，例如<code>索引越界、不可恢复的环境问题、栈溢出、数据库连接后需操作</code>，我们才使用 panic。</li>\n<li>对于其他的错误情况，我们应该是期望使用 error 来进行判定。</li>\n</ul>\n<p><br/></p>\n<h3 id=\"3-recover-函数\"><a href=\"#3-recover-函数\" class=\"headerlink\" title=\"3.recover 函数\"></a>3.recover 函数</h3><p>描述: panic异常会导致程序崩溃,而recover函数专门用于“捕获”运行时的panic异常,它可以是当前程序从运行时panic的状态中恢复并重新获得流程控制权。</p>\n<p>通常我们会使用 Recover 捕获 Panic 异常，例如Java中利用<code>Catch Throwable</code>来进行捕获异常。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Java</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C++</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>panic 函数语法定义:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recover</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 在未发生panic时调用recover会返回nil。</p>\n<p><br/></p>\n<p><strong>流程说明:</strong> 如果调用了内置函数recover,并且定义该defer语句的函数发生了panic异常,recover会使程序从panic中恢复,并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。</p>\n<p><br/></p>\n<p><strong>示例1:panic与recover联合使用，此处采用 panic 演示的代码中的B函数进行继续修改</strong><br>描述: 在Go语言中可以通过defer定义的函数去执行一些错误恢复的行为<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recoverB</span><span class=\"params\">()</span> <span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"我是recoverB 函数 - 正在执行\"</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 必须是 defer 语句中以及在panic函数前</span></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    x := <span class=\"built_in\">recover</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      err = fmt.Errorf(<span class=\"string\">\"# 1.进行 recover（恢复） Panic 导致的程序异常,从此之后将会继续执行后续代码：\\n%v\"</span>, x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;() <span class=\"comment\">// 此处利用匿名函数</span></span><br><span class=\"line\">  <span class=\"comment\">//panic(\"# 2.recoverB 函数中捕获 Panic\")</span></span><br><span class=\"line\">  <span class=\"built_in\">panic</span>(errors.New(<span class=\"string\">\"# 2.recoverB 函数中出现 Panic\"</span>))</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"我是recoverB 函数 - 结束执行\"</span>) <span class=\"comment\">// 无法访问的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo3</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  A()</span><br><span class=\"line\">  err := recoverB()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"#recoverB 输出的信息：\"</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  C()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我是A函数 - 正常执行</span><br><span class=\"line\">我是recoverB 函数 - 正在执行</span><br><span class=\"line\"><span class=\"comment\"># recoverB 输出的信息： # 1.进行 recover（恢复） Panic 导致的程序异常,从此之后将会继续执行后续代码：</span></span><br><span class=\"line\"><span class=\"comment\"># 2.recoverB 函数中出现 Panic</span></span><br><span class=\"line\">我是c函数 - 正在执行</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>示例 2.recover捕获异常后的异常，不能再次被recover捕获。</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo4</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 采用匿名函数进行立即执行该函数</span></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//   声明defer，</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"----调用 defer func1 start----\"</span>)</span><br><span class=\"line\">    err := <span class=\"built_in\">recover</span>() <span class=\"comment\">// 此处输出为 nil ，因为panic只能被 recover 捕获一次</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"# 第二次 捕获 : %#v \\n\"</span>, err)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"----调用 defer func1 end----\"</span>)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//   声明defer，压栈操作后进先出。</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"----调用 defer func2 start----\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"# 第一次 捕获:\"</span>, err) <span class=\"comment\">// 这里的err其实就是panic传入的内容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"----调用 defer func2 end----\"</span>)</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">panic</span>(<span class=\"string\">\"panic 异常 抛出 测试！\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----调用 <span class=\"keyword\">defer</span> func2 start----</span><br><span class=\"line\"># 第一次 捕获: <span class=\"built_in\">panic</span> 异常 抛出 测试！</span><br><span class=\"line\">----调用 <span class=\"keyword\">defer</span> func2 end----</span><br><span class=\"line\">----调用 <span class=\"keyword\">defer</span> func1 start----</span><br><span class=\"line\"># 第二次 捕获 : &lt;<span class=\"literal\">nil</span>&gt; </span><br><span class=\"line\">----调用 <span class=\"keyword\">defer</span> func1 end----</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>Q: panic() 与 recover() 位置区别?</strong><br>答: panic函数可以在任何地方引发(但panic退出前会执行defer指定的内容)，但recover函数<code>只有在defer调用的函数中有效</code>并且一定要<code>位于panic语句之前</code>。</p>\n<p>TIPS : 非常注意下面这种“错误方式”, 他可能会形成僵尸服务进程，导致<code>Health Check</code>失效。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer <span class=\"function\"><span class=\"title\">func</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := recover(); err != nil &#123;</span><br><span class=\"line\">    Log.Error(<span class=\"string\">\"Recovered Panic\"</span>, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;()</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>Q: panic 和 os.Exit 联用时对recover的影响</strong></p>\n<ul>\n<li>os.Exit 退出时不会调用defer指定的函数.</li>\n<li>os.Exit 退出时不会输出当前调用栈信息.</li>\n</ul>\n<p><br></p>\n<h3 id=\"4-错误处理最佳实践\"><a href=\"#4-错误处理最佳实践\" class=\"headerlink\" title=\"4.错误处理最佳实践\"></a>4.错误处理最佳实践</h3><ul>\n<li>1、预定义错误，code里判断</li>\n<li>2、及早失败，避免嵌套</li>\n</ul>\n<hr>\n<h2 id=\"0x02-Go语言基础之结构体\"><a href=\"#0x02-Go语言基础之结构体\" class=\"headerlink\" title=\"0x02 Go语言基础之结构体\"></a>0x02 Go语言基础之结构体</h2><p>描述: Go语言中没有<code>“类”</code>的概念，也<code>不支持“类”的继承</code>等面向对象的概念。但 Go语言中<code>通过结构体的内嵌</code>再<code>配合接口</code>比面向对象具<code>有更高的扩展性</code>和<code>灵活性</code>。</p>\n<ul>\n<li><p>Go语言中的基础数据类型可以<code>表示一些事物的基本属性</code>，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了（局限性）。</p>\n</li>\n<li><p>Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体(英文名称struct), 我们<code>可以通过struct来定义自己的类型</code>了。</p>\n</li>\n</ul>\n<p><strong>简单得说:</strong> 结构体时一种数据类型，一种我们自己可以保持多个维度数据的类型。 所以与其他高级编程语言一样，Go语言也可以采用结构体的特性, 并且Go语言<code>通过struct来实现面向对象</code>。</p>\n<p><br></p>\n<h3 id=\"1-类型定义\"><a href=\"#1-类型定义\" class=\"headerlink\" title=\"1.类型定义\"></a>1.类型定义</h3><p>描述: 在Go语言中有一些基本的数据类型，如<code>string、int{}整型、float{}浮点型、boolean布尔</code>等数据类型， Go语言中可以<code>使用type关键字来定义自定义类型</code>(实际上定义了一个全新的类型)。</p>\n<p>Tips : 我们可以基于内置的基本类型定义，也可以通过struct定义。</p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将MyInt定义为int类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyInt <span class=\"keyword\">int</span></span><br></pre></td></tr></table></figure></p>\n<p>通过type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p>\n<p><br></p>\n<h3 id=\"2-类型别名\"><a href=\"#2-类型别名\" class=\"headerlink\" title=\"2.类型别名\"></a>2.类型别名</h3><p>描述: 类型别名从字面意义上都很好理解，即类型别名本章上与原类型一样, 就比如像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> TypeAlias = Type</span><br></pre></td></tr></table></figure></p>\n<p>我们之前见过的<code>rune</code>和<code>byte</code>就是类型别名，他们的定义如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">type</span> byte = uint8</span><br><span class=\"line\"><span class=\"built_in\">type</span> rune = int32</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 采用int32别名创建一个变量的几种方式。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyInt32 = <span class=\"keyword\">int32</span></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i MyInt32</span><br><span class=\"line\">i = <span class=\"number\">1024</span></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> j MyInt32 = <span class=\"number\">1024</span></span><br><span class=\"line\"><span class=\"comment\">// 方式3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> k  = MyInt32(<span class=\"number\">1024</span>)</span><br><span class=\"line\"><span class=\"comment\">// 方式4</span></span><br><span class=\"line\">l := MyInt32(<span class=\"number\">1024</span>)  <span class=\"comment\">// 此处并非是函数，而是一个强制类型转换而已</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>Q: 类型定义和类型别名有何区别?</strong></p>\n<blockquote>\n<p>答: 类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p>\n</blockquote>\n<p><strong>示例演示1:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.类型定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> NewInt <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.类型别名</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyInt = <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类型定义 与 类型别名 区别演示</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 类型定义的使用</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> i NewInt</span><br><span class=\"line\">  i = <span class=\"number\">1024</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of i: %T, Value:%v \\n\"</span>, i, i)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 类型别名的使用</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> j MyInt</span><br><span class=\"line\">  j = <span class=\"number\">2048</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of j: %T, Value:%v \\n\"</span>, j, j)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// rune 也是类型别名底层还是int32类型</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> k <span class=\"keyword\">rune</span></span><br><span class=\"line\">  k = <span class=\"string\">'中'</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of j: %T, Value:%c \\n\"</span>, k, k)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type of i: main.NewInt, Value:<span class=\"number\">1024</span> </span><br><span class=\"line\">Type of j: <span class=\"keyword\">int</span>, Value:<span class=\"number\">2048</span> </span><br><span class=\"line\">Type of j: <span class=\"keyword\">int32</span>, Value:中</span><br></pre></td></tr></table></figure></p>\n<p>结果显示说明:</p>\n<ul>\n<li><code>i</code> 变量的类型是main.NewInt，表示main包下定义的NewInt类型。</li>\n<li><code>j</code> 变量的类型是int，因MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</li>\n</ul>\n<p><br></p>\n<h3 id=\"3-结构体的定义\"><a href=\"#3-结构体的定义\" class=\"headerlink\" title=\"3.结构体的定义\"></a>3.结构体的定义</h3><p>描述: 语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。<code>比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</code>。</p>\n<p><br></p>\n<p>使用<code>type</code>和<code>struct</code>关键字来定义结构体，具体代码格式如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> 类型名 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  字段名 字段类型</span><br><span class=\"line\">  字段名 字段类型</span><br><span class=\"line\">  …</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中:</p>\n<ul>\n<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>\n<li>字段名：表示结构体字段名。结构体中的字段名必须唯一。</li>\n<li>字段类型：表示结构体字段的具体类型。</li>\n</ul>\n<p>举例说明: 以定义一个Person（人）结构体为例:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式(0)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式(1)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name <span class=\"keyword\">string</span></span><br><span class=\"line\">  city <span class=\"keyword\">string</span></span><br><span class=\"line\">  age  <span class=\"keyword\">int8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式(2): 同样类型的字段也可以写在一行</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> person1 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name, city <span class=\"keyword\">string</span></span><br><span class=\"line\">  age   <span class=\"keyword\">int8</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Tips : 上面创建了结构体一个person的自定义类型，它有<code>name、city、age</code>三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。</p>\n<p><br></p>\n<h3 id=\"4-结构体实例化\"><a href=\"#4-结构体实例化\" class=\"headerlink\" title=\"4.结构体实例化\"></a>4.结构体实例化</h3><p>描述: 只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p>\n<p>Tips ：结构体本身也是一种类型，我们可以像声明内置类型一样使用<code>var</code>关键字声明结构体类型。例如:<code>var 结构体实例 结构体类型</code>。</p>\n<p><br/></p>\n<p>描述: 结构体初始化是非常必要，因为没有初始化的结构体，其成员变量都是对应其类型的零值。</p>\n<p><strong>结构体示例化的三种语法格式:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> demo <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  username <span class=\"keyword\">string</span></span><br><span class=\"line\">  city <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.方式1.利用`.`进行调用指定属性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> m1 demo</span><br><span class=\"line\">demo.username = <span class=\"string\">\"WeiyiGeek\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.方式2.使用键值对初始化</span></span><br><span class=\"line\">m2 := demo &#123;username: <span class=\"string\">\"WeiyiGeek\"</span>,city:<span class=\"string\">\"重庆\"</span>,&#125;</span><br><span class=\"line\">m2 := &amp;demo &#123;username: <span class=\"string\">\"WeiyiGeek\"</span>,city:<span class=\"string\">\"重庆\"</span>,&#125; <span class=\"comment\">// ==&gt; new(demo) 此种方式会在结构体指针里面实践。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.方式3.使用值的列表初始化</span></span><br><span class=\"line\">m3 := demo &#123;</span><br><span class=\"line\">  <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"重庆\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">m3 := &amp;demo &#123;</span><br><span class=\"line\">  <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"重庆\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 特别注意在<code>使用值的列表初始化</code>这种格式初始化时, (1)<code>必须初始化结构体的所有字段</code>,(2)<code>初始值的填充顺序必须与字段在结构体中的声明顺序一致</code>,(3) <code>该方式不能和键值初始化方式混用。</code></p>\n<p><br></p>\n<p><strong>示例演示:</strong> 下述演示三种基础方式进行结构体的实例化。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.结构体初识还是老示例采用结构体描述人员信息并进行赋值使用</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name  <span class=\"keyword\">string</span></span><br><span class=\"line\">  age   <span class=\"keyword\">uint8</span></span><br><span class=\"line\">  sex   <span class=\"keyword\">bool</span></span><br><span class=\"line\">  hobby []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 方式1.声明一个Persin类型的变量x</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x Person</span><br><span class=\"line\">  <span class=\"comment\">// 通过结构体中的属性进行赋值</span></span><br><span class=\"line\">  x.name = <span class=\"string\">\"WeiyiGeek\"</span></span><br><span class=\"line\">  x.age = <span class=\"number\">20</span></span><br><span class=\"line\">  x.sex = <span class=\"literal\">true</span> <span class=\"comment\">// &#123;Boy,Girl)</span></span><br><span class=\"line\">  x.hobby = []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Basketball\"</span>, <span class=\"string\">\"乒乓球\"</span>, <span class=\"string\">\"羽毛球\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 输出变量x的类型以及其字段的值</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of x : %T, Value : %v \\n\"</span>, x, x)</span><br><span class=\"line\">  x.name = <span class=\"string\">\"WeiyiGeeker\"</span></span><br><span class=\"line\">  <span class=\"comment\">// 我们通过.来访问结构体的字段（成员变量）, 例如x.name和x.age等。</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"My Name is %v \\n\"</span>, x.name)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 方式2.在声明是进行赋值(key：value，或者 value)的值格式</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用键值对初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = Person&#123;</span><br><span class=\"line\">    name:  <span class=\"string\">\"Go\"</span>,</span><br><span class=\"line\">    age:   <span class=\"number\">16</span>,</span><br><span class=\"line\">    sex:   <span class=\"literal\">false</span>,</span><br><span class=\"line\">    hobby: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"Computer\"</span>, <span class=\"string\">\"ProgramDevelopment\"</span>&#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of y : %T, Value : %v \\n\"</span>, y, y)</span><br><span class=\"line\">  <span class=\"comment\">// 非常注意此种方式是按照结构体中属性顺序进行赋值,同样未赋值的为该类型的零值</span></span><br><span class=\"line\">  <span class=\"comment\">// 使用值的列表初始化</span></span><br><span class=\"line\">  z := Person&#123;</span><br><span class=\"line\">    <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"literal\">true</span>,</span><br><span class=\"line\">    []<span class=\"keyword\">string</span>&#123;&#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of z : %T, Value : %v \\n\"</span>, z, z)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type of x : main.Person, Value : &#123;WeiyiGeek <span class=\"number\">20</span> <span class=\"literal\">true</span> [Basketball 乒乓球 羽毛球]&#125; </span><br><span class=\"line\">My Name is WeiyiGeeker </span><br><span class=\"line\">Type of y : main.Person, Value : &#123;Go <span class=\"number\">16</span> <span class=\"literal\">false</span> [Computer ProgramDevelopment]&#125; </span><br><span class=\"line\">Type of z : main.Person, Value : &#123;WeiyiGeek <span class=\"number\">10</span> <span class=\"literal\">true</span> []&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 如果没有给结构体中的属性赋值，则默认采用该类型的零值。</p>\n<p><br></p>\n<h3 id=\"5-结构体内存布局\"><a href=\"#5-结构体内存布局\" class=\"headerlink\" title=\"5.结构体内存布局\"></a>5.结构体内存布局</h3><p>描述: 结构体占用一块连续的内存，但是需要注意空结构体是不占用空间的。</p>\n<h4 id=\"连续内存空间\"><a href=\"#连续内存空间\" class=\"headerlink\" title=\"连续内存空间\"></a>连续内存空间</h4><p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1.空结构体是不占用空间的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">fmt.Println(unsafe.Sizeof(v))  <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例2.结构体占用一块连续的内存</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> test <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  a <span class=\"keyword\">int8</span></span><br><span class=\"line\">  b <span class=\"keyword\">int8</span></span><br><span class=\"line\">  c <span class=\"keyword\">int8</span></span><br><span class=\"line\">  d <span class=\"keyword\">int8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">n := test&#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"n.a %p, int8 size: %d\\n\"</span>, &amp;n.a, unsafe.Sizeof(<span class=\"keyword\">bool</span>(<span class=\"literal\">true</span>)))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"n.b %p\\n\"</span>, &amp;n.b)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"n.c %p\\n\"</span>, &amp;n.c)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"n.d %p\\n\"</span>, &amp;n.d)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行结果:</span></span><br><span class=\"line\">n.a <span class=\"number\">0xc0000a0060</span></span><br><span class=\"line\">n.b <span class=\"number\">0xc0000a0061</span></span><br><span class=\"line\">n.c <span class=\"number\">0xc0000a0062</span></span><br><span class=\"line\">n.d <span class=\"number\">0xc0000a0063</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"内存对齐分析\"><a href=\"#内存对齐分析\" class=\"headerlink\" title=\"内存对齐分析\"></a>内存对齐分析</h4><p><strong>[进阶知识点] 关于在 Go 语言中恰到好处的内存对齐</strong><br>描述: 在讲解前内存对齐前, 我们先丢出两个struct结构体引发思考:</p>\n<p><strong>示例1.</strong> 注意两个结构体中声明不同元素类型的顺序。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Part1 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  a <span class=\"keyword\">bool</span></span><br><span class=\"line\">  b <span class=\"keyword\">int32</span></span><br><span class=\"line\">  c <span class=\"keyword\">int8</span></span><br><span class=\"line\">  d <span class=\"keyword\">int64</span></span><br><span class=\"line\">  e <span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Part2 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  e <span class=\"keyword\">byte</span></span><br><span class=\"line\">  c <span class=\"keyword\">int8</span></span><br><span class=\"line\">  a <span class=\"keyword\">bool</span></span><br><span class=\"line\">  b <span class=\"keyword\">int32</span></span><br><span class=\"line\">  d <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在开始之前，希望你计算一下 Part1 与 Part2 两个结构体分别占用的大小是多少呢?<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">typeSize</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"bool size: %d\\n\"</span>, unsafe.Sizeof(<span class=\"keyword\">bool</span>(<span class=\"literal\">true</span>)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"int32 size: %d\\n\"</span>, unsafe.Sizeof(<span class=\"keyword\">int32</span>(<span class=\"number\">0</span>)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"int8 size: %d\\n\"</span>, unsafe.Sizeof(<span class=\"keyword\">int8</span>(<span class=\"number\">0</span>)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"int64 size: %d\\n\"</span>, unsafe.Sizeof(<span class=\"keyword\">int64</span>(<span class=\"number\">0</span>)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"byte size: %d\\n\"</span>, unsafe.Sizeof(<span class=\"keyword\">byte</span>(<span class=\"number\">0</span>)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"string size: %d\\n\"</span>, unsafe.Sizeof(<span class=\"string\">\"WeiyiGeek\"</span>))  <span class=\"comment\">// 注意上面声明的结构体中没有该类型。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> size: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">int32</span> size: <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">int8</span> size: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">int64</span> size: <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span> size: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">string</span> size: <span class=\"number\">16</span></span><br></pre></td></tr></table></figure></p>\n<p>这么一算 Part1/Part2 结构体的占用内存大小为 <code>1+4+1+8+1 = 15</code> 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p>\n<p>真实情况是怎么样的呢？我们实际调用看看，如下：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  part1 := Part1&#123;&#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"part1 size: %d, align: %d\\n\"</span>, unsafe.Sizeof(part1), unsafe.Alignof(part1))</span><br><span class=\"line\">  fmt.Println()</span><br><span class=\"line\">  part2 := Part2&#123;&#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"part2 size: %d, align: %d\\n\"</span>, unsafe.Sizeof(part2), unsafe.Alignof(part2))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">part1 size: <span class=\"number\">32</span>, align: <span class=\"number\">8</span></span><br><span class=\"line\">part2 size: <span class=\"number\">16</span>, align: <span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\">Tips : <span class=\"string\">`unsafe.Sizeof`</span> 来返回相应类型的空间占用大小</span><br><span class=\"line\">Tips : <span class=\"string\">`unsafe.Alignof`</span> 来返回相应类型的对齐系数</span><br></pre></td></tr></table></figure></p>\n<p>从上述结果中可以看见 <code>part1</code> 占用32个字节而 <code>part2</code> 占用16字节,此时 part1 比我们上面计算结构体占用字节数多了16 Byte, 并且相同的元素类型但顺序不同的 part2 是正确的只占用了 16 Byte, 那为什么会出现这样的情况呢？同时这充分地说明了先前的计算方式是错误的。</p>\n<p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算，接下来我们详细的讲讲它是什么</p>\n<p><br></p>\n<p><strong>Q: What 什么是内存对齐?</strong><br>答:有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放<code>(例图1) 表示一个坑一个萝卜的内存读取方式</code>。但实际上 CPU 并不会以一个一个字节去读取和写入内存, <code>相反 CPU 读取内存是一块一块读取的</code>，块的大小可以为 2、4、6、8、16 字节等大小, 块大小我们称其为内存访问粒度(例图2)：</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2021/5/20210818152721.png\" alt=\"WeiyiGeek.内存对齐\" title=\"\" class=\"\">\n                <p>WeiyiGeek.内存对齐</p>\n            </figure>\n<p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p>\n<p><br></p>\n<p><strong>Q: Why 为什么要关心对齐?</strong></p>\n<ul>\n<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li>\n<li>你正在处理向量方面的指令</li>\n<li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li>\n</ul>\n<p><br></p>\n<p><strong>Q: Why 为什么要做对齐?</strong></p>\n<ul>\n<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。<code>例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</code></li>\n<li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2021/5/20210818152928.png\" alt=\"WeiyiGeek.内存申请\" title=\"\" class=\"\">\n                <p>WeiyiGeek.内存申请</p>\n            </figure>\n<p>在上图中，假设从 Index 1 开始读取，将会出现很崩溃的问题, <code>因为它的内存访问边界是不对齐的</code>。因此 CPU 会做一些额外的处理工作。如下：</p>\n<ul>\n<li>1.CPU 首次读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li>\n<li>2.CPU 再次读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li>\n<li>3.合并 1-4 字节的数据</li>\n<li>4.合并后放入寄存器</li>\n</ul>\n<p>从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作, <code>而假设做了内存对齐，从 Index 0 开始读取 4 个字节，只需要读取一次</code>，也不需要额外的运算。这显然高效很多，是标准的空间换时间做法</p>\n<p><br></p>\n<p><strong>默认系数</strong><br>描述: 在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 #pragma pack(n) 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：<code>32 位：4, 64 位：8</code>, 例如, 前面示例中的对齐系数是8验证了我们系统是64位的。</p>\n<p>另外要注意不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p>\n<p><br></p>\n<p><strong>不同数据类型的对齐系数</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>() &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"bool align: %d\\n\"</span>, unsafe.Alignof(bool(<span class=\"literal\">true</span>)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"byte align: %d\\n\"</span>, unsafe.Alignof(byte(0)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"int8 align: %d\\n\"</span>, unsafe.Alignof(int8(0)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"int32 align: %d\\n\"</span>, unsafe.Alignof(int32(0)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"int64 align: %d\\n\"</span>, unsafe.Alignof(int64(0)))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"string align: %d\\n\"</span>, unsafe.Alignof(<span class=\"string\">\"WeiyiGeek\"</span>))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"map align: %d\\n\"</span>, unsafe.Alignof(map[string]string&#123;&#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> align: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span> align: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">int8</span> align: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">int32</span> align: <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">int64</span> align: <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">string</span> align: <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"keyword\">map</span> align: <span class=\"number\">8</span></span><br></pre></td></tr></table></figure><br>通过观察输出结果，可得知基本都是 2^n，最大也不会超过 8。这是因为我手提（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数。</p>\n<p>Tips: 在上小节中提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p>\n<p><br></p>\n<p><strong>对齐规则</strong></p>\n<ul>\n<li>1.<code>结构体的成员变量</code>，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值。<code>其偏移量必须为对齐值的整数倍</code></li>\n<li>2.<code>结构体本身</code>，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值</li>\n<li>3.结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>\n</ul>\n<p><br></p>\n<p><strong>分析流程</strong></p>\n<p>Step 1.首先我们先来分析 <code>part1 结构体</code> 到底经历了些什么，影响了 “预期” 结果</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>类型</th>\n<th>偏移量</th>\n<th>自身占用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td>bool</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>字节对齐</td>\n<td>无</td>\n<td>1</td>\n<td>3</td>\n</tr>\n<tr>\n<td>b</td>\n<td>int32</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>c</td>\n<td>int8</td>\n<td>8</td>\n<td>1</td>\n</tr>\n<tr>\n<td>字节对齐</td>\n<td>无</td>\n<td>9</td>\n<td>7</td>\n</tr>\n<tr>\n<td>d</td>\n<td>int64</td>\n<td>16</td>\n<td>8</td>\n</tr>\n<tr>\n<td>e</td>\n<td>byte</td>\n<td>24</td>\n<td>1</td>\n</tr>\n<tr>\n<td>字节对齐</td>\n<td>无</td>\n<td>25</td>\n<td>7</td>\n</tr>\n<tr>\n<td>总占用大小</td>\n<td>-</td>\n<td>-</td>\n<td>32</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<p>成员对齐步骤</p>\n<ul>\n<li>第一个成员 a<ul>\n<li>类型为 bool</li>\n<li>大小/对齐值为 1 字节</li>\n<li>初始地址，偏移量为 0。占用了第 1 位</li>\n</ul>\n</li>\n<li>第二个成员 b<ul>\n<li>类型为 int32</li>\n<li>大小/对齐值为 4 字节</li>\n<li><code>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding</code>(理解点)。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</li>\n</ul>\n</li>\n<li>第三个成员 c<ul>\n<li>类型为 int8</li>\n<li>大小/对齐值为 1 字节</li>\n<li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c…</li>\n</ul>\n</li>\n<li>第四个成员 d<ul>\n<li>类型为 int64</li>\n<li>大小/对齐值为 8 字节</li>\n<li>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</li>\n</ul>\n</li>\n<li>第五个成员 e<ul>\n<li>类型为 byte</li>\n<li>大小/对齐值为 1 字节</li>\n<li>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e…</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<p>整体对齐步骤</p>\n<ul>\n<li>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 2^n，不是偶数倍。显然不符合对齐的规则</li>\n<li>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</li>\n</ul>\n<p><br></p>\n<p>结果说明：</p>\n<blockquote>\n<p>最终 Part1 内存布局 <code>axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</code></p>\n</blockquote>\n<p><strong>通过本节的分析，可得知先前的 “推算” 为什么错误？</strong><br>是因为实际内存管理并非 “一个萝卜一个坑” 的思想。而是一块一块。通过空间换时间（效率）的思想来完成这块读取、写入。另外也需要兼顾不同平台的内存操作情况</p>\n<p><br></p>\n<p>Step 2.通过上述我们可知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。而像 <code>part2</code> 结构体一样，按照变量类型对齐值从小到大，进行依次排序进行占用内存空间的结果分析。</p>\n<p>通过开头的示例我们可知，只是 “简单” 对成员变量的字段顺序(<code>类型占用字节数从小到大排序</code>)进行改变，就改变了结构体占用大小。</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>类型</th>\n<th>偏移量</th>\n<th>自身占用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>e</td>\n<td>byte</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>c</td>\n<td>int8</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>a</td>\n<td>bool</td>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>字节对齐</td>\n<td>无</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr>\n<td>b</td>\n<td>int32</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>d</td>\n<td>int64</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>总占用大小</td>\n<td>-</td>\n<td>-</td>\n<td>16</td>\n</tr>\n</tbody>\n</table>\n<p><br></p>\n<p>成员对齐</p>\n<ul>\n<li>第一个成员 e<ul>\n<li>类型为 byte</li>\n<li>大小/对齐值为 1 字节</li>\n<li>初始地址，偏移量为 0。占用了第 1 位</li>\n</ul>\n</li>\n<li>第二个成员 c<ul>\n<li>类型为 int8</li>\n<li>大小/对齐值为 1 字节</li>\n<li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 2。不需要额外对齐</li>\n</ul>\n</li>\n<li>第三个成员 a<ul>\n<li>类型为 bool</li>\n<li>大小/对齐值为 1 字节</li>\n<li>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 3。不需要额外对齐</li>\n</ul>\n</li>\n<li>第四个成员 b<ul>\n<li>类型为 int32</li>\n<li>大小/对齐值为 4 字节</li>\n<li><code>根据规则1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此第 3 位为 Padding</code>(理解点)。而当前数值从第 4 位开始填充，到第 8 位。如下：ecax|bbbb</li>\n</ul>\n</li>\n<li>第五个成员 d<ul>\n<li>类型为 int64</li>\n<li>大小/对齐值为 8 字节</li>\n<li>根据规则1，其偏移量必须为 8 的整数倍。当前偏移量为 8。不需要额外对齐，从 9-16 位填充 8 个字节。如下：ecax|bbbb|dddd|dddd</li>\n</ul>\n</li>\n</ul>\n<p>整体对齐: 由于符合规则 2，则不需要额外对齐。</p>\n<p>结果说明:</p>\n<blockquote>\n<p>Part2 内存布局：ecax|bbbb|dddd|dddd</p>\n</blockquote>\n<p><br/></p>\n<p><strong>总结</strong></p>\n<p>通过对比 <code>Part1</code> 和 <code>Part2</code> 的内存布局，你会发现两者有很大的不同。如下：</p>\n<ul>\n<li>Part1：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</li>\n<li>Part2：ecax|bbbb|dddd|dddd</li>\n</ul>\n<p>仔细一看，<code>Part1</code> 存在许多 Padding。显然它占据了不少空间，那么 Padding 是怎么出现的呢？</p>\n<p>通过本文的介绍，可得知是由于不同类型导致需要进行字节对齐，以此保证内存的访问边界</p>\n<p>那么也不难理解，为什么<strong>调整结构体内成员变量的字段顺序</strong>就能达到缩小结构体占用大小的疑问了，是因为巧妙地减少了 Padding 的存在。让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮</p>\n<p>当然了，没什么特殊问题，你可以不关注这一块。但你要知道这块知识点 😄</p>\n<p><br></p>\n<h3 id=\"6-指针类型结构体\"><a href=\"#6-指针类型结构体\" class=\"headerlink\" title=\"6.指针类型结构体\"></a>6.指针类型结构体</h3><h4 id=\"结构体指针实例化\"><a href=\"#结构体指针实例化\" class=\"headerlink\" title=\"结构体指针实例化\"></a>结构体指针实例化</h4><p>描述: 我们还可以通过使用<code>new</code>关键字(<code>对基础类型进行实例化</code>)对结构体进行实例化，得到的是结构体的地址。</p>\n<p>创建一个结构体指针格式:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方式1.New 实例化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"built_in\">new</span>(person)     </span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%T\\n\"</span>, p2)     <span class=\"comment\">// *main.person</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"p2=%#v\\n\"</span>, p2) <span class=\"comment\">// p2=&amp;main.person&#123;name:\"\", city:\"\", age:0&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</span></span><br><span class=\"line\">p2.name = <span class=\"string\">\"WeiyiGeek\"</span></span><br><span class=\"line\">p2.age = <span class=\"number\">22</span></span><br><span class=\"line\">p2.city = <span class=\"string\">\"重庆\"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"p2=%#v\\n\"</span>, p2)  <span class=\"comment\">//显示出其结构体结构: p2=&amp;main.person&#123;name:\"WeiyiGeek\", city:\"重庆\", age:22&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2.使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</span></span><br><span class=\"line\">p3 := &amp;person&#123;&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"%T\\n\"</span>, p3)     <span class=\"comment\">//*main.person</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"p3=%#v\\n\"</span>, p3) <span class=\"comment\">//p3=&amp;main.person&#123;name:\"\", city:\"\", age:0&#125;</span></span><br><span class=\"line\">p3.name = <span class=\"string\">\"WeiyiGeek\"</span></span><br><span class=\"line\">p3.age = <span class=\"number\">30</span></span><br><span class=\"line\">p3.city = <span class=\"string\">\"重庆\"</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"p3=%#v\\n\"</span>, p3) <span class=\"comment\">//p3=&amp;main.person&#123;name:\"WeiyiGeek\", city:\"重庆\", age:30&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips ：<code>p3.name = &quot;WeiyiGeek&quot;</code>其实在底层是<code>(*p3).name = &quot;Geeker&quot;</code>，这是Go语言帮我们实现的语法糖。</p>\n<p><br/></p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name  <span class=\"keyword\">string</span></span><br><span class=\"line\">  age   <span class=\"keyword\">uint8</span></span><br><span class=\"line\">  sex   <span class=\"keyword\">bool</span></span><br><span class=\"line\">  hobby []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.结构体指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo3</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 方式1.结构体利用new实例化在内存中申请一块空间</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> p1 = <span class=\"built_in\">new</span>(Person)</span><br><span class=\"line\">  (*p1).name = <span class=\"string\">\"WeiyiGeek\"</span> <span class=\"comment\">// 取得地址存放的值并将其进行覆盖</span></span><br><span class=\"line\">  p1.age = <span class=\"number\">20</span>              <span class=\"comment\">// Go语言的语法糖自动根据指针找到对应地址的值并将其值覆盖。</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of p1 : %T, Struct 实例化结果: %#v\\n\"</span>, p1, p1)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 方式2.采用取地址&amp;符号进行实例化结构体(效果与new差不多)</span></span><br><span class=\"line\">  p2 := &amp;Person&#123;&#125;</span><br><span class=\"line\">  (*p2).name = <span class=\"string\">\"Golang\"</span> <span class=\"comment\">// 取得地址存放的值并将其进行覆盖</span></span><br><span class=\"line\">  p2.age = <span class=\"number\">12</span>           <span class=\"comment\">// Go语言的语法糖自动根据指针找到对应地址的值并将其值覆盖。</span></span><br><span class=\"line\">  p2.sex = <span class=\"literal\">true</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of p2 : %T, Struct 实例化结果: %#v\\n\"</span>, p2, p2)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 5.使用键值对初始化(也可以对结构体指针进行键值对初始化)</span></span><br><span class=\"line\">  <span class=\"comment\">// 当某些字段没有初始值的时候，该字段可以不写。此时没有指定初始值的字段的值就是该字段类型的零值。</span></span><br><span class=\"line\">  p3 := &amp;Person&#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"北京\"</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"p3 Value = %#v \\n\"</span>, p3)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 6.使用值的列表初始化</span></span><br><span class=\"line\">  <span class=\"comment\">// 初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</span></span><br><span class=\"line\">  p4 := &amp;Person&#123;</span><br><span class=\"line\">    <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">    <span class=\"number\">20</span>,</span><br><span class=\"line\">    <span class=\"literal\">false</span>,</span><br><span class=\"line\">    []<span class=\"keyword\">string</span>&#123;&#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"p4 Value = %#v \\n\"</span>, p4)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 4.探究Struct结构体开辟的是连续的内存空间(内存对齐效果)</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"*p2 size of = %d, p2 align of = %d \\n\"</span>, unsafe.Sizeof(*p2), unsafe.Alignof(p2))</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Pointer p2 = %p, \\name = %p,p2.name size of = %d \\nnage = %p, p2.age size of = %d\\nsex = %p, p2.sex size of = %d\\nhobby = %p,p2.hobby size of = %d \\n\"</span>, p2, &amp;p2.name, unsafe.Sizeof((*p2).name), &amp;p2.age, unsafe.Sizeof(p2.age), &amp;p2.sex, unsafe.Sizeof(p2.sex), &amp;p2.hobby, unsafe.Sizeof(p2.hobby))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type of p1 : *main.Person, Struct 实例化结果: &amp;main.Person&#123;name:<span class=\"string\">\"WeiyiGeek\"</span>, age:<span class=\"number\">0x14</span>, sex:<span class=\"literal\">false</span>, hobby:[]<span class=\"keyword\">string</span>(<span class=\"literal\">nil</span>)&#125;</span><br><span class=\"line\">Type of p2 : *main.Person, Struct 实例化结果: &amp;main.Person&#123;name:<span class=\"string\">\"Golang\"</span>, age:<span class=\"number\">0xc</span>, sex:<span class=\"literal\">true</span>, hobby:[]<span class=\"keyword\">string</span>(<span class=\"literal\">nil</span>)&#125;</span><br><span class=\"line\">p3 Value = &amp;main.Person&#123;name:<span class=\"string\">\"北京\"</span>, age:<span class=\"number\">0x0</span>, sex:<span class=\"literal\">false</span>, hobby:[]<span class=\"keyword\">string</span>(<span class=\"literal\">nil</span>)&#125; </span><br><span class=\"line\">p4 Value = &amp;main.Person&#123;name:<span class=\"string\">\"WeiyiGeek\"</span>, age:<span class=\"number\">0x14</span>, sex:<span class=\"literal\">false</span>, hobby:[]<span class=\"keyword\">string</span>&#123;&#125;&#125; </span><br><span class=\"line\"><span class=\"comment\">// 结构体占用一块连续的内存地址。</span></span><br><span class=\"line\">*p2 size of = <span class=\"number\">48</span>, p2 align of = <span class=\"number\">8</span> </span><br><span class=\"line\">Pointer p2 = <span class=\"number\">0xc0001181b0</span>, </span><br><span class=\"line\">name = <span class=\"number\">0xc0001181b0</span>,p2.name size of = <span class=\"number\">16</span> </span><br><span class=\"line\">age = <span class=\"number\">0xc0001181c0</span>, p2.age size of = <span class=\"number\">1</span></span><br><span class=\"line\">sex = <span class=\"number\">0xc0001181c1</span>, p2.sex size of = <span class=\"number\">1</span></span><br><span class=\"line\">hobby = <span class=\"number\">0xc0001181c8</span>,p2.hobby size of = <span class=\"number\">24</span></span><br></pre></td></tr></table></figure></p>\n<p>从上述Person 结构体指针 p2 内存对齐结果中可知，元素类型占用的大小 <code>16 + 1 + 1 + 24 = 42 Byte</code>, 但是收到整体对齐的规则约束，该 <code>p2 指针类型的结构体</code>占用的内存空间大小为 48 Byte。</p>\n<p><br></p>\n<h4 id=\"结构体指针函数传递\"><a href=\"#结构体指针函数传递\" class=\"headerlink\" title=\"结构体指针函数传递\"></a>结构体指针函数传递</h4><p>描述: 我们可以将指针类型的结构体进行地址传递在函数中修改其元素属性内容。</p>\n<p>示例演示:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">personChange</span><span class=\"params\">(p Person)</span></span> &#123;</span><br><span class=\"line\">  p.name = <span class=\"string\">\"Change\"</span>   <span class=\"comment\">// 拷贝的是 p4 指针类型的结构的副本(值引用)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">personPointerChange</span><span class=\"params\">(p *Person)</span></span> &#123;</span><br><span class=\"line\">  p.name = <span class=\"string\">\"PointerChange\"</span>  <span class=\"comment\">// 传递的是 p4 的地址，所以修改的是 p4.name 的属性值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo4</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  p4 := &amp;Person&#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  personChange(*p4)  <span class=\"comment\">// 值传递</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"personChange(*p4) -&gt;\tname = %v \\n\"</span>, p4.name)</span><br><span class=\"line\"></span><br><span class=\"line\">  personPointerChange(p4) <span class=\"comment\">// 地址传递</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"personPointerChange(*p4) -&gt;\tname = %v\"</span>, p4.name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">personChange(*p4) -&gt;\tname = WeiyiGeek </span><br><span class=\"line\">personPointerChange(*p4) -&gt;\tname = PointerChange</span><br></pre></td></tr></table></figure><br>Tips : Go 语言中函数传的参数永远传的是拷贝, 如果要修改原数据必须进行取地址传递并修改。</p>\n<p><br></p>\n<h4 id=\"结构体指针构造函数\"><a href=\"#结构体指针构造函数\" class=\"headerlink\" title=\"结构体指针构造函数\"></a>结构体指针构造函数</h4><p>描述: Go语言的结构体没有构造函数，但我们可以自己实现一个。 </p>\n<p>Tips: Go语言构造函数约定俗成用<code>new</code>进行开头，例如 <code>newDog()</code>。</p>\n<p>例如: 下方的代码就实现了一个person的构造函数。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) 结构体构造函数</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name, city <span class=\"keyword\">string</span></span><br><span class=\"line\">  age        <span class=\"keyword\">uint8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式1.值传递(拷贝副本) 返回的是结构体</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newPerson</span><span class=\"params\">(name, city <span class=\"keyword\">string</span>, age <span class=\"keyword\">uint8</span>)</span> <span class=\"title\">Person</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Person&#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    city: city,</span><br><span class=\"line\">    age:  age,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2.地址(指针类型变量)传递返回的是结构体指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newPointerPerson</span><span class=\"params\">(name, city <span class=\"keyword\">string</span>, age <span class=\"keyword\">uint8</span>)</span> *<span class=\"title\">Person</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Person&#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    city: city,</span><br><span class=\"line\">    age:  age,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// (1) 通过定义的函数直接进行结构体的初始化(值拷贝的方式)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> person = newPerson(<span class=\"string\">\"WeiyiGeek\"</span>, <span class=\"string\">\"重庆\"</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"newPerson Type : %T, Value : %v\\n\"</span>, person, person)</span><br><span class=\"line\">  <span class=\"comment\">// (2) 通过定义的函数直接传入指针类型的结构体进行初始化(地址拷贝的方式)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> pointerperson = newPointerPerson(<span class=\"string\">\"Go\"</span>, <span class=\"string\">\"world\"</span>, <span class=\"number\">12</span>)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"newPointerPerson Type : %T, Value : %v\\n\"</span>, pointerperson, pointerperson)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newPerson Type : main.Person, Value : &#123;WeiyiGeek 重庆 20&#125;</span><br><span class=\"line\">newPointerPerson Type : *main.Person, Value : &amp;&#123;Go world 12&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips ：因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>\n<p><br></p>\n<h3 id=\"7-结构体方法与接收者\"><a href=\"#7-结构体方法与接收者\" class=\"headerlink\" title=\"7.结构体方法与接收者\"></a>7.结构体方法与接收者</h3><p>描述: Go语言中的<code>方法（Method）</code>是一种作用于特定类型变量的函数, 这种<code>特定类型变量叫做接收者（Receiver）</code>, 接收者的概念就类似于其他语言中的 <code>this</code> 或者 <code>self</code>。</p>\n<h4 id=\"结构体方法\"><a href=\"#结构体方法\" class=\"headerlink\" title=\"结构体方法\"></a>结构体方法</h4><p><strong>定义格式：</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(接收者变量 接收者类型)</span> 方法名<span class=\"params\">(参数列表)</span> <span class=\"params\">(返回参数)</span></span> &#123;</span><br><span class=\"line\">  函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中，</p>\n<ul>\n<li><code>接收者变量</code>：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是self、this之类的命名。例如 Person类型 的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</li>\n<li><code>接收者类型</code>：接收者类型和参数类似，可以是<code>指针类型</code>和<code>非指针类型</code>。</li>\n<li><code>方法名、参数列表、返回参数</code>：具体格式与函数定义相同。</li>\n</ul>\n<p>Tips : 结构体方法名称写法约束规定，如果其标识符首字母是大写的就表示对外部包可见(<code>例如 java 中 public 指定的函数或者是类</code>公共的)，如果其标识符首字母是小写的表示对外部不可见(<code>不能直接调用</code>), 当然这是一种开发习惯非强制必须的。</p>\n<BR>\n\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Person 结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name <span class=\"keyword\">string</span></span><br><span class=\"line\">  age  <span class=\"keyword\">int8</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NewPerson 构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPerson</span><span class=\"params\">(name <span class=\"keyword\">string</span>, age <span class=\"keyword\">int8</span>)</span> *<span class=\"title\">Person</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;Person&#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    age:  age,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Dream Person做梦的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span> <span class=\"title\">Dream</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"%s的梦想是学好Go语言！\\n\"</span>, p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  p1 := NewPerson(<span class=\"string\">\"WeiyiGeek\"</span>, <span class=\"number\">25</span>)</span><br><span class=\"line\">  p1.Dream()  <span class=\"comment\">// WeiyiGeek的梦想是学好Go语言！</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>\n<p><br></p>\n<h4 id=\"值类型的接收者\"><a href=\"#值类型的接收者\" class=\"headerlink\" title=\"值类型的接收者\"></a>值类型的接收者</h4><p>描述: 当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。</p>\n<p>在值类型接收者的方法中可以获取接收者的成员值，但<code>修改操作只是针对副本，无法修改接收者变量本身</code>。</p>\n<p>例如: 我们为 Person 添加一个SetAge方法，来修改实例变量的年龄, 验证是否可被修改。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  使用值接收者：SetAge2 设置p的年龄</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span> <span class=\"title\">SetAge2</span><span class=\"params\">(newAge <span class=\"keyword\">int8</span>)</span></span> &#123;</span><br><span class=\"line\">  p.age = newAge</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  p1 := NewPerson(<span class=\"string\">\"WeiyiGeek\"</span>, <span class=\"number\">25</span>)</span><br><span class=\"line\">  p1.Dream()</span><br><span class=\"line\">  fmt.Println(p1.age) <span class=\"comment\">// 25</span></span><br><span class=\"line\">  p1.SetAge2(<span class=\"number\">30</span>) <span class=\"comment\">// (*p1).SetAge2(30)</span></span><br><span class=\"line\">  fmt.Println(p1.age) <span class=\"comment\">// 25</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"指针类型的接收者\"><a href=\"#指针类型的接收者\" class=\"headerlink\" title=\"指针类型的接收者\"></a>指针类型的接收者</h4><p>描述: 指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。此种方式就十分接近于其他语言中面向对象中的this或者self达到的效果。</p>\n<p>例如：我们为 Person 添加一个SetAge方法，来修改实例变量的年龄。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用指针接收者 : SetAge 设置p的年龄: 传入的 Person 实例化后的变量的地址 p ，并通过p.属性进行更改其内容存储的内容。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span> <span class=\"title\">SetAge</span><span class=\"params\">(newAge <span class=\"keyword\">int8</span>)</span></span> &#123;</span><br><span class=\"line\">  p.age = newAge</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  p1 := NewPerson(<span class=\"string\">\"WeiyiGeek\"</span>, <span class=\"number\">25</span>)</span><br><span class=\"line\">  fmt.Println(p1.age) <span class=\"comment\">// 25</span></span><br><span class=\"line\">  p1.SetAge(<span class=\"number\">30</span>)</span><br><span class=\"line\">  fmt.Println(p1.age) <span class=\"comment\">// 30</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Q: 什么时候应该使用指针类型接收者?</strong></p>\n<ul>\n<li>一是、需要修改接收者中的值。</li>\n<li>二是、接收者是拷贝代价比较大的大对象。</li>\n<li>三是、保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>\n</ul>\n<p><strong>案例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结构体方法和接收者, 只能被Person结构体实例化的对象进行调用，不能像函数那样直接调用。此处还是采用上面声明的结构体</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span> <span class=\"title\">ChangePersonName</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  p.name = name</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"# 执行 -&gt; ChangePersonName 方法 -&gt; p Ptr : %p ,value : %v\\n\"</span>, &amp;p, p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span> <span class=\"title\">ChangePointerPersonName</span><span class=\"params\">(name <span class=\"keyword\">string</span>, age <span class=\"keyword\">uint8</span>)</span></span> &#123;</span><br><span class=\"line\">  p.name = name</span><br><span class=\"line\">  p.age = age</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"# 执行 -&gt; ChangePointerPersonName 方法 -&gt; p Ptr : %p (关键点),value : %v\\n\"</span>, p, p.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 利用构造函数进行初始化</span></span><br><span class=\"line\">  p1 := newPerson(<span class=\"string\">\"小黄\"</span>, <span class=\"string\">\"Beijing\"</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"p1 Pointer : %p , Struct : %+v \\n\"</span>, &amp;p1, p1)</span><br><span class=\"line\">  <span class=\"comment\">// 调用 ChangePersonName 方法</span></span><br><span class=\"line\">  p1.ChangePersonName(<span class=\"string\">\"小黑\"</span>) <span class=\"comment\">// 值类型的接收者(修改的是p1结构体副本的值)</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"\tp1 Pointer : %p , Struct : %+v \\n\"</span>, &amp;p1, p1)</span><br><span class=\"line\">  <span class=\"comment\">// 调用 ChangePointerPersonName 方法</span></span><br><span class=\"line\">  p1.ChangePointerPersonName(<span class=\"string\">\"小白\"</span>, <span class=\"number\">30</span>) <span class=\"comment\">//指针类型的接收者 (修改的是p1结构体元素的值)</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"\tp1 Pointer : %p , Struct : %+v \\n\"</span>, &amp;p1, p1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1 Pointer : 0xc00010c150 , Struct : &#123;name:小黄 city:Beijing age:20&#125; </span><br><span class=\"line\"><span class=\"comment\"># 执行 -&gt; ChangePersonName 方法 -&gt; p Ptr : 0xc00010c1b0 ,value : 小黑</span></span><br><span class=\"line\">  p1 Pointer : 0xc00010c150 , Struct : &#123;name:小黄 city:Beijing age:20&#125; </span><br><span class=\"line\"><span class=\"comment\"># 执行 -&gt; ChangePointerPersonName 方法 -&gt; p Ptr : 0xc00010c150 (关键点),value : 小白</span></span><br><span class=\"line\">  p1 Pointer : 0xc00010c150 , Struct : &#123;name:小白 city:Beijing age:30&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"任意类型的接收者\"><a href=\"#任意类型的接收者\" class=\"headerlink\" title=\"任意类型的接收者\"></a>任意类型的接收者</h4><p>描述: 在Go语言中接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。</p>\n<p>举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3.任意类型的接收者都可以拥有自己的方法</span></span><br><span class=\"line\"><span class=\"comment\">// MyInt 将int定义为自定义MyInt类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyInt <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"comment\">// SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m MyInt)</span> <span class=\"title\">SayHello</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Hello, 我是一个int, %s\"</span>, s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ChangeM 为MyInt添加一个ChangeM的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *MyInt)</span> <span class=\"title\">ChangeM</span><span class=\"params\">(newm MyInt)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"# Start old m : %d -&gt; new m : %d \\n\"</span>, *m, newm)</span><br><span class=\"line\">  *m = newm  <span class=\"comment\">// 关键点修改m其值，此处非拷贝的副本</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"# End old m : %d -&gt; new m : %d \\n\"</span>, *m, newm)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo3</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> m1 MyInt</span><br><span class=\"line\">  <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">  m1 = <span class=\"number\">100</span></span><br><span class=\"line\">  <span class=\"comment\">// 方式2</span></span><br><span class=\"line\">  m2 := MyInt(<span class=\"number\">255</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 调用类型方法</span></span><br><span class=\"line\">  m1.SayHello(<span class=\"string\">\"Let'Go\"</span>)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"SayHello -&gt; Type m1 : %T, value : %+v \\n\"</span>, m1, m1)</span><br><span class=\"line\">  <span class=\"comment\">// 调用类型方法修改m1其值</span></span><br><span class=\"line\">  m1.ChangeM(<span class=\"number\">1024</span>)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"ChangeM -&gt; Type m1 : %T, value : %+v \\n\"</span>, m1, m1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello, 我是一个int, Let<span class=\"string\">'GoSayHello -&gt; Type m1 : main.MyInt, value : 100 </span></span><br><span class=\"line\"><span class=\"string\"># Start old m : 100 -&gt; new m : 1024 </span></span><br><span class=\"line\"><span class=\"string\"># End old m : 1024 -&gt; new m : 1024 </span></span><br><span class=\"line\"><span class=\"string\">ChangeM -&gt; Type m1 : main.MyInt, value : 1024</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips : 非常注意，非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p>\n<p><br></p>\n<h3 id=\"8-匿名结构体与匿名字段\"><a href=\"#8-匿名结构体与匿名字段\" class=\"headerlink\" title=\"8.匿名结构体与匿名字段\"></a>8.匿名结构体与匿名字段</h3><p>描述: 在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匿名结构体(只能使用一次，所以常常使用与临时场景)</span></span><br><span class=\"line\"><span class=\"comment\">// 2.匿名结构体(只能使用一次，所以常常使用与临时场景)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp <span class=\"keyword\">struct</span> &#123;title <span class=\"keyword\">string</span>;address []<span class=\"keyword\">string</span>&#125;</span><br><span class=\"line\">  temp.title = <span class=\"string\">\"地址信息\"</span></span><br><span class=\"line\">  temp.address = []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"中国\"</span>, <span class=\"string\">\"重庆\"</span>, <span class=\"string\">\"江北区\"</span>&#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Type of temp : %T\\nStruct define: %#v \\nValue : %v\\n\"</span>, temp, temp, temp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type of temp : <span class=\"keyword\">struct</span> &#123; title <span class=\"keyword\">string</span>; address []<span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\">Struct define: <span class=\"keyword\">struct</span> &#123; title <span class=\"keyword\">string</span>; address []<span class=\"keyword\">string</span> &#125;&#123;title:<span class=\"string\">\"地址信息\"</span>, address:[]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"中国\"</span>, <span class=\"string\">\"重庆\"</span>, <span class=\"string\">\"江北区\"</span>&#125;&#125; </span><br><span class=\"line\">Value : &#123;地址信息 [中国 重庆 江北区]&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>描述: 结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>\n<p>Tips: 这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>\n<p>示例演示:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Anonymous <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">string</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo4</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  a1 := Anonymous&#123;<span class=\"string\">\"WeiyiGeek\"</span>, <span class=\"number\">18</span>&#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Struct: %#v ，字段1: %v , 字段2: %v \\n\"</span>, a1, a1.<span class=\"keyword\">string</span>, a1.<span class=\"keyword\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Struct: main.Anonymous&#123;string:<span class=\"string\">\"WeiyiGeek\"</span>, int:18&#125; ，字段1: WeiyiGeek , 字段2: 18</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"9-嵌套结构体与匿名字段\"><a href=\"#9-嵌套结构体与匿名字段\" class=\"headerlink\" title=\"9.嵌套结构体与匿名字段\"></a>9.嵌套结构体与匿名字段</h3><p>描述: 结构体中可以嵌套包含另一个结构体或结构体指针, 并且上面user结构体中嵌套的Address结构体也可以采用匿名字段的方式。</p>\n<p>并且为了防止嵌套结构体的相同的字段名冲突，所以在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Address 地址结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Address <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Province <span class=\"keyword\">string</span></span><br><span class=\"line\">  City     <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Email 邮箱结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Email <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Account    <span class=\"keyword\">string</span></span><br><span class=\"line\">  CreateTime <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//User 用户结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Name    <span class=\"keyword\">string</span></span><br><span class=\"line\">  Gender  <span class=\"keyword\">string</span></span><br><span class=\"line\">  Address Address</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//AnonUser 用户结构体</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> AnonUser <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Name    <span class=\"keyword\">string</span></span><br><span class=\"line\">  Gender  <span class=\"keyword\">string</span></span><br><span class=\"line\">  Address <span class=\"comment\">// 采用结构体的匿名字段来嵌套结构体Address</span></span><br><span class=\"line\">  Email   <span class=\"comment\">// 采用结构体的匿名字段来嵌套结构体Email</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1.嵌套结构体</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 结构体初始化</span></span><br><span class=\"line\">  user := User&#123;</span><br><span class=\"line\">    Name:   <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">    Gender: <span class=\"string\">\"男\"</span>,</span><br><span class=\"line\">    Address: Address&#123;</span><br><span class=\"line\">      Province: <span class=\"string\">\"重庆\"</span>,</span><br><span class=\"line\">      City:     <span class=\"string\">\"重庆\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Struct : %#v \\n\"</span>, user)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Name = %v, Address City = %v \\n\"</span>, user.Name, user.Address.City)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.嵌套匿名字段防止字段名称冲突</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">demo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> anonuser = AnonUser&#123;</span><br><span class=\"line\">    Name:   <span class=\"string\">\"WeiyiGeek\"</span>,</span><br><span class=\"line\">    Gender: <span class=\"string\">\"男\"</span>,</span><br><span class=\"line\">    Address: Address&#123;</span><br><span class=\"line\">      <span class=\"string\">\"重庆\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"重庆\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Email: Email&#123;</span><br><span class=\"line\">      <span class=\"string\">\"Master@weiyigeek.top\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"2021年8月23日 10:21:36\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Struct : %#v\\n\"</span>, anonuser)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Name = %v,Address Province = %v, Email Account = %v \\n\"</span>, anonuser.Name, anonuser.Address.Province, anonuser.Email.Account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>执行结果:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 嵌套结构体</span></span><br><span class=\"line\">Struct : main.User&#123;Name:<span class=\"string\">\"WeiyiGeek\"</span>, Gender:<span class=\"string\">\"男\"</span>, Address:main.Address&#123;Province:<span class=\"string\">\"重庆\"</span>, City:<span class=\"string\">\"重庆\"</span>&#125;&#125; </span><br><span class=\"line\">Name = WeiyiGeek, Address City = 重庆 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//嵌套匿名字段</span></span><br><span class=\"line\">Struct : main.AnonUser&#123;Name:<span class=\"string\">\"WeiyiGeek\"</span>, Gender:<span class=\"string\">\"男\"</span>, Address:main.Address&#123;Province:<span class=\"string\">\"重庆\"</span>, City:<span class=\"string\">\"重庆\"</span>&#125;, Email:main.Email&#123;Account:<span class=\"string\">\"Master@weiyigeek.top\"</span>, CreateTime:<span class=\"string\">\"2021年8月23日 10:21:36\"</span>&#125;&#125;</span><br><span class=\"line\">Name = WeiyiGeek,Address Province = 重庆, Email Account = Master@weiyigeek.top</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。</p>\n<p><br></p>\n<h3 id=\"10-结构体的“继承”\"><a href=\"#10-结构体的“继承”\" class=\"headerlink\" title=\"10.结构体的“继承”\"></a>10.结构体的“继承”</h3><p>描述: Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>\n<p>示例演示:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span>&#123; name <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(a *Animal)</span> <span class=\"title\">voice</span><span class=\"params\">(v <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"我是动物，我叫 %v, 我会叫 %s,\"</span>, a.name, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Dog <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  eat <span class=\"keyword\">string</span></span><br><span class=\"line\">  *Animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d *Dog)</span> <span class=\"title\">love</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"狗狗喜欢吃的食物是 %v.\\n\"</span>, d.eat)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cat <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  eat <span class=\"keyword\">string</span></span><br><span class=\"line\">  *Animal</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cat)</span> <span class=\"title\">love</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"猫猫喜欢吃的食物是 %v.\\n\"</span>, c.eat)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  d1 := &amp;Dog&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注意嵌套的是结构体指针</span></span><br><span class=\"line\">    Animal: &amp;Animal&#123;</span><br><span class=\"line\">      name: <span class=\"string\">\"小黄\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    eat: <span class=\"string\">\"bone\"</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  d1.voice(<span class=\"string\">\"汪汪.汪汪.\"</span>)</span><br><span class=\"line\">  d1.love()</span><br><span class=\"line\"></span><br><span class=\"line\">  c1 := &amp;Cat&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注意嵌套的是结构体指针</span></span><br><span class=\"line\">    Animal: &amp;Animal&#123;</span><br><span class=\"line\">      name: <span class=\"string\">\"小白\"</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    eat: <span class=\"string\">\"fish\"</span>,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  c1.voice(<span class=\"string\">\"喵喵.喵喵.\"</span>)</span><br><span class=\"line\">  c1.love()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我是动物，我叫 小黄, 我会叫 汪汪.汪汪.,狗狗喜欢吃的食物是 bone.</span><br><span class=\"line\">我是动物，我叫 小白, 我会叫 喵喵.喵喵.,猫猫喜欢吃的食物是 fish.</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"11-结构体与“JSON”\"><a href=\"#11-结构体与“JSON”\" class=\"headerlink\" title=\"11.结构体与“JSON”\"></a>11.结构体与“JSON”</h3><p>描述: JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式,其优点是易于人阅读和编写，同时也易于机器解析和生成。</p>\n<p>Tips : JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p>\n<p>在Go中我们可以通过<code>结构体序列号生成json字符串</code>，同时也能<code>通过json字符串反序列化为结构体得实例化对象</code>，在使用json字符串转换时, 我们需要用到<code>&quot;encoding/json&quot;</code>包。</p>\n<p><strong>结构体标签（Tag）</strong><br>描述: Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来，Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：<code>key1:&quot;value1&quot; key2:&quot;value2&quot;</code>,可以看到它由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p>\n<p>例如: 我们为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Student <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID     <span class=\"keyword\">int</span>    <span class=\"string\">`json:\"id\"`</span> <span class=\"comment\">//通过指定tag实现json序列化该字段时的key</span></span><br><span class=\"line\">  Gender <span class=\"keyword\">string</span> <span class=\"comment\">//json序列化是默认使用字段名作为key</span></span><br><span class=\"line\">  name   <span class=\"keyword\">string</span> <span class=\"comment\">//私有不能被json包访问</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>\n<p><br/></p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"encoding/json\"</span></span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构体转json字符串的三种示例</span></span><br><span class=\"line\"><span class=\"comment\">// 结构体中的字段首字母大小写影响的可见性，表示不能对外使用</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person1 <span class=\"keyword\">struct</span>&#123; name, sex <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构体对象字段可以对外使用</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person2 <span class=\"keyword\">struct</span>&#123; Name, Sex <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 但json字符串中键只要小写时可以采用此种方式</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person3 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Name <span class=\"keyword\">string</span> <span class=\"string\">`json:\"name\"`</span></span><br><span class=\"line\">  Sex  <span class=\"keyword\">string</span> <span class=\"string\">`json:\"age\"`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 结构体实例化对象转JSON字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serialize</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 示例1.字段首字母大小写影响的可见性</span></span><br><span class=\"line\">  person1 := &amp;Person1&#123;<span class=\"string\">\"weiyigeek\"</span>, <span class=\"string\">\"男孩\"</span>&#125;</span><br><span class=\"line\">  person2 := &amp;Person2&#123;<span class=\"string\">\"WeiyiGeek\"</span>, <span class=\"string\">\"男生\"</span>&#125;</span><br><span class=\"line\">  person3 := &amp;Person3&#123;<span class=\"string\">\"WeiyiGeek\"</span>, <span class=\"string\">\"男人\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//序列化</span></span><br><span class=\"line\">  p1, err := json.Marshal(person1)</span><br><span class=\"line\">  p2, err := json.Marshal(person2)</span><br><span class=\"line\">  p3, err := json.Marshal(person3)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Marshal Failed ：%v\"</span>, err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 由于返回是一个字节切片，所以需要强转为字符串</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"person1 -&gt; %v\\nperson2 -&gt; %v\\nperson3 -&gt; %v\\n\"</span>, <span class=\"keyword\">string</span>(p1), <span class=\"keyword\">string</span>(p2), <span class=\"keyword\">string</span>(p3))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # JSON字符串转结构体实例化对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person4 <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Name <span class=\"keyword\">string</span>    <span class=\"string\">`json:\"name\"`</span></span><br><span class=\"line\">  Sex  <span class=\"keyword\">string</span>    <span class=\"string\">`json:\"sex\"`</span></span><br><span class=\"line\">  Addr [<span class=\"number\">3</span>]<span class=\"keyword\">string</span> <span class=\"string\">`json:\"addr\"`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">unserialize</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  jsonStr := <span class=\"string\">`&#123;\"name\": \"WeiyiGeek\",\"sex\": \"man\",\"addr\": [\"中国\",\"重庆\",\"渝北\"]&#125;`</span></span><br><span class=\"line\">  p4 := Person4&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 在其内部修改p4的值</span></span><br><span class=\"line\">  err := json.Unmarshal([]<span class=\"keyword\">byte</span>(jsonStr), &amp;p4)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"Unmarhal Failed: %v\"</span>, err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"jsonStr -&gt; Person4 : %#v\\nPerson4.name : %v\\n\"</span>, p4, p4.Name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  serialize()</span><br><span class=\"line\">  unserialize()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person1 -&gt; &#123;&#125;</span><br><span class=\"line\">person2 -&gt; &#123;<span class=\"string\">\"Name\"</span>:<span class=\"string\">\"WeiyiGeek\"</span>,<span class=\"string\">\"Sex\"</span>:<span class=\"string\">\"男生\"</span>&#125;</span><br><span class=\"line\">person3 -&gt; &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"WeiyiGeek\"</span>,<span class=\"string\">\"age\"</span>:<span class=\"string\">\"男人\"</span>&#125;</span><br><span class=\"line\">jsonStr -&gt; Person4 : main.Person4&#123;Name:<span class=\"string\">\"WeiyiGeek\"</span>, Sex:<span class=\"string\">\"man\"</span>, Addr:[3]string&#123;<span class=\"string\">\"中国\"</span>, <span class=\"string\">\"重庆\"</span>, <span class=\"string\">\"渝北\"</span>&#125;&#125;</span><br><span class=\"line\">Person4.name : WeiyiGeek</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"12-结构体和方法补充知识点\"><a href=\"#12-结构体和方法补充知识点\" class=\"headerlink\" title=\"12.结构体和方法补充知识点\"></a>12.结构体和方法补充知识点</h3><p>描述: 因为slice和map这两种数据类型都包含了指向底层数据的指针，因此我们在需要复制它们时要特别注意。</p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name   <span class=\"keyword\">string</span></span><br><span class=\"line\">  age    <span class=\"keyword\">int8</span></span><br><span class=\"line\">  dreams []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不推荐的方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span> <span class=\"title\">SetDreams</span><span class=\"params\">(dreams []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  p.dreams = dreams</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确的做法是在方法中使用传入的slice的拷贝进行结构体赋值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Person)</span> <span class=\"title\">NewSetDreams</span><span class=\"params\">(dreams []<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  p.dreams = <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(dreams))</span><br><span class=\"line\">  <span class=\"built_in\">copy</span>(p.dreams, dreams)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// (1) 不安全的方式</span></span><br><span class=\"line\">  p1 := Person&#123;name: <span class=\"string\">\"小王子\"</span>, age: <span class=\"number\">18</span>&#125;</span><br><span class=\"line\">  data := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"吃饭\"</span>, <span class=\"string\">\"睡觉\"</span>, <span class=\"string\">\"打豆豆\"</span>&#125;</span><br><span class=\"line\">  p1.SetDreams(data)</span><br><span class=\"line\">  <span class=\"comment\">// 你真的想要修改 p1.dreams 吗？</span></span><br><span class=\"line\">  data[<span class=\"number\">1</span>] = <span class=\"string\">\"不睡觉\"</span>        <span class=\"comment\">// 会覆盖更改切片中的值从而影响p1中的dreams字段中的值</span></span><br><span class=\"line\">  fmt.Println(p1.dreams) <span class=\"comment\">// [吃饭 不睡觉 打豆豆]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// (2) 推荐方式</span></span><br><span class=\"line\">  p2 := Person&#123;name: <span class=\"string\">\"WeiyiGeek\"</span>, age: <span class=\"number\">18</span>&#125;</span><br><span class=\"line\">  data2 := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"计算机\"</span>, <span class=\"string\">\"网络\"</span>, <span class=\"string\">\"编程\"</span>&#125;</span><br><span class=\"line\">  p2.NewSetDreams(data2)</span><br><span class=\"line\">  data2[<span class=\"number\">1</span>] = <span class=\"string\">\"NewMethod\"</span> <span class=\"comment\">// 由于NewSetDreams返回中是将拷贝的副本给p2的dreams字段，所以此处更改不会影响其值，</span></span><br><span class=\"line\">  fmt.Println(p2.dreams) <span class=\"comment\">// [计算机 网络 编程]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>执行结果:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[吃饭 不睡觉 打豆豆]</span><br><span class=\"line\">[计算机 网络 编程]</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 同样的问题也存在于返回值slice和map的情况，在实际编码过程中一定要注意这个问题。</p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"Development","path":"api/categories/Development.json"},{"name":"Programming","path":"api/categories/Programming.json"}],"tags":[{"name":"Go","path":"api/tags/Go.json"}]}