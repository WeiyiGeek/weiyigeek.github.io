{"title":"2.Go语言之标准库学习记录(2)","slug":"编程世界/Go/Package/2.Go语言之标准库学习记录(2)","date":"2020-04-23T03:16:58.000Z","updated":"2022-03-11T03:29:11.749Z","url":"2020/4-23-603.html","path":"api/articles/2020/4-23-603.html.json","covers":null,"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h2 id=\"0x00-Strconv-字符串类型转换库\"><a href=\"#0x00-Strconv-字符串类型转换库\" class=\"headerlink\" title=\"0x00 Strconv.字符串类型转换库\"></a>0x00 Strconv.字符串类型转换库</h2><p>描述: Go语言中strconv包实现了基本数据类型和其字符串表示的相互转换，主要可以将字符串类型转换为整型(int32 、int64、int、uint)、浮点型(float32、float64)、布尔型（Boolean）等。</p>\n<p>主要有以下常用函数: Atoi()、Itoa()、parse系列和format以及append系列等，更多函数参考地址: <a href=\"https://golang.org/pkg/strconv/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/strconv/</a></p>\n<h3 id=\"1-Atoi-、Itoa-函数\"><a href=\"#1-Atoi-、Itoa-函数\" class=\"headerlink\" title=\"1.Atoi()、Itoa()函数\"></a>1.Atoi()、Itoa()函数</h3><p><strong>函数说明:</strong></p>\n<ul>\n<li><code>Atoi()</code> 函数用于将字符串类型的整数转换为int类型，函数原型如下: <code>func Atoi(s string) (i int, err error)</code></li>\n<li><code>Itoa()</code> 函数用于将int类型数据转换为对应的字符串表示，函数原型如下: <code>func Itoa(i int) string</code></li>\n</ul>\n<p>Tips: 你会发现 <code>Atoi()</code> 与 <code>Itoa()</code> 函数在C语言中也是存在，此处go延续了C语言某些函数用法便于C语言程序员的学习理解，因为C语言中没有string类型而是用字符数组(array)表示字符串。</p>\n<p>Tips: 如果传入的字符串参数无法转换为int类型时将会返回错误。</p>\n<p><br/></p>\n<h3 id=\"2-Parse系列函数\"><a href=\"#2-Parse系列函数\" class=\"headerlink\" title=\"2.Parse系列函数\"></a>2.Parse系列函数</h3><p>描述: Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。</p>\n<p><strong>函数说明</strong></p>\n<ul>\n<li><code>ParseInt()</code> 解析一个表示整数类型的字符串，返回字符串表示的整数值，接受正负号。</li>\n<li><code>ParseUnit()</code> ParseUint类似ParseInt但不接受正负号，用于无符号整型。</li>\n<li><code>ParseFloat()</code> 解析一个表示浮点数的字符串并返回其值.</li>\n<li><code>ParseBool()</code>  解析一个表示布尔类型的字符串,返回字符串表示的bool值。它接受 <code>1、0、t、f、T、F、true、false、True、False、TRUE、FALSE</code> 否则返回错误。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ParseInt</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ParseUint</span><span class=\"params\">(s <span class=\"keyword\">string</span>, base <span class=\"keyword\">int</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(n <span class=\"keyword\">uint64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ParseFloat</span><span class=\"params\">(s <span class=\"keyword\">string</span>, bitSize <span class=\"keyword\">int</span>)</span> <span class=\"params\">(f <span class=\"keyword\">float64</span>, err error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">ParseBool</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value <span class=\"keyword\">bool</span>, err error)</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>参数说明</strong></p>\n<ul>\n<li><code>s</code> 指传入的指定要转换的类型的字符串。</li>\n<li><code>base</code> 指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</li>\n<li><code>bitSize</code> 指定结果必须能无溢出赋值的整数或者浮点数类型，转换为整型时 0、8、16、32、64 分别代表 int、int8、int16、int32、int64；转换为浮点数类型时为float32（返回值可以不改变精确值的赋值给float32）、float64；</li>\n<li><code>返回的err是*NumErr类型的</code> 如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</li>\n</ul>\n<p>Tips : 上述函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。</p>\n<p><strong>实例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"strconv\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// 采用strconv包进行字符串的强制转换示例演示</span></span><br><span class=\"line\"><span class=\"comment\">// 字符串与整形互换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">strInteger</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 字符串转整型</span></span><br><span class=\"line\">  str := <span class=\"string\">\"1024\"</span></span><br><span class=\"line\">  ret1, err := strconv.ParseInt(str, <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"Parseint failed,err\"</span>, err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Integer Ret1 = %#v %T \\n\"</span>, ret1, ret1) <span class=\"comment\">// 返回int64类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ret2, _ := strconv.Atoi(str) <span class=\"comment\">// 字符串 -&gt; 整数</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"Integer Ret2 = %#v %T \\n\"</span>, ret2, ret2) <span class=\"comment\">// 返回int类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 整形转字符串</span></span><br><span class=\"line\">  i := <span class=\"keyword\">int32</span>(<span class=\"number\">1024</span>)</span><br><span class=\"line\">  ret3 := fmt.Sprintf(<span class=\"string\">\"%d\"</span>, i)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"String Ret3 = %#v %T\\n\"</span>, ret3, ret3)</span><br><span class=\"line\"></span><br><span class=\"line\">  ret4 := strconv.Itoa(<span class=\"keyword\">int</span>(i)) <span class=\"comment\">// int32 -&gt; int 类型 -&gt; 字符串</span></span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"String Ret4 = %#v %T\\n\"</span>, ret4, ret4)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串与浮点型互换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">strFloat</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  floatStr := <span class=\"string\">\"3.1415926\"</span> <span class=\"comment\">// 圆周率 Pi</span></span><br><span class=\"line\">  floatValue, _ := strconv.ParseFloat(floatStr, <span class=\"number\">32</span>)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"float floatValue = %#v %T\\n\"</span>, floatValue, floatValue)</span><br><span class=\"line\">&#125;、</span><br><span class=\"line\"><span class=\"comment\">// 字符串与布尔型互换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">strBoolean</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  boolStr := <span class=\"string\">\"True\"</span></span><br><span class=\"line\">  boolValue, _ := strconv.ParseBool(boolStr)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"boolean boolValue = %#v %T\\n\"</span>, boolValue, boolValue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 字符串与整形互换</span></span><br><span class=\"line\">  strInteger()</span><br><span class=\"line\">  <span class=\"comment\">// 字符串与浮点型互换</span></span><br><span class=\"line\">  strFloat()</span><br><span class=\"line\">  <span class=\"comment\">// 字符串与布尔型互换</span></span><br><span class=\"line\">  strBoolean()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer Ret1 = 1024 int64 </span><br><span class=\"line\">Integer Ret2 = 1024 int </span><br><span class=\"line\">String Ret3 = <span class=\"string\">\"1024\"</span> string</span><br><span class=\"line\">String Ret4 = <span class=\"string\">\"1024\"</span> string</span><br><span class=\"line\"><span class=\"built_in\">float</span> floatValue = 3.141592502593994 float64</span><br><span class=\"line\">boolean boolValue = <span class=\"literal\">true</span> bool</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"3-Format系列函数\"><a href=\"#3-Format系列函数\" class=\"headerlink\" title=\"3.Format系列函数\"></a>3.Format系列函数</h3><p>描述: Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p>\n<p><strong>函数说明:</strong><br><code>FormatInt()</code> : 返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。<code>func FormatInt(i int64, base int) string</code><br><code>FormatUint()</code> : 是FormatInt的无符号整数版本。<code>func FormatUint(i uint64, base int) string</code><br><code>FormatFloat()</code> : 函数将浮点数表示为字符串并返回。<code>func FormatFloat(f float64, fmt byte, prec, bitSize int) string</code><br><code>FormatBool()</code> : 根据b的值返回”true”或”false”。<code>func FormatBool(b bool) string</code></p>\n<p><strong>参数说明:</strong><br><code>base</code> 指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p>\n<p><code>bitSize</code> 表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p>\n<p><code>fmt</code> 表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p>\n<p><code>prec</code> 控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s1 := strconv.FormatBool(<span class=\"literal\">true</span>)</span><br><span class=\"line\">s2 := strconv.FormatFloat(<span class=\"number\">3.1415</span>, <span class=\"string\">'E'</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">s3 := strconv.FormatInt(<span class=\"number\">-2</span>, <span class=\"number\">16</span>)</span><br><span class=\"line\">s4 := strconv.FormatUint(<span class=\"number\">2</span>, <span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"6-Append系列、Quote系列等函数\"><a href=\"#6-Append系列、Quote系列等函数\" class=\"headerlink\" title=\"6.Append系列、Quote系列等函数\"></a>6.Append系列、Quote系列等函数</h3><p>描述: strconv包中还有Append系列、Quote系列等函数。具体用法可查看官方文档 <a href=\"https://golang.org/pkg/strconv/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/strconv/</a> , 后续用到时扩充。</p>\n<p><br></p>\n<h3 id=\"5-扩展说明\"><a href=\"#5-扩展说明\" class=\"headerlink\" title=\"5.扩展说明\"></a>5.扩展说明</h3><p><code>isPrint()</code> : 返回一个字符是否是可打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。<code>func IsPrint(r rune) bool</code><br><code>IsGraphic()</code> 报告符文是否由Unicode定义为图形。这些字符包括字母、标记、数字、标点符号、符号和空格，它们来自类别L、M、N、P、S和Zs。<code>func IsGraphic(r rune) bool</code><br><code>CanBackquote()</code> : 返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。<code>func CanBackquote(s string) bool</code></p>\n<p><br></p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := strconv.IsPrint(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">b := strconv.IsGraphic(<span class=\"string\">'佛'</span>)</span><br><span class=\"line\">c := strconv.CanBackquote(<span class=\"string\">\"THIS IS DEMO\"</span>)</span><br><span class=\"line\">fmt.Println(a, b, c) <span class=\"comment\">// true true true</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"0x01-Sync-并发安全库\"><a href=\"#0x01-Sync-并发安全库\" class=\"headerlink\" title=\"0x01 Sync.并发安全库\"></a>0x01 Sync.并发安全库</h2><p>描述: Go语言天生是支持并发的,所以为了更好方便开发者的基础使用,Go语言中可以使用Sync包提供基本同步原语，如互斥锁。除了Once和WaitGroup类型之外，大多数都是供低级库例程使用的，更高级别的同步最好通过通道和通信完成。</p>\n<p>主要有以下结构体方法: WaitGroup、Once、Mutex、RWMutex、Map等结构体，在下面我将简单描述其使用</p>\n<p>参考地址: <a href=\"https://golang.org/pkg/sync/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/sync/</a></p>\n<h3 id=\"1-sync-WaitGroup\"><a href=\"#1-sync-WaitGroup\" class=\"headerlink\" title=\"1.sync.WaitGroup\"></a>1.sync.WaitGroup</h3><p>描述: 在代码中生硬的使用time.Sleep肯定是不合适的，Go语言中可以使用sync.WaitGroup来实现并发任务的同步。</p>\n<p>sync.WaitGroup 有以下几个方法：</p>\n<ul>\n<li><code>func (wg *WaitGroup) Add(delta int)</code>: 计数器+1</li>\n<li><code>func (wg *WaitGroup) Done()</code>: 计数器-1</li>\n<li><code>func (wg *WaitGroup) Wait()</code>: 阻塞直到计数器变为0</li>\n</ul>\n<p><code>sync.WaitGroup</code> 内部维护着一个计数器，计数器的值可以增加和减少, 例如当我们启动了 N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用 <code>Done()</code> 方法将计数器减1。通过调用 <code>Wait()</code> 来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p>\n<p>使用示例:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done() <span class=\"comment\">// 完成时计数器-1</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"Hello Goroutine!\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)     <span class=\"comment\">// 计数器+1</span></span><br><span class=\"line\">  <span class=\"keyword\">go</span> hello()    <span class=\"comment\">// 启动一个goroutine去执行hello函数</span></span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"main goroutine done!\"</span>)</span><br><span class=\"line\">  wg.Wait()     <span class=\"comment\">//  阻塞直到计数器变为0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p>\n<p><br></p>\n<h3 id=\"2-sync-Once\"><a href=\"#2-sync-Once\" class=\"headerlink\" title=\"2.sync.Once\"></a>2.sync.Once</h3><p>描述: 在goroutine执行某一任务,我们想当最后一个goroutine任务执行完毕时，就关闭任务中的通道，此时为了防止其它线程执行完毕时多次关闭任务中的通道导致程序Panic，为了确保关闭通道只执行一次，在Go语言中的sync包中提供了一个针对只执行一次场景的解决方案<code>sync.Once</code>。</p>\n<p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p>\n<p>sync.Once 只有一个Do方法原型: <code>func (o *Once) Do(f func()) {}</code></p>\n<p>Tips: 如果要执行的函数f需要传递参数，此时需要搭配闭包来使用。</p>\n<p><br/></p>\n<p><strong>示例1.加载配置文件说明</strong><br>描述: 延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> icons <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]image.Image <span class=\"comment\">// 声明一个 Map 类型的icons变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadIcons</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 实例化</span></span><br><span class=\"line\">  icons = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]image.Image &#123;</span><br><span class=\"line\">    <span class=\"string\">\"left\"</span>:  loadIcon(<span class=\"string\">\"left.png\"</span>),</span><br><span class=\"line\">    <span class=\"string\">\"up\"</span>:    loadIcon(<span class=\"string\">\"up.png\"</span>),</span><br><span class=\"line\">    <span class=\"string\">\"right\"</span>: loadIcon(<span class=\"string\">\"right.png\"</span>),</span><br><span class=\"line\">    <span class=\"string\">\"down\"</span>:  loadIcon(<span class=\"string\">\"down.png\"</span>),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Icon 被多个goroutine调用时不是并发安全的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Icon</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">image</span>.<span class=\"title\">Image</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判读 icons 如果为nil表示没有值为空。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> icons == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    loadIcons()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> icons[name]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个goroutine都满足串行一致的基础上自由地重排访问内存的顺序。</p>\n<p>loadIcons函数可能会被重排为以下结果：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadIcons</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  icons = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]image.Image)</span><br><span class=\"line\">  icons[<span class=\"string\">\"left\"</span>] = loadIcon(<span class=\"string\">\"left.png\"</span>)</span><br><span class=\"line\">  icons[<span class=\"string\">\"up\"</span>] = loadIcon(<span class=\"string\">\"up.png\"</span>)</span><br><span class=\"line\">  icons[<span class=\"string\">\"right\"</span>] = loadIcon(<span class=\"string\">\"right.png\"</span>)</span><br><span class=\"line\">  icons[<span class=\"string\">\"down\"</span>] = loadIcon(<span class=\"string\">\"down.png\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在这种情况下就会出现<code>即使判断了icons不是nil也不意味着变量初始化完成了</code>考虑到这种情况; 我们能想到的办法就是添加互斥锁，保证初始化icons的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p>\n<p>使用sync.Once改造的示例代码如下:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> icons <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]image.Image</span><br><span class=\"line\"><span class=\"keyword\">var</span> loadIconsOnce sync.Once</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">loadIcons</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  icons = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]image.Image&#123;</span><br><span class=\"line\">    <span class=\"string\">\"left\"</span>:  loadIcon(<span class=\"string\">\"left.png\"</span>),</span><br><span class=\"line\">    <span class=\"string\">\"up\"</span>:    loadIcon(<span class=\"string\">\"up.png\"</span>),</span><br><span class=\"line\">    <span class=\"string\">\"right\"</span>: loadIcon(<span class=\"string\">\"right.png\"</span>),</span><br><span class=\"line\">    <span class=\"string\">\"down\"</span>:  loadIcon(<span class=\"string\">\"down.png\"</span>),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Icon 是并发安全的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Icon</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> <span class=\"title\">image</span>.<span class=\"title\">Image</span></span> &#123;</span><br><span class=\"line\">  loadIconsOnce.Do(loadIcons)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> icons[name]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<p><strong>示例2.并发安全的单例模式</strong><br>描述: 下面是借助sync.Once实现的并发安全的单例模式<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> singleton <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance *singleton</span><br><span class=\"line\"><span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span> *<span class=\"title\">singleton</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保实例化singleton只做一次</span></span><br><span class=\"line\">  once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    instance = &amp;singleton&#123;&#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips : sync.Once 其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全, 而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的,并且初始化操作也不会被执行多次。</p>\n<p><br></p>\n<h3 id=\"3-sync-Map\"><a href=\"#3-sync-Map\" class=\"headerlink\" title=\"3.sync.Map\"></a>3.sync.Map</h3><p>描述: Syn包中的 Map 类似于Go语言内置Map但其是这样<code>map[interface{}]interface{}</code>类型，但对于多个goroutine并发使用是安全的，无需额外的锁定或协调。加载、存储和删除在摊余固定时间内运行。</p>\n<p>Map 类型是专用的，大多数代码应该使用一个普通的Go Map来代替，并带有单独的锁定或协调，以提高类型安全性，并使维护其他不变量以及Map内容变得更容易。</p>\n<p>Map类型针对两种常见的使用情况进行了优化：<br>（1）当给定密钥的条目只写入一次但多次读取时（如在仅增长的缓存中）<br>（2）当多个goroutine读取、写入和覆盖不相交密钥集的条目时。在这两种情况下，与Go Map与单独的互斥或RW互斥配对相比，使用Map可以显著减少锁争用。</p>\n<p>Tips: 空值的Map也是可以使用的。</p>\n<p>sync.Map 中的方法如下:</p>\n<ul>\n<li>func (m *Map) Delete(key interface{}) : 删除键的值。</li>\n<li>func (m *Map) Load(key interface{}) (value interface{}, ok bool): 加载返回地图中存储的键值。</li>\n<li>func (m *Map) LoadAndDelete(key interface{}) (value interface{}, loaded bool): 加载以及删除键的值。</li>\n<li>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool): 会退回键的现有值</li>\n<li>func (m *Map) Range(f func(key, value interface{}) bool): 范围按顺序调用地图中存在的每个键和值。如果 f 返回错误，范围将停止迭代。</li>\n<li>func (m *Map) Store(key, value interface{}) : 设置键的值。</li>\n</ul>\n<p><br/></p>\n<p><strong>示例1.Go语言中内置的map不是并发安全的</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  m[key] = value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg := sync.WaitGroup&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">      key := strconv.Itoa(n)  <span class=\"comment\">// 整型转为字符串类型。</span></span><br><span class=\"line\">      set(key, n) <span class=\"comment\">// 读</span></span><br><span class=\"line\">      fmt.Printf(<span class=\"string\">\"k=:%v,v:=%v\\n\"</span>, key, get(key)) <span class=\"comment\">// 写</span></span><br><span class=\"line\">      wg.Done()</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 上面的代码开启少量几个goroutine的时候可能没什么问题，当并发多了(数量大于等于21时)之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误，像这种场景下就需要为map加锁来保证并发的安全性了。</p>\n<p>Go语言的sync包中提供了一个开箱即用的并发安全版的map就是<code>sync.Map</code>。开箱即用表示它不用像内置的map一样使用make函数初始化就能直接使用，同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法,提高了使用便利性及安全性。</p>\n<p><strong>实际案例</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"strconv\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">var</span> m = sync.Map&#123;&#125;  <span class=\"comment\">// 并发安全版的Map类型变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg := sync.WaitGroup&#123;&#125;  <span class=\"comment\">// 并发执行等待组变量</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++ &#123;</span><br><span class=\"line\">    wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">      key := strconv.Itoa(n)</span><br><span class=\"line\">      m.Store(key, n)  <span class=\"comment\">// 将n存入 m[\"key\"]=n</span></span><br><span class=\"line\">      value, _ := m.Load(key) <span class=\"comment\">// 读取存入 m[\"key\"] 的值</span></span><br><span class=\"line\">      fmt.Printf(<span class=\"string\">\"k=:%v,v:=%v\\n\"</span>, key, value)</span><br><span class=\"line\">      wg.Done()</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k=:<span class=\"number\">19</span>,v:=<span class=\"number\">19</span></span><br><span class=\"line\">k=:<span class=\"number\">0</span>,v:=<span class=\"number\">0</span></span><br><span class=\"line\">k=:<span class=\"number\">1</span>,v:=<span class=\"number\">1</span></span><br><span class=\"line\">k=:<span class=\"number\">2</span>,v:=<span class=\"number\">2</span></span><br><span class=\"line\">k=:<span class=\"number\">3</span>,v:=<span class=\"number\">3</span></span><br><span class=\"line\">k=:<span class=\"number\">4</span>,v:=<span class=\"number\">4</span></span><br><span class=\"line\">k=:<span class=\"number\">5</span>,v:=<span class=\"number\">5</span></span><br><span class=\"line\">k=:<span class=\"number\">6</span>,v:=<span class=\"number\">6</span></span><br><span class=\"line\">k=:<span class=\"number\">7</span>,v:=<span class=\"number\">7</span></span><br><span class=\"line\">k=:<span class=\"number\">8</span>,v:=<span class=\"number\">8</span></span><br><span class=\"line\">k=:<span class=\"number\">9</span>,v:=<span class=\"number\">9</span></span><br><span class=\"line\">k=:<span class=\"number\">10</span>,v:=<span class=\"number\">10</span></span><br><span class=\"line\">k=:<span class=\"number\">11</span>,v:=<span class=\"number\">11</span></span><br><span class=\"line\">k=:<span class=\"number\">12</span>,v:=<span class=\"number\">12</span></span><br><span class=\"line\">k=:<span class=\"number\">13</span>,v:=<span class=\"number\">13</span></span><br><span class=\"line\">k=:<span class=\"number\">14</span>,v:=<span class=\"number\">14</span></span><br><span class=\"line\">k=:<span class=\"number\">15</span>,v:=<span class=\"number\">15</span></span><br><span class=\"line\">k=:<span class=\"number\">16</span>,v:=<span class=\"number\">16</span></span><br><span class=\"line\">k=:<span class=\"number\">17</span>,v:=<span class=\"number\">17</span></span><br><span class=\"line\">k=:<span class=\"number\">18</span>,v:=<span class=\"number\">18</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"4-sync-Mutex、RWMutex\"><a href=\"#4-sync-Mutex、RWMutex\" class=\"headerlink\" title=\"4.sync.Mutex、RWMutex\"></a>4.sync.Mutex、RWMutex</h3><p>描述: 在Mutex、RWMutex结构体中分别定义的是互斥锁和读写锁。<br>互斥锁: 主要用于防止资源竞争问题的应用场景，一个互斥锁只能同时被一个 goroutine 锁定，其它 goroutine 将阻塞直到互斥锁被解锁。<br>读写锁: 主要用于读多写少的应用场景，它是针对读写操作的互斥锁，读写锁与互斥锁最大的不同就是可以分别对 读、写 进行锁定。</p>\n<p><strong>方法原型:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sync.Mutex</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Mutex)</span> <span class=\"title\">Lock</span><span class=\"params\">()</span>   // 加锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(m *Mutex)</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span> // 解锁</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">sync</span>.<span class=\"title\">RWMutex</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">Lock</span><span class=\"params\">()</span>   // 加写锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span> // 解写锁</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">RLock</span><span class=\"params\">()</span>  // 加读锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"params\">(rw *RWMutex)</span> <span class=\"title\">RUnlock</span><span class=\"params\">()</span>// 解读锁</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>补充说明:</strong></p>\n<ul>\n<li>当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；</li>\n<li>当有一个 goroutine 获得读锁定，其它读锁定任然可以继续；</li>\n<li>当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定;</li>\n</ul>\n<p>所以说这里的读锁定（RLock）目的其实是告诉写锁定：有很多人正在读取数据，你需要排队等待;</p>\n<p><br/></p>\n<p><strong>实践示例1: Mutex 互斥锁</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"comment\">// 启动足够多个协程</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> lock sync.Mutex</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(idx <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">        lock.Lock()  <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">        <span class=\"keyword\">defer</span> lock.Unlock() <span class=\"comment\">// 执行完毕后解锁</span></span><br><span class=\"line\">        a += <span class=\"number\">1</span></span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"goroutine %d, a=%d\\n\"</span>, idx, a)</span><br><span class=\"line\">    &#125;(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 主程序等待1s 确保所有协程执行完</span></span><br><span class=\"line\">  time.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行结果: 此时你将发现结果不仅没有发现抢占资源导致的输出重复,而且输出结果顺序递增.<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">goroutine <span class=\"number\">42946</span>, a=<span class=\"number\">47847</span></span><br><span class=\"line\">goroutine <span class=\"number\">42947</span>, a=<span class=\"number\">47848</span></span><br><span class=\"line\">goroutine <span class=\"number\">42948</span>, a=<span class=\"number\">47849</span></span><br><span class=\"line\">goroutine <span class=\"number\">42949</span>, a=<span class=\"number\">47850</span></span><br><span class=\"line\">goroutine <span class=\"number\">42856</span>, a=<span class=\"number\">47851</span></span><br><span class=\"line\">goroutine <span class=\"number\">42950</span>, a=<span class=\"number\">47852</span></span><br><span class=\"line\">goroutine <span class=\"number\">42857</span>, a=<span class=\"number\">47853</span></span><br><span class=\"line\">goroutine <span class=\"number\">42951</span>, a=<span class=\"number\">47854</span></span><br><span class=\"line\">goroutine <span class=\"number\">42858</span>, a=<span class=\"number\">47855</span></span><br><span class=\"line\">goroutine <span class=\"number\">42952</span>, a=<span class=\"number\">47856</span></span><br><span class=\"line\">goroutine <span class=\"number\">42859</span>, a=<span class=\"number\">47857</span></span><br><span class=\"line\">goroutine <span class=\"number\">43050</span>, a=<span class=\"number\">47858</span></span><br><span class=\"line\">goroutine <span class=\"number\">42860</span>, a=<span class=\"number\">47859</span></span><br><span class=\"line\">goroutine <span class=\"number\">42953</span>, a=<span class=\"number\">47860</span></span><br><span class=\"line\">goroutine <span class=\"number\">42861</span>, a=<span class=\"number\">47861</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<p><strong>实践示例1: RWMutex 读写锁锁</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">  <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m *sync.RWMutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> val = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// read 方法应用了读锁RLock;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">read</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  m.RLock()</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"读: \"</span>, i, val)</span><br><span class=\"line\">  time.Sleep(<span class=\"number\">3</span> * time.Second) <span class=\"comment\">// 为了验证协程抢夺资源, 读写方法中我们让程序休眠一定的时间;</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"读结束\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> m.RUnlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  write 方法应用了写锁 Lock;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">write</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  m.Lock()</span><br><span class=\"line\">  val = val + <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"写: \"</span>, i, val)</span><br><span class=\"line\">  time.Sleep(<span class=\"number\">3</span> * time.Second) <span class=\"comment\">// 为了验证协程抢夺资源, 读写方法中我们让程序休眠一定的时间;</span></span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"写结束\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> m.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  m = <span class=\"built_in\">new</span>(sync.RWMutex)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> read(<span class=\"number\">1</span>)  <span class=\"comment\">// 读</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"number\">5</span>; j++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> write(<span class=\"number\">2</span>) <span class=\"comment\">// 写</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> m := <span class=\"number\">0</span>; m &lt; <span class=\"number\">5</span>; m++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">go</span> read(<span class=\"number\">3</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 此处防止主程序提前退出,goroutine 协程函数还未执行完.</span></span><br><span class=\"line\">  time.Sleep(<span class=\"number\">25</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读:  <span class=\"number\">1</span> <span class=\"number\">10</span></span><br><span class=\"line\">读:  <span class=\"number\">3</span> <span class=\"number\">10</span></span><br><span class=\"line\">读:  <span class=\"number\">3</span> <span class=\"number\">10</span></span><br><span class=\"line\">读:  <span class=\"number\">3</span> <span class=\"number\">10</span></span><br><span class=\"line\">读:  <span class=\"number\">1</span> <span class=\"number\">10</span></span><br><span class=\"line\">读:  <span class=\"number\">1</span> <span class=\"number\">10</span></span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">读结束</span><br><span class=\"line\">写:  <span class=\"number\">2</span> <span class=\"number\">20</span></span><br><span class=\"line\">写结束</span><br><span class=\"line\">写:  <span class=\"number\">2</span> <span class=\"number\">30</span></span><br><span class=\"line\">写结束</span><br><span class=\"line\">写:  <span class=\"number\">2</span> <span class=\"number\">40</span></span><br><span class=\"line\">写结束</span><br><span class=\"line\">写:  <span class=\"number\">2</span> <span class=\"number\">50</span></span><br><span class=\"line\">写结束</span><br></pre></td></tr></table></figure></p>\n<p>注意: 每次执行的结果都有差异, 当你复制上面代码运行结果和上面有所不同, 但是结果展示出来的规律却是一致的:</p>\n<ul>\n<li><p>规律一: <code>[同时可以有任意多个 gorouinte 获得读锁定]</code></p>\n<blockquote>\n<p>RWMutex 读锁可以并发多个执行,从上面read 程序和程序执行输出的内容来看<br>说明在加上读取锁时,其他 goroutine 依然可以并发多个 读 访问.</p>\n</blockquote>\n</li>\n<li><p>规律二: <code>[同时只能有一个 goroutine 能够获得写锁定]</code></p>\n<blockquote>\n<p>RWMutex 写获得锁定时,不论程序休眠多长时间,一定会输出 写结束,其他 goroutine 才能获得锁资源.</p>\n</blockquote>\n</li>\n<li><p>规律三: <code>[同时只能存在写锁定或读锁定（读和写互斥）]</code></p>\n<blockquote>\n<p>读虽然可以同时多个 goroutine 来锁定,但是写锁定之前其他多个读锁定必须全部释放锁.<br>写锁定获得锁时,其他 读 或者 写 都无法再获得锁,直到此 goroutine 写结束,释放锁后,其他 goroutine 才会争夺.<br>所以 读和写 的俩种锁是互斥的.</p>\n</blockquote>\n</li>\n</ul>\n<p><br/></p>\n<p>Tips: 对一个未锁定的互斥锁解锁将会产生运行时错误，并且上面的锁必须成对使用不能互相拆分混用,否则会发生运行时错误。</p>\n<hr>\n<h2 id=\"0x02-Atomic-原子操作库\"><a href=\"#0x02-Atomic-原子操作库\" class=\"headerlink\" title=\"0x02 Atomic.原子操作库\"></a>0x02 Atomic.原子操作库</h2><p>描述: Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供,它可以为我们提供更高性能效率的并发同步安全。</p>\n<p><strong>常用方法原型:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadInt32</span><span class=\"params\">(addr *<span class=\"keyword\">int32</span>)</span> <span class=\"params\">(val <span class=\"keyword\">int32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">LoadInt64</span><span class=\"params\">(addr *<span class=\"keyword\">int64</span>)</span> <span class=\"params\">(val <span class=\"keyword\">int64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">LoadUint32</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>)</span> <span class=\"params\">(val <span class=\"keyword\">uint32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">LoadUint64</span><span class=\"params\">(addr *<span class=\"keyword\">uint64</span>)</span> <span class=\"params\">(val <span class=\"keyword\">uint64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">LoadUintptr</span><span class=\"params\">(addr *<span class=\"keyword\">uintptr</span>)</span> <span class=\"params\">(val <span class=\"keyword\">uintptr</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">LoadPointer</span><span class=\"params\">(addr *unsafe.Pointer)</span> <span class=\"params\">(val unsafe.Pointer)</span> \t</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 写入操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">StoreInt32</span><span class=\"params\">(addr *<span class=\"keyword\">int32</span>, val <span class=\"keyword\">int32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">StoreInt64</span><span class=\"params\">(addr *<span class=\"keyword\">int64</span>, val <span class=\"keyword\">int64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">StoreUint32</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, val <span class=\"keyword\">uint32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">StoreUint64</span><span class=\"params\">(addr *<span class=\"keyword\">uint64</span>, val <span class=\"keyword\">uint64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">StoreUintptr</span><span class=\"params\">(addr *<span class=\"keyword\">uintptr</span>, val <span class=\"keyword\">uintptr</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">StorePointer</span><span class=\"params\">(addr *unsafe.Pointer, val unsafe.Pointer)</span> \t</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 修改操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">AddInt32</span><span class=\"params\">(addr *<span class=\"keyword\">int32</span>, delta <span class=\"keyword\">int32</span>)</span> <span class=\"params\">(<span class=\"built_in\">new</span> <span class=\"keyword\">int32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">AddInt64</span><span class=\"params\">(addr *<span class=\"keyword\">int64</span>, delta <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(<span class=\"built_in\">new</span> <span class=\"keyword\">int64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">AddUint32</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, delta <span class=\"keyword\">uint32</span>)</span> <span class=\"params\">(<span class=\"built_in\">new</span> <span class=\"keyword\">uint32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">AddUint64</span><span class=\"params\">(addr *<span class=\"keyword\">uint64</span>, delta <span class=\"keyword\">uint64</span>)</span> <span class=\"params\">(<span class=\"built_in\">new</span> <span class=\"keyword\">uint64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">AddUintptr</span><span class=\"params\">(addr *<span class=\"keyword\">uintptr</span>, delta <span class=\"keyword\">uintptr</span>)</span> <span class=\"params\">(<span class=\"built_in\">new</span> <span class=\"keyword\">uintptr</span>)</span> \t</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 交换操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SwapInt32</span><span class=\"params\">(addr *<span class=\"keyword\">int32</span>, <span class=\"built_in\">new</span> <span class=\"keyword\">int32</span>)</span> <span class=\"params\">(old <span class=\"keyword\">int32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SwapInt64</span><span class=\"params\">(addr *<span class=\"keyword\">int64</span>, <span class=\"built_in\">new</span> <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(old <span class=\"keyword\">int64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SwapUint32</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, <span class=\"built_in\">new</span> <span class=\"keyword\">uint32</span>)</span> <span class=\"params\">(old <span class=\"keyword\">uint32</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SwapUint64</span><span class=\"params\">(addr *<span class=\"keyword\">uint64</span>, <span class=\"built_in\">new</span> <span class=\"keyword\">uint64</span>)</span> <span class=\"params\">(old <span class=\"keyword\">uint64</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SwapUintptr</span><span class=\"params\">(addr *<span class=\"keyword\">uintptr</span>, <span class=\"built_in\">new</span> <span class=\"keyword\">uintptr</span>)</span> <span class=\"params\">(old <span class=\"keyword\">uintptr</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">SwapPointer</span><span class=\"params\">(addr *unsafe.Pointer, <span class=\"built_in\">new</span> unsafe.Pointer)</span> <span class=\"params\">(old unsafe.Pointer)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 比较并交换操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">CompareAndSwapInt32</span><span class=\"params\">(addr *<span class=\"keyword\">int32</span>, old, <span class=\"built_in\">new</span> <span class=\"keyword\">int32</span>)</span> <span class=\"params\">(swapped <span class=\"keyword\">bool</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">CompareAndSwapInt64</span><span class=\"params\">(addr *<span class=\"keyword\">int64</span>, old, <span class=\"built_in\">new</span> <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(swapped <span class=\"keyword\">bool</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">CompareAndSwapUint32</span><span class=\"params\">(addr *<span class=\"keyword\">uint32</span>, old, <span class=\"built_in\">new</span> <span class=\"keyword\">uint32</span>)</span> <span class=\"params\">(swapped <span class=\"keyword\">bool</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">CompareAndSwapUint64</span><span class=\"params\">(addr *<span class=\"keyword\">uint64</span>, old, <span class=\"built_in\">new</span> <span class=\"keyword\">uint64</span>)</span> <span class=\"params\">(swapped <span class=\"keyword\">bool</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">CompareAndSwapUintptr</span><span class=\"params\">(addr *<span class=\"keyword\">uintptr</span>, old, <span class=\"built_in\">new</span> <span class=\"keyword\">uintptr</span>)</span> <span class=\"params\">(swapped <span class=\"keyword\">bool</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">CompareAndSwapPointer</span><span class=\"params\">(addr *unsafe.Pointer, old, <span class=\"built_in\">new</span> unsafe.Pointer)</span> <span class=\"params\">(swapped <span class=\"keyword\">bool</span>)</span></span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"0x03-Context-上下文操作库\"><a href=\"#0x03-Context-上下文操作库\" class=\"headerlink\" title=\"0x03 Context.上下文操作库\"></a>0x03 Context.上下文操作库</h2><h3 id=\"1-Context-简述\"><a href=\"#1-Context-简述\" class=\"headerlink\" title=\"1.Context 简述\"></a>1.Context 简述</h3><p>描述: Go在1.7时加入context标准库它定义了Context类型，专门用来简化对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p>\n<p>通常对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文, 它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel、WithDeadline、WithTimeout或WithValue</code>创建的派生上下文。</p>\n<p>简单来说就是使用<code>Context</code>创建上下文来控制子goroutine的生命周期(终止), 当一个上下文被取消时, 它派生的所有上下文也被取消。</p>\n<p><br/></p>\n<p><strong>Why Use Context</strong><br>在回答问题前，我们可以从以下两个例子中找到对应的答案, 实现效果(目标): 分别采用特定变量以及通道来控制子goroutine退出。</p>\n<ul>\n<li>示例1.利用自定义全局变量控制<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1.采用自定义全局变量控制子goroutine退出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">var</span> notify <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发调用work函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">work</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%v : %v\\n\"</span>, time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>), <span class=\"string\">\"WeiyiGeek\"</span>)</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> notify &#123;  <span class=\"comment\">// 接收外部命令实现退出</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> work()</span><br><span class=\"line\">  time.Sleep(time.Second * <span class=\"number\">5</span>)</span><br><span class=\"line\">  notify = <span class=\"literal\">true</span>  <span class=\"comment\">// 利用全局变量实现子goroutine的退出</span></span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 执行结果 # </span></span><br><span class=\"line\">➜  demo1 <span class=\"keyword\">go</span> run .</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">08</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">09</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">09</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">10</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">10</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">11</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">12</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">12</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">13</span> : WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">44</span>:<span class=\"number\">13</span> : WeiyiGeek</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>示例2.利用channel(通道)控制<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例2.采用通道Channel方式控制子goroutine退出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"><span class=\"keyword\">var</span> notifyChan = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>, <span class=\"number\">1</span>) <span class=\"comment\">// 定义&amp;声明内存申请一气呵成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发调用work函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">work</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">LOOPEXIT:</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%v : %v\\n\"</span>, time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>), <span class=\"string\">\"WeiyiGeek\"</span>)</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-notifyChan: <span class=\"comment\">// 接收外部命令实现退出</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span> LOOPEXIT <span class=\"comment\">// 退出跳转，如果直接break则无法跳出</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"# Default\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> work()</span><br><span class=\"line\">  time.Sleep(time.Second * <span class=\"number\">5</span>)</span><br><span class=\"line\">  notifyChan &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 执行结果 # </span></span><br><span class=\"line\">➜  demo2 <span class=\"keyword\">go</span> run .</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">28</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">28</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">29</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">29</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">30</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">30</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">31</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">31</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">32</span> : WeiyiGeek</span><br><span class=\"line\"># Default</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-29</span> <span class=\"number\">05</span>:<span class=\"number\">54</span>:<span class=\"number\">32</span> : WeiyiGeek</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<p>下面我们来看看，如何利用context实现子goroutine优雅退出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"context\"</span></span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">  <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例3.利用context实现子goroutine退出</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发调用childwork函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">childwork</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">LOOPEXIT:</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%v : %v\\n\"</span>, time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>), <span class=\"string\">\"childwork -&gt; WeiyiGeek\"</span>)</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-ctx.Done():  <span class=\"comment\">// 等待上级通知</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span> LOOPEXIT <span class=\"comment\">// 退出跳转，如果直接break则无法跳出</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"# childwork\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 并发调用work函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">work</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Done()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> childwork(ctx)  <span class=\"comment\">// 并发调用 childwork</span></span><br><span class=\"line\">LOOPEXIT:</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"%v : %v\\n\"</span>, time.Now().Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>), <span class=\"string\">\"work-&gt;WeiyiGeek\"</span>)</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">500</span>)</span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-ctx.Done():  <span class=\"comment\">// 关键点: 当调用cancle()后表示完成的取消频道。</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span> LOOPEXIT <span class=\"comment\">// 退出跳转，如果直接break则无法跳出</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      fmt.Println(<span class=\"string\">\"# work\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// WithCancel返回具有新完成通道的父级副本。</span></span><br><span class=\"line\">  <span class=\"comment\">// 调用返回的cancel函数或关闭父上下文的Done通道时，返回上下文的Done通道关闭，以先发生的为准。</span></span><br><span class=\"line\">  ctx, cancle := context.WithCancel(context.Background())</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> work(ctx)</span><br><span class=\"line\">  time.Sleep(time.Second * <span class=\"number\">5</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 表示关闭上下文通道</span></span><br><span class=\"line\">  cancle()</span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 执行结果 #</span></span><br><span class=\"line\">➜  demo3 <span class=\"keyword\">go</span> run .</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">54</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">54</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">55</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">55</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">55</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">55</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">56</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">56</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">56</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">56</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">57</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">57</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">57</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">57</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">58</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">58</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">58</span> : work-&gt;WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">58</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># childwork</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">59</span> : childwork -&gt; WeiyiGeek</span><br><span class=\"line\"># work</span><br><span class=\"line\"><span class=\"number\">2021</span><span class=\"number\">-12</span><span class=\"number\">-28</span> <span class=\"number\">04</span>:<span class=\"number\">29</span>:<span class=\"number\">59</span> : work-&gt;WeiyiGeek</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"2-Context-接口初识\"><a href=\"#2-Context-接口初识\" class=\"headerlink\" title=\"2.Context 接口初识\"></a>2.Context 接口初识</h3><p>描述: 在 context 包中有一个Context接口, 该接口定义了以下四个需要实现的方法。</p>\n<p><strong>context.Context 接口方法:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 上下文跨API边界携带截止日期、取消信号和其他值, 多个goroutine可以同时调用上下文的方法。</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Deadline方法需要返回当前Context被取消的时间，也就是完成工作的截止时间（deadline）;</span></span><br><span class=\"line\">  Deadline() (deadline time.Time, ok <span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Done方法需要返回一个Channel，这个Channel会在当前工作完成或者上下文被取消之后关闭，多次调用Done方法会返回同一个Channel；</span></span><br><span class=\"line\">  Done() &lt;-<span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Err方法会返回当前Context结束的原因，它只会在Done返回的Channel被关闭时才会返回非空的值;</span></span><br><span class=\"line\">  <span class=\"comment\">// - 如果当前Context被取消就会返回Canceled错误;</span></span><br><span class=\"line\">  <span class=\"comment\">// - 如果当前Context超时就会返回DeadlineExceeded错误;</span></span><br><span class=\"line\">  Err() error  <span class=\"comment\">// 如果尚未关闭Done，Err将返回nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Value方法会从Context中返回键对应的值，对于同一个上下文来说，多次调用Value并传入相同的Key会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</span></span><br><span class=\"line\">  Value(key <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// \t示例: FromContext返回存储在ctx中的用户值（如果有）。</span></span><br><span class=\"line\">  <span class=\"comment\">// \tfunc FromContext(ctx context.Context) (*User, bool) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">// \t\tu, ok := ctx.Value(userKey).(*User)</span></span><br><span class=\"line\">  <span class=\"comment\">// \t\treturn u, ok</span></span><br><span class=\"line\">  <span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法原型:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> emptyCtx <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*emptyCtx)</span> <span class=\"title\">Deadline</span><span class=\"params\">()</span> <span class=\"params\">(deadline time.Time, ok <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*emptyCtx)</span> <span class=\"title\">Done</span><span class=\"params\">()</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">struct</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*emptyCtx)</span> <span class=\"title\">Err</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*emptyCtx)</span> <span class=\"title\">Value</span><span class=\"params\">(key <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"3-Context-内置函数\"><a href=\"#3-Context-内置函数\" class=\"headerlink\" title=\"3.Context 内置函数\"></a>3.Context 内置函数</h3><p>描述: Context 中了如下两个函数 <code>Background()</code> 和<code>TODO()</code>，该函数其分别返回一个实现了Context接口的<code>background</code>和<code>todo</code>, 我们代码中最开始都是以这两个内置的上下文对象作为最顶层的 <code>partent context</code> 衍生出更多的<code>子上下文对象</code>。</p>\n<ul>\n<li><code>Background()</code>: 主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</li>\n<li><code>TODO()</code>: 它目前还不知道具体的使用场景，当不清楚要使用哪个上下文或它还不可用时(因为周围的函数还没有扩展到接受上下文参数), 可以使用这个。</li>\n</ul>\n<p><strong>函数原型:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由下可知background和todo本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *emptyCtx)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> e &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> background:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"context.Background\"</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> todo:</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"context.TODO\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"unknown empty Context\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">  background = <span class=\"built_in\">new</span>(emptyCtx)</span><br><span class=\"line\">  todo       = <span class=\"built_in\">new</span>(emptyCtx)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Background() 返回一个非零的空上下文。它从未被取消，没有值，也没有截止日期。它通常由主函数、初始化和测试使用，并作为传入请求的顶级上下文。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Background</span><span class=\"params\">()</span> <span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> background</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// TODO() 返回一个非零的空上下文。代码应该使用上下文。当不清楚要使用哪个上下文或它还不可用时（因为周围的函数还没有扩展到接受上下文参数）。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TODO</span><span class=\"params\">()</span> <span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> todo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"4-Context-With系列函数\"><a href=\"#4-Context-With系列函数\" class=\"headerlink\" title=\"4.Context.With系列函数\"></a>4.Context.With系列函数</h3><p>描述: 此外 context包中还定义了四个With系列函数, 其函数签名分别如下:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// # WithCancel 的函数签名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithCancel</span><span class=\"params\">(parent Context)</span> <span class=\"params\">(ctx Context, cancel CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\">// # <span class=\"title\">WithDeadline</span> 的函数签名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">WithDeadline</span><span class=\"params\">(parent Context, deadline time.Time)</span> <span class=\"params\">(Context, CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\">// # <span class=\"title\">WithTimeout</span> 的函数签名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">WithTimeout</span><span class=\"params\">(parent Context, timeout time.Duration)</span> <span class=\"params\">(Context, CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\">// # <span class=\"title\">WithValue</span>的函数签名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">WithValue</span><span class=\"params\">(parent Context, key, val <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Context</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">// 注意: 多个<span class=\"title\">goroutine</span>可以同时调用<span class=\"title\">CancelFunc</span>, 并在第一次调用之后对<span class=\"title\">CancelFunc</span>的后续调用不会执行任何操作。</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">CancelFunc</span> 通知操作放弃其工作。</span></span><br><span class=\"line\"><span class=\"function\">// <span class=\"title\">CancelFunc</span> 不会等待工作停止。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">type</span> <span class=\"title\">CancelFunc</span> <span class=\"title\">func</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"WithCancel\"><a href=\"#WithCancel\" class=\"headerlink\" title=\"WithCancel()\"></a>WithCancel()</h4><p>描述: WithCancel 返回<code>带有新Done通道的父节点的副本</code>, 当调用返回的cancel函数时, 上下文的Done通道关闭或者当父上下文的“Done”通道关闭时，将关闭返回上下文的Done通道。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 取消此上下文将释放与其关联的资源，因此代码应该在该上下文中运行的操作完成后立即调用cancel。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithCancel</span><span class=\"params\">(parent Context)</span> <span class=\"params\">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> parent == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"cannot create context from nil parent\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  c := newCancelCtx(parent)</span><br><span class=\"line\">  propagateCancel(parent, &amp;c)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;c, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; c.cancel(<span class=\"literal\">true</span>, Canceled) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例演示:</strong>下述代码中gen函数在<code>单独的goroutine</code>中生成整数并将它们发送到返回的通道, gen的调用者在使用生成的整数之后需要取消上下文，以免gen启动的内部goroutine发生泄漏。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gen</span><span class=\"params\">(ctx context.Context)</span> &lt;-<span class=\"title\">chan</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    dst := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">int</span>)</span><br><span class=\"line\">    n := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-ctx.Done():  <span class=\"comment\">// 在调用cancle()后将进入此代码块。</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"comment\">// return结束该goroutine防止泄露。</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> dst &lt;- n:</span><br><span class=\"line\">          n++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dst</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  ctx, cancel := context.WithCancel(context.Background())</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel() <span class=\"comment\">// 当我们取完需要的整数后调用cancel</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> n := <span class=\"keyword\">range</span> gen(ctx) &#123;</span><br><span class=\"line\">    fmt.Println(n)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">5</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>  <span class=\"comment\">// 当返回5时退出for循环</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 执行结果 #</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"WithDeadline\"><a href=\"#WithDeadline\" class=\"headerlink\" title=\"WithDeadline()\"></a>WithDeadline()</h4><p>描述: WithDeadline 返回父上下文的副本并将deadline调整为<code>不迟于当前时间(time.Now())</code>。如果父上下文的 deadline 已经<code>早于当前时间(time.Now())</code>，则 <code>WithDeadline(parent, d)</code> 在语义上等同于父上下文, 并当截止日过期时当调用返回的cancel函数时，或者当父上下文的Done通道关闭时，返回上下文的Done通道将被关闭，以最先发生的情况为准。</p>\n<p><strong>函数原型:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithDeadline</span><span class=\"params\">(parent Context, d time.Time)</span> <span class=\"params\">(Context, CancelFunc)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> parent == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"cannot create context from nil parent\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 目前的截止日期已经比新的截止日期早。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> WithCancel(parent)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  c := &amp;timerCtx&#123;</span><br><span class=\"line\">    cancelCtx: newCancelCtx(parent),</span><br><span class=\"line\">    deadline:  d,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  propagateCancel(parent, c)</span><br><span class=\"line\">  dur := time.Until(d)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> dur &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    c.cancel(<span class=\"literal\">true</span>, DeadlineExceeded) <span class=\"comment\">// 截止日期已经过去了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; c.cancel(<span class=\"literal\">false</span>, Canceled) &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  c.mu.Lock()  <span class=\"comment\">// 锁机制</span></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> c.mu.Unlock()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> c.err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    c.timer = time.AfterFunc(dur, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      c.cancel(<span class=\"literal\">true</span>, DeadlineExceeded)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; c.cancel(<span class=\"literal\">true</span>, Canceled) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<p><strong>示例演示:</strong> 下述代码中定义了一个50毫秒之后过期的deadline，然后我们调用<code>context.WithDeadline(context.Background(), d)</code>得到一个上下文(ctx)和一个取消函数(cancel)，然后使用一个select让主程序陷入等待, 即等待1秒后打印overslept退出或者等待ctx过期后退出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  d := time.Now().Add(<span class=\"number\">5000</span> * time.Millisecond)  </span><br><span class=\"line\">  <span class=\"comment\">// 设置 5000 毫秒之后过期的 deadline</span></span><br><span class=\"line\">  ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class=\"line\">  <span class=\"comment\">// 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。</span></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-time.After(<span class=\"number\">1</span> * time.Second):  <span class=\"comment\">// 当前时间等待1s后打印执行输出</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"overslept\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">    fmt.Println(ctx.Err())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 运行结果</span></span><br><span class=\"line\"><span class=\"comment\">// 当 d 为 50 微秒时显示 context deadline exceeded</span></span><br><span class=\"line\"><span class=\"comment\">// 当 d 为 5000 微秒时显示 overslept</span></span><br></pre></td></tr></table></figure>\n<p>Tips: 非常注意尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践, 如果不这样做可能会使上下文及其父类存活的时间超过必要的时间。</p>\n<p><br></p>\n<h4 id=\"WithTimeout\"><a href=\"#WithTimeout\" class=\"headerlink\" title=\"WithTimeout()\"></a>WithTimeout()</h4><p>描述: WithTimeout 取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel，通常用于数据库或者网络连接的超时控制。</p>\n<p><strong>函数原型:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithTimeout</span><span class=\"params\">(parent Context, timeout time.Duration)</span> <span class=\"params\">(Context, CancelFunc)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">LOOP:</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"db connecting ...\"</span>)</span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">10</span>) <span class=\"comment\">// 假设正常连接数据库耗时10毫秒</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-ctx.Done(): <span class=\"comment\">// 50毫秒后自动调用</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span> LOOP</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"worker done!\"</span>)</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设置一个50毫秒的超时</span></span><br><span class=\"line\">  ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class=\"number\">50</span>)</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> worker(ctx)</span><br><span class=\"line\">  time.Sleep(time.Second * <span class=\"number\">5</span>)</span><br><span class=\"line\">  cancel() <span class=\"comment\">// 通知子goroutine结束</span></span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"over\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 执行结果 #</span></span><br><span class=\"line\">db connecting ...</span><br><span class=\"line\">db connecting ...</span><br><span class=\"line\">db connecting ...</span><br><span class=\"line\">db connecting ...</span><br><span class=\"line\">worker done!</span><br><span class=\"line\">over</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"WithValue\"><a href=\"#WithValue\" class=\"headerlink\" title=\"WithValue()\"></a>WithValue()</h4><p>描述: WithValue 函数能够将请求作用域的数据与 Context 对象建立关系, WithValue 返回父节点的副本，其中与key关联的值为val。</p>\n<p>注意其仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数，所提供的键必须是可比较的，并且不应该是string类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。</p>\n<p>WithValue的用户应该为键定义自己的类型,为了避免在分配给<code>interface{}</code>时进行分配，上下文键通常<code>具有具体类型struct{}</code>或者<code>导出的上下文关键变量的静态类型应该是指针或接口</code>。</p>\n<p><strong>函数原型:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithValue</span><span class=\"params\">(parent Context, key, val <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> parent == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"cannot create context from nil parent\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> key == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"nil key\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(<span class=\"string\">\"key is not comparable\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用withValue时定义自己的类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> TraceCode <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">worker</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  key := TraceCode(<span class=\"string\">\"TRACE_CODE\"</span>)           <span class=\"comment\">// TraceCode 类型的字符串实际上就是string类型，只是采用了别名方式</span></span><br><span class=\"line\">  traceCode, ok := ctx.Value(key).(<span class=\"keyword\">string</span>) <span class=\"comment\">// 在子goroutine中获取ctx上下文绑定TRACE_CODE键值。</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"invalid trace code\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">LOOP:</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"worker, trace code:%s\\n\"</span>, traceCode)  <span class=\"comment\">// 循环输出直到关闭上下文</span></span><br><span class=\"line\">    time.Sleep(time.Millisecond * <span class=\"number\">10</span>) <span class=\"comment\">// 假设正常连接数据库耗时10毫秒</span></span><br><span class=\"line\">    <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> &lt;-ctx.Done(): <span class=\"comment\">// 50毫秒后自动调用</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span> LOOP <span class=\"comment\">// 退出当前for循环</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"worker done!\"</span>)</span><br><span class=\"line\">  wg.Done()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设置一个50毫秒的超时并返回一个parent上下文。</span></span><br><span class=\"line\">  ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class=\"number\">50</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合。</span></span><br><span class=\"line\">  ctx = context.WithValue(ctx, TraceCode(<span class=\"string\">\"TRACE_CODE\"</span>), <span class=\"string\">\"12512312234\"</span>)  <span class=\"comment\">// 注意此处是传入的是ct(即parent上下文)</span></span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">go</span> worker(ctx)</span><br><span class=\"line\">  time.Sleep(time.Second * <span class=\"number\">5</span>) <span class=\"comment\">// 防止太快看不出效果</span></span><br><span class=\"line\">  cancel()     <span class=\"comment\">// 关闭上下文并通知子goroutine结束</span></span><br><span class=\"line\">  wg.Wait()</span><br><span class=\"line\">  fmt.Println(<span class=\"string\">\"over\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 执行结果 # </span></span><br><span class=\"line\">worker, trace code:<span class=\"number\">12512312234</span></span><br><span class=\"line\">worker, trace code:<span class=\"number\">12512312234</span></span><br><span class=\"line\">worker, trace code:<span class=\"number\">12512312234</span></span><br><span class=\"line\">worker, trace code:<span class=\"number\">12512312234</span></span><br><span class=\"line\">worker, trace code:<span class=\"number\">12512312234</span></span><br><span class=\"line\">worker done!</span><br><span class=\"line\">over</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"5-Context-总结\"><a href=\"#5-Context-总结\" class=\"headerlink\" title=\"5.Context 总结\"></a>5.Context 总结</h3><p>描述: 我们在使用Context的时候需要注意以下事项。</p>\n<ul>\n<li>推荐以参数的方式显示传递Context，并以Context作为参数的函数方法，应该把Context作为第一个参数。</li>\n<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li>\n<li>Context 的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li>\n<li>Context 是线程安全的，可以放心的在多个goroutine中传递</li>\n</ul>\n<p><strong>示例1.调用服务端API时如何在客户端实现超时控制？</strong></p>\n<p>Server 端:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"math/rand\"</span></span><br><span class=\"line\">  <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">  <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// 此处将演示 server 端随机出现慢响应</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">  number := rand.Intn(<span class=\"number\">2</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> number == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    time.Sleep(time.Second * <span class=\"number\">10</span>)    <span class=\"comment\">// 耗时10秒的慢响应</span></span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">\"slow response - WeiyiGeek\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Fprint(w, <span class=\"string\">\"quick response - master@weiyigeek.top\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  http.HandleFunc(<span class=\"string\">\"/\"</span>, indexHandler)</span><br><span class=\"line\">  err := http.ListenAndServe(<span class=\"string\">\":8000\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<p>client 端:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">\"context\"</span></span><br><span class=\"line\">  <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">  <span class=\"string\">\"io/ioutil\"</span></span><br><span class=\"line\">  <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">  <span class=\"string\">\"sync\"</span></span><br><span class=\"line\">  <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 客户端</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> respData <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  resp *http.Response</span><br><span class=\"line\">  err  error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doCall</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求频繁可定义全局的client对象并启用长链接，否则请使用短链接。</span></span><br><span class=\"line\">  transport := http.Transport&#123;</span><br><span class=\"line\">    DisableKeepAlives: <span class=\"literal\">true</span>, </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  client := http.Client&#123;</span><br><span class=\"line\">    Transport: &amp;transport,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 针对指针结构体类型的通道进行内存申请</span></span><br><span class=\"line\">  respChan := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> *respData, <span class=\"number\">1</span>)</span><br><span class=\"line\">  req, err := http.NewRequest(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"http://127.0.0.1:8000/\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"new requestg failed, err:%v\\n\"</span>, err)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用带超时的ctx创建一个新的 client request。</span></span><br><span class=\"line\">  req = req.WithContext(ctx) </span><br><span class=\"line\">  <span class=\"keyword\">var</span> wg sync.WaitGroup</span><br><span class=\"line\">  wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> wg.Wait()</span><br><span class=\"line\">  <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    resp, err := client.Do(req)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"client.do resp:%v, err:%v\\n\"</span>, resp, err)</span><br><span class=\"line\">    rd := &amp;respData&#123;</span><br><span class=\"line\">      resp: resp,</span><br><span class=\"line\">      err:  err,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    respChan &lt;- rd</span><br><span class=\"line\">    wg.Done()</span><br><span class=\"line\">  &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> &lt;-ctx.Done():  <span class=\"comment\">// 当请求超过时间超过WithTimeout设定的时间时将会支持cancel()发送关闭上下文信号给通道。</span></span><br><span class=\"line\">    <span class=\"comment\">//transport.CancelRequest(req)</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"call api timeout\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">case</span> result := &lt;-respChan:</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"call server api success\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> result.err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      fmt.Printf(<span class=\"string\">\"call server api failed, err:%v\\n\"</span>, result.err)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> result.resp.Body.Close()</span><br><span class=\"line\">    data, _ := ioutil.ReadAll(result.resp.Body)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"resp:%v\\n\"</span>, <span class=\"keyword\">string</span>(data))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义一个100毫秒的超时</span></span><br><span class=\"line\">  ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*<span class=\"number\">100</span>)</span><br><span class=\"line\">  <span class=\"comment\">// 调用cancel释放子goroutine资源</span></span><br><span class=\"line\">  <span class=\"keyword\">defer</span> cancel() </span><br><span class=\"line\">  doCall(ctx)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 执行结果 #</span></span><br><span class=\"line\">client.do resp:*, err:*</span><br><span class=\"line\">call server api success</span><br></pre></td></tr></table></figure></p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"Development","path":"api/categories/Development.json"},{"name":"Programming","path":"api/categories/Programming.json"}],"tags":[{"name":"Go","path":"api/tags/Go.json"}]}