{"title":"操作系统学习笔记(三).md","slug":"书籍笔记/计算机操作系统原理/操作系统学习笔记(三)","date":"2019-03-27T06:35:30.000Z","updated":"2023-01-31T02:29:07.991Z","url":"2019/3-27-26.html","path":"api/articles/2019/3-27-26.html.json","covers":["https://img.weiyigeek.top/2019/20190405091849.png","https://img.weiyigeek.top/2019/20190405092904.png","https://img.weiyigeek.top/2019/20190405095729.png","https://img.weiyigeek.top/2019/20190405101318.png","https://img.weiyigeek.top/2019/20190405111905.png","https://img.weiyigeek.top/2019/20190405114121.png","https://img.weiyigeek.top/2019/20190405144604.png","https://img.weiyigeek.top/2019/20190405154519.png","https://img.weiyigeek.top/2019/20190417100549.png","https://img.weiyigeek.top/2019/20190417095955.png","https://img.weiyigeek.top/2019/20190417103005.png","https://img.weiyigeek.top/2019/20190417104606.png","https://img.weiyigeek.top/2019/20190417110100.png","https://img.weiyigeek.top/2019/20190420091634.png","https://img.weiyigeek.top/2019/20190420114641.png","https://img.weiyigeek.top/2019/20190521221551.png","https://img.weiyigeek.top/2019/20190607103911.png","https://img.weiyigeek.top/2019/20190607112027.png","https://img.weiyigeek.top/2019/20190607105605.png","https://img.weiyigeek.top/2019/20190607110710.png","https://img.weiyigeek.top/2019/20190607105932.png","https://img.weiyigeek.top/2019/20190609164926.png","https://img.weiyigeek.top/2019/20190609170247.png"],"content":"<h4 id=\"8-CPU调度算法\"><a href=\"#8-CPU调度算法\" class=\"headerlink\" title=\"8.CPU调度算法\"></a>8.CPU调度算法</h4><p>(1) 算法背景<br>(2) 调度原则<br>(3) 调度算法/实时调度/多处理器调度<br>(4) 优先级反转</p>\n<a id=\"more\"></a>\n<h5 id=\"8-1-算法背景\"><a href=\"#8-1-算法背景\" class=\"headerlink\" title=\"8-1 算法背景\"></a>8-1 算法背景</h5><p>简述上下文切换与CPU调度(Schedule)关系：</p>\n<ul>\n<li>切换CPU当前任务,从一个进程/线程到另一个</li>\n<li>保存当前进程/线程在PCB/TCB的执行上下文(CPU状态)</li>\n<li>读取下一个进程/线程的上下文</li>\n</ul>\n<p><em>Q:什么是CPU调度？</em><br>答：按照调度算法程序从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个线程/进程。</p>\n<p><em>Q:什么是调度算法程序?</em><br>答：挑选进程/线程的内核函数（通过一切调度策略）使得效率最高,满足用户需求;</p>\n<p><em>Q:在进程/线程的生命周期中的什么时候进行调度？</em><br>答：在五种进程状态（Start/Ready/Runing/Waiting/Done）切换的时候进行调度,即从一个状态变为另一个状态,特别是和运行（running）相关的状态。 </p>\n<p>内核运行调度程序的条件(满足一条即可):</p>\n<ul>\n<li>进程从Runing 到 Wait 状态</li>\n<li>进程Done(终结)<br>不可抢占调度：调度必须等待事件/进程结束,早期OS。<br>可以抢占调度：OS决定在何时打断进程,调度程序在中断被响应后执行,当前进程从运行切换到就绪(或者一个进程从等待W切换到就绪R),当前运行的进程可以被换出,现代OS。</li>\n</ul>\n<p><em>针对是用户态的进程:</em></p>\n<ul>\n<li>进程在内核中通过系统调用执行,因为系统调用返回时,是到发起这个调用的进程继续执行,所以内核中不会切换/抢占。</li>\n<li>只要进程在系统调用时不存在从运行态到阻塞态的变化,OS可以确保返回正常。</li>\n</ul>\n<p>如果在内核中也允许这种抢占,系统调用返回时不是原来的进程而是另一个优先级更高的进程,就是内核中的抢占。<br>OS发展：不可抢占 -&gt; 只支持用户态进程抢占 -&gt; 用户态和内核态进程都可抢占</p>\n<p><br></p>\n<h5 id=\"8-2-调度原则\"><a href=\"#8-2-调度原则\" class=\"headerlink\" title=\"8-2 调度原则\"></a>8-2 调度原则</h5><p>执行模型：程序在CPU突发和I/O中交替;</p>\n<ul>\n<li>每一个调度决定都是关于下一个CPU突发时将哪个工作交给CPU;</li>\n<li>在时间分片机制下,线程可能在结束当前CPU突发请被迫放弃CPU;</li>\n</ul>\n<p>CPU的占用率是波状,CPU大量运算是高峰,而读写I/O时是平稳的低值;</p>\n<ul>\n<li>CPU使用率：CPU处于忙状态所占用时间的百分比;</li>\n<li>吞吐量：在单位时间内完成进程数量;</li>\n<li>周转时间：一个进程从初始化到结束,包括所有等待时间所花费的时间;</li>\n<li>等待时间：进程在就绪队列中总时间;</li>\n<li>响应时间：从一个请求被提交到产生第一次应所花费的总时间;</li>\n</ul>\n<p><em>Q:通常选择更快的服务,但什么是更快?</em></p>\n<ul>\n<li>高吞吐量（高带宽）</li>\n<li>低响应时间（低延迟）</li>\n<li>补充：但两者很难兼顾</li>\n</ul>\n<p>用量化的方法来看调度算法：</p>\n<ol>\n<li>减少响应时间-即使处理用户的输入并将输出结果提供给用户;</li>\n<li>减少平均响应时间的波动 - 在交互系统中,可预测性比高差异低平均更重要;</li>\n<li>减少等待时间-每个进程为单位</li>\n<li>增加吞吐量(两个方面)</li>\n</ol>\n<ul>\n<li>减少开销（操作系统开销,上下文切换） </li>\n<li>系统资源的高效利用（CPU,I/O设备）</li>\n</ul>\n<p>桌面系统要求交互 - 低延迟调度增加了交互式表现,<br>数据中心的服务器更强调吞吐量 - OS需要保证吞吐量不受影响;</p>\n<p><em>Q:调度公平的意义？</em><br>每个进程都公平地得到CPU的支持,比如占用相同的CPU时间或等待相同时间;但是公平通常会增加平均响应时间。<br><br></p>\n<h5 id=\"8-3-调度算法\"><a href=\"#8-3-调度算法\" class=\"headerlink\" title=\"8-3 调度算法\"></a>8-3 调度算法</h5><p>调度算法的三大种类：</p>\n<ul>\n<li>一般性的调度算法</li>\n<li>针对嵌入式系统的特殊调度算法</li>\n<li>多CPU多内核的调度算法</li>\n</ul>\n<p><strong>(1) 基本调度算法</strong></p>\n<ul>\n<li>先来先服务(FCFS,First Come First Served) | 不公平,平等等待时间较差;</li>\n<li>短进程优先(SPN,Shortest Process Next) == 短作业优先(SJF,Shortest Job First ) | 不公平,但是平均等待时间最小,需要精确预测计算时间;</li>\n<li>短剩余时间优先(SRT,Shortest Remaining Time) </li>\n<li>最高响应比优先(HRRN,Highest Response Ratio Next) | 基于SPN调度改进,不可抢占</li>\n<li>轮循(Round Robin) – 公平 但是平均等待时间较差 </li>\n<li>多级反馈队列(Multilevel Feedback Queues)  | 和 SPN 类型类似</li>\n<li>公平共享调度(Fair Share Scheduling) | 公平是第一要素</li>\n</ul>\n<p>8.3.1 FCFS<br>fifo队列规定：如果在进程在执行中阻塞,队列的下一个会得到CPU;</p>\n<p>比如下面：进程运行时间短的放在起始位置则周转时间变短;<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405091849.png\" alt=\"WeiyiGeek.FCFS案例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.FCFS案例</p>\n            </figure></p>\n<p>优点：简单方便理解<br>缺点：</p>\n<ul>\n<li>平均等待时间波动大</li>\n<li>花费时间少的可能反而排在时间长的进程后面</li>\n<li>可能导致CPU 和 I/O之间的重叠处理(CPU密集的进程导致I/O闲置时,I/O密集型进程也在等)</li>\n<li>没考虑进程抢占</li>\n</ul>\n<p>8.3.2/.3 SPN / SRT<br>按照预测的完成时间来将任务入就绪队列之中,既可以是抢占的也可以是不可抢占的;</p>\n<ul>\n<li>不可抢占(SJF SPN)</li>\n<li>可抢占(SRT - 短剩余时间优先)</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405092904.png\" alt=\"WeiyiGeek.SPN案例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.SPN案例</p>\n            </figure>\n<p>SRT 优点：最小的平均等待时间和周转时间<br>SRT 缺点：</p>\n<ul>\n<li>连续的短任务可能导致长任务饥饿,短任务可用时被长任务占用则会增加平均等待时间,不能保证公平；</li>\n<li>需要预知未来下一个进程的突发时间,比如询问用户,如果用户欺骗就杀死进程。 </li>\n</ul>\n<p>8.3.4 HRRN<br>在SPN调度的基础上改进,不可抢占,关注进程等待多长时间,防止无限期推迟;</p>\n<p>R最高者优先进程：Wait 等待 / Service 服务/执行<br>R=(waiting time + service time) / service time,</p>\n<p>SPN与HRRN对比：前者只考虑了执行时间,而后者还考虑了等待时间;<br>优点：防止无限期延迟即进程饥饿(不可抢占);交互性,响应性更好;<br>缺点：对抢占性的支持不够,也需要预知执行时间;</p>\n<p>8.3.5 RR<br>用时间切片和抢占来轮流执行,提高公平; 在量子切片/时间切片的离散单元中分配处理器,时间片结束时切换到下一个准备好的进程;<br>线程执行时间单元： (n-1)q<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405095729.png\" alt=\"WeiyiGeek.RR线程执行案例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.RR线程执行案例</p>\n            </figure></p>\n<p>案例：进程所需时间<br>P1 : 53 , P2 : 8 , P3 : 68 , P4 : 24<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P1 P2 P3 P4 P1 P3 P4  P1   P3  P3 </span><br><span class=\"line\">0  20 28 48 68 88 108 112  125 145 153</span><br><span class=\"line\"></span><br><span class=\"line\">#等待时间</span><br><span class=\"line\">P1 &#x3D; (68 -20) + (112 - 88) &#x3D; 72</span><br><span class=\"line\">P2 &#x3D; (20 - 0) &#x3D; 20</span><br><span class=\"line\">P3 &#x3D; (28 - 0) + (88 - 48) + (125 - 108) &#x3D; 85</span><br><span class=\"line\">p4 &#x3D; (48 - 0) + (108 -68) &#x3D; 88</span><br><span class=\"line\"></span><br><span class=\"line\">#平均等待时间</span><br><span class=\"line\">(p1 + p2 + p3 + p4) &#x2F; 4 &#x3D; 66</span><br></pre></td></tr></table></figure></p>\n<p>优点:公平相对稳定;<br>缺点：</p>\n<ul>\n<li>平均等待时间较长(与时间片有关)</li>\n<li>按时间片轮流执行增加了上下文切换开销</li>\n</ul>\n<p><em>时间片大小的重要性?</em></p>\n<ul>\n<li>时间(量子)片过大：等待时间变长,极限的情况下退化成为FCFS</li>\n<li>时间(量子)片过小：反应迅速(每个队列中的进程都将被执行),但是上下文切换开销太大</li>\n</ul>\n<p>目标：选择一个合适的时间量子,维持上下文切换开销处于 &lt; 1%;</p>\n<p>案例：在FCFS和RR中,不同时间片对平均等待时间的影响,进程Pn所需时间与上面案例一致;</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405101318.png\" alt=\"WeiyiGeek.时间片对平均等待时间的影响\" title=\"\" class=\"\">\n                <p>WeiyiGeek.时间片对平均等待时间的影响</p>\n            </figure>\n<p>8.3.6 Multilevel Feedback Queues (多级队列)<br>就绪队列分为相对独立的队列：前台交互,后台批处理;<br>每个队列拥有自己的调度策略：前台RR,后台FCFS<br>调度必须在队列间进行:</p>\n<ul>\n<li>固定优先级：先处理前台,然后处理后台;可能导致饥饿;</li>\n<li>时间切片：每一个队列的到一个确定能够调度其进程的CPU/总时间;如80%给前台,20%给后台;</li>\n</ul>\n<p>一个进程可以在不同的队列中移动,例如：n级优先级-优先级在所有级别中RR在每个级别中;</p>\n<ol>\n<li>时间量子大小随优先级级别的增加而增加;</li>\n<li>如果当前时间量子中没有完成,则自动降到下一个优先级;</li>\n</ol>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405111905.png\" alt=\"WeiyiGeek.时间片对平均等待时间的影响\" title=\"\" class=\"\">\n                <p>WeiyiGeek.时间片对平均等待时间的影响</p>\n            </figure>\n<p>队列的特点：<br>W等待时间越长,优先级会越来越高;(即前台交互任务,保证公平性)<br>E执行时间越长,优先级会越来越低;(即后台运算任务,提高效率)</p>\n<p>优点：</p>\n<ul>\n<li>CPU密集型任务的优先级下降很快,就随着不断消耗时间量子就下降到低的优先级,I/O密集型任务停留在高优先级;</li>\n<li>能动态地根据进程的特征来调整队列优先级和调度CPU;</li>\n</ul>\n<p>8.3.7 Fair Share Scheduling<br>公平共享调度,用户层面的公平,适用于多用户共享服务器的场景;<br>FFS控制用户对系统资源的访问：</p>\n<ul>\n<li>一些用户组比其他的用户组更重要;</li>\n<li>保证不重要的组无法垄断资源;</li>\n<li>未使用的资源按照每个组分配的资源的比例来分配;</li>\n<li>没有达到资源使用率目标的组合获取更高优先级;</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405114121.png\" alt=\"WeiyiGeek.FFS控制\" title=\"\" class=\"\">\n                <p>WeiyiGeek.FFS控制</p>\n            </figure>\n<p>评价调度方法：</p>\n<ul>\n<li>确定性建模：对确定的工作量计算每个算法的表现</li>\n<li>队列模型：用来处理随机工作负载的数学方法</li>\n<li>实现/模拟：建立一个允许算法运行实际数据的系统,最灵活/一般性</li>\n</ul>\n<p><em>总结：</em></p>\n<ul>\n<li>上面的都是一些通用计算机调度算法,与实际计算机调度有所差异;（在真实机器上跑一遍因为和硬件也有关系）</li>\n<li>需要交互性强的进程,我们希望它的优先级较高;</li>\n<li>公平每个进程占用同等的CPU时间,但会牺牲效率</li>\n</ul>\n<p><br></p>\n<p><strong>(2) 实时调度(real-time)</strong></p>\n<p>定义：正确性依赖于其时间和功能两方面的一种OS,比如调度火车/工厂,需要确保任务在规定时间内完成的</p>\n<p>性能指标：强调时间约束的及时性（deadlines|期限）,速度和平均性能相对不重要。<br>主要特征：重点是时间约束的可预测性,实时调度算法主要用于嵌入式;</p>\n<p>类别：</p>\n<ul>\n<li>硬件/强实时系统：重要任务在规定时间必须完成;</li>\n<li>软件/弱实时系统：重要任务优先级更高,尽量完成并非必须完成;</li>\n</ul>\n<p>任务/工作单元job：一次计算,一次文件读取,一次信息传递等等<br>属性：取得进展所需要的资源和定时参数;</p>\n<p><em>案例：</em><br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">release time 进程处于就绪态的时间</span><br><span class=\"line\">relative deadline  任务是间隔时间段完成,每个任务有个特定的时间,要在特定的时间段内完成</span><br><span class=\"line\">absolute deadline 最终的结束时间</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405144604.png\" alt=\"WeiyiGeek.相对于绝对期限\" title=\"\" class=\"\">\n                <p>WeiyiGeek.相对于绝对期限</p>\n            </figure></p>\n<p>一些列相识任务周期任务,即有规律的重复</p>\n<ul>\n<li>周期 P= inter - realease time = relative deadline (0 &lt; p) </li>\n<li>执行时间e = 最大执行时间 (0 &lt; e &lt; p) </li>\n<li>使用率 / 利用率 U = e / p</li>\n</ul>\n<p>(硬时限)Hard real-time—hard deadline：保证确定性</p>\n<ul>\n<li>错过了最后期限,肯能会发生灾难性或非常严重的后果;</li>\n</ul>\n<p>(软时限)Soft real-time—-soft deadline：</p>\n<ul>\n<li>理想情况下,时限没有被满足,那么就相应的降低要求;</li>\n</ul>\n<p>设计算法满足deadline要求,决定实时任务执行的顺序;</p>\n<ol>\n<li>静态优先级调度（事先确定）<br>描述：在这个任务执行之前,已经把优先级确定下来,然后根据优先级进行调度任务;</li>\n<li>动态优先级调度（优先级会动态变化）<br>描述：任务的优先级,随着任务的运行而变化,不同时间和不同优先级,有可能导致任务被延迟;</li>\n</ol>\n<p>RM(Rate Monotonic,速率单调调度) : 最佳静态优先级调度,通过周期安排优先级,周期越短优先级越高;<br>EDF(Earliest Deadline First,最早期限调度) : 最佳动态优先级调度,deadline越早优先级越高,执行Deadline最早的任务;</p>\n<p><br></p>\n<p><strong>(3) 多处理器调度</strong><br>多处理器调度算法（多核）,追求负载平衡（load balance）(优点是负载共享)<br>多处理器的CPU调度更加复杂,多个相同的单处理器组成一个多处理器;</p>\n<p>对称多处理器(SMP):</p>\n<ul>\n<li>每个处理器运行自己的调度程序</li>\n<li>需要在调度程序中同步</li>\n</ul>\n<p>System Bus上连接了两个Physical CPU 然后它再连接Logical CPU;</p>\n<p><br></p>\n<h5 id=\"8-4-优先级反转\"><a href=\"#8-4-优先级反转\" class=\"headerlink\" title=\"8-4 优先级反转\"></a>8-4 优先级反转</h5><p>原理：低优先级任务占用了某共享资源,高优先级任务不能及时执行(即高优先级任务要等待低优先级任务时发生)</p>\n<p>优先级反转的持续时间取决于其他不相关任务的不可预测的行为;<br>案例：比如火星探路者(进程优先级文问题)<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190405154519.png\" alt=\"WeiyiGeek.优先级反转问题\" title=\"\" class=\"\">\n                <p>WeiyiGeek.优先级反转问题</p>\n            </figure></p>\n<p>原因解析：T3先执行,到t2时访问共享资源,t3时T1抢占,开始执行T1,某时刻需要访问已经被T3占用的共享资源,但T3还没有释放,所以不能继续T1就开始等待,t5时T2又抢占执行,此时T1受制于T2的执行时间,因为T1必须要等T3,导致T1的时间延长了,引起不稳定状态,最后频繁的重启系统;</p>\n<p><em>解决优先级反转方法：</em> 低优先级任务 继承 高优先级任务的 优先级依赖他们共享的资源;(优先级继承 与 高优先级任务共享资源的低优先级任务,其优先级被提升)<br>优先级天花板: 资源的优先级 和 所有可以锁定该资源的任务中最高优先级的任务 优先级相同;(任务的优先级取决于所占用资源的优先级)</p>\n<p><em>注意点：</em></p>\n<ol>\n<li>除非优先级高于系统中所有被锁定的资源的优先级上限,否则任务尝试执行临界区的时候会被阻塞;</li>\n<li>持有最高优先级上限信号量锁的任务,会被继承被该锁所阻塞的任务的优先级;</li>\n</ol>\n<hr>\n\n<h4 id=\"9-同步与互斥\"><a href=\"#9-同步与互斥\" class=\"headerlink\" title=\"9.同步与互斥\"></a>9.同步与互斥</h4><p>(1) 背景以及概念介绍<br>(2) 临界区及管理方法</p>\n<h5 id=\"9-1-背景概念介绍\"><a href=\"#9-1-背景概念介绍\" class=\"headerlink\" title=\"9.1 背景概念介绍\"></a>9.1 背景概念介绍</h5><p>背景：多道程序设计(Multi-Programming)是现代OS中的一个重要特性,需要以下来基础来支撑下</p>\n<ul>\n<li>并行与并发的概念的引入来支持,</li>\n<li>进程/线程操作系统抽象出来用于支持多道程序设计;</li>\n<li>CPU调度与调度算法(不同测试)</li>\n</ul>\n<p><em>面试必问Q:什么是并行和并发?</em><br>答：并发和并行最开始都是操作系统中的概念,表示的是CPU执行多个任务的方式。这两个概念极容易混淆。</p>\n<p><strong>并发 Concurrent：</strong> 在操作系统中,是指一个时间段中有几个程序都处于已启动运行到运行完毕之间,且这几个程序都是在同一个处理机上运行;</p>\n<p>比如:现在使用的windows操作系统,可以”同时”做很多件事儿(一边看电影/一边聊QQ/一边听歌),这所谓的”同时”,在操作系统底层可能并不是真正的意义上的”同时”;</p>\n<ul>\n<li>实际上对于单CPU的计算机来说,在CPU中同一时间是只能干一件事儿的,但同一个时间段内可以完成多个事件,不同的事通过时间片分时调度;</li>\n<li>操作系统是把CPU的时间划分成长短基本相同的时间区间即”时间片”,通过操作系统的管理,把这些时间片依次轮流地分配给各个应用使用</li>\n<li>给用户的感觉是他在同时的进行听歌和打游戏,实际上在操作系统中,CPU是在游戏进程和音乐播放器进程之间来回切换执行的。</li>\n<li>操作系统时间片的使用规则：某个作业在时间片结束之前没有完成整个任务,这时该作业将被暂停(等待状态),等待下一次CPU调度执行</li>\n</ul>\n<p><br></p>\n<p><strong>并发 Concurrent：</strong> 当系统多个CPU(多核处理器)时,当一个CPU执行一个进程时,另一个CPU可以执行另一个进程,两个进程互不抢占CPU资源可以同时进行执行;</p>\n<p>比如：两个人吃午饭过程中,你吃了米饭、蔬菜、牛肉;我也吃了米饭、蔬菜和牛肉,这时我们两个人之间的吃饭就是并行的。<br>两个人之间可以在同一时间点一起吃牛肉,或者一个吃牛肉,一个吃蔬菜,我们之间是互不影响的(但是会影响资源-后面要说到)</p>\n<ul>\n<li>有多个CPU的情况下,才会出现真正意义上的『同时进行』</li>\n<li>多个人同时做多件事儿</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190417100549.png\" alt=\"WeiyiGeek.并发并行\" title=\"\" class=\"\">\n                <p>WeiyiGeek.并发并行</p>\n            </figure>\n<p>并发并行之间的区别：</p>\n<ul>\n<li>并发:指的是多个事情,在同一时间段内同时发生了,多个任务之间是互相抢占资源的 </li>\n<li>并行:指的是多个事情,在同一时间点上同时发生了,多个任务之间是不互相抢占资源的<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190417095955.png\" alt=\"WeiyiGeek.对比图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.对比图</p>\n            </figure>\n</li>\n</ul>\n<p><br></p>\n<p><strong>1.主要讲解协同多道程序设计和并发问题</strong><br>独立线程：(1)不和其他线程共享资源或状态 (2)缺点性(输入状态决定结果) (3)可重现(能够重现起始条件I/O) (4)调度顺序不重要<br>合作线程：(1)在多个线程中共享状态 (2)不确定性 (3)不可重现  [2/3一维着bug可能时间接性的发生的]</p>\n<p>在实际运行中进程或者线程,计算机/设备需要进行合作;<br><em>Q:为什么需要合作?</em></p>\n<ul>\n<li>共享资源（嵌入式系统）</li>\n<li>并行提高效率（I/O操作和计算可以重叠,拆分小任务,流水,并行,多处理器）</li>\n<li>模块化（大程序分解成小程序,使系统易于扩展）</li>\n</ul>\n<p>案例1：程序可以调用函数fork()来创建一个新的进程(拥有相同的代码段),OS需要分配一个新的并且唯一的进程ID;<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_pid = next_pid++  <span class=\"comment\">//此时在内核中系统调用执行(共享全局变量),当前系统最高的PID值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//机器指令</span></span><br><span class=\"line\">LOAD next_pid Reg1  <span class=\"comment\">// 将next_pid的值放入到reg1</span></span><br><span class=\"line\">STORE Reg1 new_pid</span><br><span class=\"line\">INC Reg1           <span class=\"comment\">// next_pid++</span></span><br><span class=\"line\">STORE Reg1 next_pid</span><br></pre></td></tr></table></figure></p>\n<p>假设两个进程并发执行,如果next-pid等于100,其中一个进程PID是101,而next_Pid应该增加到102;</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190417103005.png\" alt=\"WeiyiGeek.实际情况\" title=\"\" class=\"\">\n                <p>WeiyiGeek.实际情况</p>\n            </figure>\n<p>我们的希望是无论多个线程的指令序列怎么交替,程序都必须正常工作;不确定性要求并行程序的正确性,一定更要预先思考。</p>\n<p><strong>竞态条件(Race condition ):</strong></p>\n<ul>\n<li>系统缺陷：结果依赖于并发执行的时间点 顺序/时间(不确定性/不可重现)</li>\n</ul>\n<p><em>Q：如何避免竞争？</em><br>答：让指令不被打断;</p>\n<p>问题1：多个进程会交互对共享资源的访问,如果处理不当就会导致饥饿与死锁。</p>\n<p><strong>概念介绍：</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原子操作(Atomic Operation)：指一次不存在任何中断或者失败的执行,要么完整执行要么不执行,不会发生部分执行;但实际操作往往不是原子的,甚至单个机器指令都不一定是原子的。 </span><br><span class=\"line\"></span><br><span class=\"line\">临界区(Critical Section)： 进程中访问共享资源的代码区域,且当另一个进程处于相应代码区域时便不会执行。</span><br><span class=\"line\">互斥(Mutual Exclusion)：保证只有一个进程处于临界区,不允许多个进程访问同一共享资源.(一个厕所同时只能一个人使用)</span><br><span class=\"line\">死锁(Dead Lock)： 多个进程相互等待完成特定任务,而最终没法继续自身任务</span><br><span class=\"line\">饥饿(Starvation)： 一个可执行的进程长期等待执行,被调度器持续忽略。</span><br><span class=\"line\">锁(Lock) ：获得锁,获得控制权,</span><br><span class=\"line\">解锁(Unlock):释放锁,失去控制权</span><br><span class=\"line\">忙等待(Busy-waiting) ：进程在等待进入临界区时,循环执行无意义操作,浪费系统资源</span><br><span class=\"line\">Progress：希望进入临界区的进程总是能够进入临界区</span><br></pre></td></tr></table></figure></p>\n<p>案例2：操作系统中问题与现实生活中问题类比;</p>\n<ul>\n<li>存在的问题：两人都去买了面包,却不知道对方也买了面包;</li>\n<li>1.利用便签(lock)还是会多购买面包;(先判断有无面包,再判断有没有标签(lock)[此时如果发生上下文切换就会导致异常])</li>\n<li>2.如果将留便签放在第一位可能还是不会去买bread;(先贴上锁,再判断有无面包,再判断有无便签[如果在此之前发生了切换B线程也贴上了标签],所以A不会去买且B到判断时候也不会去买)</li>\n<li>3.为便签增加标签,进行增加访问过的记录,判断A和B有无访问过;可能导致没有线程去买面包(错误时间的上下文切换可能导致每个进程都认为宁一个进程去买面包了),这就是我们的饥饿问题;<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190417104606.png\" alt=\"WeiyiGeek.案例2\" title=\"\" class=\"\">\n                <p>WeiyiGeek.案例2</p>\n            </figure>\n</li>\n</ul>\n<p>解决方法：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190417110100.png\" alt=\"WeiyiGeek.解决方法\" title=\"\" class=\"\">\n                <p>WeiyiGeek.解决方法</p>\n            </figure></p>\n<p><em>解决方法总结:</em></p>\n<ul>\n<li>它是有效的但是不够完美,太复杂了</li>\n<li>A和B的代码不同,每个线程的代码也会略有不同</li>\n<li>A在等待的时候,其实是在消耗CPU的时间,这样的情况叫做忙等待(BUS-WAITING) </li>\n</ul>\n<p>案例3:假设我们有一些锁的实现<br>都是原子操作-如果两个线程都在等待同一个锁,并且同时发现锁备释放了,那么只有一个能够获得锁;<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//解决上面的面包问题</span></span><br><span class=\"line\">BreadLock.Acquire() - 在锁释放前一直等待,然后获得锁</span><br><span class=\"line\"><span class=\"keyword\">if</span>(nobread)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  buy bread</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">BreadLock.Release() - 解锁并唤醒任何等待中的进程</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h5 id=\"9-2-临界区及管理方法\"><a href=\"#9-2-临界区及管理方法\" class=\"headerlink\" title=\"9.2 临界区及管理方法\"></a>9.2 临界区及管理方法</h5><p>临界区(Critical Section)的一些主要概念：</p>\n<ul>\n<li>互斥：同一时刻只有一个线程在临界区里面</li>\n<li>有限等待:如果一个线程i处于入口区,那么在i的请求被接收之前,其他线程进入临界区的时间是有限制的;</li>\n<li>无忙等待：[可选]如果一个进程在等待进入临界区,那么在它可以进入之前会被挂起;</li>\n</ul>\n<p>保护临界区进程三种方法(互斥实现方式)：禁用硬件中断，基于软件(Peterson算法,更高级的抽象;</p>\n<ul>\n<li>进入与离开临界区代码ENTER/EXIT_CRITICAL_SECTION</li>\n<li>比较不同的机制,性能并发级别</li>\n</ul>\n<p><br><br><strong>(1)硬件中断方法</strong><br>描述：没有中断，就没有上下文切换,没有并发,减少不确定性。</p>\n<ul>\n<li>进入临界区时禁用中断</li>\n<li>退出临界区时开启中断</li>\n<li>如果两个CPU并行的话一个CPU只能屏蔽自身,另一个仍可能产生中断</li>\n</ul>\n<p>禁用中断产生问题：</p>\n<ul>\n<li>不能进行响应外部硬件设备请求</li>\n<li>线程无法被停止,整个系统都会停下来,可能导致其他线程可能会饥饿/影响效率;</li>\n</ul>\n<p><em>Q:临界区要是太长咋整？</em><br>答：无法限制响应中断所需的时间，可能有硬件影响。一般都用于短的临界区时间。</p>\n<p><br><br><strong>(2)基于软件的解决方法</strong><br>两个线程T0和T1,多进程Ti的通常结构,线程可能共享一些共有的变量来同步他们的行为;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#//常规结构</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">  enter critical_section <span class=\"comment\">#//进入区域</span></span><br><span class=\"line\">  Critical_Section <span class=\"comment\">#//临界区</span></span><br><span class=\"line\">  exite critical_section  <span class=\"comment\">#//离开区域</span></span><br><span class=\"line\">  Reminder_Section  <span class=\"comment\">#//提醒区域 </span></span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#//1.共享变量初始化(满足互斥但是有时候不满足Progresss)</span></span><br><span class=\"line\"><span class=\"comment\">#//Ti在退出临界区后做其他的事情去了,Tj想继续运行,但必须等待Ti处理临界区</span></span><br><span class=\"line\"></span><br><span class=\"line\">int turn=0; <span class=\"comment\">#//初始是Ti进入临界区 </span></span><br><span class=\"line\"><span class=\"comment\">#//对Thread Ti，有： </span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">while</span>(turn != i); <span class=\"comment\">#//busy waiting  (忙等待)   turn == i;//表示进入临界区否则忙等待</span></span><br><span class=\"line\">      ....</span><br><span class=\"line\">  critical section </span><br><span class=\"line\">  turn = j;     <span class=\"comment\">#//after exit turn=j  </span></span><br><span class=\"line\">  reminder section </span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span> (1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#//2.改进方法用数组(flag),必须是一种交替循环(如果先flag[i]=1再while循环，满足互斥但可能死锁)</span></span><br><span class=\"line\">flag[i]==1  <span class=\"comment\">#//进程i想进入临界区执行 </span></span><br><span class=\"line\"></span><br><span class=\"line\">int flag[2];flag[0]=flag[1]=0;   <span class=\"comment\">#//初始化共享变量</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">while</span>(flag[j] == 1); <span class=\"comment\"># //初始flag都是0，没有满足互斥 </span></span><br><span class=\"line\">  flag[i] == 1;  <span class=\"comment\">#//先请求 想进入临界区执行 </span></span><br><span class=\"line\">  critical section </span><br><span class=\"line\">  flag[i]=0; </span><br><span class=\"line\">  remainder section</span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span> (1);</span><br></pre></td></tr></table></figure><br>上面的方法为下面的实现奠定了基础：<br>满足进程Pi 和 Pj之间互斥的正解基于软件的解决方法(1981年)：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//use two shared data items</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>  turn;       <span class=\"comment\">// who ‘s turn to enter the critical section(谁准备好进入临界区)</span></span><br><span class=\"line\">boolean flag[];  <span class=\"comment\">//whether the process is ready to enter(知识进程是否准备好进入临界区)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PETERSON算法</span></span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">flag[i] = TURE;  <span class=\"comment\">//为真确定做好准备</span></span><br><span class=\"line\">turn = j;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[j] &amp;&amp; turn==j);  <span class=\"comment\">//同时满足进入临界区</span></span><br><span class=\"line\">    CRITICAL SECTION</span><br><span class=\"line\">    flag[i]=FLASE;   <span class=\"comment\">//重新设置为做好准备</span></span><br><span class=\"line\">REMAINDER SECTION  <span class=\"comment\">//提醒临界区</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(TURE);</span><br></pre></td></tr></table></figure></p>\n<p>Dekker算法(改进)：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190420091634.png\" alt=\"WeiyiGeek.Dekker\" title=\"\" class=\"\">\n                <p>WeiyiGeek.Dekker</p>\n            </figure></p>\n<p>Eisenberg and Mcguire’s algorirhm：(多进程互斥)对N个进程, 进程i之前的先进入了i再进入，i之后的等i先进入</p>\n<p>Bakert算法(排队取号，同号比ID)：类似于银行取号的原理(如果有两个取票机,假如会取到相同的票号,这时再按照顾客的身份证进行排序出不相同的票号),所以当多个进程按照其顺序取票号时候,有可能还要按照进程本身的PID进行排序;<br>假如N个进程的临界区：</p>\n<ul>\n<li>进入临界区之前,进程接收一个数字;</li>\n<li>得到的数字最小的进入临界区;</li>\n<li>如果进程Pi和Pj收到相同的数字,那么如果i &lt; j,Pi先进入临界区否则Pj先进入</li>\n<li>编号方案总是按照枚举的增加顺序生成数字;</li>\n</ul>\n<p><em>总结：</em></p>\n<ul>\n<li>对于算法的设计最好是满足互斥,前进,有序等待对于临界区的管理;</li>\n<li>Dekker算法(1965)：第一个针对于双线程例子的正确解决方案;</li>\n<li>Bakery算法(1979): 针对于n线程的临界区问题解决方案;</li>\n<li>产生的问题：<ul>\n<li>复杂,需要共享数据项</li>\n<li>耗资源,需要忙等待,浪费CPU时间</li>\n<li>没有硬件保证的情况下无真正的软件解决方法,load store必须要是原子操作;</li>\n</ul>\n</li>\n</ul>\n<p><br><br><strong>(3)更高级的抽象方法-主流方式</strong><br>硬件提供原子操作指令，通过特殊的内存访问电路实现,大多数现代体系结构都这样;<br>操作系统提供更高级的编程抽象来简化并行编程：例如锁,信号量(硬件源语中构建)实现进入与退出临界区;</p>\n<p>锁是一个抽象的数据结构,一个二进制状态(锁定/解锁)：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lock::Acquire - 锁释放前一直等待,然后得到锁</span></span><br><span class=\"line\"><span class=\"comment\">// Lock::Acquire - 释放锁,唤醒任何等待的进程</span></span><br><span class=\"line\">lock_next_pid -&gt; Acquire(); <span class=\"comment\">//进入临界区</span></span><br><span class=\"line\">new_pid = nex_pid++;</span><br><span class=\"line\">lock_next_pid -&gt; Release();  <span class=\"comment\">//退出临界区</span></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">大多数现代体系结构都提供特殊的原子操作指令：</span><br><span class=\"line\">- 通过特殊的内存访问电路</span><br><span class=\"line\">- 针对单处理器和多处理器</span><br><span class=\"line\"></span><br><span class=\"line\">Test-<span class=\"keyword\">and</span>-Set 指测试和置位 : 从内存读取值返回该值,测试该值是否为<span class=\"number\">1</span>(返回boolean类型)，并将该内存值设为<span class=\"number\">1</span>;</span><br><span class=\"line\">Exchange 交换指令 : 交换内存中两个值,然后返回;</span><br><span class=\"line\">![WeiyiGeek.语义和执行过程](https:<span class=\"comment\">//img.weiyigeek.top/2019/20190420112708.png)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">锁的实现：</span><br><span class=\"line\">```bash</span><br><span class=\"line\">#下面是导致忙等版本，适用于临界区较小的情况, 可以支持N个进程的操作且是一样的，都很简洁 </span><br><span class=\"line\">#如果临界区较大，则加入阻塞和唤醒语句，会产生上下文切换开销</span><br><span class=\"line\">#线程在等待的时间消耗CPU周期;</span><br><span class=\"line\">class Lock &#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> lock = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Lock::Acquire() &#123;</span><br><span class=\"line\">  <span class=\"string\">\"\"</span><span class=\"string\">\"</span></span><br><span class=\"line\"><span class=\"string\">  1.如果锁被释放,那么testandset读取0并将值设置为1,锁被设置为忙并且需要等待完成</span></span><br><span class=\"line\"><span class=\"string\">  2.如果锁处于忙状态,那么test-and-set读取1并将值设置为1,不改变锁的状态并且需要循环(自旋pin)</span></span><br><span class=\"line\"><span class=\"string\">  \"</span><span class=\"string\">\"\"</span></span><br><span class=\"line\">  <span class=\"comment\">// test-and-set</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (test-<span class=\"keyword\">and</span>-<span class=\"built_in\">set</span>(lock));</span><br><span class=\"line\">  <span class=\"comment\">// exchange</span></span><br><span class=\"line\">  key = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (key == <span class=\"number\">1</span>) exchange(lock, key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Lock::Release() &#123;</span><br><span class=\"line\">  lock = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#无忙等待(采用睡眠的形式)，当它等待其他事件时，可以睡眠/阻塞</span><br><span class=\"line\">class lock&#123; <span class=\"keyword\">int</span> value = <span class=\"number\">0</span>; waitqueue q;&#125;</span><br><span class=\"line\">lock::acquire()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (test-<span class=\"keyword\">and</span>-<span class=\"built_in\">set</span>(value))&#123;</span><br><span class=\"line\">  <span class=\"comment\">//add this TCB to wait queen q;</span></span><br><span class=\"line\">  schedule();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">lock::release()&#123;</span><br><span class=\"line\">  value=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//remove one thread t from q;</span></span><br><span class=\"line\">  wakeup(t);  <span class=\"comment\">//需要进行唤醒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>利用Exchange来完成进入与退出临界区”<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> lock=<span class=\"number\">0</span>;   <span class=\"comment\">//初始化 </span></span><br><span class=\"line\"><span class=\"comment\">//to process Ti that want to enter the critical section </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> key;</span><br><span class=\"line\"><span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">  key=<span class=\"number\">1</span>; </span><br><span class=\"line\">  <span class=\"keyword\">while</span>(key==<span class=\"number\">1</span>) exchange(lock,key); <span class=\"comment\">//when key!=1 swap out of (k = 0)时候while退出执行临界区</span></span><br><span class=\"line\">  critical section     <span class=\"comment\">//at that time key=0 lock=1</span></span><br><span class=\"line\">  lock=<span class=\"number\">0</span>; </span><br><span class=\"line\">  remainder section </span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure></p>\n<p><em>基于原子操作的机器指令方式优点：</em></p>\n<ul>\n<li>适用于单处理器或共享主存的多处理器中任意数量的进程</li>\n<li>实现简单并且容易证明</li>\n<li>易扩展到多临界区，开销小，广泛使用</li>\n</ul>\n<p><em>基于原子操作的机器指令方式缺点:</em></p>\n<ul>\n<li>还是有忙等浪费CPU时间;</li>\n<li>抢LOCK随机可能某个一直抢不到，当进程离开临界区，且多个进程在等待时可能导致饥饿；</li>\n<li>死锁: 一个低优先级的进程拥有临界区，一个高优先级的进程也需求，那么高优先级进程忙等占用cpu,低优先级的不能释放Lock, 要通过优先级反转来解决。</li>\n</ul>\n<p><em>总结：</em><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190420114641.png\" alt=\"WeiyiGeek.临界区\" title=\"\" class=\"\">\n                <p>WeiyiGeek.临界区</p>\n            </figure></p>\n<ul>\n<li>如果临界区很短的情况下,还是建议选择忙等待状态,因为他们不需要完成上下文切换,否则要引入WAITING和wakeup;</li>\n<li>用锁来解决互斥问题，锁是高层编程抽象，需要一定硬件支持;</li>\n<li>常用三种：禁用中断（仅可单处理器），软件方法（复杂），原子操作指令（单处理器或多处理器都可以）</li>\n<li>可选的实现内容：有忙等待，无忙等待（进程睡眠）</li>\n</ul>\n<hr>\n\n<h4 id=\"10-信号量与同步\"><a href=\"#10-信号量与同步\" class=\"headerlink\" title=\"10.信号量与同步\"></a>10.信号量与同步</h4><p>(1) 背景以及信号量<br>(2) 信号量的使用与实现<br>(3) 临界区与管程区别<br>(4) 同步问题与实现</p>\n<h5 id=\"10-1-背景以及信号量-Semaphore\"><a href=\"#10-1-背景以及信号量-Semaphore\" class=\"headerlink\" title=\"10.1 背景以及信号量(Semaphore)\"></a>10.1 背景以及信号量(Semaphore)</h5><p>信号量 Semaphore 是由Dijkstra在20世纪60年代提出的,在早期的操作系统是主要的同步原语,由于产生信号量是由于多程序并发存在大的问题,即出现并发问题(竞争条件);</p>\n<p>同步需要多线程共享公共数据的协调执行,包括互斥与条件同步;</p>\n<ul>\n<li>互斥：在同一时间只有一个线程可以执行临界区;</li>\n</ul>\n<p><em>Q：如何确保同步正确执行？</em></p>\n<ul>\n<li>从底层硬件支持编译,需要高层次的编程抽象如锁lock;</li>\n<li>锁只解决了互斥为了有时候要让多个进程进入临界区（比如只在临界区进行读操作，不必要求互斥），需要解决同步</li>\n<li>信号量和管程是比锁更高级的抽象,也是同步互斥的解决方式</li>\n</ul>\n<p><em>抽象数据类型：</em> 用一个整形（sem）表示，提供两个原子操作 P() 和 V()</p>\n<blockquote>\n<p>V ：verhoog(荷兰语增加) / P ：Prolaag(荷兰语减少)<br>P()，表示有线程需要进入临界区，sem–; if (sem &lt; 0) wait; else progress(继续);<br>V()，表示有线程离开临界区，sem++; if (sem &lt;= 0) wakeup a thread in waiting list  #sem &lt;= 0意味着有线程在等待进入临界区，唤醒常用FIFO方式<br>sem初值设为1就相当于锁了；初值设为更大的值，可以实现条件同步</p>\n</blockquote>\n<p>信号量类似于铁路中信号灯,比如下面初始化两个资源控制信号灯:<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190521221551.png\" alt=\"WeiyiGeek.信号量类似\" title=\"\" class=\"\">\n                <p>WeiyiGeek.信号量类似</p>\n            </figure></p>\n<p><em>信号量的特征</em>：</p>\n<ul>\n<li>Semaphore是有符号的整数:一般初始是&gt;0的数，一旦小于0就不能继续，要挂在信号量上，其他进程做V操作才能唤醒，具体唤醒哪个取决于具体的算法，如常用FIFO先来先服务较为公平</li>\n<li>Semaphore是被保护的变量:但操作必须是原子即初始化完成后只能通过P() 于V() 这两个原子操作改变值;</li>\n<li>P 操作会阻塞 , V 操作不会阻塞</li>\n</ul>\n<p><br></p>\n<h5 id=\"10-2-信号量的使用与实现\"><a href=\"#10-2-信号量的使用与实现\" class=\"headerlink\" title=\"10.2 信号量的使用与实现\"></a>10.2 信号量的使用与实现</h5><p>信号量的两种类型：</p>\n<ul>\n<li>二进制信号量 ：0 或者 1</li>\n<li>一般 / 计数信号量 ：可取任何非负值</li>\n</ul>\n<p>信号量的使用场景：</p>\n<ul>\n<li>互斥</li>\n<li>条件同步(调度约束—一个线程等待另一个线程的事情发生)</li>\n</ul>\n<p><strong>(1)用二进制信号量实现互斥于调度约束</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#实现互斥</span></span><br><span class=\"line\">mutex = new semaphore(0);</span><br><span class=\"line\">mutex-&gt;P();</span><br><span class=\"line\">Critical section;</span><br><span class=\"line\">mutex-&gt;V();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#实现调度约束</span></span><br><span class=\"line\"><span class=\"comment\">#调度约束sem初值设为0，Thread A某处P() / Thread B某处V()，确保Thread A在P()之后的语句一定在Thread B的V()执行之后才会开始执行</span></span><br><span class=\"line\">condition=new semaphore(0);</span><br><span class=\"line\"><span class=\"keyword\">for</span> thread A  condition-&gt;P();  <span class=\"comment\">#开始等待</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> thread B  condition-&gt;V();  <span class=\"comment\">#发出信号唤醒 A / B 在V()操作之前的语句执行完后才能执行A的 P()之后的语句-同步</span></span><br></pre></td></tr></table></figure></p>\n<p>一个线程等待另外一个线程处理事情的时候,光有互斥(锁机制)是不够的;</p>\n<p>例如：有界缓冲区的生产者-消费者问题;</p>\n<ul>\n<li>一个或者多个生产者产生数据将数据放在一个缓冲区里,单个消费者每次从缓冲区取出数据;</li>\n<li>在任何一个时间只有一个生产者或消费者可以访问该缓冲区;</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Producer (生产者)</th>\n<th>Buffer</th>\n<th>Consumer (消费者)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>用于存放产品</td>\n<td>缓冲区</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>正确性要求：可以多个生产者访问Buffer写数据，但写的时候消费者不能有操作（互斥）, 缓冲区空消费者必须等待生产者,缓冲区满生产者必须等待消费者（调度/同步约束）。</p>\n<p>每个约束用一个单独的信号量表示：</p>\n<ul>\n<li>二进制信号量互斥(1/0)</li>\n<li>一般信号量 full buffers</li>\n<li>一般信号量 empty buffer</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#初始化信号量</span></span><br><span class=\"line\">Class BoundedBuffer&#123;</span><br><span class=\"line\">  Mutex = new semaphore(1);</span><br><span class=\"line\">  fullBuffers = new semaphore(0);</span><br><span class=\"line\">  emptyBuffers = new semaphore(n); <span class=\"comment\">#当前生产者可以往里面放多少个数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">#如果Buffer不空，则full/empty设别的值</span></span><br><span class=\"line\"><span class=\"comment\">#缓冲区界限 -&gt; 生产存放</span></span><br><span class=\"line\">BoundedBuffer::Deposit(c)&#123;</span><br><span class=\"line\">  emptyBuffer-&gt;P(); <span class=\"comment\">#个生产者都可以进入直到empty&lt;0被阻塞，不能先锁再emptybuffer--, 不然会在Buffers满的时候死锁 </span></span><br><span class=\"line\">  mutex-&gt;P(); </span><br><span class=\"line\">  Add c to the buffer; </span><br><span class=\"line\">  mutex-&gt;V(); </span><br><span class=\"line\">  fullBuffers-&gt;V(); <span class=\"comment\">#初始是0，只有先V()不然消费者不能取</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\"># 消费移除</span></span><br><span class=\"line\">BoundedBuffer::Remove(c)&#123; </span><br><span class=\"line\">    fullBuffers-&gt;P();  <span class=\"comment\">#初始是0时会被挂起 </span></span><br><span class=\"line\">    mutex-&gt;P();  <span class=\"comment\">#线程进入临界区</span></span><br><span class=\"line\">    Remove c from buffer; </span><br><span class=\"line\">    mutex-&gt;V();  <span class=\"comment\">#线程执行完成退出临界区</span></span><br><span class=\"line\">    emptyBuffers-&gt;V(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>Q：问题上面的P&amp;V可以换顺序吗？</em><br>答：可以。</p>\n<p><br></p>\n<p><strong>(2)信号量实现</strong><br>信号量的用用途：</p>\n<ul>\n<li>互斥和条件同步</li>\n<li>但等待条件是独立的互斥</li>\n</ul>\n<p>使用两种方式硬件原语：</p>\n<ul>\n<li>禁用中断</li>\n<li>原子指令(test and set)</li>\n</ul>\n<p>例如:使用禁用中断：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Semaphore</span>&#123;</span> </span><br><span class=\"line\">  <span class=\"keyword\">int</span> sem; </span><br><span class=\"line\">  Waitqueue q;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//有了数据结构,sem信号量自减，如果小于0则放入等待序列中,同时自身睡眠</span></span><br><span class=\"line\">Semaphore::P()&#123;</span><br><span class=\"line\">   sem--; </span><br><span class=\"line\">   <span class=\"keyword\">if</span>(sem&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">     Add <span class=\"keyword\">this</span> thread t to q; </span><br><span class=\"line\">     block(p); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//信号量自加,判断是否有线程在睡眠等待队列(&lt;=0),将从等待队列中取出FIFO算法存在时间最久的进程进行执行（唤醒）</span></span><br><span class=\"line\">Semaphore::V()&#123; </span><br><span class=\"line\">  Sem++; </span><br><span class=\"line\">  If(sem&lt;=<span class=\"number\">0</span>)&#123; </span><br><span class=\"line\">   Remove a thread t from q; </span><br><span class=\"line\">   wakeup(t);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>信号量和LOCK有区别：LOCK是通过忙等/等待队列实现sleep，信号量是等待队列。</p>\n<p>上面这种方式存在的问题：</p>\n<ul>\n<li>读/开发代码比较困难(程序员必须非常精通才行)，开发容易犯错（忘记释放信号量,使用的信号量已经被另外一个线程占用）</li>\n<li>不能够处理死锁问题</li>\n</ul>\n<p><br></p>\n<h5 id=\"10-3-管程的使用与实现\"><a href=\"#10-3-管程的使用与实现\" class=\"headerlink\" title=\"10.3 管程的使用与实现\"></a>10.3 管程的使用与实现</h5><p>描述：比信号量抽象程度更高的机制,目的分离互斥(mutex)和条件同步的关注;作为编程语言的特性而诞生，用来简化并发编程，而非为OS设计;</p>\n<p><em>什么是管程?</em><br>描述：管程(monitor)包含了一系列的共享变量，以及针对这些变量的操作的函数的组合/模块 </p>\n<ul>\n<li>一个Lock(指定临界区)</li>\n<li>0 或者多个条件变量(等待/通知信号量用于管理并发访问共享数据)</li>\n</ul>\n<p>一般方法：</p>\n<ul>\n<li>收集在对象/模块中的相关共享数据</li>\n<li>定义方法来访问共享数据</li>\n</ul>\n<p>进入管程的队列是互斥的,然后执行wait等待睡眠/signal唤醒操作;<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Lock 锁机制</span></span><br><span class=\"line\">Lock::Acquire() - 等待直到锁可用,然后抢占锁;</span><br><span class=\"line\">Lock::Release() - 释放锁,唤醒等待者如果有</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#条件(Condition)变量</span></span><br><span class=\"line\">- 允许等待状态进入临界区（允许处于等待[睡眠]的线程进入临界区,某个时刻原子释放锁进入睡眠)</span><br><span class=\"line\">- <span class=\"built_in\">wait</span>() : 释放锁/睡眠重新获得锁返回</span><br><span class=\"line\">- signal() : 唤醒等待者,(或者使用所有等待则)在如果有的前提下</span><br></pre></td></tr></table></figure></p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190607103911.png\" alt=\"WeiyiGeek.管程原理\" title=\"\" class=\"\">\n                <p>WeiyiGeek.管程原理</p>\n            </figure>\n<p>管程实现:需要维持每个条件队列,线程等待的条件等待signal();<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190607112027.png\" alt=\"WeiyiGeek.管程的实现\" title=\"\" class=\"\">\n                <p>WeiyiGeek.管程的实现</p>\n            </figure></p>\n<p>用管程实现生产者-消费者模型</p>\n<ul>\n<li>count表示buffer中产品的数量,唤醒后获得锁</li>\n<li>条件变量notFull、notEmpty表示是否为满或空的状态，notFull可以理解为okToProduce</li>\n<li>先在前后加锁因为要保证只有一个线程在临界区 lock 在等待/睡眠的时候通过 notfull.wait(&amp;lock) 释放锁。</li>\n</ul>\n<p>Hansen方式，signal()之后继续执行完release()再切换线程，易于实现，实际OS采用此方式<br>Hoare方式，signal()之后立刻切换线程，直观，但实现困难，教科书一般按此方式</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190607105605.png\" alt=\"WeiyiGeek.操作系统管程的使用\" title=\"\" class=\"\">\n                <p>WeiyiGeek.操作系统管程的使用</p>\n            </figure>\n<p>While和if的区别，前者release后是挂在条件变量上的多个线程抢CPU，抢到谁给谁所以要check again, 后者是直接转交给了下一个线程，始终满足 count &lt; n 的条件，所以直接走IF下面的语句</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190607110710.png\" alt=\"WeiyiGeek.两种方法的类比\" title=\"\" class=\"\">\n                <p>WeiyiGeek.两种方法的类比</p>\n            </figure>\n<p><em>存在的问题：</em></p>\n<ul>\n<li>开发/调试并行程序很难,非确定性的交叉指令</li>\n</ul>\n<p>两个同步互斥的机制，临界区和monitor，比起LOCK都可以解决更广泛的问题，但也都离不开底层的硬件支持。<br>同步互斥的不确定性强，调试困难。<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190607105932.png\" alt=\"WeiyiGeek.临界区和MONITOR比较\" title=\"\" class=\"\">\n                <p>WeiyiGeek.临界区和MONITOR比较</p>\n            </figure></p>\n<p>同步结构：锁(互斥),条件变量(有条件的同步),其他原语(信号量)</p>\n<p><em>怎么有效的使用这些结构?</em><br>答：制定并遵循严格的程序设计风格/策略;</p>\n<p><br></p>\n<h5 id=\"10-4-同步问题与实现\"><a href=\"#10-4-同步问题与实现\" class=\"headerlink\" title=\"10.4 同步问题与实现\"></a>10.4 同步问题与实现</h5><p><strong>(1) 经典同步问题 - 读者优先</strong><br>主要讨论读者(reader)和写者问题(Writer);</p>\n<ul>\n<li>动机：共享数据的访问</li>\n<li>两种类型使用者的定义：<ul>\n<li>读者：不需要修改数据(只读)</li>\n<li>写者：读取和修改数据(读取和修改)</li>\n</ul>\n</li>\n<li>主要的问题约束：<ul>\n<li>同一时间有多个读者,但是在任何时候只有一个写者;</li>\n<li>但没有写者时,读者才能访问数据;(读写不能同时进行)</li>\n<li>当没有读者和写者时,写者才能访问数据;(写者不能同时进行)</li>\n<li>在任何时间只有一个线程可以操作共享变量;(即对于同一个文件读写只能由一个进程进行)</li>\n</ul>\n</li>\n</ul>\n<p><em>多个并发进程的数据集共享</em>：</p>\n<ul>\n<li>读者 - 只读数据集,他们不执行任何更新</li>\n<li>写者 - 可以读取和写入</li>\n</ul>\n<p><em>共享数据</em>：</p>\n<ul>\n<li>数据集</li>\n<li>信号量 CountMutex 初始化为1,用于对count修改的互斥;</li>\n<li>信号量 WriteMutex 初始化为1,用于读者和写者、写者之间的互斥;</li>\n<li>整数 Rcount 初始化为 0 ,表示读者个数;</li>\n</ul>\n<p><em>实际案例：读者优先以信号量实现</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">writemutex ： 操作保证了写的互斥，和当前没有读者时，读者进入的互斥。</span><br><span class=\"line\">Rcount ：保证了可以有多个读者，由于自身是共享变量（对多个读者而言），所以在++ /– /判断操作的前后要用到CountMutex</span><br><span class=\"line\"></span><br><span class=\"line\">sem_wait() 为 P() 等待</span><br><span class=\"line\">sem_post() 为 V() 释放</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##### Writer #####</span></span><br><span class=\"line\">sem_wait(WriteMutex);</span><br><span class=\"line\">  write;</span><br><span class=\"line\">sem_post(WriteMutex);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##### Reader #####</span></span><br><span class=\"line\">sem_wait(CountMutex);</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(Rcount == 0)&#123;</span><br><span class=\"line\">  sem_wait(WriteMutex);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  ++Rcount</span><br><span class=\"line\"></span><br><span class=\"line\">sem_post(CountMutex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">read</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">sem_wait(CountMutex);</span><br><span class=\"line\">  --Rcount;  <span class=\"comment\">#表示读者全部完成了读</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(Rcount == 0)&#123;</span><br><span class=\"line\">    sem_post(WriteMutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">sem_post(CountMutex);</span><br></pre></td></tr></table></figure></p>\n<p><em>读者优先和写者优先比较</em></p>\n<ul>\n<li>读者优先策略：只要有一个读者处于活动状态,后来的读者都会被接纳.如果读者源源不断的出现的话,那么写者就始终处于阻塞状态;(避免了按照时间顺序谁先来谁执行)</li>\n<li>写者优先策略：一旦写者就绪那么写者尽可能快地执行写操作,如果写者源源不断的出现的话,那么读者就始终处于阻塞阻塞转状态;</li>\n</ul>\n<p><br></p>\n<p><strong>(2) 经典同步问题 - 写者优先</strong><br>存在两类写者：一种是正在写的,一种是在写的等待队列里；而读者只有在上面者两类写者完成后才能进行读操作;<br>关键点：</p>\n<ul>\n<li>signal() 只唤醒一个线程</li>\n<li>broadcast() 唤醒所有线程</li>\n</ul>\n<p>实际案例：写者优先-使用管程实现<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Database::Read()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Wait until no writers;  #等待没有写者</span></span><br><span class=\"line\">    <span class=\"function\">Start <span class=\"title\">Read</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    read database;</span><br><span class=\"line\">    <span class=\"comment\">//check out - wake up waiting writers;  #读完成了再检测是否有等待的写者</span></span><br><span class=\"line\">    DoneRead();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#基础结构：两种方法</span><br><span class=\"line\">Database::Write()&#123;</span><br><span class=\"line\">  <span class=\"comment\">//Wait until no readers/writes;</span></span><br><span class=\"line\">  StartWrite();</span><br><span class=\"line\">  write database;</span><br><span class=\"line\">  <span class=\"comment\">//check out - wake up waiting readers/writers; //检测并且唤醒等待队列里面的读者或者写者</span></span><br><span class=\"line\">   DoneWrite();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//#----------------------------------------------------------------#</span></span><br><span class=\"line\">#管程状态变量 （管程需要任何操作都处于互斥的，确保一个程序进入管程(临时于临界区)去执行）</span><br><span class=\"line\">AR = <span class=\"number\">0</span>;  #正在读的个数</span><br><span class=\"line\">AW = <span class=\"number\">0</span>;  #正在写的个数</span><br><span class=\"line\">WR = <span class=\"number\">0</span>;   #等待的读者个数</span><br><span class=\"line\">WW = <span class=\"number\">0</span>;   #等待的写者个数</span><br><span class=\"line\">CONDITION oktoRead;  #可以读了</span><br><span class=\"line\">CONDITION oktoWrite; #可以写了</span><br><span class=\"line\">Lock lock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//准备进行读操作(写者优先)</span></span><br><span class=\"line\">Private Database::StratRead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  lock.Acquire(); <span class=\"comment\">//保护互斥</span></span><br><span class=\"line\">  <span class=\"comment\">//再读操作之之前,先判断是否存在写者</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((AW+WW) &gt; <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">    WR++;</span><br><span class=\"line\">    okToRead.wait(&amp;lock);</span><br><span class=\"line\">    WR--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lock.Release();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//唤醒处于等待状态的Writer;</span></span><br><span class=\"line\">Private Database::DoneRead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  lock.Acquire();</span><br><span class=\"line\">  AR--;</span><br><span class=\"line\">  <span class=\"comment\">//注意下面要保证其他的正在读的读者也为0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(AR == <span class=\"number\">0</span> &amp;&amp; WW &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    okToWrite.signal();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  lock.Release();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//准备进行写操作(读者优先)</span></span><br><span class=\"line\">Private Database::StratWrite()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  lock.Acquire();</span><br><span class=\"line\">  <span class=\"comment\">//再读操作之之前,先判断是否存在写者</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>((AR+WR) &gt; <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">    WW++;</span><br><span class=\"line\">    okToWrite.wait(&amp;lock); <span class=\"comment\">//写等待</span></span><br><span class=\"line\">    WW--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  AW++;</span><br><span class=\"line\">  lock.Release();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//完成写者,检测并唤醒处理等待队列种的读者或写者</span></span><br><span class=\"line\">Private Database::StratWrite()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  lock.Acquire();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ww &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    okToWrite.signal(); <span class=\"comment\">//使等待队列的写操作唤醒</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(WR &gt; <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">    okToRead.broadcast(); <span class=\"comment\">//提高效率可以让多个读者同时进行读</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  lock.Release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br> </p>\n<p><strong>(3) 经典同步问题 -哲学家就餐</strong><br>问题描述：5个哲学家吃饭的时候需要两把叉子,但是圆桌上只有5支叉子，如何保证哲学家动作有序进行?如：不会出现饥渴现象;(由1965年由Dijkstra首先提出并解决)<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190609164926.png\" alt=\"WeiyiGeek.案例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.案例</p>\n            </figure></p>\n<p>方法1：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 5   <span class=\"comment\">//哲学家个数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">philosopher</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;    <span class=\"comment\">//哲学家编号：0 - 4</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(TRUE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  think();</span><br><span class=\"line\">  take_fork(i);      <span class=\"comment\">// 拿起左边叉子</span></span><br><span class=\"line\">  take_fork((i+<span class=\"number\">1</span>) % N); <span class=\"comment\">//拿起右边叉子</span></span><br><span class=\"line\">  eat();   </span><br><span class=\"line\">  put_fork(i);       <span class=\"comment\">// 放下左边叉子</span></span><br><span class=\"line\">  put_fork((i+<span class=\"number\">1</span>) % N);  <span class=\"comment\">// 放下右边叉子</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//上面的方法,如果是多个人可能导致死锁问题;</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p>方法2：对拿叉子的过程进行了改进(主动释放资源),但是仍然不正确;<br>如果每一个人都同时拿到叉子,然后又判断右手是否存在叉子,当然此时是不存在的;大家又把叉子放回去了,等待1秒重复执行;<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190609170247.png\" alt=\"WeiyiGeek.判断右手的叉子是否存在否则放下左手\" title=\"\" class=\"\">\n                <p>WeiyiGeek.判断右手的叉子是否存在否则放下左手</p>\n            </figure></p>\n<p><br><br>方法3：在方法2的基础上在else语句下加入 wait_random_time();等待随机长时间;<br>此种方法等待时间随机变化,可行但是并非万全之策;</p>\n<p><br><br>方式4: 我们学习了同步和互斥,利用此种方法来实现,但需要考虑问题(是否会出现死锁/还有效率)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#此种方法互斥访问不会出现死锁lock是正确的,但是每次只允许一人进餐(效率比较低)</span><br><span class=\"line\">semaphore mutex;   <span class=\"comment\">//互斥信号量初值为1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">philosopher</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//哲学家编号：0~4</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(TRUE)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    think();  <span class=\"comment\">//哲学家思考</span></span><br><span class=\"line\">    P(mutex); <span class=\"comment\">//进入临界区</span></span><br><span class=\"line\">      take_fork(i);      <span class=\"comment\">// 拿起左边叉子</span></span><br><span class=\"line\">      take_fork((i+<span class=\"number\">1</span>) % N); <span class=\"comment\">//拿起右边叉子</span></span><br><span class=\"line\">      eat();   </span><br><span class=\"line\">      put_fork(i);       <span class=\"comment\">// 放下左边叉子</span></span><br><span class=\"line\">      put_fork((i+<span class=\"number\">1</span>) % N);  <span class=\"comment\">// 放下右边叉子</span></span><br><span class=\"line\">    V(mutex);   <span class=\"comment\">//退出临界区</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方案的缺点：它把就餐（而不是叉子）看成是必须互斥的访问的临界资源,因此会造成(叉子)资源的浪费;<br>从理论上说,如果有五把叉子,但应该允许两个不相邻的哲学家同时就餐;</p>\n<p><br/></p>\n<p><strong>最终解决：</strong></p>\n<p>(1) 从哲学家的角度解决,指导原则：要么不拿,要么就拿两把叉子;<br>(2) 从计算机程序来解决这个问题,指导原则：不能浪费CPU时间,进程间相互通信;</p>\n<ul>\n<li>S1：思考中…</li>\n<li>S2: 进入饥饿状态</li>\n<li>S3: 如果左邻居或者右邻居正在就餐,进程进入阻塞态否则转S4;</li>\n<li>S4: 拿起两把叉子</li>\n<li>S5: 开始吃饭…</li>\n<li>S6: 放下左边叉子看看左邻居是否可以进餐(饥饿状态,它的左边叉子是存在的),若能则唤醒之;</li>\n<li>S7: 放下右边叉子看看右邻居是否可以进餐(饥饿状态,它的右边叉子是存在的),若能则唤醒之;</li>\n<li>S8：根据判断又回到S1种;</li>\n</ul>\n<p>(3) 编写程序的要求;</p>\n<ul>\n<li><ol>\n<li>必须有数据结构,来描述每个哲学家的当前状态;</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>该状态是一个临界区资源,每个哲学家对它的访问应该互斥地进行-进程互斥;</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>一个哲学家吃饱后,可能需要唤醒它的左邻右舍,两者之间存在着同步关系-进程同步</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 必须有一个数据结构,来描述每个哲学家得当前状态</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 5     <span class=\"comment\">//哲学家个数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LEFT i   <span class=\"comment\">//第i个哲学家得左邻居;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RIGHT (i+1)%N <span class=\"comment\">//第i个哲学家得右邻居;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> THINKING 0 <span class=\"comment\">//思考状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> HUNGRY 1 <span class=\"comment\">//饥饿状态</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> EATING 2 <span class=\"comment\">//进餐状态</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> statep[N];    <span class=\"comment\">//记录每个人得状态</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 该状态是一个临界资源,对他得访问应该互斥得进行</span></span><br><span class=\"line\">semaphore mutex;  <span class=\"comment\">//互斥信号量,初始值为1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 一个哲学家吃饱后,可能要唤醒邻居，存在同步关系</span></span><br><span class=\"line\">semaphore s[N];   <span class=\"comment\">//同步信号量初始值为0 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 主函数philosopher(int i) </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">philosopher</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//封闭式循环</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(TRUE)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    think(); <span class=\"comment\">//S1</span></span><br><span class=\"line\">    take_forks(i); <span class=\"comment\">//S2-S4</span></span><br><span class=\"line\">    eat(); <span class=\"comment\">//S5</span></span><br><span class=\"line\">    put_forks(i); <span class=\"comment\">//S6-S7</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数take_forks功能：要么拿到两把叉子,要么被阻塞起来;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">take_forks</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  P(mutex);   <span class=\"comment\">//进入临界区</span></span><br><span class=\"line\">  state[i] = HUNGRY;             <span class=\"comment\">//饥饿状态</span></span><br><span class=\"line\">  test_take_left_right_forks(i); <span class=\"comment\">//试图拿两把叉子</span></span><br><span class=\"line\">  V(mutex);  <span class=\"comment\">//退出临界区</span></span><br><span class=\"line\">  P(s[i]);                       <span class=\"comment\">//没有叉子便阻塞</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//test_take_left_right_forks函数定义（i 即哲学家得序号排列）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_take_left_right_forks</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(state[i] == GUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    state[i] = EATING;  <span class=\"comment\">//两把叉子到手</span></span><br><span class=\"line\">    V(s[i]); <span class=\"comment\">//通知第i人可以吃饭了(说白了是自己);(让进程进行唤醒)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数put_forks定义：把两把叉子放回原处,并且在需要得时候去唤醒左邻右舍</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put_forks</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">  P(mutex); <span class=\"comment\">//进入临界区</span></span><br><span class=\"line\">  state[i] = THINKING;  <span class=\"comment\">//交出两把叉子</span></span><br><span class=\"line\">  test_take_left_right_forks(LEFT);  <span class=\"comment\">//看左邻居是否可以进餐</span></span><br><span class=\"line\">  test_take_left_right_forks(RIGHT); <span class=\"comment\">//看右邻居是否可以进餐</span></span><br><span class=\"line\">  V(mutex); <span class=\"comment\">//退出临界区</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","comments":true,"excerpt":"8.CPU调度算法(1) 算法背景<br>(2) 调度原则<br>(3) 调度算法/实时调度/多处理器调度<br>(4) 优先级反转","categories":[{"name":"计算机基础","path":"api/categories/计算机基础.json"}],"tags":[{"name":"OperatingSystem","path":"api/tags/OperatingSystem.json"}]}