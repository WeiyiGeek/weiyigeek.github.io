<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="content-language" content="zh-CN"/>
    <meta name="author" content="WeiyiGeek" />
    <meta name="msvalidate.01" content="5C552FB1D885E0E11D2957EC958C8018" />
    <meta name="shenma-site-verification" content="4c655e91c76be0a93c1b6954c666c9d6_1649049085"/>
    <meta name="bytedance-verification-code" content="lKs4FqwCHSJ3A/c5tT7X" />
    <meta name="sogou_site_verification" content="OC65iET6Bk" />
    
    <title>🌐 JAVA入门学习十|WeiyiGeek Blog|唯一极客Geek-IT网络安全运维开发技术知识分享-博客站点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
    <meta name="keywords" content="JAVA">
    <meta name="Description" content="WeiyiGeek-唯一极客博客站点,关注于网络安全运维,Web安全开发,IOT物联网安全开发,应用开发,分享技术学习知识与入坑解决,提升网络安全技术与自身技术能力,立志维护大众网络安全为己任,做一个对国家有用的人,为实现中华民族伟大复兴的中国梦不懈奋斗">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/jquery/3.5.2-jquery.fancybox.min.css?v=1.6.6" />
    <link rel="stylesheet" href="/css/style.css?v=1.6.6">
    <!--  -->
     <script type="text/javascript" src="/js/custom/articlecost.js?v=1.6.6"></script> 
    <link rel="stylesheet" href="/css/third-party/gitalk.css?v=1.6.6"> 
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9134434519967436" crossorigin="anonymous"></script>    
    <script type="text/javascript">
        // Data Center
        var DC = {
          reward:	true,
          lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
          v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}')
        };
    </script>
    <script type="text/javascript">window.lazyScripts=[];</script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="WeiyiGeek Blog" type="application/atom+xml">
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg" alt="WeiyiGeek-backgroud">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg" alt="WeiyiGeek-头像">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">WeiyiGeek</h5>
          <a href="mailto:master@weiyigeek.top" title="master@weiyigeek.top" class="mail">
            <span>m</span><span>a</span><span>s</span><span>t</span><span>e</span><span>r</span><span>@</span><span>w</span><span>e</span><span>i</span><span>y</span><span>i</span><span>g</span><span>e</span><span>e</span><span>k</span><span>.</span><span>t</span><span>o</span><span>p</span>
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://weiyigeek.top/img/wechat-search.png" target="_blank">
                  <i class="icon icon-lg icon-wechat"></i>
                </a>
              </li>
            
              <li>
                <a href="https://github.com/weiyigeek" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://t.me/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-telegram"></i>
                </a>
              </li>
            
              <li>
                <a href="https://twitter.com/WeiyiGeek" target="_blank">
                  <i class="icon icon-lg icon-twitter"></i>
                </a>
              </li>
            
              <li>
                <a href="https://weibo.com/615643678" target="_blank">
                  <i class="icon icon-lg icon-weibo"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                首页
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                文章分类
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                文章标签
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章归档
              </a>
            </li>
        
            <li class="">
              <a href="/2018/1-1-1.html"  >
                <i class="icon icon-lg icon-mortar-board"></i>
                学习之路
              </a>
            </li>
        
            <li class="">
              <a href="/books"  >
                <i class="icon icon-lg icon-book"></i>
                学习书籍
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于作者
              </a>
            </li>
        
            <li class="">
              <a href="/sites"  >
                <i class="icon icon-lg icon-globe"></i>
                站点导航
              </a>
            </li>
        
            <li class="">
              <a href="/img/share-wechat.jpg" target="_blank" >
                <i class="icon icon-lg icon-wechat"></i>
                公众账号
              </a>
            </li>
        
            <li class="">
              <a href="https://space.bilibili.com/385802642" target="_blank" >
                <i class="icon icon-lg icon-youtube-play"></i>
                哔哩哔哩
              </a>
            </li>
        
            <li class="">
              <a href="/img/video-account.jpg" target="_blank" >
                <i class="icon icon-lg icon-video-camera"></i>
                视频号
              </a>
            </li>
        
            <li class="">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                友情链接
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>JAVA入门学习十</span>
            
        </div>

        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        

        
            <a href="/atom.xml" class="header-icon pull-right waves-effect waves-circle waves-light">
                <i class="icon icon-lg icon-rss"></i>
            </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg" alt="文章头部背景">
    <div class="container fade-scale">
        <h1 class="title">JAVA入门学习十</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-10-14T02:34:30.000Z" itemprop="datePublished" class="page-time">
  2019-10-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/">Development</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/Programming/">Programming</a></li></ul></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap" style="display: none;">
  <article id="post-编程世界/Java/JAVA入门学习十"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">JAVA入门学习十</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-10-14 10:34:30" datetime="2019-10-14T02:34:30.000Z"  itemprop="datePublished">2019-10-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/">Development</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Development/Programming/">Programming</a></li></ul></li></ul>



            

            


            
        </div>
        <span class="post-href" style="display: none;">|</span> 
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p>[TOC]</p>
<a id="more"></a>
<h4 id="多线程Thread入门"><a href="#多线程Thread入门" class="headerlink" title="多线程Thread入门"></a>多线程Thread入门</h4><h5 id="1-简单概述"><a href="#1-简单概述" class="headerlink" title="1.简单概述"></a>1.简单概述</h5><p>描述:<em>什么是线程？</em></p>
<ul>
<li>线程是程序执行的一条路径, 一个进程中可以包含多条线程</li>
<li>多线程并发执行可以提高程序的效率, 可以同时完成多项工作;(简单说利用了空闲时间)</li>
</ul>
<p>多线程的应用场景:</p>
<ul>
<li>迅雷开启多条线程一起下载</li>
<li>QQ同时和多个人一起视频</li>
<li>服务器同时处理多个客户端请求</li>
</ul>
<p><br></p>
<p><em>多线程并行和并发的区别？</em></p>
<ul>
<li>并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行(<code>需要多核CPU</code>)<ul>
<li>比如:我跟两个网友聊天，左手操作一个电脑跟甲聊同时右手用另一台电脑跟乙聊天这就叫并行。</li>
</ul>
</li>
<li>并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。<ul>
<li>比如:用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。</li>
</ul>
</li>
</ul>
<p><em>注意:</em> 一颗CPU在同一时刻只处理一个任务,只不过执行时间(<code>执行效率高</code>)太短让我们误认为是同一时刻运行多个后台程序;</p>
<p>Java程序运行原理:</p>
<ul>
<li>Java命令会启动java虚拟机,之后启动JVM等同于启动了一个应用程序，但实际上是<code>启动了一个进程</code>。</li>
<li>该进程会自动启动一个 “主线程” 然后主线程去<code>调用某个类的 main 方法</code>。</li>
</ul>
<p><br></p>
<p><em>JVM的启动是多线程的吗？</em></p>
<ul>
<li>JVM启动至少启动了<code>垃圾回收线程</code>和<code>主线程</code>所以是多线程的。</li>
</ul>
<p><br></p>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_Thread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//示例1.证明Java的JVM是多线程执行的</span></span><br><span class="line">    <span class="comment">//CPU在同一时刻只会运行一个任务,但是由于执行效率太高了会出现联系执行相同的任务;</span></span><br><span class="line">    <span class="comment">//线程就是一条路所有的任务将在上面执行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)</span><br><span class="line">      <span class="keyword">new</span> Demo();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">      System.out.println(<span class="string">"Master Thread 执行 "</span> + i);	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//Demo:进行垃圾回收</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.getClass() + <span class="string">"类垃圾回收!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行结果:</span></span><br><span class="line"><span class="comment"> * class com.weiyigeek.Thread.Demo类垃圾回收!</span></span><br><span class="line"><span class="comment">	class com.weiyigeek.Thread.Demo类垃圾回收!</span></span><br><span class="line"><span class="comment">	class com.weiyigeek.Thread.Demo类垃圾回收!</span></span><br><span class="line"><span class="comment">	Master Thread 执行 620</span></span><br><span class="line"><span class="comment">	class com.weiyigeek.Thread.Demo类垃圾回收!</span></span><br><span class="line"><span class="comment">	class com.weiyigeek.Thread.Demo类垃圾回收!</span></span><br><span class="line"><span class="comment">	Master Thread 执行 621</span></span><br><span class="line"><span class="comment">	Master Thread 执行 622</span></span><br><span class="line"><span class="comment"> ***/</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="2-多线程实现"><a href="#2-多线程实现" class="headerlink" title="2.多线程实现"></a>2.多线程实现</h5><p>描述:线程是程序中的执行线程,Java虚拟机允许应用程序并发的运行多个执行线程;</p>
<ul>
<li>每一个线程都有一个优先级，高优先级线程的执行优于低优先级进程;</li>
<li>每一个线程可能会或可能不会被标记为一个守护进程。</li>
<li>在某个线程中运行的代码创建了一个新的Thread对象时，新线程的优先级被设置为创建线程的优先级，当且仅当创建线程是一个守护进程，新线程才是守护线程的。</li>
</ul>
<p>基础语法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread类</span></span><br><span class="line">java.lang.Object </span><br><span class="line">java.lang.Thread </span><br><span class="line">All Implemented Interfaces: Runnable </span><br><span class="line"></span><br><span class="line"><span class="comment">//类声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//构造方法</span></span><br><span class="line"><span class="class"><span class="title">Thread</span>(<span class="title">Runnable</span> <span class="title">target</span>)  //分配一个新的 <span class="title">Thread</span>对象。  </span></span><br><span class="line"><span class="class"><span class="title">Thread</span>(<span class="title">String</span> <span class="title">name</span>)  //分配一个新的 <span class="title">Thread</span>对象。（参数是一个线程的名称）</span></span><br><span class="line"><span class="class"><span class="title">Thread</span>(<span class="title">Runnable</span> <span class="title">target</span>, <span class="title">String</span> <span class="title">name</span>) //分配一个新的 <span class="title">Thread</span>对象。 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//类方法</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">start</span>() //导致该线程开始执行 <span class="title">java</span>虚拟机自动调用这个线程的<span class="title">run</span>方法。</span></span><br><span class="line"><span class="class"><span class="title">String</span> <span class="title">getName</span>()  //返回此线程的名称。  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">setName</span>(<span class="title">String</span> <span class="title">name</span>) //改变该线程的名称等于参数 <span class="title">name</span>。</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">Thread</span> <span class="title">currentThread</span>()  //返回当前正在执行的线程对象的引用。(可以直接类.调用)</span></span><br></pre></td></tr></table></figure><br><br></p>
<p><em>多线程实现的两种方式:</em></p>
<ul>
<li>继承Thread类重写run方法</li>
<li>实现Runable接口重写run方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个功能接口因此可以作为赋值的目标一个lambda表达式或方法参考</span></span><br><span class="line"><span class="comment">//例如，Runnable通过类Thread实施。激活的意思是说一个线程已启动并且尚未停止。</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> //一个类实现<span class="title">Runnable</span>可以运行<span class="title">run</span>方法，通过自身实例化一个对象并且传入<span class="title">Thread</span>实例作为目标参数</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个方法(需要重写)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  <span class="comment">//当一个对象实现的接口 Runnable是用来创建一个线程，启动线程使对象的 run方法在单独执行的线程调用。</span></span></span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<p><em>实现Runnable的原理:</em></p>
<ul>
<li>1,看Thread类的构造函数：传递了Runnable接口的引用 </li>
<li>2,通过init()方法：找到传递的target给成员变量的target赋值</li>
<li>3,查看run方法：发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法</li>
</ul>
<p>实际案例1:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_ThreadClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//示例1.多线程程序实现的方式1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		* 1)定义新类继承Thread类</span></span><br><span class="line"><span class="comment">		* 2)重写run方法</span></span><br><span class="line"><span class="comment">		* 3)把新线程要做的事写在run方法中</span></span><br><span class="line"><span class="comment">		* 4)创建线程对象</span></span><br><span class="line"><span class="comment">		* 5)开启start()新线程内部会自动执行run方法</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    NewThread mt = <span class="keyword">new</span> NewThread();</span><br><span class="line">    mt.start();  <span class="comment">//调用start方法开启多线程;</span></span><br><span class="line">    <span class="comment">//比对多线程执行，我们在主线程里面写入一个循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">      System.out.println(<span class="keyword">new</span> Thread().getName() + <span class="string">" - MasterThread"</span>);  <span class="comment">//可以直接获取线程的名称</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//示例2.多线程程序实现的方式2:实现Runnable接口</span></span><br><span class="line">    <span class="comment">/* 1)定义类实现Runnable接口</span></span><br><span class="line"><span class="comment">		* 2)实现run方法</span></span><br><span class="line"><span class="comment">		* 3)把新线程要做的事写在run方法中</span></span><br><span class="line"><span class="comment">		* 4)创建自定义的Runnable的子类对象</span></span><br><span class="line"><span class="comment">		* 5)创建Thread对象, 传入Runnable对象</span></span><br><span class="line"><span class="comment">		* 6)调用start()开启新线程, 内部会自动调用Runnable的run()方法</span></span><br><span class="line"><span class="comment">		* */</span></span><br><span class="line">    NewRunnable nr = <span class="keyword">new</span> NewRunnable(); <span class="comment">//创建自定义类对象</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(nr); <span class="comment">//注意这里传入Thread的子类Runnable对象（将其当作参数传递给Thread的构造函数）</span></span><br><span class="line">    t.start();  <span class="comment">//自动调用方法中的run方法 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">      System.out.println(<span class="keyword">new</span> Thread().getName() + <span class="string">" - MasterThread-NewRunnable"</span>);  <span class="comment">//可以直接获取线程的名称</span></span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (1)继承Thread类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="comment">//2.重写Run方法：将要执行的代码放入run方法之中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" - "</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)实现Runnable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//实现接口中方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">      System.out.println(i + <span class="string">"-"</span> + <span class="keyword">this</span>.getClass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  #示例1执行结果(节选了比较匀称的地方)</span></span><br><span class="line"><span class="comment"> *  Thread-0 - class com.weiyigeek.Thread.NewThread</span></span><br><span class="line"><span class="comment">	Thread-232 - MasterThread</span></span><br><span class="line"><span class="comment">	Thread-0 - class com.weiyigeek.Thread.NewThread</span></span><br><span class="line"><span class="comment">	Thread-233 - MasterThread</span></span><br><span class="line"><span class="comment">	Thread-0 - class com.weiyigeek.Thread.NewThread</span></span><br><span class="line"><span class="comment">	Thread-234 - MasterThread</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	#示例2执行结果(节选了比较匀称的地方)</span></span><br><span class="line"><span class="comment">	833-class com.weiyigeek.Thread.NewRunnable</span></span><br><span class="line"><span class="comment">	Thread-1524 - MasterThread-NewRunnable</span></span><br><span class="line"><span class="comment">	.....................</span></span><br><span class="line"><span class="comment">	Thread-1968 - MasterThread-NewRunnable</span></span><br><span class="line"><span class="comment">	834-class com.weiyigeek.Thread.NewRunnable</span></span><br><span class="line"><span class="comment"> ***/</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><em>两种实现方式的区别总结:</em><br>1.查看源码的区别:</p>
<ul>
<li>a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法</li>
<li>b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法</li>
</ul>
<p>2.两种实现方式优缺点:</p>
<ul>
<li>继承Thread<ul>
<li>好处是:可以直接使用Thread类中的方法,代码简单</li>
<li>弊端是:如果已经有了父类,就不能用这种方法(由于JAVA是单继承的特性)</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的(扩展性比较好)</li>
<li>弊端是:不能直接使用Thread中的方法需要先获取到Thread类线程对象后,才能得到Thread的方法代码复杂</li>
</ul>
</li>
</ul>
<p>3.在实际开发中根据业务需求来定,一般先用基础的Thread类如果满足不了就采用Runnable接口;</p>
<p><br></p>
<h5 id="3-线程匿名内部类"><a href="#3-线程匿名内部类" class="headerlink" title="3.线程匿名内部类"></a>3.线程匿名内部类</h5><p>描述:匿名内部类实现线程的两种方式更能方便的实现线程执行程序代码并且更加的简介，它也有两种方法</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ul>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_AnonmouseThread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.采用匿名内部类直接实现，精简代码但是流程是与实现线程的两种方式大致相同;、</span></span><br><span class="line">    <span class="comment">//方法1：new 类()&#123;&#125;继承这个类</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123; <span class="comment">//将要执行的代码,写在run方法中</span></span><br><span class="line">          System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" - Thread Anonymous Inner Class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start(); <span class="comment">//注意调用start()方法开启线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法2：将Runable的子类对象传递给Thread的构造方法（值得注意）</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">          System.out.println(<span class="keyword">new</span> Thread().getName() + <span class="string">" - Runnable Anonymous Inner Class"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start(); <span class="comment">//同样是开启线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> - Thread Anonymous Inner Class</span><br><span class="line">Thread-<span class="number">2</span> - Runnable Anonymous Inner Class</span><br><span class="line">.....</span><br><span class="line">Thread-<span class="number">1001</span> - Runnable Anonymous Inner Class</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="4-线程类常用方法"><a href="#4-线程类常用方法" class="headerlink" title="4.线程类常用方法"></a>4.线程类常用方法</h5><p>1.获取线程名字:<code>通过getName()方法</code>获取线程对象的名字，我们前面的代码有所接触<br>2.设置线程名字:<code>通过构造函数</code>可以传入String类型的名字，还可以通过<code>setName(String)方法</code>可以设置线程对象的名字<br>3.获取当前线程:当前 <code>currentThread()</code>主线程对象也可以获取,可以使用在Runable接口之中获取当前线程对象就能利用线程的方法了;</p>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4_ThreadMethod</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//示例1.线程的常用的方法(设置与获取名字)</span></span><br><span class="line">    demo1();</span><br><span class="line">    <span class="comment">//实例2.获取当前正在执行线程对象(可以使用在Runable接口之中获取当前线程对象就能利用线程的方法了)</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();<span class="comment">////获取主函数线程的引用,runnable子类接口便可以直接使用Thread类中的方法</span></span><br><span class="line">        t.setName(<span class="string">"Slave-01"</span>);  <span class="comment">//直接给当前线程对象进行设置线程名称</span></span><br><span class="line">        System.out.println(t.getName() + <span class="string">"#Runnable接口实现并获取当前线程对象-并调用其Thread类中方法"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start(); <span class="comment">//必须开启线程 (重要 重要 Important!)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方式1.通过构造方法进行线程名称赋值</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Master"</span>) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="keyword">this</span>.getName() + <span class="string">"#线程执行的代码块!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式2.通过this.setName进行设置线程名称</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">"Master-01"</span>);</span><br><span class="line">        System.out.println( <span class="keyword">this</span>.getName() + <span class="string">"#线程执行的代码块!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//方式3:通过Thread类的setName方法进行设置线程名称</span></span><br><span class="line">    Thread th = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="keyword">this</span>.getName() + <span class="string">"#线程执行的代码块!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    th.setName(<span class="string">"Slave"</span>);</span><br><span class="line">    th.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Master-01#线程执行的代码块!</span><br><span class="line">Slave#线程执行的代码块!</span><br><span class="line">Master#线程执行的代码块!</span><br><span class="line">Slave-01#Runnable接口实现并获取当前线程对象-并调用其Thread类中方法</span><br></pre></td></tr></table></figure><br><br></p>
<h5 id="5-线程休眠与守护"><a href="#5-线程休眠与守护" class="headerlink" title="5.线程休眠与守护"></a>5.线程休眠与守护</h5><p>描述:在windows上一般采用毫秒级别(不支持纳秒值),但是Linux系统比起Windows更加合适处理纳秒级别的休眠sleep;<br>线程也需要等待和唤醒线程采用正常继续工作;</p>
<p>基础方法:</p>
<ul>
<li>Thread.sleep(毫秒,纳秒) 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 <em> 1000 </em> 1000纳秒 = 1000000000</li>
<li>Thread setDaemon(true) 设置一个线程为守护线程,<code>该线程不会单独执行当其他非守护线程都执行结束后,自动退出</code>,注意他会存在时间缓冲当非守护进程执行完毕后线程守护进程不会立即结束(比如QQ:聊天界面传文件)</li>
</ul>
<p>基础实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5_SleepThread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例1.休眠线程 Thread.sleep(毫秒,纳秒)</span></span><br><span class="line">    <span class="comment">// (1)这里主要以main主线程进行测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>); <span class="comment">//线程休眠中断1s,由于是暂停需要加入一个中断异常处理</span></span><br><span class="line">      System.out.println(<span class="string">"倒计时"</span>+i+<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (2)采用Thread创建两个线程进行体现进程休眠</span></span><br><span class="line">    demo1();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例1：构建方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//这里不是抛异常，由于父类在写run方法的时候没有抛异常，所有子类重写也不能抛(自能自己进行处理try...catch)</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125; </span><br><span class="line">          System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" - "</span> + i);  <span class="comment">//输出线程名称查看执行效果</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span> ) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" - "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//基础示例2</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"Master"</span>) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>;i++)  <span class="comment">//这里将非守护线程故意设置成为2次</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(getName() + <span class="string">" - "</span> + i); <span class="comment">//注意这里由于采用了匿名内部类的方法可以直接调用Thread中的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设是作为守护线程查看效果;</span></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="string">"SetDeamon"</span>) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(getName() + <span class="string">" - "</span> + i); <span class="comment">//注意这里由于采用了匿名内部类的方法可以直接调用Thread中的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    t2.setDaemon(<span class="keyword">true</span>); <span class="comment">//将t1设置为守护线程(当Master线程执行两次结束后setDeamon线程也跟着结束)</span></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例1</span></span><br><span class="line">倒计时2s</span><br><span class="line">倒计时1s</span><br><span class="line">Thread1 - 0</span><br><span class="line">Thread2 - 0</span><br><span class="line">Thread1 - 1</span><br><span class="line">Thread2 - 1</span><br><span class="line">Thread1 - 2</span><br><span class="line">Thread2 - 2</span><br><span class="line">Thread1 - 3</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2</span></span><br><span class="line">Master - 0</span><br><span class="line">SetDeamon - 0</span><br><span class="line">Master - 1</span><br><span class="line">SetDeamon - 1</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="6-线程添加与优先级"><a href="#6-线程添加与优先级" class="headerlink" title="6.线程添加与优先级"></a>6.线程添加与优先级</h5><p>描述:添加线程给当前执行任务的CPU进行插队执行,我们也可以让程序让出CPU给其他线程执行;<br>还可以设置线程的优先级使其优先执行;</p>
<p>基础方法：</p>
<ul>
<li>join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续</li>
<li>join(int), 可以等待指定的毫秒之后继续</li>
<li>Thread.yield() 给调度程序的一个提示，当前线程愿意得到它当前的处理器的使用,调度程序可以自由地忽略这个提示。 </li>
</ul>
<ul>
<li>setPriority()设置线程的优先级范围(1~10)默认值是5,优先执行的线程;</li>
</ul>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7_JointThread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//示例1.线程加入</span></span><br><span class="line">    demo1();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//示例2.yield让出cpu礼让线程</span></span><br><span class="line">    MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"MasterYield"</span>);</span><br><span class="line">    MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"SlaveYield"</span>);</span><br><span class="line">    <span class="comment">// mt1.start();</span></span><br><span class="line">    <span class="comment">// mt2.start();</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread th1 = <span class="keyword">new</span> Thread(<span class="string">"Slave-Join"</span>) &#123; <span class="comment">//由于需要被匿名内部类调用所以这里采用final进行修饰</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(getName() + <span class="string">" - "</span> + i);  <span class="comment">//需要加入的线程执行输出的语句</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread th2 = <span class="keyword">new</span> Thread(<span class="string">"Master"</span>) &#123; </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//th1.join();						   //插队,加入(执行完成后才执行Master线程)</span></span><br><span class="line">            th1.join(<span class="number">30</span>);						<span class="comment">//加入,有固定的时间过了固定时间继续交替执行</span></span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(getName() + <span class="string">" - "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//示例3.优先级设置(注意是在start()方法前进行设置)</span></span><br><span class="line">    th1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">    th2.setPriority(Thread.MAX_PRIORITY); <span class="comment">//优先执行Master线程</span></span><br><span class="line">    th1.start();</span><br><span class="line">    th2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)  <span class="comment">//当可以整除2时候进行让出CPU让其他线程执行</span></span><br><span class="line">      &#123;</span><br><span class="line">        Thread.yield(); <span class="comment">//让出CPU这里就不采用Thread.sleep() 方式</span></span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(getName() + <span class="string">" - "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*示例1(按照加入的线程时间进行执行)</span></span><br><span class="line"><span class="comment">Slave-Join - 0</span></span><br><span class="line"><span class="comment">Slave-Join - 1</span></span><br><span class="line"><span class="comment">Master - 0  (由于加了setPriority优先执行，但其中又加入其他线程则也同时执行)</span></span><br><span class="line"><span class="comment">Slave-Join - 2</span></span><br><span class="line"><span class="comment">Slave-Join - 3</span></span><br><span class="line"><span class="comment">Master - 1</span></span><br><span class="line"><span class="comment">Slave-Join - 4</span></span><br><span class="line"><span class="comment">Slave-Join - 5</span></span><br><span class="line"><span class="comment">Slave-Join - 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*示例2(实际上yield效果还是比较明显的)</span></span><br><span class="line"><span class="comment">SlaveYield - 0</span></span><br><span class="line"><span class="comment">MasterYield - 0</span></span><br><span class="line"><span class="comment">SlaveYield - 1</span></span><br><span class="line"><span class="comment">MasterYield - 1</span></span><br><span class="line"><span class="comment">SlaveYield - 2</span></span><br><span class="line"><span class="comment">MasterYield - 2</span></span><br><span class="line"><span class="comment">SlaveYield - 3</span></span><br><span class="line"><span class="comment">MasterYield - 3</span></span><br><span class="line"><span class="comment">SlaveYield - 4</span></span><br><span class="line"><span class="comment">SlaveYield - 5</span></span><br><span class="line"><span class="comment">MasterYield - 4</span></span><br><span class="line"><span class="comment">MasterYield - 5</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><em>注意事项:</em></p>
<ul>
<li>匿名内部类使用局部变量的时候必须采用final进行修饰的变量才可调用;</li>
<li>CPU在随机的切换正在执行的线程如果要让出线程执行时间需要采用yield()方法,但是实际上达不到效果只是理论上可以;</li>
</ul>
<p><br></p>
<h5 id="7-线程同步锁对象"><a href="#7-线程同步锁对象" class="headerlink" title="7.线程同步锁对象"></a>7.线程同步锁对象</h5><p>描述:<em>什么情况下需要同步?</em></p>
<ul>
<li>当多线程并发有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作这时就需要同步机制.</li>
<li>如果两段代码是同步的<code>那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码</code>.</li>
</ul>
<p>实现同步互斥的机制方式:</p>
<ul>
<li>同步代码块:使用synchronized关键字加上一个锁对象来定义一段代码这就叫同步代码块,多个同步代码块如果使用相同的锁对象那么他们就是同步的;</li>
<li>同步方法:使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的</li>
</ul>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8_Synchronized</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例1.同步代码块与同步方法</span></span><br><span class="line">    <span class="keyword">final</span> Printer pp = <span class="keyword">new</span> Printer();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Sync-0"</span>) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          <span class="comment">//pp.p1();</span></span><br><span class="line">          <span class="comment">//pp.p3();</span></span><br><span class="line">          pp.p4();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Sync-1"</span>) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          <span class="comment">//pp.p2();</span></span><br><span class="line">          <span class="comment">//pp.p31();</span></span><br><span class="line">          pp.p41();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">  Syn d = <span class="keyword">new</span> Syn();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//(1)锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,并且不能用匿名对象</span></span><br><span class="line">    <span class="comment">//注意不能采用匿名内部类synchronized(new)</span></span><br><span class="line">    <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">      System.out.print(<span class="string">"P1"</span>);</span><br><span class="line">      System.out.print(<span class="string">"Method"</span>);</span><br><span class="line">      System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">      System.out.print(<span class="string">"P2"</span>);</span><br><span class="line">      System.out.print(<span class="string">"Method"</span>);</span><br><span class="line">      System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//(2)同步放只需要在方法上加synchrnized关键字即可</span></span><br><span class="line">  <span class="comment">//非静态同步函数的锁是:this	</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">p3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"W"</span>);</span><br><span class="line">    System.out.print(<span class="string">"e"</span>);</span><br><span class="line">    System.out.print(<span class="string">"i"</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p31</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;  <span class="comment">//this 这里与出现p3()表示同一把锁所以不出现乱序;</span></span><br><span class="line">      System.out.print(<span class="string">"G"</span>);</span><br><span class="line">      System.out.print(<span class="string">"e"</span>);</span><br><span class="line">      System.out.print(<span class="string">"e"</span>);</span><br><span class="line">      System.out.print(<span class="string">"k"</span>);</span><br><span class="line">      System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//(3)静态的同步函数的锁是:字节码对象(本类) - 注意静态方法优先于对象存在;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">p4</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">    System.out.print(<span class="string">"W"</span>);</span><br><span class="line">    System.out.print(<span class="string">"e"</span>);</span><br><span class="line">    System.out.print(<span class="string">"i"</span>);</span><br><span class="line">    System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">p41</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Printer.class) &#123;  <span class="comment">//参数是该类的字节码，与p4()表示同一把锁</span></span><br><span class="line">    System.out.print(<span class="string">"G"</span>);</span><br><span class="line">    System.out.print(<span class="string">"e"</span>);</span><br><span class="line">    System.out.print(<span class="string">"e"</span>);</span><br><span class="line">    System.out.print(<span class="string">"k"</span>);</span><br><span class="line">    System.out.print(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建立一个类构建同步锁（空类即可）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Syn</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">#1.未加入同步锁的情况下</span></span><br><span class="line"><span class="comment">P1Method</span></span><br><span class="line"><span class="comment">P1MethodP2Method</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">P2Method</span></span><br><span class="line"><span class="comment">#2.加入synchronized()关键字便不会出现这样的问题</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">3.同步方法(静态与非静态)</span></span><br><span class="line"><span class="comment">Geek</span></span><br><span class="line"><span class="comment">Geek</span></span><br><span class="line"><span class="comment">Geek</span></span><br><span class="line"><span class="comment">Geek</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></p>
<p><em>注意事项:</em></p>
<ul>
<li>同步锁对象不能采用匿名对象，因为匿名对象不是同一个对象;</li>
<li>非静态的同步方法的锁对象是什么? 答:非静态同步函数的锁是this</li>
<li>静态的同步方法的锁对象是什么? 答:静态的同步函数的锁是字节码对象,原因由于静态方法优先于对象存在；</li>
</ul>
<p><br></p>
<h5 id="8-线程安全"><a href="#8-线程安全" class="headerlink" title="8.线程安全"></a>8.线程安全</h5><p>描述:多线程并发操作同一数据时, 就有可能出现线程安全问题,所以使用同步技术可以解决这种问题, <code>把操作数据的代码进行同步</code>, 不要多个线程一起操作;<br>如果需要所有的对象的都共享一个数据，让一个类中变量编程一个<code>静态变量</code>;否则每个线程对象都将执行run中代码并且类中变量是独立且不影响得;</p>
<p>死锁:多线程同步的时候, 如果<code>同步代码嵌套使用相同锁就有可能出现死锁</code>,所以尽量不要嵌套使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一定不要出现同步代码块 嵌套</span></span><br><span class="line"><span class="function"><span class="title">synchronized</span></span>()&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">synchronized</span></span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo9_SyncTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//示例1.利用Thread实现火车站购票(一共30张，4个窗口同时卖)四条线程;</span></span><br><span class="line"><span class="comment">//		new Tickets().start(); //注意每一个对象都有自己的成员变量，我们可以采用static来共享成员变量并且利用同步锁对象来进防止线程错误发生</span></span><br><span class="line"><span class="comment">//		new Tickets().start();</span></span><br><span class="line"><span class="comment">//		new Tickets().start();</span></span><br><span class="line"><span class="comment">//		new Tickets().start();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//示例2.只创建了一次对象所以run中采用synchronized同步锁并且传入this指向我们的那一个Thread对象</span></span><br><span class="line">    NewTickets nr = <span class="keyword">new</span> NewTickets(); </span><br><span class="line">    <span class="keyword">new</span> Thread(nr).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(nr).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(nr).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(nr).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//车站售卖票类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tickets</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">30</span>; <span class="comment">//让四个售卖员一起买这三十张票,为了让线程操作同一个数据不发生错误采用同步代码块</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object(); <span class="comment">//创建一个静态的Obj对象可作为同步锁;(如果用引用数据类型成员变量当做锁对象则必须是静态的)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//当票没有买完一直进行售票状态</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//同步锁(为了共同操作30同一个synchronized(obj),不过建议采用下面的方式</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Tickets.class) &#123;</span><br><span class="line">          <span class="keyword">if</span>(ticket &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);  <span class="comment">//线程1睡,线程2睡,线程3睡,线程4睡(随机唤醒线程)</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println( getName()+ <span class="string">" | 卖出第"</span>  + ticket-- + <span class="string">"张票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用runnable接口实现售卖车票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTickets</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">30</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object(); <span class="comment">//锁对象:非常注意是静态的哟!</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//同步锁，防止线程操作同一个变量时候出错; 锁对象也可以是NewTickets.class</span></span><br><span class="line">      <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意这里是Thread子类接口实现不能直接调用其内部方法，需要先获取当前执行线程.Thread类方法</span></span><br><span class="line">        System.out.println( Thread.currentThread().getName()+ <span class="string">" | 卖出第"</span>  + ticket-- + <span class="string">"张票"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Thread-0 | 卖出第30张票</span></span><br><span class="line"><span class="comment"># Thread-0 | 卖出第29张票</span></span><br><span class="line"><span class="comment"># Thread-0 | 卖出第28张票</span></span><br><span class="line"><span class="comment"># Thread-0 | 卖出第27张票</span></span><br><span class="line"><span class="comment"># Thread-0 | 卖出第26张票</span></span><br><span class="line"><span class="comment"># Thread-0 | 卖出第25张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第24张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第23张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第22张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第21张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第20张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第19张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第18张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第17张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第16张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第15张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第14张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第13张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第12张票</span></span><br><span class="line"><span class="comment"># Thread-3 | 卖出第11张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第10张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第9张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第8张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第7张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第6张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第5张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第4张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第3张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第2张票</span></span><br><span class="line"><span class="comment"># Thread-1 | 卖出第1张票</span></span><br></pre></td></tr></table></figure></p>
<p>示例2：死锁代码（哲学家就餐问题-在操作系统同步互斥中学习过）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s1 = <span class="string">"筷子左"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s2 = <span class="string">"筷子右"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"...拿到"</span> + s1 + <span class="string">"等待"</span> + s2);</span><br><span class="line">        <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">          System.out.println(getName() + <span class="string">"...拿到"</span> + s2 + <span class="string">"开吃"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;.start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(s2) &#123;</span><br><span class="line">      System.out.println(getName() + <span class="string">"...拿到"</span> + s2 + <span class="string">"等待"</span> + s1);</span><br><span class="line">      <span class="keyword">synchronized</span>(s1) &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"...拿到"</span> + s1 + <span class="string">"开吃"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>学习多线程以前的线程安全的类问题，如何判断线程是安全的?<br>答:通过ctrl+shift+t进行查找下面类是否使用了同步锁sychronized来修饰方法即（后面ctrl+o搜索具体的方法）看源码<code>Vector,StringBuffer,Hashtable,</code>，可判断线程是不是安全的;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>学习总结:</strong></p>
<ul>
<li>Vector是线程安全的,ArrayList是线程不安全的</li>
<li>StringBuffer是线程安全的,StringBuilder是线程不安全的</li>
<li>Hashtable是线程安全的,HashMap是线程不安全的</li>
<li>Collections.synchroinzed(xxx) 支持线程不安全的列表集合变成线程安全的;<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span>  <span class="comment">//返回由指定集合支持的同步（线程安全）集合。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span>  <span class="comment">//返回由指定列表支持的同步（线程安全）列表。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> <span class="comment">//返回由指定的Map支持的同步（线程安全）Map。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; NavigableMap&lt;K,V&gt; <span class="title">synchronizedNavigableMap</span><span class="params">(NavigableMap&lt;K,V&gt; m)</span> <span class="comment">//返回指定的导航Map支持的同步（线程安全）导航Map。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; NavigableSet&lt;T&gt; <span class="title">synchronizedNavigableSet</span><span class="params">(NavigableSet&lt;T&gt; s)</span> <span class="comment">//返回由指定的导航集支持的同步（线程安全）导航集。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span> <span class="comment">//返回一个由指定集合支持的同步（线程安全）集。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap&lt;K,V&gt; m)</span> <span class="comment">//返回一个由指定的排序映射支持的同步（线程安全）排序的Map。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span> <span class="comment">//返回一个由指定的排序集支持的同步（线程安全）排序集。</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>

<h4 id="多线程进阶"><a href="#多线程进阶" class="headerlink" title="多线程进阶"></a>多线程进阶</h4><h5 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h5><p>单例设计模式思想:保证类在内存中只有一个对象，方便让大家指向同一个对象。</p>
<p><em>如何保证类在内存中只有一个对象呢？</em></p>
<ul>
<li>(1)控制类的创建,不让其他类来创建本类的对象:private构造方法;</li>
<li>(2)在本类中定义一个本类的对象：Singleton s;</li>
<li>(3)提供公共的访问方式本类对象： public static Singleton getInstance(){return s};</li>
<li>(4)单例写法有三种，在基础示例中进行体现;</li>
</ul>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11_Singleton</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现单例设计模式的几种方法</span></span><br><span class="line">    <span class="comment">// 1.饿汉式</span></span><br><span class="line">    Singleton s1 = Singleton.getInstance(); </span><br><span class="line">    Singleton s2 = Singleton.getInstance();</span><br><span class="line">    <span class="keyword">if</span>(s1 == s2) &#123;</span><br><span class="line">      s1.print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.懒汉式</span></span><br><span class="line">    Singleton1 sl1 = Singleton1.getInstance(); </span><br><span class="line">    Singleton1 sl2 = Singleton1.getInstance();</span><br><span class="line">    <span class="keyword">if</span>(sl1 == sl2) &#123;</span><br><span class="line">      sl1.print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.无名式</span></span><br><span class="line">    Singleton2 slt1 = Singleton2.s;</span><br><span class="line">    Singleton2 slt2 = Singleton2.s;</span><br><span class="line">    System.out.println(slt1 == slt2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1:饿汉式开发建议使用这种方式。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1,私有构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="comment">//2,创建本类对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法1"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2:懒汉式面试时候建议使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1,私有构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">//2,创建本类对象（但不对其进行赋值）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 s;</span><br><span class="line">  <span class="comment">//3,对外提供公共的访问方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">//线程1,线程2（多线程的时候会导致安全问题，所以面试的时候不建议使用）</span></span><br><span class="line">      s = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方式2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3：暂无名称</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">  <span class="comment">//第一步.都是构造私有函数</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">//第二步.集其精华之所在</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 s = <span class="keyword">new</span> Singleton2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><br><br></p>
<p><strong>Runtime类</strong><br>描述:Runtime类是一个单例类并且允许应用程序与环境中运行应用程序接口的一个实例，以后在写命令执行的shell的时候非常有用;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">java.lang.Runtime </span><br><span class="line"></span><br><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//类方法</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">Runtime</span> <span class="title">getRuntime</span>()  //返回与当前应用程序相关的<span class="title">java</span>运行时对象。 </span></span><br><span class="line"><span class="class"><span class="title">Process</span> <span class="title">exec</span>(<span class="title">String</span> <span class="title">command</span>) //在一个单独的进程中执行指定的字符串命令。</span></span><br></pre></td></tr></table></figure>
<p>基础示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10_Runtime</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</span><br><span class="line">    <span class="comment">//单线程类学习 Runtime</span></span><br><span class="line">    Runtime r = Runtime.getRuntime(); <span class="comment">//注意由于Runtime类是单实例的所以用其静态公共的方法获取Runtime内部实例化对象</span></span><br><span class="line">    <span class="comment">//演示操作同一个对象：命令执行关机命令和取消关机</span></span><br><span class="line">    System.out.println(<span class="string">"正在执行关机命令!"</span>);</span><br><span class="line">    r.exec(<span class="string">"shutdown -s -t 300"</span>);  <span class="comment">//300s 关机</span></span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);  <span class="comment">//主线程 休眠 5s</span></span><br><span class="line">    r.exec(<span class="string">"shutdown -a"</span>);</span><br><span class="line">    System.out.println(<span class="string">"已经取消关机!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正在执行关机命令!</span><br><span class="line">已经取消关机!</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><em>注意事项</em>:<br><strong>1.饿汉式与懒汉式之间的区别:</strong></p>
<ul>
<li>饿汉式:不管怎么样运行时候先建立一个对象,在实际开发中使用因为在多线程编程中它不会创建多个对象，它以空间换取时间;</li>
<li>懒汉式:在调用静态方法的时候需要进行判断然后创建对象,但是在开发中不建议使用,因为在多线程开发时候会出现问题导致创建多个对象,它以时间换空间;</li>
</ul>
<p><br></p>
<h5 id="Timer定时器"><a href="#Timer定时器" class="headerlink" title="Timer定时器"></a>Timer定时器</h5><p>描述:简单的说定时器就是指定时间执行指定的某一任务;任务可能被安排指定时间为一次性执行，或定期重复执行。 </p>
<p>语法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">java.util.Timer </span><br><span class="line"></span><br><span class="line"><span class="comment">//类声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//类方法</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">cancel</span>() //终止此计时器，丢弃任何当前计划的任务。  </span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">purge</span>() //从这个计时器的任务队列中移除所有已取消的任务。  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">schedule</span>(<span class="title">TimerTask</span> <span class="title">task</span>, <span class="title">Date</span> <span class="title">time</span>) //在指定的时间计划执行指定的任务。  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">schedule</span>(<span class="title">TimerTask</span> <span class="title">task</span>, <span class="title">Date</span> <span class="title">firstTime</span>, <span class="title">long</span> <span class="title">period</span>) //计划重复固定延迟执行指定的任务，开始在指定的时间。  </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//由它的子类实现由定时器一次性或重复执行的任务。 (具体的要执行的任务-它是抽象类)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">TimerTask</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo_TimerTask</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//定时器timer的实现演示</span></span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(); <span class="comment">//定时器对象</span></span><br><span class="line">    t.schedule(<span class="keyword">new</span> NewTask(), <span class="keyword">new</span> Date(<span class="number">2019</span>-<span class="number">1900</span>,<span class="number">9</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">21</span>,<span class="number">30</span>),<span class="number">3000</span>); <span class="comment">//定时器任务 参数一传入TimerTask对象 3s重复一次</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);  <span class="comment">//f2-添加一次中断</span></span><br><span class="line">      System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建立一个类继承timer的子类来自定要指定的任务(实际上继承了Runnable实现多线程)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"正在执行任务!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sat Oct <span class="number">19</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">29</span> CST <span class="number">2019</span></span><br><span class="line">正在执行任务!</span><br><span class="line">Sat Oct <span class="number">19</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">30</span> CST <span class="number">2019</span></span><br><span class="line">Sat Oct <span class="number">19</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">Sat Oct <span class="number">19</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">32</span> CST <span class="number">2019</span></span><br><span class="line">正在执行任务!</span><br><span class="line">Sat Oct <span class="number">19</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">33</span> CST <span class="number">2019</span></span><br><span class="line">Sat Oct <span class="number">19</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">34</span> CST <span class="number">2019</span></span><br><span class="line">Sat Oct <span class="number">19</span> <span class="number">11</span>:<span class="number">21</span>:<span class="number">35</span> CST <span class="number">2019</span></span><br><span class="line">正在执行任务!</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h5><p><em>1.什么时候需要通信？</em></p>
<ul>
<li>多个线程并发执行时, 在默认情况下CPU是随机切换线程的</li>
<li>如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印</li>
</ul>
<p><em>2.怎么通信？</em></p>
<ul>
<li>如果希望线程等待, 就调用wait()</li>
<li>如果希望唤醒等待的线程, 就调用notify();</li>
<li>这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用</li>
</ul>
<p>语法方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类:Object类是类层次结构的根。每个类都有 Object作为超类。所有对象包括数组实现这个类的方法。 </span></span><br><span class="line">java.lang.object</span><br><span class="line"></span><br><span class="line"><span class="comment">//类中的方法</span></span><br><span class="line"><span class="comment">//等待:</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span>  <span class="comment">///使当前线程等待另一个线程调用此对象的方法或 notify() notifyAll()方法。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="comment">//使当前线程等待另一个线程调用此对象的方法或 notify() notifyAll()方法，或一个指定的时间流逝。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span>  <span class="comment">//使当前线程等待另一个线程调用此对象的方法或 notify() notifyAll()方法，或者其他某个线程中断当前线程，或一定量的实际时间已经过去了。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//唤醒</span></span></span><br><span class="line"><span class="function"><span class="title">nofify</span><span class="params">()</span></span>; 方法是随机唤醒一个线程</span><br><span class="line">notifyAll()方法是唤醒所有线程</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>多个线程通信的问题(三个或三个以上间的线程通信):</p>
<ul>
<li>JDK5之前无法唤醒指定的一个线程（而是随机唤醒）：多个线程之间通信,需要使用notifyAll()通知所有线程,用while来反复判断条件;<ul>
<li>简单的说假如有三个保安,第一个保安夜班结束了但它不知道剩下的两个保安谁值班,他就将两个保安都唤醒,其中一个保安说今天该我上班，而剩下的那个还是继续回到床上睡觉; (所以对线程程序来说他不知道谁满足条件她就把所有的线程都唤醒)</li>
</ul>
</li>
<li>在JDK1.5之后有更改的解决方案互斥锁(后面描述)</li>
</ul>
<p><br></p>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12_Waitnotify</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//JDK5之前无法唤醒指定的一个线程（而是随机唤醒）,多个线程之间通信需要使用notifyAll()通知所有线程,用while来反复判断条件;</span></span><br><span class="line">    <span class="comment">//三个线程通信实例:</span></span><br><span class="line">    <span class="keyword">final</span> Waitnofity wn = <span class="keyword">new</span> Waitnofity(); <span class="comment">//注意必须采用final修饰才能在匿名内部类中使用</span></span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类中的子类自能自己处理异常</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            wn.print1();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类中的子类自能自己处理异常</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            wn.print2();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程3</span></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="comment">//匿名内部类中的子类自能自己处理异常</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            wn.print3();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个类3个方法一个属性;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waitnofity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//同步锁对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span>(flag != <span class="number">1</span>)&#123; <span class="comment">//线程1在次等待,while()循环是循环判断每次都会判断标记</span></span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(Thread.currentThread().getName() + <span class="string">" - Print1()"</span>);</span><br><span class="line">      System.out.println(<span class="string">" "</span>);</span><br><span class="line">      flag=<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒所有的线程(但还是随机选项线程，当满足条件就行执行)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//如果采用if它会在哪里等待哪里就起来</span></span><br><span class="line">      <span class="keyword">while</span>(flag != <span class="number">2</span>)&#123; <span class="comment">//线程2在次等待</span></span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(Thread.currentThread().getName() + <span class="string">" - Print2()"</span>);</span><br><span class="line">      System.out.println(<span class="string">" "</span>);</span><br><span class="line">      flag=<span class="number">3</span>;</span><br><span class="line">      <span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒所有的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span>(flag != <span class="number">3</span>)&#123; <span class="comment">//线程3在次等待记</span></span><br><span class="line">        <span class="keyword">this</span>.wait();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(Thread.currentThread().getName() + <span class="string">" - Print3()"</span>);</span><br><span class="line">      System.out.println(<span class="string">" "</span>);</span><br><span class="line">      flag=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>.notifyAll(); <span class="comment">// 唤醒所有的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果按照顺序执行；</span></span><br><span class="line">Thread-<span class="number">0</span> - Print1() </span><br><span class="line">Thread-<span class="number">1</span> - Print2() </span><br><span class="line">Thread-<span class="number">2</span> - Print3() </span><br><span class="line">Thread-<span class="number">0</span> - Print1() </span><br><span class="line">Thread-<span class="number">1</span> - Print2() </span><br><span class="line">Thread-<span class="number">2</span> - Print3() </span><br><span class="line">Thread-<span class="number">0</span> - Print1()</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>学习总结:</strong><br>1,在同步代码块中用哪个对象锁就用哪个对象调用wait方法</p>
<p><em>2,为什么wait方法和notify方法定义在Object这类中?</em></p>
<ul>
<li>答:因为锁对象可以是任意对象,Object是所有的类的基类,所以wait方法和notify方法需要定义在Object这个类中</li>
</ul>
<p><em>3,sleep方法和wait方法的区别?</em><br>区别1：</p>
<ul>
<li>sleep方法必须传入参数,参数就是时间时间到了自动醒来,</li>
<li>wait方法可以传入参数也可以不传入参数,传入参数就是在参数的时间结束后等待不传入参数就是直接等待</li>
</ul>
<p>区别2：</p>
<ul>
<li>sleep方法在<code>同步函数或同步代码块</code>中,<code>不释放锁 - 睡着了也抱着锁睡(他不能被唤醒)</code></li>
<li>wait方法在同步函数或者同步代码块中<code>释放锁 - 如果不释放锁，线程产生等待CPU也会一直在该段程序中耗着不能执行其他任务</code>;</li>
</ul>
<p><br></p>
<h5 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h5><p>描述:学过操作系统或者信号和通信的人应该了解过互斥锁（不多讲自己百度在信号同步那一章节的）, 它是JDK1.5的新特性；</p>
<ul>
<li>1.同步: 使用ReentrantLock类的lock() 获取锁和unlock()释放锁方法进行同步</li>
<li>2.通信<ul>
<li>使用ReentrantLock类的newCondition()方法可以获取Condition对象</li>
<li><code>需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法</code></li>
<li><code>不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了</code></li>
</ul>
</li>
</ul>
<p>基础语法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个可重入的互斥锁 Lock，具有与synchronized方法和语义为隐式监控相同的基本行和语义使用，但扩展功能更加强大;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">//常用方法:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>  <span class="comment">//获取锁。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> <span class="comment">//试图释放这个锁。  </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//在 Lock取代 synchronized方法和语句的使用，一个 Condition取代对象监视器的使进行唤醒和等待</span></span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> <span class="comment">//返回一个用于这 Lock 的Condition实例。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span>  <span class="comment">//使当前线程等待它暗示或 interrupted。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> <span class="comment">///唤醒一个等待线程。  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> <span class="comment">//唤醒所有等待线程。</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>基础实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo13_ReentranLock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (1)1.5新特性互斥锁实现：不需要将每个线程都唤醒，只是唤醒指定线程；</span></span><br><span class="line">    <span class="keyword">final</span> Reentran rt = <span class="keyword">new</span> Reentran();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程1中执行的代码</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            rt.p1();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程2中执行的代码</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            rt.p2();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线3中执行的代码</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            rt.p3();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reentran</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ReentrantLock r = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//互斥锁对象</span></span><br><span class="line">  <span class="comment">//创建三个监听器</span></span><br><span class="line">  <span class="keyword">private</span> Condition c1 = r.newCondition(); <span class="comment">//返回Condition对象</span></span><br><span class="line">  <span class="keyword">private</span> Condition c2 = r.newCondition(); <span class="comment">//返回Condition对象</span></span><br><span class="line">  <span class="keyword">private</span> Condition c3 = r.newCondition(); <span class="comment">//返回Condition对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    r.lock();<span class="comment">//获取锁-&gt;这里替换了synchronzied同步锁</span></span><br><span class="line">    <span class="keyword">if</span>(flag != <span class="number">1</span>)</span><br><span class="line">      c1.await();  <span class="comment">//使线程1等待</span></span><br><span class="line">    System.out.println(<span class="string">"Wei"</span>);</span><br><span class="line">    flag = <span class="number">2</span>;  <span class="comment">//灵魂之所在</span></span><br><span class="line">    c2.signal(); <span class="comment">//唤醒线程2</span></span><br><span class="line">    r.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    r.lock();<span class="comment">//获取锁-&gt;这里替换了synchronzied同步锁</span></span><br><span class="line">    <span class="keyword">if</span>(flag != <span class="number">2</span>)</span><br><span class="line">      c2.await();  <span class="comment">//使线程2等待</span></span><br><span class="line">    System.out.println(<span class="string">"Geek"</span>);</span><br><span class="line">    flag = <span class="number">3</span>;  <span class="comment">//灵魂之所在</span></span><br><span class="line">    c3.signal(); <span class="comment">//唤醒线程3</span></span><br><span class="line">    r.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">p3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    r.lock();<span class="comment">//获取锁-&gt;这里替换了synchronzied同步锁</span></span><br><span class="line">    <span class="keyword">if</span>(flag != <span class="number">3</span>)</span><br><span class="line">      c3.await();  <span class="comment">//使线程3等待</span></span><br><span class="line">    System.out.println(<span class="string">"Hacker"</span>);</span><br><span class="line">    flag = <span class="number">1</span>;  <span class="comment">//灵魂之所在</span></span><br><span class="line">    c1.signal(); <span class="comment">//唤醒线程1</span></span><br><span class="line">    r.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行结果:</span></span><br><span class="line"><span class="comment">Wei</span></span><br><span class="line"><span class="comment">Geek</span></span><br><span class="line"><span class="comment">Hacker</span></span><br><span class="line"><span class="comment">Wei</span></span><br><span class="line"><span class="comment">Geek</span></span><br><span class="line"><span class="comment">Hacker</span></span><br><span class="line"><span class="comment">***/</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h5><p>描述:<em>为什么要存在组?</em><br>答:那是为了方便管理和维护，同样JAVA中线程中也有自己的组;</p>
<p>线程组概述: Java中使用ThreadGroup来表示线程组，<code>它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制</code>。默认情况下所有的线程都属于<code>主线程组</code>。</p>
<p>基础语法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadGroup类:一个线程组表示一组线程。</span></span><br><span class="line"><span class="comment">// 此外一个线程组还可以包括其他线程组。线程组形成一个树，其中每一个线程组除了初始线程组有一个父。 </span></span><br><span class="line"><span class="comment">// 允许一个线程访问它自己的线程组的信息，但不允许访问它的线程组的父线程组或其他任何线程组的信息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//构造方法</span></span><br><span class="line"><span class="class"><span class="title">ThreadGroup</span>(<span class="title">String</span> <span class="title">name</span>) //构建一个新的线程组,并给其赋值名字 </span></span><br><span class="line"><span class="class"><span class="title">Thread</span>(<span class="title">ThreadGroup</span>?<span class="title">group</span>, <span class="title">Runnable</span>?<span class="title">target</span>, <span class="title">String</span>?<span class="title">name</span>) //设置整组的优先级或者守护线程</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">//常用方法:</span><br><span class="line"><span class="function">ThreadGroup <span class="title">getThreadGroup</span><span class="params">()</span> <span class="comment">//通过线程对象获取他所属于的组</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="comment">//通过线程组对象获取他组的名字</span></span></span><br><span class="line"><span class="function">ThreadGroup <span class="title">getParent</span><span class="params">()</span> <span class="comment">//返回这个线程组的父。  </span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">//返回这个线程组的字符串表示形式</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>线程的生命周期:</strong></p>
<ul>
<li>新建:创建线程;</li>
<li>就绪:线程对象已经启动了,但是还没回去到CPU执行权;</li>
<li>运行:获取到了CPU的执行权;</li>
<li>阻塞:没有CPU的执行权回到就绪;</li>
<li>死亡:代码运行完毕线程消亡; </li>
</ul>
<p><a rel=JAVA入门学习十 href="https://img.weiyigeek.top/2019/1/20191021211308.png" target="_blank" title="WeiyiGeek." data-fancybox="images"><img src="https://img.weiyigeek.top/2019/1/20191021211308.png" alt="WeiyiGeek."></a></p>
<p><br></p>
<p>基础示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo13_ThreadGroup</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.线程组的使用案例</span></span><br><span class="line">    <span class="comment">// 线程默认情况下属于main线程组</span></span><br><span class="line">    <span class="comment">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</span></span><br><span class="line">    System.out.println(<span class="string">"默认线程组: "</span>+Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 声明使用线程对象，创建Runable的子类对象;</span></span><br><span class="line">    Mrunnable mr = <span class="keyword">new</span> Mrunnable();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建两个线程</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(mr,<span class="string">"One"</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(mr,<span class="string">"Two"</span>);</span><br><span class="line">    </span><br><span class="line">    ThreadGroup tg1 = t1.getThreadGroup();</span><br><span class="line">    ThreadGroup tg2 = t2.getThreadGroup();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"+ 默认都是主线程组:"</span> + tg1.getName()); <span class="comment">//输出线程组名称</span></span><br><span class="line">    System.out.println(<span class="string">"+ 默认都是主线程组:"</span> + tg2.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置创建新的线程组名称</span></span><br><span class="line">    ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"NewThreadGroup"</span>);</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(tg,mr,<span class="string">"Group"</span>);</span><br><span class="line">    ThreadGroup tg3 =  t3.getThreadGroup(); <span class="comment">//获取进程组对象</span></span><br><span class="line">    System.out.println(<span class="string">"+ 设置的线程组:"</span> + tg3.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过组名称设置后台线程，表示该组的线程都是后台线程</span></span><br><span class="line">    tg.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程对象类 (ctrl+1 =&gt; 错误提示添加)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mrunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"...."</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认线程组: main</span><br><span class="line">+ 默认都是主线程组:main</span><br><span class="line">+ 默认都是主线程组:main</span><br><span class="line">+ 设置的线程组:NewThreadGroup</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h5><p>概述:程序启动一个新线程成本是比较高的(经过五种状态)，因为它涉及到要与操作系统进行交互;而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。<br>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</p>
<ul>
<li>在JDK5之前我们必须手动实现自己的线程池</li>
<li>从JDK5开始Java内置支持线程池</li>
</ul>
<p>内置线程池的使用JDK5新增了一个<code>Executors工厂类来产生线程池</code>，有如下几个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Executors工程类的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">* <span class="title">public</span> <span class="title">static</span> <span class="title">ExecutorService</span> <span class="title">newFixedThreadPool</span>(<span class="title">int</span> <span class="title">nThreads</span>)  //线程池中可存放线程的数量使用固定数量的线程操作了共享无界队列。 </span></span><br><span class="line"><span class="class">* <span class="title">public</span> <span class="title">static</span> <span class="title">ExecutorService</span> <span class="title">newSingleThreadExecutor</span>() //创建一个执行器，使用一个单一的工作线程操作关闭一个无限的队列。</span></span><br></pre></td></tr></table></figure><br>这些方法的返回值是ExecutorService对象，该对象表示一个线程池可以<code>执行Runnable对象</code>或者Callable对象代表的线程。<br>它提供了如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理终端和方法可以用于跟踪一个或多个异步任务的进展产生 Future提供方法。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">//常用方法:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span>  <span class="comment">//启动一个有序的关机，在以前提交的任务被执行，但没有新的任务将被接受。  </span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span>  <span class="comment">//提交一个值返回任务执行，并返回一个表示任务挂起结果的未来。  </span></span></span><br><span class="line"><span class="function">Future&lt;?&gt; <span class="title">submit</span><span class="params">(Runnable task)</span>  <span class="comment">//提交执行一个Runnable任务并返回一个表示该任务的未来。  </span></span></span><br><span class="line"><span class="function">&lt;T&gt; Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span>  <span class="comment">//提交执行一个Runnable任务并返回一个表示该任务的未来。</span></span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>基础示例:多线程程序实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用步骤：</span></span><br><span class="line"><span class="comment">// * 创建线程池对象 ExecutorService  Pool</span></span><br><span class="line"><span class="comment">// * 创建Runnable实例</span></span><br><span class="line"><span class="comment">// * 提交Runnable实例</span></span><br><span class="line"><span class="comment">// * 关闭线程池</span></span><br><span class="line"><span class="keyword">package</span> com.weiyigeek.Thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo14_Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//(1) 线程池的使用</span></span><br><span class="line">    ExecutorService pool =  Executors.newFixedThreadPool(<span class="number">2</span>); <span class="comment">//创建线程池对象</span></span><br><span class="line">    <span class="comment">//提交执行的线程(可以执行Runnable对象或者Callable对象代表的线程)</span></span><br><span class="line">    pool.submit(<span class="keyword">new</span> Mrunnable()); <span class="comment">//线程一放入池中执行</span></span><br><span class="line">    pool.submit(<span class="keyword">new</span> Mrunnable()); <span class="comment">//线程二</span></span><br><span class="line">    <span class="comment">//避免重复执行</span></span><br><span class="line">    pool.shutdown(); <span class="comment">//关闭线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//(2)多线程程序实现(实现线程方法3)</span></span><br><span class="line">    ExecutorService pool1 =  Executors.newFixedThreadPool(<span class="number">2</span>); <span class="comment">//创建线程池对象</span></span><br><span class="line">    Future&lt;Integer&gt; f1 = pool1.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>)); <span class="comment">//将线程放入池中执行并且返回其值</span></span><br><span class="line">    Future&lt;Integer&gt; f2 = pool1.submit(<span class="keyword">new</span> MyCallable(<span class="number">50</span>));</span><br><span class="line">    System.out.println(<span class="string">"前100之和:"</span> + f1.get()); <span class="comment">//采用get方法获取其值(需要抛出异常)</span></span><br><span class="line">    System.out.println(<span class="string">"前50之和:"</span> + f2.get());</span><br><span class="line">    pool1.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现线程的第三种方式Callable（笔试中常常会问到）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">  <span class="comment">//构造方法传入要求前num的之综合</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">//call方法相比于run方法可以抛出异常以及有返回值;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      sum += num--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果:</span></span><br><span class="line"><span class="comment">//	pool-1-thread-1....0</span></span><br><span class="line"><span class="comment">//	pool-1-thread-1....1</span></span><br><span class="line"><span class="comment">//	pool-1-thread-1....2</span></span><br><span class="line"><span class="comment">//	pool-1-thread-2....0</span></span><br><span class="line"><span class="comment">//	pool-1-thread-1....3</span></span><br><span class="line"><span class="comment">//	pool-1-thread-1....4</span></span><br><span class="line"><span class="comment">//	pool-1-thread-1....5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前100之和:5050</span></span><br><span class="line"><span class="comment">//前50之和:1275</span></span><br></pre></td></tr></table></figure></p>
<p><strong>总结:</strong>多线程程序实现的方式3的好处和弊端<br><em>好处：</em></p>
<ul>
<li>可以有返回值</li>
<li>可以抛出异常</li>
</ul>
<p><em>弊端：</em></p>
<ul>
<li>代码比较复杂，所以一般不用</li>
</ul>

        </div>
        
        <!-- 微信公众号关注/文章版权复制 -->
        
        <div id="btw-mask" style="position: fixed; top: 0px; right: 0px; bottom: 0px; left: 0px; opacity: 0.7; z-index: 999; background: rgb(0, 0, 0); display:none"></div>
<div id="btw-modal" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 360px; text-align: center; font-size: 13px; background: rgb(255, 255, 255); border-radius: 10px; z-index: 9999; font-family: PingFangSC-Regular, sans-serif;display:none">
<span id="btw-modal-close-btn" style="position: absolute; top: 5px; right: 15px; line-height: 1.8; font-size: 15px; cursor: pointer; opacity: 0.2; z-index: 9999; color: rgb(0, 0, 0); background: none; border: none; outline: none;">X</span>
<p id="btw-modal-header" style="margin-top: 40px; line-height: 1.8; font-size: 13px; ">
<b style="color:#6190e8;">你好看友,欢迎关注博主微信公众号哟! ❤ <br> 这将是我持续更新文章的动力源泉，谢谢支持！(๑′ᴗ‵๑) </b> <br> 如不想关注请点击右上角的【X】即可关闭继续浏览文章.<br>  <b style="color:red;"> 温馨提示: 未解锁的用户不能粘贴复制文章内容哟!</b> <br>
<br>Method 1.Please visit <strong><a href="https://twitter.com/WeiyiGeek" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【My Twitter】</a></strong>. There is an article verification code in the homepage.
<br>方式2.请访问本博主的B站<strong><a href="https://space.bilibili.com/385802642" target="_blank" rel="noopener" style="color: rgb(240, 65, 52);text-decoration:underline;">【WeiyiGeek】</a></strong>首页关注UP主,<br>将自动随机获取解锁验证码。
<br>方式3.扫一扫下方二维码，关注本站<strong>官方公众号</strong><br>
回复：<strong style="color: rgb(240, 65, 52);">验证码</strong>
将获取<strong style="color: rgb(240, 65, 52);">解锁(有效期7天)</strong>本站所有技术文章哟!</p>
<img src="/img/wechat-search.png" style="width: 300px; margin-top: 10px;">
<div id="btw-modal-input-code" style="margin-top: 20px; background: rgb(255, 255, 255);">
  <input id="btw-modal-input" type="number" minlength="4" maxlength="4" placeholder="请输入验证码|Verification Code"
    style="width: 165px; height: 32px; line-height: 32px; padding: 0px 10px; margin: 0px 10px; font-size: 13px; text-rendering: auto; text-transform: none; cursor: text; outline: none; box-sizing: border-box; border: 1px solid rgb(221, 221, 221); -webkit-appearance: textfield; background-color: white; -webkit-rtl-ordering: logical;"/>
  <button id="btw-submit-btn" onclick="yzm_vertify()"
    style="padding: 0px 20px; height: 32px; font-size: 14px; outline: none; border: none; color: rgb(255, 255, 255); background: rgb(222, 104, 109); cursor: pointer;">提
    交</button> </div>
<p id="btw-footer" style="margin: 40px 0px 20px; color: rgb(153, 153, 153);">@WeiyiGeek - 为了能到远方，脚下的每一步都不能少</p>
</div>
           

        <!-- Google 广告 -->
        
<ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-9134434519967436" data-ad-slot="7905848205"></ins>
  

        
<hr/>
<div style="text-align: center;font-weight: bold;">
  <p> 欢迎各位志同道合的朋友一起学习交流，如文章有误请在下方留下您宝贵的经验知识，个人邮箱地址<b style="color:#ff654e"><code>【master#weiyigeek.top】</code></b>或者个人公众号<b style="color:#ff654e"><code>【WeiyiGeek】</code></b>联系我。 </p>
  <p> 更多文章来源于<b style="color:#03a9f4">【WeiyiGeek Blog - 为了能到远方，脚下的每一步都不能少】</b>, 个人首页地址( <a style="color: #03a9f4;" href="https://weiyigeek.top" target="_blank"> https://weiyigeek.top </a> )</p>
<!-- 

  <ul style="font-weight: bolder;">
    <li>
      <p><span style="color: #03a9f4">echo&nbsp;&nbsp;"【点个赞】，动动你那粗壮的拇指或者芊芊玉手，亲！"</span></p>
    </li>
    <li>
      <p><span style="color: #ff9201">printf("%s",&nbsp;"【投个币】，万水千山总是情，投个硬币行不行，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #02a2ff">fmt.Printf("【收个藏】，阅后即焚不吃灰，亲！")&nbsp;&nbsp;</span></p>
    </li>
    <li>
      <p><span style="color:red">console.info("【转个发】，让更多的志同道合的朋友一起学习交流，亲！")</span></p>
    </li>
    <li>
      <p><span style="color: #ff654e">System.out.println("【关个注】，后续浏览查看不迷路哟，亲！")</span></p>
    </li>
  </ul> -->
  <div>
    <img src="/img/share-wechat.jpg" class="img-responsive" alt="扫描Follow(关注)WeiyiGeek公众号与Visit(浏览)极客全栈修炼小程序" >
    <p>专栏书写不易，如果您觉得这个专栏还不错的，请给这篇专栏 <b style="color: red;">【点个赞、投个币、收个藏、关个注、转个发、赞个助】</b>，这将对我的肯定，我将持续整理发布更多优质原创文章！。</p>
    <img src="/img/weiyigeek.jpg" class="img-responsive" alt="WeiyiGeek-banner">
  </div>
</div>
  <hr>
  

  <blockquote class="post-copyright">
    <div class="content">
      
        
<span class="post-time">
    最后更新时间：<time datetime="2023-01-31T02:29:10.672Z" itemprop="dateUpdated">2023-01-31 10:29:10</time>
</span><br>


        <span>文章原始路径：<a href="https://github.com/WeiyiGeek/blog/edit/master/source/_posts/编程世界/Java/JAVA入门学习十.md" target="_blank" rel="noopener noreferrer">_posts/编程世界/Java/JAVA入门学习十.md</a></span><br>
         <span class="copy-copyright">转载注明出处，原文地址：<a href="/2019/10-14-293.html" target="_blank" rel="external">https://blog.weiyigeek.top/2019/10-14-293.html</a></span><br>本站文章内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a> 
    </div>
    <footer>
      <a href="https://blog.weiyigeek.top">
        <img src="/img/avatar.jpg" alt="WeiyiGeek">
        WeiyiGeek
      </a>
    </footer>
  </blockquote>


        
            <div class="page-reward">
  <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-rectangle waves-light">☕️ 请作者喝杯咖啡!</a>
</div>
            
        
        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2019/10-14-293.html&title=《JAVA入门学习十》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2019/10-14-293.html&title=《JAVA入门学习十》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2019/10-14-293.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JAVA入门学习十》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2019/10-14-293.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2019/10-14-293.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
          <!-- 评论组件 -->


<div id="gitalk-container"></div>
<script type="text/javascript" src="/js/plugins/gitalk.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/custom/gitalk.init.js?v=1.6.6"></script>
        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/10-16-115.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JeecmsX1入门安装使用和二次开发</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/10-10-226.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">域控信息查看与操作一览表</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多线程Thread入门"><span class="post-toc-number">1.</span> <span class="post-toc-text">多线程Thread入门</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多线程进阶"><span class="post-toc-number">2.</span> <span class="post-toc-text">多线程进阶</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
    <!-- 
  <div id="post-wechat" class="post-wechat" style="position:fixed;top: 360px;bottom: 500px;right: 3%;width: 190px;text-align: center; z-index: 9999">
    <p><b>关注【全栈工程师修炼指南】</b></p>
    <img src="/img/wechat-gzh.jpg" class="img-responsive" alt="weiyigeek">
    <p><b>欢迎添加【作者】微信</b></p>
    <img src="/img/wehat.jpg" class="img-responsive" alt="weiyigeek">
  </div>
 -->

    <!-- 支付宝微信文章赞赏 -->
    
      <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        如果此篇文章对您有帮助，就请作者喝杯 Coffee ☕️☕️!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardwechat" src="/img/reward-wechat.jpg" height="250" height="250" alt="微信打赏二维码">
            <img id="rewardalipay" src="/img/reward-alipay.png" height="250" height="250" alt="支付宝打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <!-- <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.png"> -->
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

      
</article>
</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://weiyigeek.top" target="_blank">https://weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.weiyigeek.top" target="_blank">https://blog.weiyigeek.top</a>
    </span>
    
    <span class="blogroll-item">
        <a href="/img/share-wechat.jpg" target="_blank">公众账号</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://space.bilibili.com/385802642/article" target="_blank">哔哩哔哩专栏</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/weiyigeek" target="_blank">博主Github</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://gitee.com/WeiyiGeek" target="_blank">博主Gitee</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.zhihu.com/people/weiyiSec" target="_blank">知乎</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.cnblogs.com/WeiyiGeek" target="_blank">博客园</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://my.oschina.net/weiyigeek" target="_blank">OSCHINA</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAqcPSoMqfctaEqJpGSF775eeCjWkrop4AOyLITdMx-L78F5iXzfQcSRM5sY4dq3wR" target="_blank">今日头条</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.csdn.net/u013072756?type=lately" target="_blank">CSDN</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.jianshu.com/u/5199a1104739" target="_blank">简书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cloud.tencent.com/developer/user/1389665/articles" target="_blank">腾讯云社区</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://cuttlefish.baidu.com/shop/75c5dbd8d15abe23482f4d40" target="_blank">百度文库</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://author.baidu.com/home?from=blog&app_id=1726736601523415" target="_blank">IT极客知识分享</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://blog.51cto.com/weiyigeek" target="_blank">51CTO博客</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://juejin.cn/user/122767337595934" target="_blank">掘金</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://weibo.com/a/hot/7622022703618049_1.html" target="_blank">微博文章</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.xiaohongshu.com/user/profile/627c98bb000000001000e7ba" target="_blank">小红书</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://segmentfault.com/u/weiyigeek" target="_blank">Segmentfault</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.modb.pro/u/506690" target="_blank">墨天轮</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.douyin.com/user/MS4wLjABAAAAMSBdMja6XLsdmzafb0RNbFeBemIOk38K1PaOClZeI1Q" target="_blank">抖音主页</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.kuaishou.com/profile/3xfbrsrhd2i69x9" target="_blank">快手主页</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://www.ixigua.com/home/3984243135350727" target="_blank">西瓜视频</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
      <p>
        <span>WeiyiGeek &copy; 2018 - 2023 <a href="https://weiyigeek.top" target="_blank" rel="noopener">weiyigeek.top</a> All rights reserved.唯一极客IT知识分享 版权所有 </span>
        
        <span>
          Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/weiyigeek" target="_blank">mellow</a>
        </span>
        
        <br/><a id="SiteRunTime"></a>
        <br/>访问统计
        <span><a href="/sitemap.xml" target="_blank" rel="Sitemaps-站点地图">Sitemaps</a> </span>
        <span><a href="/baidusitemap.xml" target="_blank" rel="baidusitemaps-百度站点地图">站点地图</a> </span>
        <!-- 
  -->
        <br/>ICP备案号<span><a href="https://beian.miit.gov.cn" target="_blank">渝ICP备2022003447号</a></span>
        <br/>
        <div>
        <div id="blog-wormhole-id" >
          <a href="https://www.foreverblog.cn/go.html" target="_blank"> 
            <img src="https://img.foreverblog.cn/wormhole_2_tp.gif" alt="十年之约虫洞" style="height:32px;max-height:50px;display:block;margin:0 auto;" title="穿梭虫洞-随机访问十年之约友链博客">
          </a>
        </div>
        <div id="cc-myssl-id" >
          <a href="https://myssl.com/blog.weiyigeek.top?from=mysslid" target="_blank">
            <img src="https://static.myssl.com/res/images/myssl-id1.png" alt="MySSL安全认证" style="max-height:50px;display:block;margin:0 auto">
          </a>
        </div>
      </p>
    </div>
</footer>



    <div class="mask" id="mask"></div>

<div id="go" class="waves-effect waves-light">
  <a href="javascript:;" id="goqrcode"> <span class="icon icon-lg icon-qrcode"></span> </a>
  <a href="javascript:;" id="gotop"> <span class="icon icon-lg icon-chevron-up"></span></a>
</div>





<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://blog.weiyigeek.top/2019/10-14-293.html&title=《JAVA入门学习十》 — WeiyiGeek Blog&pic=https://blog.weiyigeek.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.weiyigeek.top/2019/10-14-293.html&title=《JAVA入门学习十》 — WeiyiGeek Blog&source=[TOC]" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://blog.weiyigeek.top/2019/10-14-293.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JAVA入门学习十》 — WeiyiGeek Blog&url=https://blog.weiyigeek.top/2019/10-14-293.html&via=https://blog.weiyigeek.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://blog.weiyigeek.top/2019/10-14-293.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKklEQVR42u3ay27CMBAFUP7/p6nUVSVKuNcOSEyOVxVxqU8WU8/jdovX/Xcle/7ufPytxz350xMWBgbG1zLuh2t/zyMpeZr/XQwMjOswjoNscrgkyCYh+Pj7n36OgYGBsXThO/4kD+IYGBgYLWMtjOZJLwYGBsZOEtseMX/60VwcAwPjCxltY+CTP7+xv4GBgfEljHu58jLcWW3O6FQYGBijGW3Rfz/53BnmeHExxcDAuAxjh5cPVbQvKyrnYWBgjGac1bY8/uq2zZkPn2FgYMxm7HxF2/LcGex4EfoxMDAuxlirvbcXu+SIRbqLgYExmpGni+3YRDJOkVz7itCPgYExlNEmnPsDGTs7n+7HwMAYzci3Jte4fEQjT32LqiEGBsYFGDsJbV5Qa9PUov2JgYExlLGWcLYhOB/dyDuu/ySxGBgYoxl5WW1//CJpiNavAwMD4wKMNmXNU9M2HLfBush0MTAwBjHaAv3azp3RiijgYmBgDGLUW8uyWnLc08I9BgbGUEZb/Eqo7fBE23LAwMDAaJuUeXg9Zq+9vuiWioGB8eWMPBSuNSbzxkO+otIbBgbGIMbaIMXawER7ocybphgYGLMZbZhrD5df6faTZwwMjNmMtSC79oby8F1fNzEwMC7A2AmCbXFt5z8ABgYGxllltaSdkD+NklgMDAyMN5fJcsaLJBYDA2M0I09i8/CaXyLz42JgYFyT0aaObXhdawysFf4wMDDGMX4ASymEmqrjuaYAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="/js/jquery/2.1.0-jquery.min.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/jquery/3.5.2-jquery.fancybox.min.js?v=1.6.6"></script>
<!--  //cdn.bootcss.com/node-waves/0.7.4/waves.min.js -->
<script type="text/javascript" src="/js/node-waves/0.7.4-waves.min.js?v=1.6.6"></script> 

<script type="text/javascript" src="/js/method.js?v=1.6.6"></script>
<script type="text/javascript" src="/js/blog.js?v=1.6.6"></script>

<!-- third-party -->
<script type="text/javascript" src="/js/plugins/local_search.js?v=1.6.6"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) { search_path = "search.xml";}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script> 

<script> (adsbygoogle = window.adsbygoogle || []).push({});</script>    


<!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> --> 


  


<script>
  var _hmt = _hmt || [];
  (function() {
    // 百度统计
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?53923c4b5560739bc0ed61e183be6acf";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>
 


<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.staticfile.org/mathjax/2.7.9/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
 
<script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = 'WeiyiGeek Blog-唯一极客-关注于网络安全_物联网安全开发_网络安全运维-学习心得分享';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)咦!又好了!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>
 

     <script type="text/javascript" src="/js/custom/copytips.js?v=1.6.6"></script> 
<script type="text/javascript">
// 站点运行时间
var BootDate = new Date("2018/01/01 00:00:00");
function ShowRunTime(id) {
  var NowDate = new Date();
  var RunDateM = parseInt(NowDate - BootDate);
  var RunDays = Math.floor(RunDateM/(24*3600*1000));
  var RunHours = Math.floor(RunDateM%(24*3600*1000)/(3600*1000));
  var RunMinutes = Math.floor(RunDateM%(24*3600*1000)%(3600*1000)/(60*1000));
  var RunSeconds = Math.round(RunDateM%(24*3600*1000)%(3600*1000)%(60*1000)/1000);
  var RunTime = RunDays + " 天 " + RunHours + " 时 " + RunMinutes + " 分 " + RunSeconds + " 秒";
  document.getElementById(id).innerHTML = "网站已在风雨中勉勉强强运行了【 " + RunTime + " 】";
}
setInterval("ShowRunTime('SiteRunTime')", 1000);
</script>
    
  <div id="post-wechat" class="post-wechat" style="position:fixed;top: 360px;bottom: 500px;right: 3%;width: 190px;text-align: center; z-index: 9999">
    <p><b>关注【全栈工程师修炼指南】</b></p>
    <img src="/img/wechat-gzh.jpg" class="img-responsive" alt="weiyigeek">
    <p><b>欢迎添加【作者】微信</b></p>
    <img src="/img/wehat.jpg" class="img-responsive" alt="weiyigeek">
  </div>

</body>
</html>