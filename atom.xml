<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WeiyiGeek Blog</title>
  
  <subtitle>花开堪折直须折，莫待无花空折枝。</subtitle>
  <link href="https://blog.weiyigeek.top/atom.xml" rel="self"/>
  
  <link href="https://blog.weiyigeek.top/"/>
  <updated>2023-02-17T02:59:51.000Z</updated>
  <id>https://blog.weiyigeek.top/</id>
  
  <author>
    <name>WeiyiGeek</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程世界/前端技术/ht</title>
    <link href="https://blog.weiyigeek.top/2023/2-17-index.html"/>
    <id>https://blog.weiyigeek.top/2023/2-17-index.html</id>
    <published>2023-02-17T02:59:51.000Z</published>
    <updated>2023-02-17T02:59:51.000Z</updated>
    
    <content type="html"><![CDATA[hth]]></content>
    
    
      
      
    <summary type="html">hth</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2.全栈修炼之前端《标准与研发工具》学习笔记</title>
    <link href="https://blog.weiyigeek.top/2023/2-15-712.html"/>
    <id>https://blog.weiyigeek.top/2023/2-15-712.html</id>
    <published>2023-02-15T10:30:30.000Z</published>
    <updated>2023-02-19T02:43:48.506Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0X00-前端标准与研发工具"><a href="#0X00-前端标准与研发工具" class="headerlink" title="0X00 前端标准与研发工具"></a>0X00 前端标准与研发工具</h2><p><strong>原文地址:</strong>  [全栈之路-前端篇 | 第三讲.基础前置知识【前端标准与研发工具】学习笔记] <a href="https://mp.weixin.qq.com/s/JpM5PO2a3wZUeFcrzzN8bg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JpM5PO2a3wZUeFcrzzN8bg</a></p><h3 id="8-行业标准"><a href="#8-行业标准" class="headerlink" title="8.行业标准"></a>8.行业标准</h3><p>前端技术中有众多的开发标准，在后续的学习之中免不了打交道，此处我们简单熟悉了解下常见标准。</p><h4 id="Web-1-0-2-0-3-0"><a href="#Web-1-0-2-0-3-0" class="headerlink" title="Web 1.0 / 2.0 / 3.0"></a>Web 1.0 / 2.0 / 3.0</h4><p>随着互联网的范式不断迭代升级，从只有静态网页的Web1.0到用户直接交互的Web2.0，再到用户自主控制数据的Web3.0。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2019/1/20190922225533.png" alt="WeiyiGeek.Web1.0/2.0/3.0" title="" class="">                <p>WeiyiGeek.Web1.0/2.0/3.0</p>            </figure><p><br/></p><p><strong>那Web 1.0、Web 2.0 和 Web 3.0之间有什么区别呢？</strong></p><ul><li>Web 1.0 ：“只读”的信息展示平台</li></ul><blockquote><p>在 Web 1.0 时代，即从 <code>1991 年到 2004 年</code>，是万维网革命的第一阶段，通常称为只读网络。网站是信息性的，仅包含超链接在一起的静态内容，或者简单地说，没有CSS、动态链接、交互性（如登录用户、对博客文章的评论等）。此时我们作为一个普通的互联网用户，只能去看也就是 <code>read-only</code> 不能写。</p><p>例如：新浪、网易、搜狐性门户站点，只能浏览查看后台管理员发布的文章。</p><p>而随着互联网发展，交互的方式也进步了，作为互联网普通用户，此时互联网不但可以读了而且还可读可写了，这就是web2.0。</p></blockquote><ul><li>Web 2.0 ：“互动”的内容生产网络</li></ul><blockquote><p>在 Web 2.0 时代，从 2004 年至今，是万维网革命的第二阶段，通常称为读写网络。目前大家都都生活在Web 2.0时代，也离不开Web 2.0带来的便捷，此时社交网络包含许多在线工具和平台，人们可以在其中分享他们的观点、意见、想法和经验，它突出了用户生成的内容、可用性和最终用户的互操作性。</p><p>Web 2.0 应用程序倾向于与最终用户进行更多交互。因此，最终用户不仅是应用程序的用户，而且是工具的参与者。例如：新浪微博，你可以发表自己的微博；Facebook 你可以发表自己的动态；微信你可以发表自己的朋友圈等；以及博客站点提供与浏览者评论交流。</p></blockquote><blockquote><p>Web 2.0 的缺点：“中心”的单一化环境，在查看缺点之前，让我们先看看传统的 web2.0 应用程序是如何工作的。</p><p>如下图所示，客户端（用户）将向服务器发出 HTTP 请求，如果一切正确，它将将该网页作为响应发回。可以看到它有一个主要缺陷是所有数据都存储在由公司控制的集中式服务器上，Facebook、谷歌和 Twitter 等开始将用户数据存储在他们的服务器中，以便他们可以通过网络为我们提供更好的内容。这反过来又会使我们在他们的网站上停留的时间更长，从而为这些公司提供更多的广告收入。</p><p>这些公司最终开始将我们的信息出售给广告商，侵犯个人隐私外还在我们身上盈利！无疑这个是中心化的时代。</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/2/image-20230108161142616.png" alt="WeiyiGeek.Web2.0客户端用户请求流程" title="" class="">                <p>WeiyiGeek.Web2.0客户端用户请求流程</p>            </figure><ul><li>Web 3.0 ：“去中心”的个性化环境</li></ul><blockquote><p>Web3.0 概念旨在创建一个去中心化但安全的互联网，人们可以在其中安全地交换金钱和信息，而无需中间商或大型科技公司。与将数据存储在单个数据库或云提供商中的 Web2.0 不同，Web3.0 应用程序要么在区块链上运行，要么在点对点节点（服务器）上运行。</p><p>采用去中心化的模式，用户的所有数据都是通过钱包/私钥来控制的，而这个时候，数据的所有权属于用户自己，而不是平台方。在web3.0中平台方变成了一个个DAPP，他们通过区块链上现有的基础协议和功能，来搭建属于自己的应用平台。比如在以太坊上智能合约使用EVM虚拟机，数据存储和交互使用swarm协议，信息的传递使用whisper协议，DAPP通过构建自己的激励代币ERC20 token来实现整个应用的激励，从而避免了作恶的可能性，也通过这种方式使得生态能够稳健运行。</p><p>简而言之，Web3.0将是一个不会依赖任何中心组织、完全由用户掌控的时代。它的到来将彻底打破现在科技巨头的垄断，改写当前数字经济的运行方式，并引发大量自下而上的创新。</p></blockquote><p>关于从Web1.0-Web 3.0的变迁和概念特点，总结如下所示：</p><ul><li>Web1.0：Yahoo、新浪和搜狐等，内容为主，少交互；</li><li>Web2.0：Facebook、微信和抖音等，关系为主，多交互；</li><li>Web3.0： 区块链、物联网和人工智能等，数据为主，去信任去中介化的价值互联。</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/2/image-20230108162002292.png" alt="WeiyiGeek.Web1.0-3.0区别" title="" class="">                <p>WeiyiGeek.Web1.0-3.0区别</p>            </figure><h4 id="W3C-WHATWG"><a href="#W3C-WHATWG" class="headerlink" title="W3C/WHATWG"></a>W3C/WHATWG</h4><p><strong>什么是W3C?</strong></p><p>万维网联盟（外语缩写：W3C）创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构, W3C标准定义了一个用于应用程序开发的开放式Web平台，该平台具有前所未有的潜力，使开发人员能够构建丰富的交互体验，由任何设备上都可以使用的海量数据存储提供支持，W3C制定这些技术规范和指南的过程旨在最大限度地达成对技术报告内容的共识，确保高技术和编辑质量，并获得W3C和更广泛社区的认可。<br>官网地址: <a href="https://www.w3.org/standards/" target="_blank" rel="noopener">https://www.w3.org/standards/</a></p><p>其中标准不是某一个标准，而是一系列标准的集合，网页主要由三部分组成：<code>结构（Structure）、表现（Presentation）和行为（Behavior）</code>。</p><p>即对应的标准也分三方面：<br>1.结构化标准语言包括：HTML、XHTML(<code>可扩展超文本标记语言</code>)、XML(<code>可扩展标记语言</code>)、HTML5标准、SVG (<code>可缩放的矢量图形</code>) 标准<br>2.表现标准语言包括: CSS（<code>层叠样式表</code>）标准<br>3.行为标准包括: DOM（<code>文档对象模型</code>）标准 / ECMAScript 标准 (<code>ECMA-262</code>)</p><p>参考地址: <a href="https://www.webstandards.org/learn/faq/" target="_blank" rel="noopener">https://www.webstandards.org/learn/faq/</a></p><p><br></p><p><strong>什么是WHATWG?</strong></p><p>Web 超文本应用技术工作组 (WHATWG) 的组织于2004年成立,它是一个由四个主要的浏览器厂商（包括苹果、谷歌、微软、Mozilla）组成的行业组织。</p><p>该组的创建是由于 W3C 开发更现代的 HTML 标准的速度缓慢，并且计划将 HTML 转换成一个名为 XHTML 的变体（具有类似 XML 的结构），浏览器厂商不赞同这种做法，最终WHATWG 击败了W3C（万维网标准机构），赢得了 HTML 和 DOM 的控制权（标准）。</p><p><code>小小插曲</code>: WHATWG（当时由来自苹果、Mozilla 和 Opera 的成员组成）认为，W3C 的领导层（还包括许多与浏览器无关的实体）并没有把 Web 开发社区的最大利益放在心上。</p><p>他们表示反对并开发了后来成为 HTML 5 标准的东西，在浏览器厂商的支持下，W3C 和 WHATWG 宣布，他们终于把他们的分歧放在一边，并签署了一份新的谅解备忘录，并且 W3C 正式批准将其作为 HTML Web 标准的下一个主要迭代。</p><p>根据这份新协议，W3C 正式发布未来的 HTML 和 DOM 标准，并支持 WHATWG，将控制权完全交还给浏览器厂商。取而代之，W3C 及其数百名成员将起草未来的 Web 标准需要包含什么特性的“建议”, 然后，WHATWG 将决定把哪些加入到他们的产品中。</p><p>当前由 WHATWG 维护的 <code>HTML Living Standard</code> 将成为 HTML 标准的官方版本, <code>DOM Living Standard</code> 也是如此。</p><p><br/></p><p><strong>WHATWG 和 W3C 的合作</strong></p><p>由于认为有两个不同的 HTML 和 DOM 规范声称是规范性的信念通常对社区有害，并且将工作重新组合在一起的共同愿望，W3C 和 WHATWG 协商（部分）如下，如果感兴趣可参考下述链接：</p><ol><li><p>W3C 和 WHATWG 在 WHATWG 存储库中协同处理 HTML 和 DOM，以生成标准和建议/审核草稿快照。</p></li><li><p>WHATWG 维护 HTML 和 DOM 标准。</p></li><li><p>W3C 直接在 WHATWG 存储库中促进社区工作（桥接社区，开发用例，提交问题，编写测试，调解问题解决方案）。</p></li><li><p>W3C 停止独立发布与 HTML 和 DOM 相关的指定规范列表，而是将 WHWWG 审核草案纳入 W3C 建议书。</p></li></ol><p>参考来源: </p><ul><li>WHATWG 击败 W3C，赢得 HTML 和 DOM 的控制权: <a href="https://www.infoq.cn/article/bsvFxt96DOh-SBZphBwJ" target="_blank" rel="noopener">https://www.infoq.cn/article/bsvFxt96DOh-SBZphBwJ</a></li><li>W3C 和 WHATWG 之间的谅解备忘录: <a href="https://www.w3.org/2019/04/WHATWG-W3C-MOU.html" target="_blank" rel="noopener">https://www.w3.org/2019/04/WHATWG-W3C-MOU.html</a></li></ul><hr><h4 id="HTML、HTML5、XHTML、XML"><a href="#HTML、HTML5、XHTML、XML" class="headerlink" title="HTML、HTML5、XHTML、XML"></a>HTML、HTML5、XHTML、XML</h4><p><strong>什么是HTML?</strong></p><blockquote><p>HTML（超文本标记语言 —— HyperText Markup Language）是构成 Web 世界的一砖一瓦, 它定义了网页内容的含义和结构。<br>其通常与CSS（层叠样式表）连用，他们两个是构建 Web 的核心技术。前者HTML提供页面的结构，后者CSS提供（视觉和听觉）布局。</p></blockquote><p><br/></p><p><strong>什么是HTML5?</strong></p><blockquote><p>HTML5 是 (HyperText Markup Language 5) 的缩写，“HTML5”一词被广泛用作指代现代网络技术的流行语，HTML5 技术结合了 HTML4.01 的相关标准并革新，符合现代网络发展要求，它由不同的技术构成，其在互联网中得到了非常广泛的应用，HTML5中还结合了其他元素，对原有的功能进行调整和修改，针对视频、音频、图像、动画以及与设备的交互都进行了规范。</p></blockquote><p>标准参考: <a href="https://html.spec.whatwg.org/multipage/" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/</a> &amp;&amp; <a href="https://www.w3.org/html/" target="_blank" rel="noopener">https://www.w3.org/html/</a></p><p><br/></p><p><strong>HTML 历史版本</strong></p><blockquote><p>HTML 1.0 产生于1990年，1997年HTML4.0成为互联网标准, 2008年发布了HTML5它是互联网的下一代标准，2014年10月W3C发布了HTML5的最终版。</p></blockquote><p>扩展：随着YouTube彻底抛弃了Flash，实现向HTML5的全面过渡，越来越多的网站平台都开始转向使用HTML5开发。</p><p><br/></p><p><strong>什么是XHTML?</strong></p><blockquote><p>XHTML是HTML的一个变体，它使用 XML的语法，可扩展标记语言。XHTML有所有相同的元素（对于段落等）作为 HTML 变体，但语法略有不同, <code>因为XHTML是一个XML应用程序</code>，可以使用其他XML带有它的工具（例如 XSLT、 用于转换XML内容的语言）。</p></blockquote><p><br/></p><p><strong>什么是XML?</strong></p><blockquote><p>XML（可扩展标记语言）是一种简单的基于文本的格式 用于表示结构化信息：文档、数据、 配置、账簿、交易、发票等等。 它派生自一种较旧的标准格式，称为 SGML（ISO 8879），以便更适合Web使用。<br>其用途是共享结构化信息，在程序之间，人与人之间，计算机与人之间，两者兼而有之本地和跨网络。</p></blockquote><p>标准参考: <a href="https://www.w3.org/standards/xml/" target="_blank" rel="noopener">https://www.w3.org/standards/xml/</a></p><p><br/></p><p><strong>扩展参考</strong></p><p>W3C HTML+CSS介绍: <a href="https://www.w3.org/standards/webdesign/htmlcss" target="_blank" rel="noopener">https://www.w3.org/standards/webdesign/htmlcss</a><br>WHATWG 发布的技术标准: <a href="https://spec.whatwg.org/" target="_blank" rel="noopener">https://spec.whatwg.org/</a></p><hr><h4 id="CSS-标准"><a href="#CSS-标准" class="headerlink" title="CSS 标准"></a>CSS 标准</h4><p><strong>什么是CSS?</strong></p><blockquote><p>CSS（ Cascading Style Sheets , ——级联样式表）是描述结构化文档呈现的语言 （如 HTML 和 XML），包括颜色、布局和字体，它允许人们调整演示文稿 到不同类型的设备，例如 大屏幕、小屏幕或打印机。<br>CSS 独立于 HTML 和 可与任何基于 XML 的标记一起使用语言, HTML 与 CSS 的分离使得维护网站、共享变得更加容易，以及跨页面样式表和定制页面到不同的环境，当前最新版本为 CSS 3.0。</p></blockquote><p>标准参考: <a href="https://www.w3.org/Style/CSS/" target="_blank" rel="noopener">https://www.w3.org/Style/CSS/</a></p><hr><h4 id="DOM-标准"><a href="#DOM-标准" class="headerlink" title="DOM 标准"></a>DOM 标准</h4><p><strong>什么是DOM?</strong></p><blockquote><p>DOM（Document Object Model——文档对象模型）是用来呈现以及与任意 HTML 或 XML 文档交互的 API。<br>DOM 是载入到浏览器中的文档模型，以节点树的形式来表现文档，每个节点代表文档的构成部分（例如：页面元素、字符串或注释等等）。</p></blockquote><p><strong>扩展知识</strong><br>DOM 是万维网上使用最为广泛的 API 之一，因为它允许运行在浏览器中的代码访问文件中的节点并与之交互。节点可以被创建，移动或修改。事件监听器可以被添加到节点上并在给定事件发生时触发。</p><p>DOM 并不是天生就被规范好了的，它是浏览器开始实现JavaScript时才出现的。这个传统的 DOM 有时会被称为 DOM 0。现在WHATWG 维护 DOM 现存标准。</p><p>标准参考：<a href="https://dom.spec.whatwg.org/" target="_blank" rel="noopener">https://dom.spec.whatwg.org/</a></p><hr><h4 id="SVG-标准"><a href="#SVG-标准" class="headerlink" title="SVG 标准"></a>SVG 标准</h4><p><strong>什么是SVG?</strong></p><blockquote><p>可缩放矢量图形（Scalable Vector Graphics，SVG）基于 XML 标记语言，用于描述二维的矢量图形。</p></blockquote><p><strong>能做什么?</strong></p><blockquote><p>SVG 作为一个基于文本的开放网络标准，SVG 能够优雅而简洁地渲染不同大小的图形，并和CSS、DOM、JavaScript 和 SMIL 等其他网络标准无缝衔接。本质上，SVG 相对于图像，就好比 HTML 相对于文本。<br>SVG和传统的点阵图像模式（如 JPEG 和 PNG）不同的是，SVG 格式提供的是矢量图，这意味着它的图像能够被无限放大而不失真或降低质量，并且可以方便地修改内容，无需图形编辑器。通过使用合适的库进行配合，SVG 文件甚至可以随时进行本地化。</p></blockquote><p>当前 SVG 是由万维网联盟（W3C）自 1999 年开始开发的开放标准。</p><hr><h4 id="WebFonts-标准"><a href="#WebFonts-标准" class="headerlink" title="WebFonts 标准"></a>WebFonts 标准</h4><p><strong>什么是WebFonts？</strong><br>WebFonts是一种技术，它使人们能够在Web上按需使用字体，而无需在操作系统中安装。W3C拥有通过HTML、CSS2和SVG下载字体的经验。直到最近，由于缺乏可互操作的字体格式，可下载字体在Web上并不常见。WebFonts计划通过创建一种行业支持的、开放的Web字体格式（称为“WOFF”）来解决这一问题。</p><hr><h4 id="JavaScript、EcmaScript-标准"><a href="#JavaScript、EcmaScript-标准" class="headerlink" title="JavaScript、EcmaScript 标准"></a>JavaScript、EcmaScript 标准</h4><p><strong>什么是Javascript?</strong></p><blockquote><p>JavaScript（缩写:JS）是一门完备的动态编程语言。当应用于 HTML 文档时，可为网站提供动态交互特性。由布兰登·艾克（Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。<br>JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式,完整的JS实现包含三个部分：ECMAScript，文档对象模型和浏览器对象模型。</p></blockquote><p>除此之外，JavaScript 的流行程度，随着除浏览器外最流行的跨平台 JavaScript 运行环境——Node.js 平台的成功而大大提升。Node.js 使开发者可以在 PC 上使用 JavaScript 作为脚本语言以自动化处理和构建功能完备的 HTTP 和 Web Sockets (en-US) 服务器。</p><p>应用场景:</p><blockquote><p>JavaScript 的应用场合极其广泛，简单到幻灯片、照片库、浮动布局和响应按钮点击，复杂到游戏、2D/3D 动画、大型数据库驱动程序等等。<br>JavaScript 相当简洁，却非常灵活。开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。</p></blockquote><p><br/></p><p><strong>什么是EcmaScript?</strong></p><blockquote><p>JavaScript 和 JScript 与 ECMAScript 兼容，但包含超出 ECMAScript 的功能，简单的说ECMAScript有的JS都有。<br>由于发展初期，JavaScript的标准并未确定，同期有Netscape网景的JavaScript，微软的JScript和CEnvi的ScriptEase三足鼎立。直至1997年，在ECMA (<code>欧洲计算机制造商协会-European Computer Manufacturers Association</code>) 的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准ECMA-262，称之为ECMAScript，</p></blockquote><p>EcmaScript 版本：ES5于2009年发布；ES6于2015年发布，也称ES2015；ES7于2016年发布，当前最新版为ECMAScript 7。</p><p>标准参考: </p><ul><li><a href="https://www.ecma-international.org/publications-and-standards/standards/" target="_blank" rel="noopener">https://www.ecma-international.org/publications-and-standards/standards/</a></li><li><a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="noopener">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a></li></ul><p><br/></p><p>温馨提示：</p><ul><li>ECMA：读音类似“埃科妈”，是欧洲计算机制造商协会（European Computer Manufacturers Association）的简称，是一家国际性会员制度的信息和电信标准组织。</li><li>Ecma 国际：1994 年之后，由于 ECMA 组织的标准牵涉到很多其他国家，为了体现其国际性，更名为 Ecma 国际（Ecma International）。</li><li>ECMAScript： 由 Ecma 国际在标准 ECMA-262 中定义的脚本语言规范， JavaScript 是 ECMA-262 标准的实现和扩展。</li><li>ECMA-262：Ecma 国际的标准，都会以 Ecma-Number 命名，ECMA-262 就是 ECMA 262 号标准，具体就是指 ECMAScript 遵照的标准。1996 年 11 月，网景公司将 JavaScript 提交给 Ecma 国际进行标准化, ECMA-262 的第一个版本于 1997 年 6 月被 Ecma 国际采纳。</li></ul><p>温馨提示：虽然最常见的脚本语言ECMAscript（更广泛地称为JavaScript）是由Ecma开发的，但浏览器中提供的许多API都是由W3C定义的。例如，ECMAScript 规范并没有描述文档对象模型（DOM），该模型由 万维网联盟（W3C）制定。</p><hr><h4 id="小程序-MiniApp-标准"><a href="#小程序-MiniApp-标准" class="headerlink" title="小程序(MiniApp) 标准"></a>小程序(MiniApp) 标准</h4><p><strong>什么是小程序?</strong></p><blockquote><p>MiniApp是一种新的移动应用程序格式，一种依赖于Web技术（特别是CSS和JavaScript）并与本机应用程序功能集成的混合解决方案。<br>超级应用程序是一个托管和支持其他应用程序（即小应用程序）的软件平台，通过使用平台的资源来执行它们。</p></blockquote><p><strong>应用场景&amp;特点</strong><br>MiniApps因其在一些超级应用程序上的使用而流行起来，因为它诞生了一些字符，有助于填补Web和本机之间的空白。</p><ul><li>它无需安装。</li><li>多个 Web 视图以提高性能。</li><li>它提供了一些通过本机访问操作系统功能或数据的机制。</li><li>内容通常更值得信赖，因为应用程序需要由平台验证。</li><li>一个小应用可以分发到多个小应用平台（Web、本机应用程序，甚至操作系统），这些平台还提供小程序的入口，以确保用户可以轻松发现它。</li></ul><p><br/></p><p>扩展学习： 小应用并非旨在取代渐进式 Web 应用程序 （PWA）、本机应用程序或 Web。</p><p>其主要区别如下</p><ul><li>PWA可以在浏览器中的几乎任何支持Web的环境中运行，而MiniApp绑定到特定平台或超级应用程序</li><li>分发机制的不同，MiniApps打包和独立，PWA的资源分布在网络上。</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230216173440.png" alt="WeiyiGeek.MiniApp应用和PWA的架构图" title="" class="">                <p>WeiyiGeek.MiniApp应用和PWA的架构图</p>            </figure><p>下表总结了其中一些差异:</p><table><thead><tr><th>特征</th><th>渐进式网络应用程序</th><th>小程序</th></tr></thead><tbody><tr><td>源代码</td><td>标准标记语言 （HTML）、样式表 （CSS） 和脚本 （JavaScript）。</td><td>HTML、CSS 和 JavaScript 的非标准方言</td></tr><tr><td>已部署格式</td><td>Web资源（主要：HTML，CSS，JavaScript代码和WebAssembly模块）</td><td>HTML，CSS，JavaScript和其他资源打包在ZIP容器中。</td></tr><tr><td>包装</td><td>否。Web 上链接的资源。</td><td>是的。每个供应商不同的封装格式。</td></tr><tr><td>需要在 Web 服务器上托管文件</td><td>是的</td><td>不</td></tr><tr><td>免安装使用</td><td>是的，在浏览器中运行。</td><td>在<a href="https://www.w3.org/TR/mini-app-white-paper/#dfn-super-app" target="_blank" rel="noopener">超级应用</a>或操作系统上运行。</td></tr><tr><td>使用独立图标安装</td><td>从浏览器或应用市场（可选）</td><td>不</td></tr><tr><td>服务业</td><td>访问网络应用程序接口</td><td>访问非标准 Web API，包括某些系统本机 API</td></tr></tbody></table><p>标准参考: <a href="https://www.w3.org/TR/mini-app-white-paper/" target="_blank" rel="noopener">https://www.w3.org/TR/mini-app-white-paper/</a></p><hr><h3 id="9-研发工具"><a href="#9-研发工具" class="headerlink" title="9.研发工具"></a>9.研发工具</h3><p>俗话说，工欲善其事必先利其器，作为一个前端开发者，必须要有适合自己的开发编辑器、浏览器调试器工具以及有一定的美工，图像处理功底，其次是了解学习在企业开发中协同开发最重要的代码版本管理相关工具。</p><h4 id="开发编辑器"><a href="#开发编辑器" class="headerlink" title="开发编辑器"></a>开发编辑器</h4><p>由于市场上开发工具很多，此处作者介绍最常用的几款前端开发工具（PS:当然也可以使用其做其他编程开发）。</p><h5 id="Visual-Studio-Code-首选"><a href="#Visual-Studio-Code-首选" class="headerlink" title="Visual Studio Code (首选)"></a>Visual Studio Code (首选)</h5><p>Visual Studio Code，简称VS code，是微软公司开发的一款轻量级的开发工具，它是基于开源构建即免费自由，支持市场上众多开发语言，包括但不限于（Java、Go、Javascript、Python、C++、C#）等。</p><p><strong>其特点如下:</strong></p><ul><li>开源，免费。</li><li>智能提示，借助 IntelliSense 超越语法突出显示和自动完成功能，它提供基于变量类型、函数定义和导入模块的智能补全功能。</li><li>调试功能强大，启动或附加到正在运行的应用，并使用断点、调用堆栈和交互式控制台进行调试。</li><li>内置 Git 命令，查看差异、暂存文件并直接从编辑器进行提交。</li><li>可扩展和可定制，市场应用上有众多强大的插件，实现编辑器功能增强。</li><li>自信而轻松地进行部署，借助 Microsoft Azure，您可以部署和托管React，Angular，Vue，Node，Python（以及更多！）站点，存储和查询关系和基于文档的数据，并使用无服务器计算进行扩展。（当然也能借助插件实现其他云服务器部署）</li><li>跨平台，其支持Windows、Linux、以及苹果 MacOS 系统上运行。</li></ul><p>VS 官网(下载递增)地址: <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a><br>Github 项目地址: <a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">https://github.com/Microsoft/vscode</a></p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230217092345.png" alt="WeiyiGeek.VS官网下载示例图" title="" class="">                <p>WeiyiGeek.VS官网下载示例图</p>            </figure><p>温馨提示：Visual Studio Code 编辑器常规配置以及常用插件可以参考此篇文章 【 <a href="https://blog.weiyigeek.top/2019/3-8-375.html#1-Visual-Studio-Code-编辑器">https://blog.weiyigeek.top/2019/3-8-375.html#1-Visual-Studio-Code-编辑器</a> 】</p><p><br/></p><h5 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h5><p>Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器, 当前版本为  Sublime Text 4</p><p><strong>其特色功能如下:</strong></p><ul><li>良好的扩展功能，官方称之为安装包 (Package)。</li><li>右边没有滚动条，取而代之的是代码缩略图，这个功能非常赞</li><li>强大的快捷命令 “可以实时搜索到相应的命令、选项、snippet 和 syntex， 按下回车就可以直接执行，减少了查找的麻烦。”</li><li>即时的文件切换。</li><li>随心所欲的跳转到任意文件的任意位置。</li><li>多重选择 (Multi-Selection) 功能允许在页面中同时存在多个光标。</li><li>支持 VIM 模式</li><li>支持宏，简单地说就是把操作录制下来或者自己编写命令，然后播放刚才录制的操作或者命令。</li><li>支持GPU渲染, 它可以在Linux、Mac和Windows上使用GPU渲染界面</li></ul><p>官网地址: <a href="https://www.sublimetext.com/" target="_blank" rel="noopener">https://www.sublimetext.com/</a></p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230217093603.png" alt="WeiyiGeek.Sublime Text下载示例图" title="" class="">                <p>WeiyiGeek.Sublime Text下载示例图</p>            </figure><p><br/></p><h4 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h4><p>WebStorm 最聪明的JavaScript IDE，是由JetBrains公司推出，WebStorm 是一个适用于 JavaScript 和相关技术的集成开发环境。类似于其他 JetBrains IDE，它也会使您的开发体验更有趣，自动执行常规工作并帮助您轻松处理复杂任务，有30天试用期限，或者免费的教育版本。它可以轻松进行 JavaScript 开发：</p><ul><li>代码检测，更可靠和更易于维护的代码。</li><li>享受高效的编码，得益于 JavaScript 开发所需的全部功能开箱即用，您可以直接开始编码</li><li>减轻处理复杂任务的压力，WebStorm 将简化这些和其他具有挑战性的任务，以便您专注于大局。</li></ul><p><strong>其特色功能如下:</strong></p><ul><li>专门针对 JavaScript 打造: 无论您是使用 JS、TS、React、Vue、Angular、Node.js、HTML 还是各种样式表，WebStorm 都能满足您的需求。</li><li>最智能的编辑器: 自动补全代码、检测错误和冗余并提供修复建议，以及帮助您安全地重构代码。</li><li>内建开发者工具: 使用 WebStorm 调试和测试您的客户端和 Node.js 应用，并利用版本控制。充分使用 linter、构建工具、终端和 HTTP 客户端，这些均已经与 IDE 集成。</li><li>快速导航和搜索: 查找文件、类或符号，并在一个地方查看所有匹配条目。只需点击几次，即可跳到任何函数、方法、变量、组件或类的定义，并找到其用法。</li><li>高效的团队合作: 共享您的项目配置，包括代码样式设置，并高效使用 Git 和 GitHub。</li><li>可自定义环境: 体验各种主题和插件等，根据您的喜好定制 WebStorm 的外观。保存您的自定义设置并在 WebStorm 的不同实例之间共享。</li></ul><p>Webstorm 官网地址: <a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">https://www.jetbrains.com/webstorm/</a><br>Webstorm 中文官网地址: <a href="https://www.jetbrains.com.cn/webstorm/" target="_blank" rel="noopener">https://www.jetbrains.com.cn/webstorm/</a></p><p><img src="https://img.weiyigeek.top/2023/1/20230217094629.png" alt="WeiyiGeek.WebStorm官网下载示例图"></p><p>温馨提示: JetBrains 系列IDE实在是太强大了，几乎涵盖到市场中常见热门的编程开发语言，包括Java、PHP、Ruby、Python、JavaScript、Kotlin、Objective-C 以及 .NET，都可以用 JetBrains 系列的IDE编辑器实现，例如 Python 开发的Pycharm IDE。</p><p>温馨提示: 当然上述这些 IDE 编辑器需要收费激活，但是 JetBrains 提供教育认证，如果你是高校的学生或者认证，都可以通过 <code>JetBrains 教育优惠认证来免费使用 JetBrains 全家桶</code>。 操作流程可以参考【 <a href="https://blog.weiyigeek.top/2019/3-8-527.html#1-教育邮箱免费激活-JetBrains-全家桶（学生-amp-教师认证）">https://blog.weiyigeek.top/2019/3-8-527.html#1-教育邮箱免费激活-JetBrains-全家桶（学生-amp-教师认证）</a> 】</p><p><br/></p><h4 id="程序调试预览"><a href="#程序调试预览" class="headerlink" title="程序调试预览"></a>程序调试预览</h4><p>前端开发中免不了进行调试预览，通过一些好的调试工具可以让您的开发找Bugs，事半功倍！</p><h5 id="浏览器调试工具"><a href="#浏览器调试工具" class="headerlink" title="浏览器调试工具"></a>浏览器调试工具</h5><p><strong>FireBug</strong></p><blockquote><p>介绍：Firebug是网页浏览器 Mozilla Firefox 下的一款开发类扩展，现属于Firefox的五星级强力推荐扩展之一。它集HTML查看和编辑、Javascript控制台、网络状况监视器于一体，是开发JavaScript、CSS、HTML和Ajax的得力助手。Firebug如同一把精巧的瑞士军刀，从各个不同的角度剖析Web页面内部的细节层面，给Web开发者带来很大的便利。</p></blockquote><p>如何打开 FireBug ?</p><blockquote><p>首先，你肯定需要安装最新版本的 Mozilla Firefox （火狐浏览器），<a href="http://www.firefox.com.cn/" target="_blank" rel="noopener">http://www.firefox.com.cn/</a> 。<br>其次，菜单栏【工具】-&gt; 【浏览器工具】 -&gt; 【Web开发者工具】 或者直接快捷键 【Ctrl+Shift+I】或者【F12】打开。<br>最后，打开后如下图所示。</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230217103018.png" alt="WeiyiGeek.火狐浏览器Web开发者工具图" title="" class="">                <p>WeiyiGeek.火狐浏览器Web开发者工具图</p>            </figure><p><br/></p><p><strong>Chrome DevTools</strong></p><blockquote><p>想必接触过开发的看友，必然知道Google浏览器吧，此Chrome开发者工具，也是前端开发者必备之一。</p></blockquote><p>如何打开 Chrome DevTools ?</p><blockquote><p>首先，你肯定需要安装最新版本的 Google Chrome （google浏览器），<a href="https://www.google.cn/chrome/" target="_blank" rel="noopener">https://www.google.cn/chrome/</a> 。<br>其次，右边【自定义及控制Google chrome】-&gt; 【更多工具】 -&gt; 【Web开发者工具】 或者直接快捷键 【Ctrl+Shift+I】或者【F12】打开。<br>最后，打开后如下图所示。</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230217104015.png" alt="WeiyiGeek.Google浏览器开发者工具图" title="" class="">                <p>WeiyiGeek.Google浏览器开发者工具图</p>            </figure><p><br/></p><p><strong>本地服务</strong></p><ul><li><p>file:// : 本地在没有Web容器服务时，可以直接通过浏览器访问本地静态文件进行调试，例如，<code>file:///E:/githubProject/WeiyiGeek/index.html</code></p></li><li><p>http:// : 本地如果有Web容器服务（SimpleHTTPServer、nginx、Tomcat、httpd）可以直接通过服务监听端口访问，此处我结合VS浏览器的<code>Live Serve</code>r插件实现前端页面自动更改。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - python 环境下快速启动http环境</span></span><br><span class="line"><span class="comment"># Python2</span></span><br><span class="line">python -m SimpleHTTPServer 8080</span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">python3 -m http.server -p 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># - PHP 环境下快速启动http环境</span></span><br><span class="line"><span class="built_in">exec</span> php -S 0:8081 index.html</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230217104843.png" alt="WeiyiGeek.vs编辑器Live Server插件调试图" title="" class="">                <p>WeiyiGeek.vs编辑器Live Server插件调试图</p>            </figure><p><br/></p><p><strong>在线服务</strong></p><ul><li>CodePen : CodePen 是构建、测试和发现前端代码的最佳场所，CodePen 是面向前端设计人员和开发人员的社交开发环境。构建和部署网站，展示您的工作，构建测试用例以学习和调试，并寻找灵感。<blockquote><p>简单的说就是在线实时预览，调试前端代码编写效果。<br>项目地址: <a href="https://codepen.io/features/" target="_blank" rel="noopener">https://codepen.io/features/</a><br>代码预览: <a href="https://codepen.io/pen/" target="_blank" rel="noopener">https://codepen.io/pen/</a></p></blockquote></li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230217110722.png" alt="WeiyiGeek.CodePen使用示例图" title="" class="">                <p>WeiyiGeek.CodePen使用示例图</p>            </figure><ul><li>JSFiddle : 它是一个Web开发人员的练习场,可在线即时编辑和测试 HTML、CSS、JavaScript代码片段（PS: 与 CodePen 差不多）。<blockquote><p>代码预览: jsfiddle.net</p></blockquote></li></ul><p><br/></p><p><strong>网络调试</strong><br>网络调试也是在前端开发中必不可少的，例如前后端项目，通常会请求后端提供的API接口，前端接收返回的响应数据（json、xml），然后返回给前台进行展示。<br>我们使用网络调试来查看http请求以及（cors）请求是否得到正常的响应，以便快速开发。</p><ul><li>hosts、Switchhosts : 通常用于解析测试环境的域名与开发服务器IP对应关系,例如本地将 demo.weiyigeek.top 域名解析到 192.168.16.222</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows</span></span><br><span class="line">notepad C:\Windows\System32\drivers\etc\hosts</span><br><span class="line">192.168.16.222 demo.weiyigeek.top</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux</span></span><br><span class="line">tee -a /etc/hosts &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">192.168.16.222 demo.weiyigeek.top</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>Debugging Proxy、Charles : Charles是一个HTTP代理/HTTP监视器/反向代理，使开发人员能够查看其机器和Internet之间的所有HTTP和SSL / HTTPS流量。这包括请求、响应和 HTTP 标头（包含 Cookie 和缓存信息）。</li></ul><figure class="image-box">                <img src="https://www.charlesproxy.com/assets/sm/upload/e8/jh/mj/ox/charles-windows.png?k=81ba37843a" alt="Debugging Proxy、Charles" title="" class="">                <p>Debugging Proxy、Charles</p>            </figure><ul><li>wireshark: Wireshark 是当前最重要和广泛使用的网络协议分析器，它可以让您看到您的微观层面的网络，即分析网络协议以及验证数据传输过程，在网络工程中它是必备的。<blockquote><p>Wireshark具有丰富的功能集，其中包括 以后：</p><ul><li>对数百个协议进行深入检查，并添加更多协议 时间</li><li>实时捕获和离线分析</li><li>标准三窗格数据包浏览器</li><li>多平台：运行在Windows，Linux，macOS，Solaris，FreeBSD， NetBSD和许多其他人</li><li>捕获的网络数据可以通过GUI或TTY模式浏览 夏克实用程序</li><li>业内最强大的显示过滤器</li><li>丰富的网络语音分析</li><li>读/写许多不同的捕获文件格式：tcpdump（libpcap）， Pcap NG， 弹射器 DCT2000， 思科安全 IDS iplog， 微软网络 监视器，网络通用嗅探器®（压缩和未压缩）， Sniffer® Pro和NetXray®，Network Instruments Observer，NetScreen Snoop， Novell LANalyzer， RADCOM WAN/LAN ANALYZER， Shomiti/Finisar 测量员， 泰克 K12xx， 视觉网络视觉正常运行时间， WildPackets EtherPeek/TokenPeek/AiroPeek等</li><li>使用gzip压缩的捕获文件可以即时解压缩</li><li>实时数据可以从以太网、IEEE 802.11、PPP/HDLC、ATM 读取。 蓝牙、USB、令牌环、帧中继、FDDI 等（取决于 在您的平台上）</li><li>解密支持许多协议，包括IPsec，ISAKMP， Kerberos、SNMPv3、SSL/TLS、WEP 和 WPA/WPA2<ul><li>着色规则可以应用于数据包列表，以便快速， 直观的分析</li><li>输出可以导出为 XML、PostScript®、CSV 或纯文本</li></ul></li></ul></blockquote></li></ul><p><br/></p><h4 id="图片编辑器"><a href="#图片编辑器" class="headerlink" title="图片编辑器"></a>图片编辑器</h4><p>前端除了代码的开发调试，对于全栈当然也涉及到图片美工，我们需要针对下述流行的图像处理软件进行学习了解，方便在后续前端开发时有图像处理时可以快速响应，以及在开发时提供排版、配色方面的基础知识储备。</p><h5 id="PhotoShop"><a href="#PhotoShop" class="headerlink" title="PhotoShop"></a>PhotoShop</h5><p>描述: PhotoShop 是由 Adobe 公司推出的一款图像处理专业软件，它可以进行图像修建、颜色（调色）、磨皮、背景消除、动画等方面的处理，实际上最新版本它也可以进行视频图像处理。</p><p>Photoshop 2022 软件在 Windows 操作系统上安装最低要求:</p><blockquote><p>操作系统:    Windows10 64位(版本20H2)或后；LTSC版本都不支持<br>多核英特尔®或AMD处理（64位）、<br>8G RAM<br>1.5GB GPU<br>分辨率 1280x800<br>硬盘 20GB的可用硬盘空间 </p></blockquote><p>官网地址: <a href="https://www.adobe.com/products/photoshop.html" target="_blank" rel="noopener">https://www.adobe.com/products/photoshop.html</a></p><p>学习指南: <a href="https://helpx.adobe.com/photoshop/user-guide.html" target="_blank" rel="noopener">https://helpx.adobe.com/photoshop/user-guide.html</a></p><p><br/></p><h5 id="Sketch"><a href="#Sketch" class="headerlink" title="Sketch"></a>Sketch</h5><p>描述: 它是一个Mac应用程序，供设计师创建，组队，原型等等，供其他人浏览、提供反馈、检查和切换— 在任何浏览器中。<br>借助周到的功能，使日常任务变得简单，以及不会中断流程的直观界面，他可以完成网站、成型、图标、应用程序、符号以及插图和设计系统方面的设计。</p><p><strong>主要功能：</strong></p><ul><li>强大的矢量编辑</li><li>简单、直观的原型设计</li><li>共享库，样式和组件</li><li>控制颜色配置文件</li><li>变量和OpenType字体支持</li><li>可重复使用的设计模板</li><li>单人或者实时协同设计</li><li>储存和同步你的工作</li></ul><p><img src="https://sketch-cdn.imgix.net/assets/pages/homepage/frames/mac-app-websites%402x.jpg?ixlib=rb-4.1.0&amp;dpr=0.5&amp;q=95&amp;fm=png&amp;auto=format&amp;s=2eff2b09592da97f72ff7346d1d84199" alt="Sketch原型设计"></p><p>官网地址: <a href="https://www.sketch.com/" target="_blank" rel="noopener">https://www.sketch.com/</a></p><p><br/></p><h4 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h4><p>此小节将讲解代码版本管理（分为集中式、分布式），它是在程序开发中非常重要的一环，方便代码更新迭代，协同开放，快速回滚，其目的是帮助开发者/团队/企业更好地管理代码，让软件研发更高效。</p><h5 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h5><p>描述：当前常用的Git代码托管平台有Github（已被微软收购）、Gitlab (社区版本企业私有化部署)、bitbucket、Gitee 码云、coding.net。</p><ul><li>Github : 全世界最大的代码托管平台，想必大家都有耳闻，此处我就不详细介绍了，官网地址: <a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></li><li>Gitlab : 支持无限的公有项目和私有项目,社区版本支持在企业内部离线部署，官网地址：<a href="https://about.gitlab.com" target="_blank" rel="noopener">https://about.gitlab.com</a></li><li>Bitbucket : 类似于Github的免费代码托管空间,其免费支持5个开发成员的团队创建无限私有代码托管库，官网地址: <a href="https://bitbucket.org" target="_blank" rel="noopener">https://bitbucket.org</a></li><li>Gitee 码云: 国内企业级 DevOps 研发管理平台，官网地址: <a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a></li><li>coding.net: 国内腾讯云推出的代码托管平台，可以直接将代码部署到腾讯云服务器上非常方便，其次功能与开源中国相似，同样一个账号最多可以创建1000个项目，也支持任务的创建等，官网地址: coding.net</li></ul><p><br/></p><h5 id="代码项目版本控制工具"><a href="#代码项目版本控制工具" class="headerlink" title="代码项目版本控制工具"></a>代码项目版本控制工具</h5><p>描述：前面我们提高过版本管理控制工具主要分为两种，集中式管理与分布式管理，其分部对应了SVN（一些传统企业还在用）与GIT（主流）</p><p>那什么是版本控制系统？</p><blockquote><p>答：使用版本控制系统通常还意味着自动帮我记录每次文件的改动，还可以让同事协作编辑，就算你胡来搞砸了整个项目，把文件改的改，删的删，你也可以轻松恢复到原先的样子。这样你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。</p></blockquote><p><br/></p><p><strong>Git (推荐)</strong></p><blockquote><p>Git是目前世界上最先进的分布式版本控制系统（没有之一），用于敏捷高效地处理任何或小或大的项目是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p></blockquote><p>官网地址: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>温馨提示: 此处对于Git不熟悉的朋友，可以参考博主的 Git学习之路 【 <a href="https://blog.weiyigeek.top/2018/1-1-1.html#Git学习之路汇总">https://blog.weiyigeek.top/2018/1-1-1.html#Git学习之路汇总</a> 】</p><p><br/></p><p><strong>SVN</strong></p><blockquote><p>Apache Subversion 通常被缩写成 SVN,是一个开源的中心服务器版本控制系統，Subversion 在 2000 年由 CollabNet Inc 开发，现在发展成为 Apache 软件基金会的一个项目，同样是一个丰富的开发者和用户社区的一部分(现在基本已经被git取代);</p></blockquote><p>为什么要使用SVN？</p><blockquote><p>答：程序员在编写程序的过程中，每个程序员都会生成很多不同的版本，这就需要程序员有效的管理代码，在需要的时候可以迅速，准确取出相应的版本。而这些数据是放置在一个中央资料档案库(repository) 中，这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动；这样您才能把档案恢复到旧的版本, 或是浏览文件的变动历史。</p></blockquote><p>官网地址: <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p>温馨提示: 此处需要快速上手体验的SVN的朋友，可以参考博主的 SVN入门安装配置与使用，【 <a href="https://blog.weiyigeek.top/2019/3-8-371.html">https://blog.weiyigeek.top/2019/3-8-371.html</a> 】</p><p><br/></p><p><strong>Q: 为什么不选择SVN而选择GIT</strong><br>答：说到这里不得不提到集中式vs分布式的分别对比;<br>Linus一直痛恨的CVS、SVN都是集中式的版本控制系统(Centralized Version Control Systems，简称 CVCS )，而Git、BitKeeper、Mercurial和Bazaar是分布式版本控制系统；</p><ul><li><p>集中式版本控制系统</p><blockquote><p>CVS（是一个C/S系统，是一个常用的代码版本控制软件，主要在开源软件管理中使用，与它相类似的代码版本控制软件有subversion）作为最早的开源而且免费的集中式版本控制系统。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。<br>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。<br>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p></blockquote></li><li><p>分布式版本控制系统</p><blockquote><p>除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p></blockquote></li></ul><p><strong>Q: 集中式和分布式版本控制系统有什么区别呢？</strong></p><blockquote><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等, 如果你熟悉使用SVN也是可以的，但是在企业开发中大多是使用Git，此时你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。</p></blockquote><blockquote><p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</p></blockquote><blockquote><p>比如：中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了再放回图书馆。</p></blockquote><blockquote><p>所以说，集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p></blockquote><figure class="image-box">                <img src="https://www.runoob.com/wp-content/uploads/2015/02/0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg" alt="Git 与 SVN 区别" title="" class="">                <p>Git 与 SVN 区别</p>            </figure><p>本章节学习至此就要完毕了，请期待作者的下一章节HTML标签学习总结文章。</p><hr><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li>元素<ul><li>根元素<ul><li>主根元素 html</li><li>分区根元素 body</li></ul></li><li>元数据<ul><li>base、head</li></ul></li><li>内容分区<ul><li>header、footer</li></ul></li><li>内容<ul><li>块级内容 div、dir</li><li>文字内容 a、b、strong</li></ul></li><li>图片和多媒体<ul><li>audio、img</li></ul></li><li>内嵌内容<ul><li>iframe、object</li></ul></li><li>脚本<ul><li>canvas、script</li></ul></li><li>表格<ul><li>table、tbody</li></ul></li><li>表单<ul><li>button、input</li></ul></li><li>可交互元素<ul><li>menu、menuitem</li></ul></li></ul></li><li>属性<ul><li>常用属性<ul><li>class、id、style、title</li></ul></li><li>全局属性</li></ul></li><li>事件<ul><li>窗口事件</li><li>表单事件</li><li>键盘事件</li><li>鼠标事件</li><li>多媒体事件</li></ul></li><li>编码<ul><li>URL编码</li><li>语言代码</li><li>字符集</li></ul></li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>语法<ul><li>@规则</li><li>层叠</li><li>注释</li><li>解释器</li><li>继承</li><li>简写</li><li>优先级</li><li>值定义</li><li>单位与取值类型</li></ul></li><li>选择器<ul><li>元素选择器</li><li>选择器分组</li><li>类选择器</li><li>ID 选择器</li><li>属性选择器</li><li>后代选择器</li><li>子元素选择器</li><li>相邻选择器</li><li>伪类</li><li>伪元素</li></ul></li><li>定位<ul><li>position</li><li>top、left、bottom、right</li><li>z-index</li></ul></li><li>布局<ul><li>Box Model</li><li>FlexBox</li><li>Grid</li><li>Column</li></ul></li><li>样式<ul><li>背景</li><li>文本</li><li>轮廓</li><li>列表</li></ul></li><li>动画<ul><li>Animation</li><li>transition</li></ul></li><li>应用<ul><li>响应式<ul><li>em、vh/vw、%</li></ul></li><li>自适应<ul><li>@media、rem</li></ul></li></ul></li></ul><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>开始使用 JavaScript 很容易，你只需要一个现代 Web 浏览器。这篇教程包含了一些只在最新版本的火狐浏览器上才有的功能，所以建议大家使用最新版本的火狐浏览器。</p><p>火狐浏览器内置的 Web 控制台非常适合学习 JavaScript,Web 控制台包含两个输入模式——单行模式、多行模式。</p><p>JavaScript 学习指南:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide</a></p><ul><li>语法<ul><li>值、变量</li><li>数据类型<ul><li>基本类型</li><li>类型判断</li><li>类型转换</li></ul></li><li>流程控制</li><li>运算（表达式、运算符）<ul><li>数学</li><li>比较</li><li>逻辑</li></ul></li><li>函数<ul><li>函数声明</li><li>函数表达式</li><li>回调函数</li><li>箭头函数</li></ul></li></ul></li><li>数据类型深入<ul><li>原始类型的方法</li><li>数字类型</li><li>字符串</li><li>数组</li><li>数组方法</li><li>Iterable object（可迭代对象）</li><li>Map and Set（映射和集合）</li><li>WeakMap and WeakSet（弱映射和弱集合）</li><li>Object.keys、values、entries</li><li>解构赋值</li><li>日期和时间</li><li>JSON序列化、反序列化</li></ul></li><li>对象<ul><li>属性/字面量</li><li>in 、for…in</li><li>对象引用</li><li>深拷贝、浅拷贝</li><li>Symbol</li><li>垃圾收集机制</li><li>this</li><li>new</li><li>Optional chaining ‘?.’</li><li>类型转换Symbol.toPrimitive</li><li>Property flags、descriptors</li><li>getters、setters</li></ul></li><li>函数<ul><li>调用栈</li><li>递归、尾递归</li><li>arguments、params spread</li><li>作用域、闭包</li><li>var、变量提升</li><li>IIFE、匿名自执行函数</li><li>NFE、函数命名表达式</li><li>箭头函数</li><li>new Function</li><li>setTimeout、setInterval</li><li>call、apply、bind</li><li>部分施用、柯里化</li></ul></li><li>原型<ul><li>原型链、继承</li><li>F.prototype</li><li>Object.prototype</li></ul></li><li>类<ul><li>extend 继承</li><li>方法重载</li><li>构造函数</li><li>Super、[[HomeObject]]</li><li>静态属性、静态函数</li><li>私有属性、私有函数</li><li>混合、Mixins</li></ul></li><li>异步流程控制<ul><li>Callback</li><li>Promise<ul><li>Promises/A+、Promisification、Thenable</li></ul></li><li>async/await</li><li>generator</li><li>iterable</li></ul></li><li>模块化<ul><li>commonJS</li><li>amd、cmd、umd、es-module</li></ul></li><li>异常捕获<ul><li>try…catch…finally</li><li>throw</li><li>Error</li></ul></li></ul><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li>DOM<ul><li>DOM Tree</li><li>DOM Node</li><li>DOM Query</li><li>DOM Properties</li><li>DOM Modify</li><li>Styles</li><li>Coordinates、Element Scrolling</li><li>DOM Events<ul><li>UI Event</li><li>Bubbling and Capturing</li><li>Event Delegate</li></ul></li></ul></li><li>浏览器API<ul><li>location</li><li>history</li><li>navigator</li><li>Default Actions<ul><li>event.preventDefault()</li></ul></li><li>Form<ul><li>change、focus、blur、submit</li></ul></li></ul></li><li>网络<ul><li>XHR</li><li>Fetch</li><li>JSONP</li><li>WebSocket</li></ul></li><li>权限<ul><li>Cookie</li><li>Session</li><li>OAuth</li><li>SSO</li><li>JWT</li></ul></li><li>安全与隐私<ul><li>Content Security Policy (CSP)</li><li>CORS</li><li>XSS</li><li>CSRF</li><li>MITM</li><li>Samesite</li></ul></li><li>兼容性<ul><li>Can I Use</li><li>polyfill</li><li>shim</li><li>browserslist</li><li>Autoprefixer</li></ul></li><li>开发者工具<ul><li>设备模式</li><li>元素面板</li><li>控制台面板</li><li>源代码面板</li><li>网络面板</li><li>性能面板</li><li>内存面板</li><li>应用面板</li><li>安全面板</li></ul></li></ul><p>[<a href="https://blog.weiyigeek.top/2019/10-21-10.html]">https://blog.weiyigeek.top/2019/10-21-10.html]</a>: </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.weiyigeek.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端学习" scheme="https://blog.weiyigeek.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="全栈学习" scheme="https://blog.weiyigeek.top/tags/%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>1.全栈修炼之前端《基础前置知识体系》学习笔记</title>
    <link href="https://blog.weiyigeek.top/2023/2-14-711.html"/>
    <id>https://blog.weiyigeek.top/2023/2-14-711.html</id>
    <published>2023-02-14T10:34:30.000Z</published>
    <updated>2023-02-19T02:20:35.333Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0X00-前言简述"><a href="#0X00-前言简述" class="headerlink" title="0X00 前言简述"></a>0X00 前言简述</h2><p>有可能有的小伙伴会问，你作为一名安全运维开发(SecOpsDev)工程师，为啥会整理学习前端相关技术笔记呢?</p><p>一是为了补齐自己的知识短板（形成知识体系结构），毕竟来说一般会运维的不会开发，会开发的不一了解安全，而成为一名网络安全工作者或者说白帽子，你就势必什么都是知道一点，但是等待你学到一定层度后，你会发现遇到的瓶颈越来越多，此时你可能会非常迷茫也很苦恼，要么有的就放弃这条路（转型），要不就重头再来恶补基础知识，比如像笔者我。</p><p>二是为了将自己所学的东西、学习路径分享出来，帮助某些计算机爱好者（同道中人）入门学习，其次是为了加固自身所学的知识，可谓是一举两得。</p><p>三是为了项目的需求不得不对前端知识进行饿补，毕竟还是要在完成工作的前提为指导，因为领导关心的就是<code>能不能做</code>以及<code>能不能做成</code>，谁不爱有产出的员工(tool man，嘻嘻)。</p><p>好的，废话不多说，从2023年2月16日开始，一起跟着【WeiyiGeek】来看一下我的前端学习之路吧，希望对你们学习有帮助!</p><p>送给各位读者的话，<code>成大事不在于力量的大小，而在于能坚持多久</code>。</p><p><strong>原文地址:</strong></p><ul><li>[全栈之路-前端篇 | 第一讲.基础前置知识【浏览器内核与网络知识】学习笔记] <a href="https://mp.weixin.qq.com/s/XYyRp1WeAwl3PcSSw5_rAQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XYyRp1WeAwl3PcSSw5_rAQ</a></li><li>[全栈之路-前端篇 | 第二讲.基础前置知识【应用服务端与编程语言】学习笔记]  <a href="https://mp.weixin.qq.com/s/8uU0EFGkrWc0W6CnV68wXw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8uU0EFGkrWc0W6CnV68wXw</a></li></ul><hr><h2 id="0X01-前端基础知识"><a href="#0X01-前端基础知识" class="headerlink" title="0X01 前端基础知识"></a>0X01 前端基础知识</h2><h3 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1.客户端"></a>1.客户端</h3><h4 id="主流浏览器"><a href="#主流浏览器" class="headerlink" title="主流浏览器"></a>主流浏览器</h4><p>现在国内常见的浏览器有：IE、Firefox、QQ浏览器、Safari、Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、遨游浏览器、世界之窗浏览器等。</p><p>但目前最为主流浏览器有五大款，分别是IE（Edge）、Firefox、Google Chrome、Safari、Opera。</p><p><strong>五大浏览器</strong>分别是Google Chrome、Safari、Firefox、Edge(Internet Explorer) 、Opera浏览器，采用的都是单内核，而随着浏览器的发展现在也出现了双内核(例如QQ/360)。</p><ul><li>Google Chrome : <a href="https://www.google.cn/intl/zh-CN/chrome/" target="_blank" rel="noopener">Google Chrome</a> 是一款由Google公司开发的一款设计简单、高效的Web浏览工具，其基于开源引擎WebKit中的分支Blink而生的浏览器，<code>Blink 内核以及Chromium</code>是Google公司自主研发的内核模式，包含V8 Javascript虚拟机，这个多线程的虚拟机可以加速Javascript的执行。目标是提升稳定性、速度和安全性，并创造出简单且有效率的使用者界面。</li><li>Safari ：<a href="https://www.apple.com/safari/" target="_blank" rel="noopener">Safari</a> 是一款由苹果公司开发的网页浏览器，是各类苹果设备（如Mac、iPhone、iPad、iPod Touch）的默认浏览器，Safari使用自家开发 WebKit 浏览器引擎，<code>WebKit 内核</code>是苹果自主研发的内核模式，包含WebCore排版引擎及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来。</li><li>Firefox : <a href="https://www.mozilla.org/zh-CN/firefox/new/" target="_blank" rel="noopener">Firefox</a>  浏览器使Mozilla公司旗下浏览器，也是刚才提到的网景公司后来的浏览器。网景被收购后，网景人员创办了Mozilla基金会，这是一个非盈利组织，他们在2004年推出自己的浏览器Firefox其采用作为内核，<code>Gecko 内核</code>是Mozilla公司自主研发的内核模式.</li><li>Edge : <a href="https://www.microsoft.com/zh-cn/edge/home" target="_blank" rel="noopener">Microsoft Edge</a>  是一款快速而安全的浏览器，其是基于谷歌开发的<code>Chromium 内核</code>，即微软的壳、Chromium 的心， 这次转变旨在解决 Edge 一直以来都难以解决的兼容性问题（在 EdgeHTML 下不少传统网页都无法正常显示）并融入现有的 Chromium 生态，所以 Google Chrome 中使用的浏览器插件通常也可以在Edge使用。<ul><li>Internet Explorer : 已经是过去式了，此处不再详细提及，曾经占用量最大的浏览器，现在已被 Microsoft 推出的 Edge 所替代，其采用的 Trident 内核。</li></ul></li><li>Opera ： 它是挪威Opera Software ASA公司旗下的浏览器。1995年，opera公司发布第一版Opera浏览器，使用自己研发的Presto内核。当时opera公司的开发团队不断完善Presto内核，使Opera浏览器一度成为顶级浏览器。直到2016年奇虎360和昆仑万维收购了Oprea浏览器，从此也丢弃了强大的Presto内核，改用当时Google开源的webkit内核，后来Opera浏览器跟随Google将浏览器内核改为Blink内核，自此Presto内核也淡出了互联网市场。</li></ul><p><br/></p><h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p><strong>五大内核</strong>分别是：Trident（也称IE内核）、Presto、Gecko、Webkit、Blink/Chromium (基于Webkit)。</p><ul><li>Trident ([‘traɪd(ə)nt]) (IE内核)：该内核程序在 1997 年的 IE4 中首次被采用，是微软在 Mosaic（”马赛克”，这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览） 代码的基础之上修改而来的，并沿用到 IE11，也被普遍称作 “IE内核”。</li><li>Presto ([‘prestəʊ])：它是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌大本营。pera 的一个里程碑作品是 Opera7.0，因为它使用了 Opera Software 自主开发的 Presto 渲染引擎，取代了旧版 Opera 4 至 6 版本使用的 Elektra 排版引擎。该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。<br>Presto 加入了动态功能，例如网页或其部分可随着 DOM 及 Script 语法的事件而重新排版。Presto 在推出后不断有更新版本推出，使不少错误得以修正，以及阅读 Javascript 效能得以最佳化，并成为当时速度最快的引擎，然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎，至此Presto 内核的 Opera 浏览器版本永远的停留在了 12.17</li></ul><ul><li>Gecko ([‘gekəʊ]) (Firefox 内核)：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。</li></ul><ul><li>Webkit ：实际上是由苹果公司开发给 Safari 浏览器使用的内核。现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 、Chromeium了），WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。当年苹果在比较了 Gecko 和 KHTML 后，选择了后者来做引擎开发，是因为 KHTML 拥有清晰的源码结构和极快的渲染速度，所以Webkit内核可以说是以硬件盈利为主的苹果公司给软件行业的最大贡献之一。<ul><li>PS：Apple 在 Safari 里面使用了自己的 Nitro JavaScript 引擎（只用 WebKit 来渲染 HTML），所以一般说到 Webkit，通常指的就是渲染引擎（而不包括 Javascript 引擎）</li></ul></li><li>Chromium/Blink ：2008 年谷歌公司发布 chrome 浏览器，浏览器使用的内核被命名为 chromium，其 fork 自开源引擎 webkit，却把 WebKit 的代码梳理得可读性提高很多，提高了效率并且带动了浏览器行业的发展，谷歌公司还研发了自己的 Javascript 引擎，V8，极大地提高了 Javascript 的运算速度，然而 2013 年 4 月 3 日，谷歌在 Chromium Blog 上发表 博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。</li></ul><p><br/></p><p><strong>我们所说的浏览器内核是什么?其究竟能干什么?</strong></p><p>浏览器最重要或者说核心的部分是<code>“Rendering Engine”</code>可大概译为<code>“渲染引擎”</code>，俗称称为“浏览器内核”。负责对网页语法的解释（如[标准通用标记语言]下的一个应用[HTML]、[JavaScript]）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的[渲染引擎]，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息，不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p><p>综上所述，浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，<code>一是渲染引擎，另一个是JS引擎</code>。用户在浏览器请求访问 URI（统一资源标示符）网络资源时，返回的数据由浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指的，这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</p><p>此处值得注意的是，并非所有的浏览器都完全遵从W3C规范（只是或多或少），通常还在开发自己独有的扩展程序。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/2/image-20221211133121844.png" alt="WeiyiGeek.浏览器渲染解析" title="" class="">                <p>WeiyiGeek.浏览器渲染解析</p>            </figure><p><br/></p><p><strong>Webkit 用的好好的，为何要投入到一个新的内核中去呢？</strong><br>Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入Webkit。</p><p>后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。<br>基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。这样以来，唯一一条维系 Google 和苹果之间技术关系的纽带就这样被切断了。</p><p><br/></p><p><strong>总结说明</strong></p><ul><li>浏览器内核主要指的是浏览器的渲染引擎，2013 年以前，代表有 Trident（IE），Gecko（firefox），Webkit（Safari chrome 等）以及 Presto（opera)。2013 年，谷歌开始研发 blink 引擎，chrome 28 以后开始使用，而 opera 则放弃了自主研发的 Presto 引擎，投入谷歌怀抱，和谷歌一起研发 blink 引擎，国内各种 chrome系的浏览器（360、UC、QQ、2345 等等）也纷纷放弃 webkit，投入 blink 的怀抱。</li><li>目前移动端浏览器有哪些内核?<br>描述：移动端的浏览器内核主要说的是系统内置浏览器的内核。<br>目前移动设备浏览器上常用的内核有 Webkit，Blink(Chromium)，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。</li><li>作为前端开发学习，熟悉浏览器内核是非常有必要的，不同内核的解析不同使网页渲染效果更具多样化，下面总结一下各常用浏览器所使用的内核。</li></ul><table><thead><tr><th>序号</th><th>浏览器</th><th>内核</th></tr></thead><tbody><tr><td>1</td><td>IE</td><td>Trident内核，也是俗称的IE内核；</td></tr><tr><td>2</td><td>Chrome</td><td>Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；</td></tr><tr><td>3</td><td>Firefox</td><td>Gecko内核，俗称Firefox内核；</td></tr><tr><td>4</td><td>Safari</td><td>Webkit内核；</td></tr><tr><td>5</td><td>Opera</td><td>最初是自己的Presto内核，后来是Webkit，现在是Blink内核；</td></tr><tr><td>6</td><td>360浏览器</td><td>IE+Chrome双内核；</td></tr><tr><td>7</td><td>猎豹浏览器</td><td>IE+Chrome双内核；</td></tr><tr><td>8</td><td>搜狗浏览器</td><td>Trident（兼容模式）+Webkit（高速模式）；</td></tr><tr><td>9</td><td>遨游浏览器</td><td>Trident（兼容模式）+Webkit（高速模式）；</td></tr><tr><td>10</td><td>QQ浏览器</td><td>Trident（兼容模式）+Webkit（高速模式）；</td></tr><tr><td>11</td><td>百度浏览器</td><td>IE内核；</td></tr><tr><td>12</td><td>世界之窗</td><td>IE内核；</td></tr><tr><td>13</td><td>2345浏览器</td><td>以前是IE内核，现在也是IE+Chrome双内核；</td></tr></tbody></table><p><strong>参考来源: </strong></p><ul><li>五大主流浏览器及四大内核 [<a href="https://zhuanlan.zhihu.com/p/102911463]" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102911463]</a> </li></ul><hr><h3 id="2-APP"><a href="#2-APP" class="headerlink" title="2.APP"></a>2.APP</h3><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>当前说得最多、最火的就是小程序，例如我们熟知的微信小程序、支付宝小程序、百度小程序等。</p><p><strong>发展背景与历程</strong></p><p>随着当前APP（安卓、IOS）市场的饱和，大部分用户已经养成了使用习惯（国人必不可少的两个软件-微信、支付宝），开发新的APP很难在市场生存。此外，APP开发和推广成本高也是不争的事实，根据某数据显示移动电商APP的下载成本高达120-200 元，而且这些后期未必能形成转化，而像互联网金融、二手车电商APP的新客户成本，更是动辄高达数千元。</p><p>因此，不少“码农”们决定开始向小程序市场“跳槽”，从而使得小程序雨后春笋般的增长。</p><table><thead><tr><th>时间</th><th>事件</th></tr></thead><tbody><tr><td>2016年11月3日</td><td>微信小程序正式开放公测</td></tr><tr><td>2017年9月20日</td><td>支付宝小程序向用户开放公测</td></tr><tr><td>2018年3月</td><td>小米、中兴、华为、金立、联想、魅族、努比亚、OPPO、vivo、一加共十家手机厂商一起推出了快应用，虽然名字不同，本质上也是小程序。</td></tr><tr><td>2018年7月</td><td>百度宣布百度智能小程序正式上线</td></tr><tr><td>2019年6月</td><td>腾讯QQ小程序上线</td></tr><tr><td>2020年6月23日</td><td>苹果推出了一项新的“App Clip”小程序</td></tr></tbody></table><p><strong>那究竟什么是小程序?</strong></p><p>按照百度百科介绍，小程序是一种不需要下载安装即可使用的[应用]，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装[卸载]。</p><p><strong>小程序开发文档</strong> </p><ul><li>微信小程序: <a href="https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN</a></li><li>支付宝小程序: <a href="https://opendocs.alipay.com/mini/development" target="_blank" rel="noopener">https://opendocs.alipay.com/mini/development</a></li><li>百度小程序: <a href="https://smartprogram.baidu.com/developer/index.html" target="_blank" rel="noopener">https://smartprogram.baidu.com/developer/index.html</a></li></ul><hr><h4 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h4><p><strong>什么是WebView?</strong></p><p>Webview 是是指网页视图，它是一个基于webkit的引擎，可以解析DOM 元素，展示html页面的控件，它和浏览器展示页面的原理是相同的，所以可以把它当做浏览器看待，简单的说它就是APP内的一个容器的概念.</p><p>它可以内嵌在移动端，实现前端的混合式开发，大多数混合式开发框架都是基于WebView模式进行二次开发的，比如：APIcloud、uni-app等等的框架，以及微信小程序就是使用Webview进行渲染的。</p><p><br/></p><p><strong>WebView主要用于什么地方？或者说什么需求下会使用到webview?</strong></p><p>个人理解，在电脑上我们可以非常轻松的通过浏览器打开页面即可浏览，而手机系统层面，如果没有webview支持，是无法展示html页面，所以webview的作用即用于手机系统来展示html界面的，所以它主要在需要在手机系统上加载html文件时被需要。</p><p><br/></p><p><strong>使用webview的好处？</strong><br>原生APP是将页面的布局设计，以及业务代码打包然后用户下载安装使用，而webview是通过加载html文件来进行页面的展示，当需要更新页面布局的或者业务逻辑变更时，如果是原生的APP就需要修改前端内容，升级打包，重新发布才可以使用最新的。</p><p>而通过webview方式的页面则只需要修改html代码或者js文件（如果是从服务器端获取，只要新的文件部署完成），用户重新刷新就可以使用更新后的，无需通过下载安装的方式完成升级。</p><hr><h3 id="3-网络知识"><a href="#3-网络知识" class="headerlink" title="3.网络知识"></a>3.网络知识</h3><p>网络相关基础知识作为开发或者说从事计算机行业的必功课，所以说一个好的开发者一定是对网络是有一定的掌握，但是互连网络知识体系、分类之多，此处作为入门教程不做过多的展开，有兴趣的小伙伴可以自行学习，下面针对我们会遇到的一些网络名词进行简单介绍。</p><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p><strong>什么是域名(Domain Name)？</strong></p><blockquote><p>A：是一串用点分割的字符，是互联网某台或者某组计算机的名称，使用者更好方便访问网页，而不需去记住一长串的IP地址字符，例如 <code>http://www.weiyigeek.top/ --&gt; IP地址</code>；</p></blockquote><p><strong>使用域名有何好处?</strong></p><ul><li>1.方便人类记忆</li><li>2.更换机器IP地址后不需要改变硬编码在应用的域名，只需要更改解析即可。</li><li>2.便于实现负载均衡，例如一个域名可以对应多个IP。</li><li>3.便于实现虚拟主机名进行访问同一个地址的多个应用，例如Nginx的代理。</li></ul><p>Tips: 域名的购买与使用流程(温馨提示：国内服务器域名需要进行依法备案哟！)：</p><ul><li>1.你在某域名提供商处购买了一个域名 weiyigeek.top</li><li>2.域名提供商向 .top 对应的顶级域名服务器中插入一条以上的 NS 记录，指向它自己的次级 DNS 服务器，如 <a href="http://dns25.hichina.com/" target="_blank" rel="noopener">dns25.hichina.com</a>.</li><li>3.阿里云会向 TLD 中插入几条 NS 记录，指向阿里云的次级 DNS 服务器（如 <a href="http://alidns.com/" target="_blank" rel="noopener">alidns.com</a> - 223.6.6.6）。</li><li>4.你在该域名提供商的 DNS 管理界面中添加 A 记录，值为你的服务器 IP。</li><li>5.OK 现在 ping 一下 weiyigeek.top，就会发现它已经解析到你自己的服务器了。</li></ul><p>阿里云-域名购买：<a href="https://wanwang.aliyun.com/?source=5176.11533457&amp;userCode=uelj47qf" target="_blank" rel="noopener">https://wanwang.aliyun.com/?source=5176.11533457&amp;userCode=uelj47qf</a></p><p>腾讯云-域名购买: <a href="https://cloud.tencent.com/act/cps/redirect?redirect=10827&amp;cps_key=b33075ae5a2baf3b47e7456ee5821502" target="_blank" rel="noopener">https://cloud.tencent.com/act/cps/redirect?redirect=10827&amp;cps_key=b33075ae5a2baf3b47e7456ee5821502</a></p><p><br/></p><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>当前在因特网中使用的协议集（一组通过不同分层进行组织的协议）被称为TCP/IP协议族，TCP/IP协议族是一个分层协议，它由提供特定功能的交互式模块组成。</p><p><strong>那TCP/IP是什么呢？又起了什么作用？</strong></p><p>定义：TCP/IP是一组通信协议的代名词（其中包含一百多个协议），这组协议使任何具有网络设备的用户能访问和共享Internet上的信息，其中最重要的协议是<code>传输控制协议（TCP）</code>和<code>因特网协议（IP）</code>。</p><p>作用：TCP和IP是两个独立且紧密结合的协议，负责管理和引导数据报文在Internet上的传输，两者使用专门的报文头定义每个报文的内容。 </p><ul><li>TCP负责和远程主机的连接。</li><li>IP负责寻址，使报文被送到其该去的地方。</li></ul><p><br/></p><p>说到此处不得不提到 TCP/IP四层模型。</p><p>TCP/IP四层模型的出现要早于OSI七层模型，它是由美国国防部创建的，所以有时又称<code>DoD（Department of Defense）</code>模型，是迄今为止发展最成功的通信协议，被用于构筑目前最大的、开放的互联网络系统Internet。</p><p>所以尽管OSI七层参考模型（后面介绍）得到了全世界的认同，但是互联网历史上和技术上的事实开发标准则是TCP/IP模型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TCP/IP 协议簇中的分层</span></span><br><span class="line">应用层 - 层5 </span><br><span class="line">传输层 - 层4</span><br><span class="line">网络层 - 层3</span><br><span class="line">数据链路层 - 层2</span><br><span class="line">物理层 - 层1</span><br></pre></td></tr></table></figure><p>温馨提示: 为了简化了层次设备，又常常将TCP/IP模型说成四层，即将<code>数据链路层</code>与<code>物理层</code>进行整合为<code>网络接口层</code>。</p><p>扩展文章：(大神之路-起始篇 | 第6章.计算机科学导论之【计算机网络】学习笔记)[<a href="https://mp.weixin.qq.com/s/usJbZHe2Cfaurz6snVQyuA]" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/usJbZHe2Cfaurz6snVQyuA]</a></p><p><br/></p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS(Domain Name System) 即域名名称服务：TCP/IP协议族使用唯一定义了该主机和网络之间连接的IP地址，但是为了方便人们记忆通常使用字符串而不是数字化的地址，因此网络需要有一个可以将名称映射到地址的目录系统，DNS的出现正是为了解决此问题。</p><blockquote><p>例如，博主的 blog.weiyigeek.top 博客站点域名，通过如下步骤将主机名词映射到对应的IP地址上。<br>$ ping blog.weiyigeek.top<br>正在 Ping blog.weiyigeek.top [82.156.18.253] 具有 32 字节的数据:<br>来自 82.156.18.253 的回复: 字节=32 时间=51ms TTL=52</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20220913135036968.png" alt="WeiyiGeek.域名解析流程" title="" class="">                <p>WeiyiGeek.域名解析流程</p>            </figure><p>扩展文章:  <a href="https://blog.weiyigeek.top/2019/1-22-511.html">🌐 https://blog.weiyigeek.top/2019/1-22-511.html</a></p><p><br/></p><h4 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h4><p><strong>什么是 HTTP/HTTPS 协议？</strong></p><ul><li><p>HTTP协议全称Hyper Text Transfer Protocol-超文本传输协议，位于TCP/IP四层模型当中的应用层。</p><ul><li>HTTP协议通过请求/响应的方式，在客户端和服务端之间进行通信。</li><li>缺点:传输不够安全容易被拦截和篡改(HTTP协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”)容易导致中间人攻击;</li></ul></li><li><p>HTTPS协议全称Hypertext Transfer Protocol Secure，超文本传输安全协议,实际上是在HTTP协议的基础之上增加了SSL安全层（下面介绍的一系列认证流程就是在SSL层中完成）,这是一套使用公钥/私钥机制的加密系统</p><ul><li>保护了交换数据隐私和完整性，提供对网站服务器身份认证的功能，简单来说它就是安全版的 HTTP。</li><li>最新推出的TLS协议是SSL 3.0协议的升级版，和SSL协议的大体原理是相同的(简单的记就是TLS是SSL的升级版本)</li></ul></li></ul><bt><p><strong>HTTP/HTTPS处于TCP/IP层次</strong></p><table><thead><tr><th>TCP/IP层次</th><th>说明</th></tr></thead><tbody><tr><td>应用层(HTTP[HTTPS]/FTP)</td><td>HTTPS在HTTP基础上构建 SSL安全层,经过发展已经推出了TLS协议；</td></tr><tr><td>传输层(TCP/UDP)</td><td>-</td></tr><tr><td>网络层(IP/ARP)</td><td>-</td></tr><tr><td>数据链路层</td><td>-</td></tr></tbody></table><figure class="image-box">                <img src="https://img.weiyigeek.top/2019/1/20190926092153.png" alt="WeiyiGeek.HTTP/HTTPS处于层次" title="" class="">                <p>WeiyiGeek.HTTP/HTTPS处于层次</p>            </figure><p><br></p><p><strong>HTTPS 主要用途</strong></p><ul><li>一是通过证书等信息确认网站的真实性；</li><li>二是建立加密的信息通道；</li><li>三是保证数据内容的完整性。</li></ul><p><br></p><p><strong>HTTPS相比较于HTTP协议的一些关键点</strong></p><ul><li>成本问题:HTTPS要比HTTP更加消耗资源，SSL握手需要更多的数据包，加密解密也需要额外的运算。</li><li>HTTPS的证书需要专门的机构颁发，大机构颁发的证书不是免费的每年都得交几百几千块钱才能申请到证书，当然也可使用Let’sEncrypt进行申请免费证书，缺点是有效期只有90天，博主就是采用此方式给博客站点申请免费证书。</li><li>因为某些颁发证书的机构会滥发证书，甚至会制造假证书，假证书可以用来进行中间人攻击;</li></ul><p>扩展参考: </p><ul><li><p>(HTTPS原理介绍以及证书签名的申请配置)[<a href="https://blog.weiyigeek.top/2019/10-21-10.html]">https://blog.weiyigeek.top/2019/10-21-10.html]</a></p></li><li><p>(Let’sEncrypt快速颁发及自动续签泛域名证书实践指南)[<a href="https://blog.weiyigeek.top/2022/3-11-589.html]">https://blog.weiyigeek.top/2022/3-11-589.html]</a></p></li></ul><hr><h3 id="4-操作系统"><a href="#4-操作系统" class="headerlink" title="4.操作系统"></a>4.操作系统</h3><p>说到操作系统，想必你肯定知道Windows操作系统，但是除了微软的操作系统外，还有苹果电脑的MacOS系统（unix），以及Linux操作系统（包含众多发型版本，例如Debian、CentOS、Ubuntu），我作为一名开发者通常会选择Ubuntu进行开发，别问我为啥不选择苹果电脑（PS: 作者太穷了买不起 ☺），此外我们简单介绍一下Windows与Linux操作系统，我相信大部分的开发者还是常常使用这两大操作系统。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>微软操作系统（Microsoft System）是美国微软公司以图形用户界面为基础研发的操作系统，于1983年开始研发，最初的研发目标是在MS-DOS的基础上提供一个多任务的图形用户界面，后续版本则逐渐发展成为主要为个人电脑和服务器用户设计的操作系统，并最终获得了世界个人电脑操作系统的垄断地位。</p><p>微软（Microsoft）自1985年推出Windows 1.0以来，Windows系统经历了十多年风风雨雨。从最初运行在DOS下的windows95操作系windows95操作系统Windows 3.x，到现在风靡全球的Windows 9x、Windows 2000、Windows XP、Windows 2003、Windows vista、Windows 2008 、Windows2012、Win 7、Win 8、Win8 or 8.1 、Win10、乃至当前流行 Windows 11。</p><p><strong>Windows 各版本发售时间</strong></p><table><thead><tr><th><strong>名称</strong></th><th><strong>最新版本</strong></th><th><strong>正式发售日期</strong></th><th><strong>开发代号</strong></th><th><strong>停止支持时间</strong></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td><strong>主流</strong></td><td><strong>扩展</strong></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 1.0/761751" target="_blank" rel="noopener">Windows 1.0</a></td><td>1.01</td><td>1985年11月20日</td><td>Interface Manager</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 2.0/762078" target="_blank" rel="noopener">Windows 2.0</a></td><td>2.03</td><td>1987年12月9日</td><td>不适用</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 2.1/6577488" target="_blank" rel="noopener">Windows 2.1</a></td><td>2.11</td><td>1988年5月27日</td><td>不适用</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 3.0/8734619" target="_blank" rel="noopener">Windows 3.0</a></td><td>3.0</td><td>1990年5月22日</td><td>不适用</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 3.1/9033659" target="_blank" rel="noopener">Windows 3.1</a></td><td>3.1</td><td>1992年4月6日</td><td>Janus</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows For Workgroups 3.1/8260011" target="_blank" rel="noopener">Windows For Workgroups 3.1</a></td><td>3.1</td><td>1992年10月</td><td>Winball、Sparta</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows NT 3.1/1223887" target="_blank" rel="noopener">Windows NT 3.1</a></td><td>NT 3.1.528</td><td>1993年7月27日</td><td>Razzle</td><td>2000年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows For Workgroups 3.11/884644" target="_blank" rel="noopener">Windows For Workgroups 3.11</a></td><td>3.11.300</td><td>1993年8月11日</td><td>Snowball</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 3.2/9033676" target="_blank" rel="noopener">Windows 3.2</a></td><td>3.2.153</td><td>1993年11月22日</td><td>不适用</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows NT 3.5/8241718" target="_blank" rel="noopener">Windows NT 3.5</a></td><td>NT 3.5.807</td><td>1994年9月21日</td><td>Daytona</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows NT 3.51/4927553" target="_blank" rel="noopener">Windows NT 3.51</a></td><td>NT 3.51.1057</td><td>1995年5月30日</td><td>Tukwila</td><td>2001年12月31日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 95/757614" target="_blank" rel="noopener">Windows 95</a></td><td>4.0.950</td><td>1995年8月24日</td><td>Chicago、4.0</td><td>2000年12月31日</td><td>2001年12月31日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows NT 4.0/9033692" target="_blank" rel="noopener">Windows NT 4.0</a></td><td>NT 4.0.1381</td><td>1996年7月31日</td><td>Cairo</td><td>2002年6月30日</td><td>2004年6月30日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 98/758579" target="_blank" rel="noopener">Windows 98</a></td><td>4.10.1998</td><td>1998年6月25日</td><td>Memphis、97、4.1</td><td>2002年6月30日</td><td>2006年6月30日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 98 SE/311956" target="_blank" rel="noopener">Windows 98 SE</a></td><td>4.10.2222</td><td>1999年5月5日</td><td>不适用</td><td>2002年6月30日</td><td>2006年6月30日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 2000/2769068" target="_blank" rel="noopener">Windows 2000</a></td><td>NT 5.0.2195</td><td>2000年2月17日</td><td>NT 5.0</td><td>2005年6月30日</td><td>2010年7月13日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Me/759311" target="_blank" rel="noopener">Windows Me</a></td><td>4.90.3000</td><td>2000年9月14日</td><td>Millennium、4.9</td><td>2003年12月31日</td><td>2006年7月11日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows XP/191927" target="_blank" rel="noopener">Windows XP</a></td><td>NT 5.1.2600</td><td>2001年10月25日</td><td>Whistler</td><td>2009年4月14日</td><td>2014年4月8日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows XP 64-bit Edition/3062713" target="_blank" rel="noopener">Windows XP 64-bit Edition</a></td><td>NT 5.2.3790</td><td>2003年3月28日</td><td>不适用</td><td>2009年4月14日</td><td>2014年4月8日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2003/761146" target="_blank" rel="noopener">Windows Server 2003</a></td><td>NT 5.2.3790</td><td>2003年4月24日</td><td>Whistler Server、Windows .NET Server</td><td>2010年7月13日</td><td>2015年7月14日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows XP Professional x64 Edition/2922503" target="_blank" rel="noopener">Windows XP Professional x64 Edition</a></td><td>NT 5.2.3790</td><td>2005年4月25日</td><td>不适用</td><td>2009年4月14日</td><td>2014年4月8日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Fundamentals for Legacy PCs/9499165" target="_blank" rel="noopener">Windows Fundamentals for Legacy PCs</a></td><td>NT 5.1.2600</td><td>2006年7月8日</td><td>Eiger、Mönch</td><td>2009年4月14日</td><td>2014年4月8日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Vista/214535" target="_blank" rel="noopener">Windows Vista</a></td><td>NT 6.0.6003</td><td>2007年1月30日</td><td>Longhorn</td><td>2012年4月10日</td><td>2017年4月11日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Home Server/6901233" target="_blank" rel="noopener">Windows Home Server</a></td><td>NT 5.2.4500</td><td>2007年11月4日</td><td>Quattro</td><td>2013年1月8日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2008/4291457" target="_blank" rel="noopener">Windows Server 2008</a></td><td>NT 6.0.6003</td><td>2008年2月27日</td><td>Longhorn Server</td><td>2015年1月13日</td><td>2020年1月14日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 7/1083761" target="_blank" rel="noopener">Windows 7</a></td><td>NT 6.1.7601</td><td>2009年10月22日</td><td>Windows 7</td><td>2015年1月13日</td><td>2020年1月14日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2008 R2/2212624" target="_blank" rel="noopener">Windows Server 2008 R2</a></td><td>NT 6.1.7601</td><td>2009年10月22日</td><td>不适用</td><td>2015年1月13日</td><td>2020年1月14日</td></tr><tr><td>Windows Home Server 2011</td><td>NT 6.1.8400</td><td>2011年4月6日</td><td>Vail</td><td>2016年4月12日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2012/1484395" target="_blank" rel="noopener">Windows Server 2012</a></td><td>NT 6.2.9200</td><td>2012年9月4日</td><td>Server 8</td><td>2018年10月9日</td><td>2023年1月9日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 8/6851933" target="_blank" rel="noopener">Windows 8</a></td><td>NT 6.2.9200</td><td>2012年10月26日</td><td>不适用</td><td>2016年1月12日</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 8.1/768457" target="_blank" rel="noopener">Windows 8.1</a></td><td>NT 6.3.9600</td><td>2013年10月17日</td><td>Blue</td><td>2018年1月9日</td><td>2023年1月10日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2012 R2/9822854" target="_blank" rel="noopener">Windows Server 2012 R2</a></td><td>NT 6.3.9600</td><td>2013年10月18日</td><td>Server Blue</td><td>2018年10月9日</td><td>2023年1月10日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 10/6877791" target="_blank" rel="noopener">Windows 10</a></td><td>NT 10.0.19045</td><td>2015年7月29日</td><td>Threshold、Redstone、Vibranium</td><td>2025年10月14日（不含LTSB/LTSC）</td><td></td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2016/18708757" target="_blank" rel="noopener">Windows Server 2016</a></td><td>NT 10.0.14393</td><td>2016年10月12日</td><td>Redstone</td><td>2022年1月11日</td><td>2027年1月12日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2019/24272934" target="_blank" rel="noopener">Windows Server 2019</a></td><td>NT 10.0.17763</td><td>2018年10月2日</td><td>Redstone</td><td>2024年1月9日</td><td>2029年1月9日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows Server 2022/59326783" target="_blank" rel="noopener">Windows Server 2022</a></td><td>NT 10.0.20348</td><td>2021年8月18日</td><td>Iron</td><td>2026年10月13日</td><td>2031年10月14日</td></tr><tr><td><a href="https://baike.baidu.com/item/Windows 11/57321047" target="_blank" rel="noopener">Windows 11</a></td><td>NT 10.0.22621</td><td>2021年10月4日</td><td>Sun Valley</td><td>2023年10月10日</td><td>2024年10月8日</td></tr></tbody></table><p><br/></p><p><strong>Q: Windows 10版本 <code>business_editions</code>和<code>consumer_editions</code>的区别？</strong></p><blockquote><p>答: 二者都内置专业版不同之处在于：<br>consumer_editions 版本包含：Home(家庭版); Education(教育版) ; Professional(专业版)；<br>business_editions 版本包含：Education(教育版); Enterprise (企业版); Professional(专业版)；</p></blockquote><p>Windows 10 (business editions) VL版 ISO镜像包含以下版本（根据需要选择安装）： </p><ul><li>专业版、企业版、教育版、专业工作站版、专业教育版</li></ul><p>Windows 10 (consumer editions) 零售版 ISO镜像包含以下版本（根据需要选择安装）：</p><ul><li>家庭版、专业版、教育版、家庭单语言版、专业工作站版、专业教育版</li></ul><p><strong>Q: Windows 10 各发行版本区别?</strong></p><ul><li>家庭版(Home)：供家庭用户使用，无法加入Active Directory和Azure AD，不允许远程桌面连接。</li><li>专业版(Professional)：供小型企业使用 在家庭版基础上增加了域账号加入、bitlocker、企业商店等功能。</li><li>企业版(Enterprise)：供中大型企业使用 在专业版基础上增加了DirectAccess，AppLocker等高级企业功能。</li><li>教育版(Education)：供学校使用 (学校职员, 管理人员, 老师和学生) 其功能基本和企业版的一样。</li><li>LTSB版：无Edge浏览器、小娜，无磁贴，可选是否下载和安装补丁，其它版都不能自选补丁。</li><li>N版：带“N”的版本相当于阉割版，移除了Windows Media Player，几乎用不到N版。</li></ul><p>当前购买的计算机默认安装的 Windows 11是Windows 11家庭版版本，但除此之外还有 Windows 11专业版、Windows 11企业版、Windows 11专业工作站版、Windows 11教育版、Windows 11混合现实版  ，延伸版本为Windows 11 22H2（代号为Sun Valley 2，即“太阳谷2”），将于2022年9月发布。</p><p><strong>扩展阅读</strong>:</p><ul><li>Windows10 家庭版(Home) 开启远程桌面支持 ：<a href="https://blog.weiyigeek.top/2019/5-28-566.html">https://blog.weiyigeek.top/2019/5-28-566.html</a></li><li>Windows服务器核心(Server-Core)安装与基础配置使用 : <a href="https://blog.weiyigeek.top/2021/5-26-559.html">https://blog.weiyigeek.top/2021/5-26-559.html</a></li></ul><p><br/></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux 操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间，以MINIX为模版）芬兰大学生 <code>auther：Linus Torvalds</code>，在BBS上发布了一则消息，他以bash/GCC等工具写了一个核心程序，它可以在inter的386机器上面运作，自1994年完成了Linux核心正式版 v1.0 ,并加入了对X Window System的支持，然后1996年发布Linux核心正式版v2.0版本 , 托瓦兹指定企鹅为吉祥物。</p><p>Linux是一个开源的软件，我们可以任意的研究使用、散布、改良的自由。</p><p>Liunx是一个终端（Terminal）也称终端字符设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入以及处理结果的输出等。 </p><ul><li>在早期计算机系统中，由于计算机主机昂贵，因此一个主机（IBM大型计算机）一般会配置多个终端，这些终端本身不具备计算能力，仅仅承担信息输入输出的工作，运算和处理均由主机来完成。 </li><li>在个人计算机时代，个人计算机可以运行称为终端仿真器的程序来模仿一个终端的工作。</li></ul><p><strong>主要特点:</strong></p><ul><li>基本思想</li><li>完全免费</li><li>完全兼容POSIX1.0标准</li><li>多用户、多任务</li><li>良好的界面</li><li>支持多种平台</li></ul><p>Linux存在着许多不同的Linux版本，但它们都使用了Linux内核，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统</p><p>The Linux Kernel Archives（官网）: <a href="https://www.kernel.org/" target="_blank" rel="noopener">https://www.kernel.org/</a></p><p><strong>Linux主要特性：(重要的核心思想 <code>一切皆文件</code> )</strong></p><p>1.严格区分大小写</p><p>2.系统一切内容皆是文件包括硬件设备也是</p><p>3.不靠扩展名来区分文件类型</p><p>4.Windows下的程序不能直接在LInux上面运行,需要移植重新编译;</p><p>5.字符界面的优势：</p><ul><li>优点1：占用系统资源更少</li><li>优点2：减少了出错，被攻击的可能性.</li></ul><ol start="6"><li><p>开源免费</p></li><li><p>完全兼容POSIX1.0标准</p></li></ol><p>8.支撑多用户、多任务</p><p>9.支持界面化与命令行 (terminal终端) 操作</p><p>10.支持多种平台</p><p><br/></p><p><strong>常见的UNIX&amp;LINUX系统分类：</strong></p><ul><li><p>UNIX System V启动方式，启动服务的脚本放在/etc/rc.d/init.d下面。<br>1.1 AIX | 这是一个由IBM公司主持研究的UNIX操作系统版本，它与SVR4兼容。主要是针对IBM的计算机硬件环境对UNIX系统进行了优化和增强。<br>1.2 HP-UX | HP公司的UNIX系统版本，该系统是基于UNIXSystem V第2版开发的。它主要运行在HP的计算机和工作站上。<br>1.3 Solaris | 是Sun公司基于UNIX System V的第2版并结合BSD 4.3开发的。它主要应用在Sun的计算机和工作站上。<br>1.4 OS/2是由微软和IBM公司共同创造，后来由IBM单独开发的一套操作系统 是因为该系统作为IBM第二代个人电脑PS/2系统产品线的理想操作系统引入的。</p></li><li><p>BSD UNIX启动方式，在/etc/rc.d和/usr/local/etc/rc.d中存放启动服务的脚本。<br>2.1 FreeBSD<br>2.1.1 MacOS 是苹果公司为Mac系列产品开发的专属操作系统；macOS是全世界第一个基于FreeBSD系统采用“面向对象操作系统”的全面的操作系统。<br>2.1.2 iOS   是由苹果公司开发的移动操作系统。<br>2.2 NetBSD  是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统。<br>2.3 OpenBSD  是一个多平台的，基于4.4BSD的类UNIX操作系统，是BSD衍生出的三种免费操作系统（另外两种是NetBSD和FreeBSD）之一，被称为世界上最安全的操作系统l 最初的OpenBSD基于NetBSD源码。</p></li><li><p>UNIX-Like<br>3.1 GNU GNU is Not Unix。<br>3.1.1 Debian GNU/Linux 采用了 Linux Kernel （操作系统的核心），但是大部分基础的操作系统工具都来自于 GNU 工程，因此又称为 Debian GNU/Linux。<br>3.1.2 Ubuntu 是一个以桌面应用为主的开源GNU/Linux操作系统| Ubuntu 是基于Debian GNU/Linux。 </p><ul><li>Ubuntu基于Debian发行版和GNOME桌面环境，而从11.04版起，Ubuntu发行版放弃了Gnome桌面环境，改为Unity。</li></ul><ul><li>ubuntu主要版本有基于Gnome的ubuntu，基于KDE的Kubuntu，基于Xfce的Xubuntu。</li></ul></li><li><p>Linux系统:Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。<br>4.1 Android 是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，由Google公司和开放手机联盟领导及开发。<br>4.2 Red Hat Enterprise Linux<br>2004年4月30日，Red Hat公司正式停止对Red Hat 9.0版本的支持，标志着Red Hat Linux的免费时代正式结束。从此Red Hat公司不再开发桌面版的Linux发行包，而将全部力量集中在服务器版的开发上，也就是Red HatEnterprise Linux版，2005年10月RHEL4发布。<br>4.2.1 CentOS |  是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本。</p></li></ul><p><br/></p><p><strong>Linux与Windows有什么不同?</strong></p><ul><li>操作系统内核不同：Windows 操作系统内核是NT, 而linux 是 shell</li><li>硬盘文件格式不同: Windows 硬盘文件格式是fat32或NTSF, 而linux 需要的文件格式是xfs/ext4/ext3/ext2或ext。</li><li>用户界面不同：Windows是图形化界面为主。而Linux是字符化界面为主（当然现在也支持桌面）</li><li>硬件配置要求不同：你的硬件如果太新或太旧建议你还是装Windows吧，因为Linux的软件/硬件兼容性还有待提高，但是基本满足常见的硬件，有的大佬还是自己写驱动呢（像我们这样低段位的只有膜拜），</li><li>安全性不同: 众所周知 Windows 恶意软件数量是最多是，Linux由于是字符界面在前几年还是相对安全，但是随着时间推移物联网、嵌入式的发展，越来越多的攻击者盯上了Linux，所以Linux系统的恶意脚本软件数量也在逐年增多，但是还是要比Windows更安全一些（一想到永恒之蓝，我都想将公司仅剩的五台windows服务器给重装为Linux）。</li></ul><p><br/></p><p><strong>补充扩展:</strong></p><ul><li>Linux系统入门学习基础知识：<a href="https://blog.weiyigeek.top/2019/5-1-214.html">https://blog.weiyigeek.top/2019/5-1-214.html</a></li><li>鸟哥的Linux私房菜基础学习篇-3版笔记：<a href="https://blog.weiyigeek.top/2020/8-8-9.html">https://blog.weiyigeek.top/2020/8-8-9.html</a></li></ul><hr><h3 id="5-应用服务端"><a href="#5-应用服务端" class="headerlink" title="5.应用服务端"></a>5.应用服务端</h3><h4 id="服务端-WebServer"><a href="#服务端-WebServer" class="headerlink" title="服务端 WebServer"></a>服务端 WebServer</h4><p>当前常见的 WebServer 有 Nginx、Apache HTTP Server(httpd)、Apache Tomcat等服务软件，但是学习开发之前你可以在你本地机器（Win/Linux）上进行安装，或者直接在腾讯云、阿里云、百度云中购买轻量级云主机进行如下Web Server安装，推荐安装Linux的操作系统（Ubuntu 或者 Debian 或者 CentOS）。</p><p><strong>云服务器价格了解与购买</strong></p><ul><li><a href="https://url.cn/WH4YQNZN" target="_blank" rel="noopener">【腾讯云】云服务器等爆品抢先购，低至4.2元/月</a></li><li><a href="https://www.aliyun.com/daily-act/ecs/activity_selection?userCode=uelj47qf" target="_blank" rel="noopener">【阿里云】云服务器0元试用，首购低至0.9元/月起</a></li></ul><p><br/></p><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><p>Nginx (读音”engine x”) 是一个高性能的HTTP负载均衡和反向代理服务器，在2019.3.12被F5硬件负载均衡厂家以6.7亿美金收购了，主要是用于发布网站代码，提供网页信息服务的，用户通过浏览器可以实现页面的访问，也可以是一个IMAP/POP3/SMTP代理服务器；在高连接并发的情况下Nginx是Apache服务器不错的替代品,其特点是占有内存少，并发能力强（在同类型的网页服务器中表现较好），Nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比Perlbal要好很多；</p><p><br/></p><p><strong>主要功能</strong></p><ul><li>负载均衡服务器:用户每次访问都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况（nginx会给你分配服务器压力小的去访问）;</li><li>HTTP代理服务器对外进行服务:通过第三方服务器访问内部服务器集群的内容，但是我们并不知道是哪一台服务器提供的内容;</li><li>动态网页与静态网页资源相互分离以提高网站的整体性能;</li></ul><p><br/></p><p><strong>工具特点</strong></p><ul><li>安装启用简单以及跨平台,配置文件非常简洁（还能够支持perl语法）, 并且Bugs非常少的服务器性能优秀稳定，能够在升级情况下不间断服务</li><li>提供反向代理(代理转发功能)、负载均衡、WEB服务器(处理静态文件)和支持7层负载均衡和故障隔离等功能</li><li>Nginx 采用C进行编写内存占有少,使用更少的资源，稳定性高等优势，并且依靠并发能力强，丰富的模块库以及友好灵活的配置而闻名(具有高性能、轻量级、内存消耗少，强大的负载均衡能力等优势。)</li><li>由于它的内存占用少（一个worker进程只占用10-12M内存），启动极快，高并发能力强(5w/s)-相当于Apache WEB整体性能的5-10倍，在互联网项目中广泛应用。</li></ul><p>总结：就是Nginx支持 IO多路复用（多线程）， 轻量级 ， 功能模块少，代码模块化，并发处理能力强。</p><p>扩展参考文章: (Nginx学习之路汇总)[<a href="https://blog.weiyigeek.top/2018/1-1-1.html#Nginx%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E6%B1%87%E6%80%BB]">https://blog.weiyigeek.top/2018/1-1-1.html#Nginx%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E6%B1%87%E6%80%BB]</a></p><p><br/></p><h5 id="Apache-HTTP-Server"><a href="#Apache-HTTP-Server" class="headerlink" title="Apache HTTP Server"></a>Apache HTTP Server</h5><p>Apache HTTP服务器是一个功能强大、高效且可扩展的web服务器。</p><p>Apache起初由伊利诺伊大学香槟分校的国家超级电脑应用中心（NCSA）开发，此后Apache Httpd被开放源代码团体的成员不断的发展和加强，从上个世纪90年代开始它的市场占有率就超过了50%。</p><p>如今虽然它的使用率有些下降但是仍是世界使用排名第一的 Web 服务器软件，它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的 Web服务器端软件之一。</p><p><strong>扩展知识：</strong>四种服务器概念与区别。</p><p>从概念上讲：HTTP服务器=WEB服务器、应用程序服务器、应用容器、有何区别？</p><ul><li>Web服务器是提供WWW服务的程序;</li><li>Web容器是提供给开发者的框架;</li><li>Web应用程序服务器内容丰富得多，既可用各厂商通常遵循一定的工业标准并自定义扩展功能而成，也可以利用开源组件轻量级拼装打造;</li><li>反向代理服务器在企业级应用中表现突出，具有解决集中式安全，负载均衡等等优点。</li><li>中间件是为应用程序提供容器和服务;</li></ul><p>如今这四个概念的边界越来模糊，看看这个表就知道了：<br>软件名词|    是否Web服务器|    是否Web容器|    是否Web应用服务器|    是否能反向代理 | 公司<br>—|—|—|—|—|—<br>IIS       |是 |是| |是 | 微软公司<br>Nginx     |是 |  | |是 |<br>Apache |是 |  | |是 | Sun公司<br>Http.sys|是 |  | |是 |<br>Tomcat |是 |是| |  | Apache开源软件组织<br>Jetty     |是 |是| |  |<br>WebSphere|是|是|是| | IBM公司<br>WebLogic |是|是|是| | BEA公司<br>JBossAS |是|是|是| | 红帽公司<br>Kerstrel |是|是？    </p><p>扩展文章参考：</p><ul><li>(Apache安装与安全配置详细)[<a href="https://blog.weiyigeek.top/2019/8-19-118.html]">https://blog.weiyigeek.top/2019/8-19-118.html]</a></li><li>(运维之LNMP环境安装与配置)[<a href="https://blog.weiyigeek.top/2019/6-1-120.html]">https://blog.weiyigeek.top/2019/6-1-120.html]</a></li></ul><p><br/></p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p><strong>Q:什么是CDN?</strong></p><blockquote><p>A: CDN的全称是 <code>Content Delivery Network</code> 即内容分发网络(互联网世界的物流服务)。是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络, 它可以帮助分担源站压力，避免网络拥塞，确保在不同区域、不同场景下加速网站内容的分发，提高资源访问速度。<br>简单的说：其通过广泛的网络节点分布，提供快速、稳定、安全、可编程的全球内容分发加速服务，支持将网站(动态、静态)、音视频、下载等内容分发至接近用户的节点。 系统将源站内容分发至最接近用户的边缘节点之上, 使用户可就近取得所需内容，提高用户访问的响应速度和成功率。</p></blockquote><p><strong>Q: 为啥要使用CDN?</strong></p><blockquote><p>答: 例如阿里云为直播行业提供了边缘节点服务<code>（ENS-最主要的技术就是CDN）</code>,基于阿里云ENS可以轻松地将业务模块放到边缘运行，在主播的推流时，实现就近节点进行转码和分发，同时支持了高并发实时弹幕的边缘分发。在获得网络低时延的同时，减少了对中心的压力，节省了30%以上的中心带宽成本，并且实现了边缘节点网络连接小于5毫秒延时，提升了主播上行质量，以及用户成功连接占比等数指标，有效提升了用户观看体验;</p></blockquote><p><br/></p><p><strong>CDN 原理</strong><br>描述: 我们可以将CDN比作天猫超市与菜鸟在全国各地建了本地仓库,当用户购买直营的东西的时候(<code>不在是跨区配送而是同城配送</code>),所以下单购买后，由最近的仓发货就近配送，用户购买的体验明显好太多了;</p><p>其实我们在浏览网络的时候其实就和以上这个过程十分相似，我们访问一个网站页面的时候，会向服务器请求很多网络资源，包括<code>各种图片、声音、影片、文字</code>（通常为前端信息）等信息。所以就像天猫超市把货物提前存储在菜鸟建设在全国各地的本地仓库来减少物流时间一样，网站也可以<code>预先把内容分发至全国各地的加速节点</code>。这样用户就可以<code>就近获取所需内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题</code>，有效提升下载速度、降低响应时间，提供流畅的用户体验。</p><figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/1/20190823142255.png" alt="WeiyiGeek.CDN原理图" title="" class="">                <p>WeiyiGeek.CDN原理图</p>            </figure><p><br/></p><p><strong>CDN优缺点</strong><br>答:您总是希望网页可以尽可能地快，您希望页面的容量尽可能地小，同时您希望浏览器尽可能多地进行缓存这就需要使用到CDN的内容分发网络。就像前面提到的”全国仓配网络”一样，解决了因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。<br>优点: </p><ul><li>1.使用户可就近取得所需内容，<code>解决 Internet网络拥挤的状况，提高用户访问网站的响应速度和成功率</code>。</li><li>2.电信运营商: CDN技术消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量;</li><li>3.冗余机制: 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种DDoS攻击对网站的影响，同时保证较好的服务质量</li><li>4.分担源站压力，避免网络拥塞</li></ul><hr><h3 id="6-服务端语言"><a href="#6-服务端语言" class="headerlink" title="6.服务端语言"></a>6.服务端语言</h3><p>作为一名前端开发者，应该对后端语言有个简单了解，并且现在前端工程师使用node也能写后端程序，所以说针对前端开发者来说可是好事（优势），因为懂后端的不一定懂（会）前端，但由于项目的需求以及贴近团队的开发项目，你只能配合后端同事完成某一项业务功能，此时你便需要针对后端语言有个简单了解。 </p><p>如果说你想成为全栈那么，如下后端语言是你必学或者必须了解的。</p><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>最好学的后端语言没有之一，所以也被戏称【最好的编程语言】。</p><p><strong>Q:什么是PHP?</strong></p><p>PHP (<code>Hypertext Preprocessor</code> 缩写) 超级文本预处理器，PHP 是一种创建动态交互性站点的服务器端脚本语言。</p><p><br/></p><p><strong>PHP发展历史简述</strong><br>PHP于1994年由<code>Rasmus Lerdorf</code>创建，刚刚开始是Rasmus Lerdorf 为了要维护个人网页而制作的一个简单的用Perl语言编写的程序，后来又用C语言重新编写，包括可以访问数据库，他将这些程序和一些表单直译器整合起来，称为 PHP/FI，PHP/FI 可以和数据库连接，产生简单的动态网页程序。</p><p><br/></p><p><strong>PHP编程语言特点</strong></p><ul><li>1.是开放源代码的，服务器端的脚本语言.</li><li>2.独立于操作系统，可以运行在几乎所有系统(Win/Linux)中（兼容所有操作系统和web服务器）</li><li>3.支持大部分的服务器</li><li>4.支持大量的数据库，例如 MySql、SQL Server、Oracle等</li><li>5.可以创建图像</li><li>6.其他功能在后面的高级技术详细介绍。</li></ul><p><br/></p><p><strong>PHP编程语言能干什么?</strong></p><p>1、生成动态页面内容；<br>2、能够创建、打开、读取、写入、删除以及关闭服务器上的内容文件；<br>3、能够接收表单数据；<br>4、能够发送并取回 cookies；<br>5、能够对(各类)数据库中的数据进行增删改查等操作；<br>6、能够限制用户访问网站中的某些页面；<br>7、语法混合了 C、Java、Perl 以及 PHP 自创新的语法；<br>8、处理 XML 文件；<br>9、会话控制Session Cookies；<br>10、开发客户端图形界面（GUI）程序</p><p><br/></p><p>在实践使用中,可根据自己的需要在HTML文件中像这样开启或关闭PHP模式，通常也是将PHP语言嵌入HTML中进行一起使用，例如CSS、JavaScript、PHP、ASP以及JSP等。</p><p><strong>简单示例:</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt; <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">"PHP 语言标记的使用"</span> <span class="meta">?&gt;</span> &lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'bgcolor="#cccccc"'</span> <span class="meta">?&gt;</span> &gt;</span><br><span class="line">    <span class="meta">&lt;?php</span>  <span class="keyword">if</span>($expression)&#123;<span class="meta">?&gt;</span></span><br><span class="line">      &lt;p align=<span class="string">" &lt;?php echo 'center' ?&gt; "</span>&gt;This is <span class="keyword">true</span>&lt;/p&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span>  &#125;<span class="keyword">else</span>&#123; <span class="meta">?&gt;</span></span><br><span class="line">      &lt;p&gt;This is <span class="keyword">false</span>&lt;/p&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span>  &#125; <span class="meta">?&gt;</span></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br/></p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java作为当前后端开发最火(hot)的语言，被广泛应用在各大企业项目开发中，所以在前几年就业还是比较广阔的，但是随着像Go、Node.js编程语言的不断发展，越来越多的岗位招聘偏向于Go(毕竟有Google背书不担心市场)，后面一章节会有简单介绍，此处还是回归正题。</p><p>Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言(Java面向对象程序设计语言和Java平台的总称)，其作者是詹姆斯.高斯林(James Gosling)，他也被誉为是JAVA之父,  他是与SUN公司的<code>Patrick/Naughton/Mike Sheridan</code>等人合作开发的一套语言，最开始叫”Oak”后改名为JAVA;</p><p><strong>Java语言特性：</strong></p><ul><li><p>开源、免费、纯面向对象。</p><ul><li>开源：开发源代码,SUN公司编写的java类库的源代码普通程序员能看到。</li><li>免费</li><li>面向对象：提供类/接口和继承等面向对象的特性(只支持类之间的单继承,但支持接口之间的多继承(extends),并支持类与接口之间的实现机制(关键字为implements),全面支持动态绑定;</li></ul></li><li><p>简单性：</p><ul><li>与C语言和C++语言很接近很容易学习和使用</li><li>丢弃了C++中(操作符重载、多继承、自动的强制类型转换)</li><li>特别地Java语言不使用指针,而是引用)并提供了自动的废料收集,使得程序员不必为内存管理而担忧。</li></ul></li><li><p>健壮性：</p><ul><li>Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证(丢弃指针pointer),Java的安全检查机制使得Java更具健壮性。</li></ul></li><li><p>动态的</p><ul><li>设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境,也可以通过网络来载入所需要的类。这也有利于软件的升级,另外Java中的类有一个运行时刻的表示,能进行运行时刻的类型检查。</li></ul></li><li><p>分布式的</p><ul><li>支持Internet应用的开发,在基本的Java应用编程接口中有一个网络应用编程接口(java net),它提供了用于网络应用编程的类库,包括URL、URLConnection、Socket、ServerSocket等,JAVARMI(远程方法激活)机制也是开发分布式应用的重要手段</li></ul></li><li><p>安全的</p><ul><li>提供了一个安全机制以防恶意代码的攻击,Java对通过网络下载的类具有一个安全防范机制(类ClassLoader),如分配不同的名字空间以防替代本地的同名类、字节代码检查,并提供安全管理机制(类SecurityManager)让Java应用设置安全哨兵。</li></ul></li><li><p>高性能的</p><ul><li>与解释型的高级脚本语言相比,Java的确是高性能的。事实上Java的运行速度随着JIT(Just-In-Time)编译器技术的发展越来越接近于C++。</li></ul></li><li><p>体系结构中立</p><ul><li>Java程序(后缀为java的文件)在Java平台上被编译为体系结构中立的字节码格式(后缀为class的文件),然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</li></ul></li><li><p>java支持多线程</p><ul><li>Java语言支持多个线程的同时执行,并提供多线程之间的同步机制(关键字为synchronized)</li><li>线程是一种特殊的对象,它必须由Thread类或其子(孙)类来创建；</li><li>通常有两种方法来创建线程：其一,使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程。</li><li>其二,从Thread类派生出子类并重写run方法,使用该子类创建的对象即为线程。</li><li>值得注意的是Thread类已经实现了Runnable接口,因此任何一个线程均有它的run方法,而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。</li></ul></li><li><p>java自动垃圾回收机制即GC机制:【java运行过程当中有一个“垃圾回收器”一直在守护者。】</p></li></ul><ul><li>跨平台/可移植 <ul><li>跨平台：依靠JVM机制【java程序不和操作系统交互,java程序运行在JVM中,JVM和操作系统交互】</li><li>Java程序并没有和底层的操作系统直接交互,java程序实际上运行在jvm当中,JVM屏蔽了操作系统之间的差异。不同的操作系统中必须安装不同版本的JVM。</li><li>可移植：来源于体系结构中立性,Java严格规定了各个基本数据类型的长度；Java程序在Java平台上被编译为字节码格式,使得可以在java平台上的任何系统种运行;</li><li>Java系统本身也具有很强的可移植性,Java编译器是用Java实现的,Java的运行环境是用ANSI C实现的。</li><li>但是为了达到可移植,必须提前在操作系统中安装JRE,JRE有了之后才会有JVM。</li></ul></li></ul><figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190419143704.png" alt="WeiyiGeek.JAVA跨平台" title="" class="">                <p>WeiyiGeek.JAVA跨平台</p>            </figure><p>总结：因为有了JVM所以同一个JAVA程序在三个不同的操作系统中都可以执行;这才使JAVA程序具有跨平台性与良好的移植性;</p><p><br/></p><p><strong>我的第一个JAVA程序</strong><br>创建文件 HelloWorld.java (文件名与类名尽量是一致), 代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：String args[] 与 String[] args 都可以执行，但推荐使用 String[] args，这样可以避免歧义和误读。</span></span><br><span class="line"><span class="comment">// 修饰符  类   类名   （注意要一致）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主方法相当于C中的main函数,入口;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用jdk目录中javac/java进行编译然后执行（下面为了防止乱码在编译成为字节码文件的时候采用utf8编码）   </span></span><br><span class="line"><span class="comment">// 1.该命令用于将 java 源文件编译为 class 字节码文件，会出现一个 HelloWorld.class 的文件</span></span><br><span class="line">&gt; javac -encoding UTF-<span class="number">8</span> HelloWorld.java  </span><br><span class="line"><span class="comment">// 2.java 后面跟着的是java文件中的类名(注意：java命令后面不要加.class)</span></span><br><span class="line">&gt; java HelloWorld   </span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><br><figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190419155103.png" alt="WeiyiGeek.HelloWorld" title="" class="">                <p>WeiyiGeek.HelloWorld</p>            </figure></p><p><strong>Q:什么是类名？</strong><br>答：假设硬盘上有一个文件叫做Hello.class，那么类名就叫做 Hello，此时在命令行终端中我们可以利用java进行直接执行;</p><p><br/></p><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4><p><strong>为什么你应该学习Go语言？</strong></p><blockquote><p>世界上已经有太多太多的编程语言了，为什么又出来一个Go语言？<br>官方介绍: Go是一种开源编程语言，它使构建简单、可靠和高效的软件变得容易。<br>因为其编程语言的良好特性和Google公司强势推广以及以Go语言相关开源项目火爆, 比如 <code>etcd、kubernetes、Prometheus</code> 等项目, 其次是硬件性能提高则我们需要高性能的软件.</p></blockquote><p>参考 Golang 编程语言排行榜 : <a href="https://www.tiobe.com/tiobe-index" target="_blank" rel="noopener">https://www.tiobe.com/tiobe-index</a></p><figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210728174737.png" alt="WeiyiGeek.2010-2021年Go编程趋势" title="" class="">                <p>WeiyiGeek.2010-2021年Go编程趋势</p>            </figure><p><strong>What,什么是Go语言?</strong></p><p>描述:<code>Go（又称Golang[4]-Google-go-language）</code>是Google开发的一种<code>静态强类型</code>、<code>编译型</code>、<code>并发型</code>，并具有<code>垃圾回收功能、优良的并行设计</code>的编程语言, 其被誉为21世纪的C语言, 因为其Go的语法接近C语言，但对于变量的声明有所不同。</p><p>Go的并行计算模型是<code>以东尼·霍尔</code>的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括<code>Occam</code>和<code>Limbo</code>，Go也具有这个模型的特征，比如通道传输，通过<code>goroutine</code>和通道等并行构造可以建造线程池和管道等。</p><ul><li><p>(1) 与 <code>C++</code> 相比 Go 并不包括如<code>枚举、异常处理、继承、泛型、断言、虚函数</code>等功能，但增加了<code>切片(Slice) 型、并发、管道、垃圾回收功能、接口等</code>特性的语言级支持以及支持垃圾回收功能。</p></li><li><p>(2) 不同于 Java，Go原生提供了关联数组（也称为<code>哈希表（Hashes）</code>或<code>字典（Dictionaries）</code>）。 </p></li></ul><p><strong>Go 语言有何特点:</strong></p><ul><li>0.Go语言语法简单易学、代码风格统一<code>(自动格式化)</code>、支持垃圾回收功能、执行性能好、是企业级编程语言。<blockquote><p>Go 语言简单易学，学习曲线平缓，不需要像 C/C++ 语言动辄需要两到三年的学习期。<br>Go 语言的风格类似于C语言。其语法在C语言的基础上进行了大幅的简化，去掉了不需要的表达式括号，循环也只有 for 一种表示方法，就可以实现数值、键值等各种遍历。<br>Go 语言提供了一套格式化工具<code>go fmt</code>, 在开发环境或者编辑器在保存时，都会使用格式化工具进行修改代码的格式化，这样就保证了不同开发者提交的代码都是统一的格式。</p></blockquote></li></ul><p><br/></p><ul><li><p>1.Go语言让你用写Python代码的开发效率编写C语言代码 (<code>编程范型: 编译型，可平行化，结构化，指令式</code>)。</p></li><li><p>2.Go语言从底层原生支持并发，无须第三方库、开发者的编程技巧和开发经验。</p><blockquote><p>Go语言的并发是基于 goroutine（<code>类似于线程，但并非线程</code>） 的。可以将 goroutine 理解为一种虚拟线程。Go 语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用CPU性能。开启一个goroutine的消耗非常小（<code>大约2KB的内存</code>），你可以轻松创建数百万个goroutine。<br>goroutine的特点:</p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 具有可增长的分段堆栈。这意味着它们只在需要时才会使用更多内存。</span><br><span class="line">* 启动时间比线程快。</span><br><span class="line">* 原生支持利用channel安全地进行通信。</span><br><span class="line">* 共享数据结构时无需使用互斥锁。</span><br></pre></td></tr></table></figure><ul><li>3.Go语言性能强悍，同<code>C,C++</code>一样Go语言也是编译型的语言，它直接将人类可读的代码编译成了处理器可以直接运行的二进制文件，执行效率更高，性能更好。 </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解释型语言：Shell 语言、Python 语言、PHP 语言</span><br><span class="line">编译型语言：C 语言、C++ 语言、Go 语言</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210728220116.png" alt="WeiyiGeek.编译型的语言" title="" class="">                <p>WeiyiGeek.编译型的语言</p>            </figure><p>由下图可以看出，Go 语言在性能上更接近于 Java 语言，虽然在某些测试用例上不如经过多年优化的 Java 语言，但毕竟 Java 语言已经经历了多年的积累和优化。</p><p>我坚信Go 语言在未来的版本中会通过不断的版本优化提高单核运行性能。</p><figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210728220435.png" alt="WeiyiGeek.常见编程语言运行性能比较" title="" class="">                <p>WeiyiGeek.常见编程语言运行性能比较</p>            </figure><p>数据来源：<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/" target="_blank" rel="noopener">https://benchmarksgame-team.pages.debian.net/benchmarksgame/</a></p><p><strong>Linux下环境安装与牛刀小试</strong></p><p>如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.下载二进制源码包并将将下载的源码包解压至 /usr/local目录</span></span><br><span class="line">wget https://dl.google.com/go/go1.16.6.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/<span class="built_in">local</span> -xzf go1.16.6.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.将 /usr/local/go/bin 目录添加至PATH环境变量</span></span><br><span class="line"><span class="comment">#在/root/.profile进行添加</span></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go  <span class="comment"># 安装目录</span></span><br><span class="line"><span class="comment">#GOROOT 第三方包的安装包路径</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=/home/go/      <span class="comment"># 项目路径一般指向src</span></span><br><span class="line"><span class="comment">#需要BIN目录和GOPATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.验证是否安装成功, 可以打开终端窗口输入go version命令，查看安装的Go版本。</span></span><br><span class="line">go env</span><br><span class="line">go version go version go1.16.6 linux/amd64</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.go语言程序编译运行</span></span><br><span class="line">package main</span><br><span class="line">import <span class="string">"fmt"</span></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.编译运行hello.go</span></span><br><span class="line">go build hello.go</span><br><span class="line">go run hello.go &amp;&amp; ./hello</span><br></pre></td></tr></table></figure><br><figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2020/1/20200423130326.png" alt="WeiyiGeek.Go-Binary" title="" class="">                <p>WeiyiGeek.Go-Binary</p>            </figure></p><hr><h3 id="7-数据库"><a href="#7-数据库" class="headerlink" title="7.数据库"></a>7.数据库</h3><p>前面了解常用的后端开发语言，本节也来简单了解一下常用的数据库存储软件，作为运维打交道最多的必不可少的就是数据库，当前企业中最常用的数据库（包含关系型与非关系型）有<a href="https://www.oracle.com" target="_blank" rel="noopener">Oracle</a>、<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL</a>、<a href="https://www.microsoft.com/zh-cn/sql-server/sql-server-2022" target="_blank" rel="noopener">MsSQL</a>、<a href="https://www.redis.io/" target="_blank" rel="noopener">Redis</a>、<a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL</a>等，此时简单介绍前三种数据库。</p><h4 id="Oracle-关系型数据库"><a href="#Oracle-关系型数据库" class="headerlink" title="Oracle  关系型数据库"></a>Oracle  关系型数据库</h4><p>Oracle 数据库(<code>Oracle database,简称 Oracle</code>) 又名<code>Oracle RDBMS</code>是甲骨文公司的一款关系数据.</p><p>Oracle 数据库产品为客户提供成本优化的高性能版 Oracle 数据库、全球领先的融合多模型数据库管理系统以及 In-memory、NoSQL 和 MySQL 数据库。客户可以在本地部署环境中通过 Oracle 公有云本地化解决方案使用 Oracle 自治数据库，也可以在 Oracle 云基础设施中使用 Oracle 自治数据库，从而简化关系数据库环境并减少管理工作量。</p><p>数据库库管理系统(RDBMS), 并且由于 Oracle 实现面向对象特性（例如用户定义类型、继承和多态）的 RDBMS 称为<code>对象关系数据库管理系统 (ORDBMS)</code>, Oracle 数据库已<code>将关系模型扩展为对象关系模型</code>，从而可以在关系数据库中存储复杂的业务模型。</p><p>Oracle 数据库它是在关系型数据库领域中一直处于领先地位的产品，它可在本地环境和云端提供市场领先的性能、可扩展性、可靠性和安全性,可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统。</p><p>Oracle 数据库系统可移植性好、使用方便、功能强,适用于各类大、中、小、微机环境 ,它是一种高效率、可靠性好的适应高吞吐量的数据库解决方案。</p><p>Tips ： 当下(<code>2021年9月23日 17:16:05</code>)最新的长期支持版 <code>Oracle Database 19c</code> 拥有超高水平的版本稳定性以及超长的支持和错误修复支持周期，可为您的应用提供一个超级稳定的平台。</p><p>Tips : Oracle 数据库技术官网站点 (<a href="https://www.oracle.com/cn/database/technologies/" target="_blank" rel="noopener">https://www.oracle.com/cn/database/technologies/</a>)</p><p><br></p><p><strong>Oracle 数据库多操作平台支持:</strong><br>甲骨文公司的<code>Oracle10g/11g/12c/18c/19c</code>支持常见的操作系统例如:</p><ul><li>Microsoft Windows x86,x86-64</li><li>Linux x86,x86-64</li><li>Apple Mac OS X Server</li><li>Sun Salaris SPARC x86,x86-64</li></ul><p><br></p><p><strong>Oracle 数据库特性:</strong></p><ul><li>高可用性 : 丰富的内置功能和选件，包括 <code>Oracle Active Data Guard</code> 和 <code>Oracle Real Application Clusters</code>，可支持高效扩展和整合客户数据库, 来保护重要客户数据库，大幅提高数据可用性。</li><li>数据库安全性 : <code>借助加密、数据屏蔽、特权用户访问控制、活动监视和审计</code>功能; 降低数据泄露风险，并让客户能够更加轻松地满足合规性要求。</li><li>数据库可管理性 : 通过单一管理仪表盘和一致的管理流程提高企业级数据库的性能和可用性，减少 DBA 的工作量。</li><li>性能与可伸缩性 : 通过一系列强大功能优化延迟，提高吞吐量，满足实时环境和数据中心环境下严格的性能要求。</li></ul><p>博主的Oracle学习之路汇总学习笔记参考: <a href="https://blog.weiyigeek.top/2018/1-1-1.html#Oracle学习之路汇总">https://blog.weiyigeek.top/2018/1-1-1.html#Oracle学习之路汇总</a></p><p><br/></p><h4 id="MySQL-关系型数据库"><a href="#MySQL-关系型数据库" class="headerlink" title="MySQL 关系型数据库"></a>MySQL 关系型数据库</h4><p>MySQL数据库是一款非常受欢迎的开源领域的重要的关系型数据库，由瑞典的MySQL AB公司开发，Mysql数据库现属于ORACLE公司，使的自身的商业数据库与开源数据库在市场上占有的份额都是跃居第一的位置，这时MySQL的主要开发者Michael widenius ，跳出来建立了一个MySQL分支数据库这就是MariaDB的诞生与发展，来防止MySQL闭源的潜在危险；</p><p>MySQL属于传统关系数据库，<em>开放式的架构使得用户选择性很强，社区开发维护人数众多，功能稳定，性能卓越，且在准寻GPL协议的前体下，可以免费的修改使用</em>，因此也为MySQL的推广带来了更多的便利；</p><p>MySQL是一种关系型数据库管理系统(RDBMS)，关系型数据库的特点是将数据保存在不同的表中，在将这些表放入不同的数据库中，而不是将所有数据统一放在一个大仓库里．这样的设计增加了 <em>MySQL 的读取速度，灵活性可管理性也得到了很大提高</em> ，访问以及管理 MysQL 数据库的最常用标准化语言为 SQL 结构化杳询语言。</p><p><em>Q:为什么选择MySQL数据库？</em></p><ul><li>1) 性能卓越，服务稳定，很少出现异常宕机（dang）</li><li>2) 开发源代码且无版权制约，自主性及使用成本低；</li><li>3) 历史悠久，社区活跃，遇到问题能很快解决；</li><li>4) 软件体积小，安装简单，并且易于维护，安装及维护成本低</li><li>5) 知名度高，企业非常喜欢直接用之，LAMP/LEMP流行架构；</li><li>6) 跨平台运行，提供各种API接口，支持多种开发语法PHP/JSP/ASP，主要是PHP语言；</li></ul><p>博主的MySQL学习之路汇总学习笔记参考: <a href="https://blog.weiyigeek.top/2018/1-1-1.html#MySQL学习之路汇总">https://blog.weiyigeek.top/2018/1-1-1.html#MySQL学习之路汇总</a></p><p><br/></p><h4 id="MsSQL-关系型数据库"><a href="#MsSQL-关系型数据库" class="headerlink" title="MsSQL 关系型数据库"></a>MsSQL 关系型数据库</h4><p>MsSQL全称为<code>Microsoft SQL Server</code>，一般简称 MsSQL 或SQL Server；它是指微软的SQLServer数据库服务器。它是一个数据库平台，提供数据库的从服务器到终端的完整的解决方案，其中数据库服务器部分，是一个关系型数据库管理系统，用于建立、使用和维护数据库。</p><p>SQL-Server是一个可扩展的、高性能的、为分布式客户机/服务器计算所设计的数据库管理系统，实现了与WindowsNT的有机结合，提供了基于事务的企业级信息管理系统方案。</p><p>当前最新的MsSQL版本为 SQL Server 2022, 以及上一个版本为 SQL Server 2019、SQL Server BI，早期版本有 SQL Server 2017、SQL Server 2016、SQL Server 2008、SQL Server 2005，其中大家熟知常用的SQL Server 2008在当前企业老的业务系统中占比还是挺大了。</p><p><strong>主要特性:</strong></p><p>1) 高性能设计，可充分利用WindowsNT的优势。</p><p>2) 系统管理先进，支持Windows图形化管理工具，支持本地和远程的系统管理和配置。</p><p>3) 强壮的事务处理功能，采用各种方法保证数据的完整性。</p><p>4) 支持对称多处理器结构、存储过程、ODBC，并具有自主的SQL语言。SQLServer以其内置的数据复制功能、强大的管理工具、与Internet的紧密集成和开放的系统结构为广大的用户、开发人员和系统集成商提供了一个出众的数据库平台。</p><p>博主的MsSQL学习之路汇总学习笔记参考: <a href="https://blog.weiyigeek.top/2018/1-1-1.html#MsSQL学习之路汇总">https://blog.weiyigeek.top/2018/1-1-1.html#MsSQL学习之路汇总</a></p><p><br/></p><h4 id="Redis-非关系型数据库"><a href="#Redis-非关系型数据库" class="headerlink" title="Redis 非关系型数据库"></a>Redis 非关系型数据库</h4><p>Redis是一种开源（BSD 许可）内存数据库，使用ANSI C语言编写、内存中数据结构存储，用作数据库、缓存和消息代理。Redis 提供了诸如字符串、散列、列表、集合、带范围查询的排序集合、位图、超级日志、地理空间索引和流等数据结构。</p><p>Redis 内置复制、Lua 脚本、LRU 驱逐、事务和不同级别的磁盘持久化，并通过 <code>Redis Sentinel</code> 和 <code>Redis Cluster</code> 自动分区提供高可用性。</p><p>它通常被称为数据结构服务器它有五种类型值（value）: <code>字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)</code>等类型。</p><p><br/></p><p><strong>Redis 特点</strong></p><ul><li>非关系型数据库， 即Not-OnlySQL（泛指非关系型的数据库），作为关系型数据库的补充。</li><li>支持数据的持久化，可以将内存中的数据保存在磁盘中,重启的时候可以再次加载进行使用。</li><li>不仅仅支持简单的<code>key-value</code>类型的数据,同时还提供list，set，zset，hash等数据结构的存储。</li><li>支持数据的备份即<code>master-slave</code>主从模式的数据备份。 </li></ul><p><br/></p><p><strong>Redis 优势</strong></p><ul><li>是一个开源的 <code>key-value</code> 存储系统,并且性能高体现在IO读写(R&gt;W)</li><li>R是非常轻量级,一个空Redis实例占用的内在只有1M左右,所以不用担心多个Redis实例会额外占用很多内存。</li><li>丰富得数据类型<code>(String/Hash/List/sets/Sorted sets)</code></li><li>所有得操作都是原子性得(要么成功要么失败完全不执行),且多个操作支持事务即原子性(通过MULTI和EXEC指令包起来)</li></ul><p><br/></p><p><strong>Redis 与其他K-V存储异同</strong></p><ul><li>R不是一个普通的键值存储，它实际上是一个数据结构服务器，支持不同类型的值。</li><li>R有更为复杂得数据结构并提供事务处理机制(原子性操作)</li><li>R运行在内存中但是可以持久化到磁盘之中,在对数据集进行高速读写时需要权衡内存(数据量不能大于硬件内存)</li><li>在磁盘格式方面他们是紧凑的以追加的方式产生的,因为他们并不需要进行随机访问</li></ul><p><br></p><p><strong>Redis 应用</strong></p><ul><li>为热点数据加速查询（主要场景）、如热点商品、热点新闻、热点资讯、推广类等提高访问量信息等。</li><li>任务队列、如秒杀、抢购、购票等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li><li>时效性信息控制，如验证码控制，投票控制等</li><li>分布式数据共享，如分布式集群构架中的session分离</li><li>消息队列(通过发布和订阅实现)</li><li>分布式锁</li></ul><p>博主的Redis学习之路汇总学习笔记参考: <a href="https://blog.weiyigeek.top/2018/1-1-1.html#Redis学习之路汇总">https://blog.weiyigeek.top/2018/1-1-1.html#Redis学习之路汇总</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.weiyigeek.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端学习" scheme="https://blog.weiyigeek.top/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="全栈学习" scheme="https://blog.weiyigeek.top/tags/%E5%85%A8%E6%A0%88%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>设计制图/AutoCAD/学习中</title>
    <link href="https://blog.weiyigeek.top/2023/2-14-index.html"/>
    <id>https://blog.weiyigeek.top/2023/2-14-index.html</id>
    <published>2023-02-14T04:42:54.962Z</published>
    <updated>2023-02-14T04:42:54.962Z</updated>
    
    <content type="html"><![CDATA[<p>op =&gt; 打开选项卡</p><p>平面设置不需要三维，三维建模-&gt; 去选掉 Viewcub 与 UCS 图标</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;op =&amp;gt; 打开选项卡&lt;/p&gt;
&lt;p&gt;平面设置不需要三维，三维建模-&amp;gt; 去选掉 Viewcub 与 UCS 图标&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>虚拟云容/云容器/Containerd/5</title>
    <link href="https://blog.weiyigeek.top/2023/2-1-index.html"/>
    <id>https://blog.weiyigeek.top/2023/2-1-index.html</id>
    <published>2023-02-01T09:39:33.607Z</published>
    <updated>2023-02-01T09:39:33.607Z</updated>
    
    <content type="html"><![CDATA[<p>前面利用 serviceaccount 与 imagePullSecrets 相绑定，此处为了验证镜像拉取 Secret 已经被添加到 Pod 规约, 现在在当前命名空间中创建使用默认服务账号的新 Pod 时，新 Pod 会自动设置其<code>.spec.imagePullSecrets</code>字段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image=nginx --restart=Never</span><br><span class="line">kubectl get pod nginx -o=jsonpath=<span class="string">'&#123;.spec.imagePullSecrets[0].name&#125;&#123;"\n"&#125;'</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面利用 serviceaccount 与 imagePullSecrets 相绑定，此处为了验证镜像拉取 Secret 已经被添加到 Pod 规约, 现在在当前命名空间中创建使用默认服务账号的新 Pod 时，新 Pod 会自动设置其&lt;code&gt;.spec.imagePul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>9.Jenkins实践之连接外部Docker部署的分布式Agent工作节点</title>
    <link href="https://blog.weiyigeek.top/2023/1-31-710.html"/>
    <id>https://blog.weiyigeek.top/2023/1-31-710.html</id>
    <published>2023-01-31T05:34:30.000Z</published>
    <updated>2023-02-07T15:21:11.368Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p>看过我前面Jenkins学习之路的朋友肯定知道，在Kubenetes中使用Jenkins可以进行动态生成分布式jnlp-slave的agent节点，相比于传统的agent节点来说极大的节约资源。</p><p>但是某一天开发反馈某个项目CICD无法正常进行，作为运维人员（搬砖）立马进入K8S集群，排除安装在集群中的Jenkins的异常问题，排查可知由于K8S集群证书到期导致动态jenkins agent节点无法正常被创建，此时项目又比较紧急。</p><p>遂利用装有Docker的机器，立即使用自行构建的jenkins-jnlp-agent镜像，并在 jenkins 中创建一个固定节点，通过docker运行该镜像并连接到Jenkins，在流水线项目绑定到该节点执行，通过几分钟的时间就快速解决了jenkins agent问题，在项目完成持续集成和交互后，趁着间隙更新Jenkins上配置连接kubernetes apiserver的证书，恢复了动态生成agent节点。</p><p>所以，为了便于自己总结知识，以及有相同需求的看友，遂将jenkins外部agent节点接入以及自行构建jnlp-agent镜像流程进行实践，希望能帮助到大家。</p><p>如果此篇文章对你有用，请您也转发、点赞、在看、给周边的朋友吧!</p><p>温馨提示: 若需要企业 Jenkins Pipeline 流水线脚本的朋友，可以关注【WeiyiGeek】后回复【Jenkins流水线代码】即可下载 <code>Jenkins-Pipeline.groovy</code> 示例文件。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230207170309.png" alt="WeiyiGeek.Jenkins流水线代码图" title="" class="">                <p>WeiyiGeek.Jenkins流水线代码图</p>            </figure><hr><h2 id="0x01-基础环境准备"><a href="#0x01-基础环境准备" class="headerlink" title="0x01 基础环境准备"></a>0x01 基础环境准备</h2><h3 id="1-环境说明"><a href="#1-环境说明" class="headerlink" title="1.环境说明"></a>1.环境说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.K8s 集群中安装的 Jenkins </span></span><br><span class="line">~$ kubectl get pod,svc -n devops -l app=jenkins</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/jenkins-7fc6f4fcf6-glqxj   1/1     Running   0          28h</span><br><span class="line"></span><br><span class="line">NAME              TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                          AGE</span><br><span class="line">service/jenkins   NodePort   10.109.163.223   &lt;none&gt;        8080:30001/TCP,50000:30634/TCP   382d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.Jenkins 安装版本</span></span><br><span class="line">Jenkins 2.330</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.地址说明</span></span><br><span class="line">Jenkins 面板: http://192.168.12.107:30001/</span><br><span class="line">TCP port <span class="keyword">for</span> inbound agents(Agent 端口): http://192.168.12.107:30634/  ( 内部为 50000，若是在集群中使用则需要将nodePort端口改成，可通过转发的形式 因为K8S默认nodePort范围在 30000-32767 之中)</span><br></pre></td></tr></table></figure><p>温馨提示: 我们需要修改 Jenkins Agent 端口 可以访问 Dashboard 全局安全配置 -&gt; 代理 (TCP port for inbound agents) 指定端口设置为 30634，注意相对应Pod暴露的端口也要一同修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit deployments.apps -n devops jenkins</span><br><span class="line">  ports:</span><br><span class="line">  - containerPort: 8080</span><br><span class="line">    name: web</span><br><span class="line">    protocol: TCP</span><br><span class="line">  - containerPort: 30634  <span class="comment"># 修改点</span></span><br><span class="line">    name: agent</span><br><span class="line">    protocol: TCP</span><br><span class="line"></span><br><span class="line">$ kubectl edit svc -n devops jenkins</span><br><span class="line">  - name: agent</span><br><span class="line">    nodePort: 30634    </span><br><span class="line">    port: 30634        <span class="comment"># 修改点与 containerPort 要一致。</span></span><br><span class="line">    protocol: TCP:q</span><br><span class="line">    targetPort: agent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证查看 Pod 与 服务是否正常</span></span><br><span class="line">$ kubectl get svc,pod -n devops -l app=jenkins</span><br><span class="line">  NAME              TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                          AGE</span><br><span class="line">  service/jenkins   NodePort   10.109.163.223   &lt;none&gt;        8080:30001/TCP,30634:30634/TCP   382d</span><br><span class="line">  </span><br><span class="line">  NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">  pod/jenkins-856bc9b47f-4t7k5   1/1     Running   0          2m9s</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230202172521.png" alt="WeiyiGeek.Jenkins-inbound agents端口修改图" title="" class="">                <p>WeiyiGeek.Jenkins-inbound agents端口修改图</p>            </figure><p>或者采用如下临时解决办法（下面实践1中采用的是此种方法，正式环境下还是建议使用上面的方法稳定，但是需要更改和注意的事项更多了）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n devops port-forward --address 127.0.0.1,192.168.12.107 jenkins-7fc6f4fcf6-glqxj 50000:50000</span><br><span class="line">  <span class="comment"># Forwarding from 127.0.0.1:50000 -&gt; 50000</span></span><br><span class="line">  <span class="comment"># Forwarding from 192.168.12.107:50000 -&gt; 50000</span></span><br><span class="line">  <span class="comment"># Handling connection for 50000</span></span><br><span class="line">  <span class="comment"># Handling connection for 50000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者在 jenkins 控制器资源清单中设置 hostNetwork: true</span></span><br></pre></td></tr></table></figure></p><p>温馨提示: 若看友不了解Jenkins持续集成的，或者需要安装实践的，可以参考博主学习【Jenkins学习之路汇总】汇总，关注 <code>WeiyiGeek</code> 公众号回复【<code>jenkins学习之路</code>】即可获得学习资料：</p><p><br/></p><h3 id="2-添加新的Jenkins-agent节点"><a href="#2-添加新的Jenkins-agent节点" class="headerlink" title="2.添加新的Jenkins agent节点"></a>2.添加新的Jenkins agent节点</h3><p>操作步骤如下: Dashboard 系统管理 -&gt; 节点管理 -&gt; 新建节点 -&gt; 按照提示输入如下信息 -&gt; 最后点击保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础配置</span></span><br><span class="line">节点名字: docker-jenkins-jnlp</span><br><span class="line">Number of executors (最大执行数): 1~5 </span><br><span class="line">远程工作目录: /home/jenkins/agent</span><br><span class="line">标签: docker-jnlp-1</span><br><span class="line">启动方式: 通过 Java Web 启动代理</span><br><span class="line">可用性: 尽量保持代理在线</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点属性</span></span><br><span class="line">- 工具位置: 请按照实际情况填写。 </span><br><span class="line">  <span class="comment"># 例如, Docker 配置，名称 Docker ，目录 /var/run/docker.sock</span></span><br><span class="line">- 环境变量:</span><br><span class="line">  <span class="comment"># 例如，键值对列表，键 name 值 weiyigeek</span></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230202154237.png" alt="WeiyiGeek.新建Docker-agent节点图" title="" class="">                <p>WeiyiGeek.新建Docker-agent节点图</p>            </figure><p>温馨提示: 在点击保存后，我们可以点击此节点，看到其提示节点连接Jenkins的方式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">java -jar agent.jar -jnlpUrl http://192.168.12.107:30001/computer/docker%2Djenkins%2Djnlp/jenkins-agent.jnlp -secret b97b9d1e0cf083f9da5721caa6ebc63f6fe648375bd90cb2c2f484681d887bb7 -workDir <span class="string">"/home/jenkins/agent"</span></span><br><span class="line"></span><br><span class="line">java -Xms512m -Xmx1g -Xss1m  -jar /usr/<span class="built_in">local</span>/bin/agent.jar -jnlpUrl http://192.168.12.107:30001/computer/jenkinsAgentWork1/jenkins-agent.jnlp  -secret 2a789bbbd0193ef576e7b62eb2d205d1d024d0ea7b14f6f79f1cccdd6fb1ed20 -workDir <span class="string">"/home/jenkins/agent"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line"><span class="comment"># Run from agent command line, with the secret stored in a file:</span></span><br><span class="line"><span class="built_in">echo</span> b97b9d1e0cf083f9da5721caa6ebc63f6fe648375bd90cb2c2f484681d887bb7 &gt; secret-file</span><br><span class="line">java -jar agent.jar -jnlpUrl http://192.168.12.107:30001/computer/docker%2Djenkins%2Djnlp/jenkins-agent.jnlp -secret @secret-file -workDir <span class="string">"/home/jenkins/agent"</span></span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230206171800.png" alt="WeiyiGeek.节点连接Jenkins的方式图" title="" class="">                <p>WeiyiGeek.节点连接Jenkins的方式图</p>            </figure><p><br/></p><h3 id="3-自行构建Jenkins-Agent镜像-干货"><a href="#3-自行构建Jenkins-Agent镜像-干货" class="headerlink" title="3.自行构建Jenkins Agent镜像(干货)"></a>3.自行构建Jenkins Agent镜像(干货)</h3><p>描述: 在<code>WeiyiGeek</code>微信公众号回复<code>20230206</code>关键字，即可获取最新Jenkins-jnlp镜像构建的Dockerfile及下述相关脚本文件，此处我们自定义的jnlp容器镜像主要实现功能如下: </p><ul><li>用户权限控制(sudo)</li><li>ssh 远程连接</li><li>git 代码版本控制</li><li>docker 容器管理</li><li>kubectl 集群管理</li><li>Java 运行环境</li><li>Maven 运行环境</li><li>NodeJS 环境</li><li>SonarQube 扫描环境</li><li>Gitlab-Release 上传环境</li><li>中文环境支持</li><li>时区更改配置</li><li>自定义工作目录（/home/jenkins/agent）</li></ul><p>温馨提示: 如下操作构建依赖于Docker环境,若你没有安装Docker环境或者不了解的Docker容器的朋友，可以参考博主学习【Docker的系列笔记】汇总，关注 <code>WeiyiGeek</code> 公众号回复【<code>Docker容器学习之路汇总</code>】即可获得学习资料：</p><p><br/></p><p><strong>构建目录</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~/k8s/jenkins/jnlp-slave$ tree .</span><br><span class="line">.</span><br><span class="line">├── agent.jar  <span class="comment"># Jenkins -&gt; 2.330</span></span><br><span class="line">├── agent.jar.bak</span><br><span class="line">├── apache-maven-3.8.4-bin.tar.gz</span><br><span class="line">├── build</span><br><span class="line">│   └── Dockerfile</span><br><span class="line">├── docker</span><br><span class="line">├── glibc-2.32-r0.apk</span><br><span class="line">├── glibc-bin-2.32-r0.apk</span><br><span class="line">├── glibc-i18n-2.32-r0.apk</span><br><span class="line">├── jdk-8u281-linux-x64.tar.gz</span><br><span class="line">├── jenkins-agent.sh</span><br><span class="line">├── kubectl</span><br><span class="line">├── locale.md</span><br><span class="line">├── release-cli-0.10.0-linux-amd64</span><br><span class="line">├── remoting-4.11.2.jar</span><br><span class="line">├── sgerrand.rsa.pub</span><br><span class="line">└── sonar-scanner-cli-4.5.0.2216-linux.zip</span><br><span class="line"></span><br><span class="line">1 directory, 16 files</span><br></pre></td></tr></table></figure></p><p>温馨提示:  在Jenkins 2.330版本中添加一个新的节点, 即可获取匹配当前版本的 agent.jar (<a href="http://youjenkins-domainname-or-ip/jnlpJars/agent.jar)" target="_blank" rel="noopener">http://youjenkins-domainname-or-ip/jnlpJars/agent.jar)</a>, 或者是在 jenkins 官网 <a href="https://repo.jenkins-ci.org/public/org/jenkins-ci/main/remoting" target="_blank" rel="noopener">https://repo.jenkins-ci.org/public/org/jenkins-ci/main/remoting</a> 进行下载;</p><p><br/></p><p><strong>自定义jnlp镜像的 Dockerfile</strong><br>博主自定义jnlp镜像hub地址: <a href="https://hub.docker.com/r/weiyigeek/alpine-jenkins-jnlp" target="_blank" rel="noopener">https://hub.docker.com/r/weiyigeek/alpine-jenkins-jnlp</a> 。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">$ cat build/Dockerfile</span><br><span class="line"><span class="comment">#----------------------------------------------------------------------#</span></span><br><span class="line"><span class="comment"># Title: Base in Alpine Images Create Custom Jenkins Kubernetes jnlp Images</span></span><br><span class="line"><span class="comment"># Author: WeiyiGeek</span></span><br><span class="line"><span class="comment"># WebSite: https://weiyigeek.top</span></span><br><span class="line"><span class="comment"># Email: mastr@weiyigeek.top</span></span><br><span class="line"><span class="comment"># Version: v1.12</span></span><br><span class="line"><span class="comment"># Image Version: alpine-3.13.1</span></span><br><span class="line"><span class="comment"># MainFunction:</span></span><br><span class="line"><span class="comment">#   Install ssh-server docker git openssh tzdata curl tar sudo git ca-certificates wget unzip docker zlib nodejs npm jq</span></span><br><span class="line"><span class="comment">#   Install JDK8 Version: 1.8.0_281</span></span><br><span class="line"><span class="comment">#   - https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</span></span><br><span class="line"><span class="comment">#   - https://github.com/sgerrand/alpine-pkg-glibc/releases/</span></span><br><span class="line"><span class="comment">#   - https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub</span></span><br><span class="line"><span class="comment">#   Install jnlp Version: 4.11.2 (两种方式都可以下载agent)</span></span><br><span class="line"><span class="comment">#   - https://repo.jenkins-ci.org/public/org/jenkins-ci/main/remoting/</span></span><br><span class="line"><span class="comment">#   - http://youjenkins-domainname/jnlpJars/agent.jar</span></span><br><span class="line"><span class="comment">#   Install Maven Version: 3.8.4</span></span><br><span class="line"><span class="comment">#   - https://apache.osuosl.org/maven/maven-3/$&#123;MAVEN_VERSION&#125;/binaries</span></span><br><span class="line"><span class="comment">#   Install SonarqubeScan Version: 4.5.0</span></span><br><span class="line"><span class="comment">#   - https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.5.0.2216-linux.zip</span></span><br><span class="line"><span class="comment">#   Install Gitlab Release Version: 0.10.0</span></span><br><span class="line"><span class="comment">#   - https://gitlab.com/gitlab-org/release-cli/-/releases</span></span><br><span class="line"><span class="comment">#   Install kubernetes cli</span></span><br><span class="line"><span class="comment">#   - kubectl Version: 1.23.1</span></span><br><span class="line"><span class="comment">#   Install docker cli</span></span><br><span class="line"><span class="comment">#   - kubectl Version: 20.10.3</span></span><br><span class="line"><span class="comment"># ChangeLog:</span></span><br><span class="line"><span class="comment"># v1.8  - 增加 docker</span></span><br><span class="line"><span class="comment"># v1.9  - 增加 中文环境</span></span><br><span class="line"><span class="comment"># v1.10 - 增加 node.js 环境支持</span></span><br><span class="line"><span class="comment"># v1.11 - 更新依赖软件版本及其agent.jar版本</span></span><br><span class="line"><span class="comment">#-------------------------------------------------#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.13</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span>  Jenkins Custom Work Node Jnlp Container - &lt;master@weiyigeek.top&gt; - WeiyiGeek</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> USERNAME=jenkins \</span><br><span class="line">    AGENT_WORKDIR=/home/jenkins \</span><br><span class="line">    BASE_DIR=/usr/local  \</span><br><span class="line">    BASE_BIN=/usr/local/bin  \</span><br><span class="line">    BASE_URL=http://<span class="number">192.168</span>.<span class="number">12.107</span>:<span class="number">8080</span>  \</span><br><span class="line">    LOCALE=locale.md \</span><br><span class="line">    JDK_NAME=jdk-<span class="number">8</span>u281-linux-x64   \</span><br><span class="line">    JDK_DIR=/usr/local/jdk1.<span class="number">8.0</span>_281  \</span><br><span class="line">    GLIBC_NAME=glibc-<span class="number">2.32</span>-r0.apk \</span><br><span class="line">    GLIBC_BIN_NAME=glibc-bin-<span class="number">2.32</span>-r0.apk \</span><br><span class="line">    GLIBC_I18N_NAME=glibc-i18n-<span class="number">2.32</span>-r0.apk \</span><br><span class="line">    MAVEN_NAME=apache-maven-<span class="number">3.8</span>.<span class="number">4</span>-bin \</span><br><span class="line">    MAVEN_DIR=/usr/local/apache-maven-<span class="number">3.8</span>.<span class="number">4</span> \</span><br><span class="line">    SONAR_SCANNER_NAME=sonar-scanner-cli-<span class="number">4.5</span>.<span class="number">0.2216</span>-linux \</span><br><span class="line">    SONAR_SCANNER_DIR=/usr/local/sonar-scanner-<span class="number">4.5</span>.<span class="number">0.2216</span>-linux \</span><br><span class="line">    GITLAB_CLI=release-cli-<span class="number">0.10</span>.<span class="number">0</span>-linux-amd64</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG=en_US.UTF-<span class="number">8</span> \</span><br><span class="line">    LC_ALL=en_US.UTF-<span class="number">8</span> \</span><br><span class="line">    JAVA_HOME=/usr/local/jdk8  \</span><br><span class="line">    JRE_HOME=/usr/local/jdk8/jre \</span><br><span class="line">    MAVEN_HOME=/usr/local/maven \</span><br><span class="line">    MAVEN_RPEO=/home/jenkins/.m2 \</span><br><span class="line">    SONAR_SCANNER_HOME=/usr/local/sonar-scanner \</span><br><span class="line">    NODEJS_MODULES=/usr/lib/node_modules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户ROOT切换</span></span><br><span class="line"><span class="keyword">USER</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shell 命令 - 此种方式极大减少了构建的镜像大小;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> sed -i <span class="string">'s/dl-cdn.alpinelinux.org/mirror.tuna.tsinghua.edu.cn/g'</span> /etc/apk/repositories \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apk update \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apk add --no-cache openssh tzdata curl tar sudo git ca-certificates wget unzip docker zlib nodejs npm jq \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chmod 4755 /bin/busybox \</span></span><br><span class="line"><span class="bash">    &amp;&amp; addgroup -g 1000 -S <span class="variable">$&#123;USERNAME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; adduser <span class="variable">$&#123;USERNAME&#125;</span> -D -g <span class="variable">$&#123;USERNAME&#125;</span> -G root -u 1000 -s /bin/sh \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"jenkins   ALL=(root) NOPASSWD:ALL"</span> &gt;&gt; /etc/sudoers \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mkdir -p <span class="variable">$&#123;AGENT_WORKDIR&#125;</span>/.ssh <span class="variable">$&#123;AGENT_WORKDIR&#125;</span>/.m2 <span class="variable">$&#123;AGENT_WORKDIR&#125;</span>/agent\</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -q -O /tmp/<span class="variable">$&#123;GLIBC_NAME&#125;</span> <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;GLIBC_NAME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -q -O /tmp/<span class="variable">$&#123;GLIBC_BIN_NAME&#125;</span> <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;GLIBC_BIN_NAME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -q -O /tmp/<span class="variable">$&#123;GLIBC_I18N_NAME&#125;</span> <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;GLIBC_I18N_NAME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -q -O /etc/apk/keys/sgerrand.rsa.pub <span class="variable">$&#123;BASE_URL&#125;</span>/sgerrand.rsa.pub \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -q -O /tmp/<span class="variable">$&#123;LOCALE&#125;</span> <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;LOCALE&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -q -O /tmp/<span class="variable">$&#123;JDK_NAME&#125;</span>.tar.gz <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;JDK_NAME&#125;</span>.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; wget -q -O <span class="variable">$&#123;BASE_BIN&#125;</span>/agent.jar <span class="variable">$&#123;BASE_URL&#125;</span>/agent.jar \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -fsSL -o <span class="variable">$&#123;BASE_BIN&#125;</span>/jenkins-agent.sh <span class="variable">$&#123;BASE_URL&#125;</span>/jenkins-agent.sh \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -fsSL -o /tmp/<span class="variable">$&#123;MAVEN_NAME&#125;</span>.tar.gz <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;MAVEN_NAME&#125;</span>.tar.gz \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -fsSL -o /tmp/<span class="variable">$&#123;SONAR_SCANNER_NAME&#125;</span>.zip <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;SONAR_SCANNER_NAME&#125;</span>.zip \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -fsSL -o /usr/<span class="built_in">local</span>/bin/release-cli <span class="variable">$&#123;BASE_URL&#125;</span>/<span class="variable">$&#123;GITLAB_CLI&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -fsSL -o /usr/<span class="built_in">local</span>/bin/kubectl <span class="variable">$&#123;BASE_URL&#125;</span>/kubectl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -fsSL -o /usr/<span class="built_in">local</span>/bin/docker <span class="variable">$&#123;BASE_URL&#125;</span>/docker \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -i <span class="string">"s/#PermitRootLogin.*/PermitRootLogin yes/g"</span> /etc/ssh/sshd_config \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -i <span class="string">"s/^#\s*StrictHostKeyChecking ask/StrictHostKeyChecking no/g"</span> /etc/ssh/ssh_config \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ssh-keygen -t dsa -P <span class="string">""</span> -f /etc/ssh/ssh_host_dsa_key \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ssh-keygen -t rsa -P <span class="string">""</span> -f /etc/ssh/ssh_host_rsa_key \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ssh-keygen -t ecdsa -P <span class="string">""</span> -f /etc/ssh/ssh_host_ecdsa_key \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ssh-keygen -t ed25519 -P <span class="string">""</span> -f /etc/ssh/ssh_host_ed25519_key \</span></span><br><span class="line"><span class="bash">    &amp;&amp; ssh-keygen -t ed25519 -P <span class="string">""</span> -C <span class="string">"master@weiyigeek.top"</span> -f /home/jenkins/.ssh/id_ed25519 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; apk add /tmp/<span class="variable">$&#123;GLIBC_NAME&#125;</span> /tmp/<span class="variable">$&#123;GLIBC_BIN_NAME&#125;</span> /tmp/<span class="variable">$&#123;GLIBC_I18N_NAME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -zxf /tmp/<span class="variable">$&#123;JDK_NAME&#125;</span>.tar.gz -C <span class="variable">$&#123;BASE_DIR&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mv <span class="variable">$&#123;JDK_DIR&#125;</span> <span class="variable">$&#123;JAVA_HOME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; tar -zxf /tmp/<span class="variable">$&#123;MAVEN_NAME&#125;</span>.tar.gz -C <span class="variable">$&#123;BASE_DIR&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mv <span class="variable">$&#123;MAVEN_DIR&#125;</span> <span class="variable">$&#123;MAVEN_HOME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; unzip /tmp/<span class="variable">$&#123;SONAR_SCANNER_NAME&#125;</span>.zip -d <span class="variable">$&#123;BASE_DIR&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; mv <span class="variable">$&#123;SONAR_SCANNER_DIR&#125;</span> <span class="variable">$&#123;SONAR_SCANNER_HOME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chmod a+x <span class="variable">$&#123;BASE_BIN&#125;</span>/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; chown -R jenkins:jenkins <span class="variable">$&#123;BASE_DIR&#125;</span>/ <span class="variable">$&#123;AGENT_WORKDIR&#125;</span>/ <span class="variable">$&#123;NODEJS_MODULES&#125;</span>/ \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"root:WeiyiGeek"</span> | chpasswd \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"jenkins:WeiyiGeek"</span> | chpasswd \</span></span><br><span class="line"><span class="bash">    &amp;&amp; cat /tmp/<span class="variable">$&#123;LOCALE&#125;</span> | xargs -i /usr/glibc-compat/bin/localedef -i &#123;&#125; -f UTF-8 &#123;&#125;.UTF-8 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; sed -i <span class="string">"s#use_embedded_jre=true#use_embedded_jre=false#g"</span> <span class="variable">$&#123;SONAR_SCANNER_HOME&#125;</span>/bin/sonar-scanner \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf /var/cache/apk/* /tmp/* <span class="variable">$&#123;SONAR_SCANNER_HOME&#125;</span>/jre/* \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">cd</span> <span class="variable">$&#123;JAVA_HOME&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; rm -rf COPYRIGHT LICENSE README release THIRDPARTYLICENSEREADME-JAVAFX.txt THIRDPARTYLICENSEREADME.txt Welcome.html  javafx-src.zip src.zip \</span></span><br><span class="line"><span class="bash">    lib/plugin.jar \</span></span><br><span class="line"><span class="bash">    lib/ext/jfxrt.jar \</span></span><br><span class="line"><span class="bash">    bin/javaws \</span></span><br><span class="line"><span class="bash">    lib/javaws.jar \</span></span><br><span class="line"><span class="bash">    lib/desktop \</span></span><br><span class="line"><span class="bash">    plugin \</span></span><br><span class="line"><span class="bash">    lib/deploy* \</span></span><br><span class="line"><span class="bash">    lib/*javafx* \</span></span><br><span class="line"><span class="bash">    lib/*jfx* \</span></span><br><span class="line"><span class="bash">    lib/amd64/libdecora_sse.so \</span></span><br><span class="line"><span class="bash">    lib/amd64/libprism_*.so \</span></span><br><span class="line"><span class="bash">    lib/amd64/libfxplugins.so \</span></span><br><span class="line"><span class="bash">    lib/amd64/libglass.so \</span></span><br><span class="line"><span class="bash">    lib/amd64/libgstreamer-lite.so \</span></span><br><span class="line"><span class="bash">    lib/amd64/libjavafx*.so \</span></span><br><span class="line"><span class="bash">    lib/amd64/libjfx*.so \</span></span><br><span class="line"><span class="bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">"export LANG=zh_CN.UTF-8"</span> &gt; /etc/profile.d/locale.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> jenkins</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;AGENT_WORKDIR&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib/dt.jar:$&#123;JAVA_HOME&#125;/lib/tools.jar \</span><br><span class="line">    PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;MAVEN_HOME&#125;/bin:$&#123;SONAR_SCANNER_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/local/bin/jenkins-agent.sh"</span>]</span></span><br></pre></td></tr></table></figure><p><br/></p><p><strong>镜像构建操作</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (0) 启动一个临时的web服务器（`存放上面的镜像构建所需软件`-非常重要-否则将会导致构建失败）</span></span><br><span class="line">~/k8s/jenkins/jnlp-slave$ python3 -m http.server 8080</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...</span><br><span class="line"><span class="comment"># 172.17.0.4 - - [30/Mar/2021 17:32:00] "GET /glibc-2.32-r0.apk HTTP/1.1" 200 -</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 172.17.0.4 - - [30/Mar/2021 17:32:00] "GET /kubectl HTTP/1.1" 200 -</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (1) 镜像构建 (建议一定要带上构建平台)</span></span><br><span class="line">docker build -t weiyigeek/alpine-jenkins-jnlp --platform linux/amd64 .</span><br><span class="line">  <span class="comment"># Sending build context to Docker daemon  25.09kB</span></span><br><span class="line">  <span class="comment"># Step 1/10 : FROM alpine:3.13.1</span></span><br><span class="line">  <span class="comment">#   ---&gt; e50c909a8df2</span></span><br><span class="line">  <span class="comment"># Step 2/10 : MAINTAINER  Jenkins Custom Work Node Jnlp Container - &lt;master@weiyigeek.top&gt; - WeiyiGeek</span></span><br><span class="line">  <span class="comment"># ....................................................................................................</span></span><br><span class="line">  <span class="comment"># Step 10/10 : ENTRYPOINT ["/usr/local/bin/jenkins-agent.sh"]</span></span><br><span class="line">  <span class="comment">#   ---&gt; Running in 1869aaba6a4e</span></span><br><span class="line">  <span class="comment"># Removing intermediate container 1869aaba6a4e</span></span><br><span class="line">  <span class="comment">#   ---&gt; 0dfabb8ae0ee</span></span><br><span class="line">  <span class="comment"># Successfully built 0dfabb8ae0ee</span></span><br><span class="line">  <span class="comment"># Successfully tagged weiyigeek/alpine-jenkins-jnlp:latest</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) 查看构建信息</span></span><br><span class="line">docker images weiyigeek/alpine-jenkins-jnlp --all</span><br><span class="line">  <span class="comment"># REPOSITORY                                 TAG             IMAGE ID       CREATED             SIZE</span></span><br><span class="line">  <span class="comment"># harbor.weiyigeek.top/devops/jenkins-jnlp   3.13.1-alpine   b47b6581b712   About an hour ago   715MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (3) 推送镜像到Docker HUB中</span></span><br><span class="line">docker push weiyigeek/alpine-jenkins-jnlp</span><br><span class="line">  <span class="comment"># The push refers to repository [harbor.weiyigeek.top/devops/jenkins-jnlp]</span></span><br><span class="line">  <span class="comment"># 059ea3fbd3b3: Pushed</span></span><br><span class="line">  <span class="comment"># 1119ff37d4a9: Layer already exists</span></span><br><span class="line">  <span class="comment"># 3.13.1-alpine: digest: sha256:1f869c553340c9399c7db9072169600a17ddb0ec41d41d3a4365b8c1571fc201 size: 741</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (4) 完毕后便可采用Ansible各节点拉取镜像（若没有安装ansible的朋友请自行ssh登录）</span></span><br><span class="line">ansible node -m shell -a <span class="string">"docker pull weiyigeek/alpine-jenkins-jnlp"</span></span><br></pre></td></tr></table></figure></p><p>至此，Jenkins Agent 镜像构建完毕!</p><hr><h2 id="0x02-项目实践"><a href="#0x02-项目实践" class="headerlink" title="0x02 项目实践"></a>0x02 项目实践</h2><h3 id="1-使用在K8S部署的Jenkins连接Docker容器中运行的Agent分布式节点-缺省端口-50000"><a href="#1-使用在K8S部署的Jenkins连接Docker容器中运行的Agent分布式节点-缺省端口-50000" class="headerlink" title="1.使用在K8S部署的Jenkins连接Docker容器中运行的Agent分布式节点 (缺省端口:50000)"></a>1.使用在K8S部署的Jenkins连接Docker容器中运行的Agent分布式节点 (缺省端口:50000)</h3><p>描述: 从前面环境可知，我将Jenkins安装在Kubernetes集群之中了，并且将Pod中的8080端口映射到30001端口，而agent缺省端口为50000，在没有更改的SVC情况下，我们可以使用两种方式一种就是使用<code>kubectl port-forward</code>转发，另外一种是在Jenkins资源清单中配置 <code>hostNetwork: true</code>, 此时运行jenkins Pod的节点IP+50000端口便可直接访问。</p><p>步骤 01.针对 Jenkins 进行 inbound agents pod 50000 端口转发到192.168.12.107节点的50000端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n devops port-forward --address 127.0.0.1,192.168.12.107 jenkins-7fc6f4fcf6-glqxj 50000:50000</span><br></pre></td></tr></table></figure></p><p><br></p><p>步骤 02.然后在其他有安装Docker的机器节点上运行如下命令进行jenkins jnlp容器的创建，注意此处为了多个agent构建时maven包的数据共享，使用nfs共享磁盘.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run --user jenkins -d --name jnlp \</span><br><span class="line">-e <span class="string">"JAVA_OPTS=-Xms512m -Xmx1g -Xss1m"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_NAME=docker-jenkins-jnlp"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_AGENT_NAME=docker-jenkins-jnlp"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_SECRET=b97b9d1e0cf083f9da5721caa6ebc63f6fe648375bd90cb2c2f484681d887bb7"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_AGENT_WORKDIR=/home/jenkins"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_PURL=http://192.168.12.107:30001"</span>  \</span><br><span class="line">-w /home/jenkins \</span><br><span class="line">-v /nfsdisk-31/appstorage/mavenRepo:/home/jenkins/.m2 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock weiyigeek/alpine-jenkins-jnlp:latest</span><br></pre></td></tr></table></figure><br>命令执行若出现<code>INFO: Connected</code>结果，则表示连接成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Java version: 1.8.0_281, vendor: Oracle Corporation, runtime: /usr/<span class="built_in">local</span>/jdk8/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: <span class="string">"linux"</span>, version: <span class="string">"5.4.0-137-generic"</span>, arch: <span class="string">"amd64"</span>, family: <span class="string">"unix"</span></span><br><span class="line">INFO: Scanner configuration file: /usr/<span class="built_in">local</span>/sonar-scanner/conf/sonar-scanner.properties</span><br><span class="line">INFO: Project root configuration file: NONE</span><br><span class="line">INFO: SonarScanner 4.5.0.2216</span><br><span class="line">INFO: Java 1.8.0_281 Oracle Corporation (64-bit)</span><br><span class="line">INFO: Linux 5.4.0-137-generic amd64</span><br><span class="line">Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main createEngine</span><br><span class="line">INFO: Setting up agent: docker-jenkins-jnlp</span><br><span class="line">Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> &lt;init&gt;</span><br><span class="line">INFO: Jenkins agent is running <span class="keyword">in</span> headless mode.</span><br><span class="line">Feb 04, 2023 10:51:19 PM hudson.remoting.Engine startEngine</span><br><span class="line">INFO: Using Remoting version: 4.11.2</span><br><span class="line">Feb 04, 2023 10:51:19 PM org.jenkinsci.remoting.engine.WorkDirManager initializeWorkDir</span><br><span class="line">INFO: Using /home/jenkins/remoting as a remoting work directory</span><br><span class="line">Feb 04, 2023 10:51:19 PM org.jenkinsci.remoting.engine.WorkDirManager setupLogging</span><br><span class="line">INFO: Both error and output logs will be printed to /home/jenkins/remoting</span><br><span class="line">Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">INFO: Locating server among []</span><br><span class="line">Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main<span class="variable">$CuiListener</span> status</span><br><span class="line">INFO: Agent discovery successful</span><br><span class="line">  Agent address: 192.168.12.107</span><br><span class="line">  Agent port:    50000</span><br><span class="line">  Identity:      8e:c7:1e:e1:39:ee:f4:2a:43:f6:aa:d9:0e:b7:b6:62</span><br><span class="line">.....</span><br><span class="line">INFO: Connected</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230202145941.png" alt="WeiyiGeek.在Docker中运行jenkins-jnlp结果图" title="" class="">                <p>WeiyiGeek.在Docker中运行jenkins-jnlp结果图</p>            </figure><p><br/></p><p>步骤 03.当然你也可以通过点击 Jenkins Dashboard -&gt; 节点列表 -&gt; docker-jenkins-jnlp 查看创建的节点已经是运行状态了。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230202150507.png" alt="WeiyiGeek.jenkins中jnlp节点agent状态图" title="" class="">                <p>WeiyiGeek.jenkins中jnlp节点agent状态图</p>            </figure><p>温馨提示：此处只是涉及jenkins agent节点的配置连接，若需要进行调用执行某一个项目的CICD，请继续往下看。</p><p><br/></p><h3 id="2-使用在K8S部署的Jenkins连接Docker容器中运行的自定义Agent端口节点-直连方式"><a href="#2-使用在K8S部署的Jenkins连接Docker容器中运行的自定义Agent端口节点-直连方式" class="headerlink" title="2.使用在K8S部署的Jenkins连接Docker容器中运行的自定义Agent端口节点 (直连方式)"></a>2.使用在K8S部署的Jenkins连接Docker容器中运行的自定义Agent端口节点 (直连方式)</h3><p>描述: 由于我们更改Jenkins中的agent TCP 端口以及在K8S集群中也作出了相应更改，但是连接时需要指定更多的参数，例如（JENKINS_DIRECT_CONNECTION与JENKINS_INSTANCE_IDENTITY），这里面的坑还是很大的，为啥说坑大请看友继续看。</p><blockquote><p>JENKINS_DIRECT_CONNECTION : Connect directly to this TCP agent port, skipping the HTTP(S) connection parameter download. Value: “<HOST>:<PORT>“<br>JENKINS_INSTANCE_IDENTITY : The base64 encoded InstanceIdentity byte array of the Jenkins master. When this is set,the agent skips connecting to an HTTP(S) port for connection info.</p></blockquote><p>步骤 00.前置准备，通过前面所需参数可知，我们需要指定要直连的jenkins agent服务的IP以及端口 （例如: 192.168.12.107:30634），和  jenkins Instance Identity值（此处值得注意）。</p><p>最开始，JENKINS_INSTANCE_IDENTITY 其值我认为是 Jenkins 家目录中 secrets 下的 master.key 的 base64 编码，但是怎么连接都是不正确的，随后没得办法只能查询官方文档，功夫不负有心人，在 jenkinsci 的 remoting 项目下找到了一个issue，然后顺腾摸瓜找到了该值。</p><blockquote><p>Issue: <a href="https://github.com/jenkinsci/remoting/pull/338/files/07d7fd668b17123afd9ef7ac7a859bdda151f5cf#diff-8f973eec7a7bc04d532ba6b42015c903d7100b09f8ed655367d0fe893a9b6d0a" target="_blank" rel="noopener">https://github.com/jenkinsci/remoting/pull/338/files/07d7fd668b17123afd9ef7ac7a859bdda151f5cf#diff-8f973eec7a7bc04d532ba6b42015c903d7100b09f8ed655367d0fe893a9b6d0a</a><br>Document: <a href="https://wiki.jenkins.io/display/JENKINS/Instance+Identity" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Instance+Identity</a></p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230206171322.png" alt="WeiyiGeek.JENKINS-53461 Direct inbound TCP agent connection 图" title="" class="">                <p>WeiyiGeek.JENKINS-53461 Direct inbound TCP agent connection 图</p>            </figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Jenkins : Instance Identity</span><br><span class="line">Created by Unknown User (kohsuke), last modified by Unknown User (songy) on Mar 26, 2015</span><br><span class="line">Each Jenkins instance maintains an RSA private/public key pair that can be used to uniquely identify Jenkins. This information is called <span class="string">"instance identity"</span>.</span><br><span class="line"></span><br><span class="line">From outside, the public key can be obtained by sending the GET request to the top page of Jenkins, and look <span class="keyword">for</span> the <span class="string">"X-Instance-Identity"</span> header <span class="keyword">in</span> the response. This header is always available, even <span class="keyword">if</span> the response is 401 access denied (<span class="built_in">which</span> can happen <span class="keyword">if</span> Jenkins is protected via security.) The value represents a base64-encoded ASN.1 DER serialization of X.509 SubjectPublicKeyInfo record.</span><br><span class="line"></span><br><span class="line">Plugins that run inside Jenkins can access this key pair programmatically through the org.jenkinsci.main.modules.instance_identity.InstanceIdentity class (add a provided scope dependency to this module into your plugin)</span><br></pre></td></tr></table></figure><p>上述大致意思是，每个Jenkins实例都维护一个RSA私钥/公钥对，可用于唯一标识Jenkins，这就是实例标识（instance identity），该值(公钥)可以通过将GET请求发送到Jenkins的首页来获得，并在响应中查找“X-Instance-Identity”标头。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Instance-Identity: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB******************1KQ5CLlISSjBaYrGqwsDThdDRbM6CjmP3UJ0NVhsMRJuQyAA2x4XktjEAYO3X0PWQIDAQAB</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230206171109.png" alt="WeiyiGeek.获取X-Instance-Identity图" title="" class="">                <p>WeiyiGeek.获取X-Instance-Identity图</p>            </figure><p><br/></p><p>步骤 01.获取到了X-Instance-Identity值后，一条Docker命令创建运行 jenkins agent 容器连接到Jenkins之中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --user jenkins -d --name jnlp \</span><br><span class="line">-e <span class="string">"JAVA_OPTS=-Xms512m -Xmx1g -Xss1m"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_NAME=docker-jenkins-jnlp"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_AGENT_NAME=docker-jenkins-jnlp"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_SECRET=b97b9d1e0cf083f9da5721caa6ebc63f6fe648375bd90cb2c2f484681d887bb7"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_AGENT_WORKDIR=/home/jenkins"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_DIRECT_CONNECTION=192.168.12.107:30634"</span> \</span><br><span class="line">-e <span class="string">"JENKINS_INSTANCE_IDENTITY=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsFqtbTp5/xRS85YdURKk6Zc+qfl+RxrtnJ0zUXXLqXIa8S0MVk5U+xhu0Xo6Kz9MN/i7znfKpljk4/6+GphGFJbgGVw/1M2xbZjg7XN8QiXU64rlHC1NaGbKsa6R0PbWZEjbExR+sgTreiKwh08FcQemEDEajN5WihvvC0LmopYoSfHXW0fYMYIvVPO0Kow80MKoXighfhpK9msLWV4ay4ttP9zjBWml2gEeCXNjPQAt+r1l/kDT3c7vaIybzrxgRg2K9IVYmao/wemwDdpEP1KQ5CLlISSjBaYrGqwsDThdDRbM6CjmP3UJ0NVhsMRJuQyAA2x4XktjEAYO3X0PWQIDAQAB"</span> \</span><br><span class="line">-w /home/jenkins \</span><br><span class="line">-v /nfsdisk-31/appstorage/mavenRepo:/home/jenkins/.m2 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock weiyigeek/alpine-jenkins-jnlp:latest</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 02.查看运行的容器及其结果，我们也可以在jenkins 面板上看到连接的节点，如需删除节点直接选择左边，菜单栏中删除节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">~/k8s/jenkins/jnlp-slave$ docker ps</span><br><span class="line">  <span class="comment"># CONTAINER ID   IMAGE                                  COMMAND                  CREATED         STATUS        PORTS     NAMES</span></span><br><span class="line">  <span class="comment"># efb27bd9cb8e   weiyigeek/alpine-jenkins-jnlp:latest   "/usr/local/bin/jenk…"   3 seconds ago   Up 1 second             jnlp</span></span><br><span class="line"></span><br><span class="line">~/k8s/jenkins/jnlp-slave$ docker logs -f efb27bd9cb8e</span><br><span class="line">  <span class="comment"># INFO: Agent discovery successful</span></span><br><span class="line">  <span class="comment">#   Agent address: 192.168.12.107</span></span><br><span class="line">  <span class="comment">#   Agent port:    30634</span></span><br><span class="line">  <span class="comment">#   Identity:      8e:c7:1e:e1:39:ee:f4:2a:43:f6:aa:d9:0e:b7:b6:62</span></span><br><span class="line">  <span class="comment"># Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main$CuiListener status</span></span><br><span class="line">  <span class="comment"># INFO: Handshaking</span></span><br><span class="line">  <span class="comment"># Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main$CuiListener status</span></span><br><span class="line">  <span class="comment"># INFO: Connecting to 192.168.12.107:30634</span></span><br><span class="line">  <span class="comment"># Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main$CuiListener status</span></span><br><span class="line">  <span class="comment"># INFO: Trying protocol: JNLP4-connect</span></span><br><span class="line">  <span class="comment"># Feb 04, 2023 10:51:19 PM org.jenkinsci.remoting.protocol.impl.BIONetworkLayer$Reader run</span></span><br><span class="line">  <span class="comment"># INFO: Waiting for ProtocolStack to start.</span></span><br><span class="line">  <span class="comment"># Feb 04, 2023 10:51:19 PM hudson.remoting.jnlp.Main$CuiListener status</span></span><br><span class="line">  <span class="comment"># INFO: Remote identity confirmed: 8e:c7:1e:e1:39:ee:f4:2a:43:f6:aa:d9:0e:b7:b6:62</span></span><br><span class="line">  <span class="comment"># Feb 04, 2023 10:51:21 PM hudson.remoting.jnlp.Main$CuiListener status</span></span><br><span class="line">  <span class="comment"># INFO: Connected</span></span><br></pre></td></tr></table></figure><p><br/></p><p>步骤 03.验证连接上Jenkins的agent节点，可以通过左侧的<code>脚本命令行</code>进行测, 你可以访问 http://你jenkinsIP地址/computer/agent节点名称/script 即可到 脚本命令行页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Groovy script</span></span><br><span class="line">println <span class="string">"uname -a"</span>.execute().text</span><br><span class="line">println System.getenv(<span class="string">"PATH"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行结果:</span></span><br><span class="line">Linux 2736a6240d91 5.4.0-137-generic <span class="comment">#154-Ubuntu SMP Thu Jan 5 17:03:22 UTC 2023 x86_64 Linux</span></span><br><span class="line">/usr/<span class="built_in">local</span>/jdk8/bin:/usr/<span class="built_in">local</span>/maven/bin:/usr/<span class="built_in">local</span>/sonar-scanner/bin:/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><hr><h2 id="0x03-实践调用Jenkins-agent节点"><a href="#0x03-实践调用Jenkins-agent节点" class="headerlink" title="0x03 实践调用Jenkins agent节点"></a>0x03 实践调用Jenkins agent节点</h2><h3 id="1-牛刀小试"><a href="#1-牛刀小试" class="headerlink" title="1.牛刀小试"></a>1.牛刀小试</h3><p>描述: 此处不再累述 Jenkins 项目的创建说明，不会的朋友请参照我的【Jenkins学习之路汇总】( <a href="https://blog.weiyigeek.top/2018/1-1-1.html#Jenkins学习之路汇总">https://blog.weiyigeek.top/2018/1-1-1.html#Jenkins学习之路汇总</a> )，帮助大家快速入门。</p><p><strong>agent 代理语法及使用介绍</strong><br>我们可以通过下面流水线中可知，其中最主要的就是 agent 代码块包含的，我们设定的 jenkins agent 标签值的机器。<br>描述: 指定整个Pipeline或特定阶段将在Jenkins环境中执行的位置，具体取决于该<code>agent</code> 部分的放置位置;</p><p><strong>语法参数:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">必须: YES</span><br><span class="line">参数：any / none / label /　node / docker / dockerfile / kubernetes</span><br><span class="line">  - 1.在任何可用的 agent 上执行Pipeline或stage</span><br><span class="line">  - 2.在pipeline块的顶层应用时，不会为整个 Pipeline运行分配全局代理，并且每个stage部分都需要包含自己的agent部分。</span><br><span class="line">  - 3.使用提供的标签在Jenkins环境中可用的代理上执行 Pipeline或阶段, 注意标签条件也可以使用。</span><br><span class="line">  - 4.node使用与lable类似</span><br><span class="line">  - 5.执行Pipeline或stage时会动态供应一个docker节点去接受Docker-based的Pipelines。</span><br><span class="line">  - 6.使用从Dockerfile源存储库中包含的容器构建的容器执行 Pipeline或阶段，Jenkinsfile 必须从多分支 Pipeline或 SCM Pipeline加载。</span><br><span class="line">  - 7.在Kubernetes集群上部署的Pod内执行 Pipeline或阶段，同样Jenkinsfile 必须从多分支 Pipeline或 SCM Pipeline加载，Pod模板在kubernetes &#123;&#125; 块内定义。</span><br><span class="line">允许：在顶层pipeline块和每个stage块中。</span><br></pre></td></tr></table></figure></p><p><strong>语法示例:</strong><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">  agent any</span><br><span class="line"></span><br><span class="line">  agent none</span><br><span class="line"></span><br><span class="line">  agent &#123; </span><br><span class="line">    label <span class="string">'my-label1 &amp;&amp; my-label2'</span> </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  agent &#123; node &#123; label <span class="string">'labelName'</span> &#125; &#125;  <span class="comment">// 等同于 agent &#123; label 'labelName' &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// docker 还可以接受一个args直接传递给`docker run`调用以及一个 alwaysPull 选项</span></span><br><span class="line">  <span class="comment">// registryUrl和registryCredentialsId参数 有助于指定要使用的Docker注册表及其凭据</span></span><br><span class="line">  agent &#123;</span><br><span class="line">    docker &#123;</span><br><span class="line">      image <span class="string">'maven:3-alpine'</span></span><br><span class="line">      label <span class="string">'my-defined-label'</span></span><br><span class="line">      args  <span class="string">'-v /tmp:/tmp'</span></span><br><span class="line">      registryUrl <span class="string">'https://myregistry.com/'</span></span><br><span class="line">      registryCredentialsId <span class="string">'myPredefinedCredentialsInJenkins'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dockerfile</span></span><br><span class="line">  agent &#123;</span><br><span class="line">    <span class="comment">// 等同于 to "docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/</span></span><br><span class="line">    dockerfile &#123;</span><br><span class="line">        filename <span class="string">'Dockerfile.build'</span></span><br><span class="line">        <span class="comment">// 如果要Dockerfile在另一个目录中构建，请使用以下dir选项</span></span><br><span class="line">        dir <span class="string">'build'</span></span><br><span class="line">        label <span class="string">'my-defined-label'</span></span><br><span class="line">        additionalBuildArgs  <span class="string">'--build-arg version=1.0.2'</span></span><br><span class="line">        args <span class="string">'-v /tmp:/tmp'</span></span><br><span class="line">        <span class="comment">// 同样也接受registryUrl和registryCredentialsId参数</span></span><br><span class="line">        registryUrl <span class="string">'https://myregistry.com/'</span></span><br><span class="line">        registryCredentialsId <span class="string">'myPredefinedCredentialsInJenkins'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// kubernetes: 例如如果要在其中装有Kaniko容器的容器</span></span><br><span class="line">  agent &#123;</span><br><span class="line">    kubernetes &#123;</span><br><span class="line">      label podlabel</span><br><span class="line">      yaml <span class="string">"""</span></span><br><span class="line"><span class="string">  kind: Pod</span></span><br><span class="line"><span class="string">  metadata:</span></span><br><span class="line"><span class="string">    name: jenkins-agent</span></span><br><span class="line"><span class="string">  spec:</span></span><br><span class="line"><span class="string">    containers:</span></span><br><span class="line"><span class="string">    - name: kaniko</span></span><br><span class="line"><span class="string">      image: gcr.io/kaniko-project/executor:debug</span></span><br><span class="line"><span class="string">      imagePullPolicy: Always</span></span><br><span class="line"><span class="string">      command:</span></span><br><span class="line"><span class="string">      - /busybox/cat</span></span><br><span class="line"><span class="string">      tty: true</span></span><br><span class="line"><span class="string">      volumeMounts:</span></span><br><span class="line"><span class="string">        - name: aws-secret</span></span><br><span class="line"><span class="string">          mountPath: /root/.aws/</span></span><br><span class="line"><span class="string">        - name: docker-registry-config</span></span><br><span class="line"><span class="string">          mountPath: /kaniko/.docker</span></span><br><span class="line"><span class="string">    restartPolicy: Never</span></span><br><span class="line"><span class="string">    volumes:</span></span><br><span class="line"><span class="string">      - name: aws-secret</span></span><br><span class="line"><span class="string">        secret:</span></span><br><span class="line"><span class="string">          secretName: aws-secret</span></span><br><span class="line"><span class="string">      - name: docker-registry-config</span></span><br><span class="line"><span class="string">        configMap:</span></span><br><span class="line"><span class="string">          name: docker-registry-config</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>常用选项:</strong><br>描述: 下面可以应用于两个或者多个agent实现的选项即label、customWorkspace、reuseNode;</p><ul><li>1.label (参数:字符串): 运行 Pipeline或单个 Pipeline的标签或标签条件stage。 【此选项对node，docker和有效对dockerfile必需 node。】</li><li>2.customWorkspace (参数: 字符串) : 运行 Pipeline或个人 stage 这 agent 是这个自定义的工作空间内的应用，而不是默认的, 它可以是相对路径（<code>在这种情况下自定义工作空间将位于节点上的工作空间根目录下</code>），也可以是绝对路径。【此选项是有效的node，docker和dockerfile。】</li><li>3.reuseNode（参数: 布尔值-false）: 如果为true在同一工作空间中在 Pipeline顶级指定的节点上运行容器，而不是在整个新节点上运行</li><li>4.args (参数: 字符串): 要传递给的运行时参数docker run,此选项对docker和有效dockerfile。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1. Docker代理，声明性 Pipeline</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">  <span class="comment">// V.在具有给定名称和标签（maven:3-alpine）的新创建容器中执行此 Pipeline中定义的所有步骤。</span></span><br><span class="line">  agent &#123; docker <span class="string">'maven:3-alpine'</span> &#125; </span><br><span class="line">  stages &#123;</span><br><span class="line">      stage(<span class="string">'Example Build'</span>) &#123;</span><br><span class="line">          steps &#123;</span><br><span class="line">              sh <span class="string">'mvn -B clean verify'</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2.阶段级代理部分</span></span><br><span class="line">pipeline &#123;</span><br><span class="line">  <span class="comment">/* agent none在 Pipeline的顶层进行定义可确保 不会不必要地分配执行程序。使用agent none还会强制每个stage部分包含其自己的agent部分。 */</span></span><br><span class="line">  agent none </span><br><span class="line">  stages &#123;</span><br><span class="line">    stage(<span class="string">'Example Build'</span>) &#123;</span><br><span class="line">      <span class="comment">/* 使用此映像在新创建的容器中执行此阶段中的步骤。*/</span></span><br><span class="line">      agent &#123; docker <span class="string">'maven:3-alpine'</span> &#125; </span><br><span class="line">      steps &#123;</span><br><span class="line">          echo <span class="string">'Hello, Maven'</span></span><br><span class="line">          sh <span class="string">'mvn --version'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Example Test'</span>) &#123;</span><br><span class="line">      <span class="comment">/* 使用与上一阶段不同的图像在新创建的容器中执行此阶段中的步骤。 */</span></span><br><span class="line">      agent &#123; docker <span class="string">'openjdk:8-jre'</span> &#125; </span><br><span class="line">      steps &#123;</span><br><span class="line">          echo <span class="string">'Hello, JDK'</span></span><br><span class="line">          sh <span class="string">'java -version'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，agent 介绍完毕，我们该回归正题了。</p><p><br/></p><p><strong>实践流程</strong></p><p>步骤 01.此处我创建了一个 Test 项目用于测试调用我们在Docker中运行的jenkins Agent节点。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230206173815.png" alt="WeiyiGeek.图" title="" class="">                <p>WeiyiGeek.图</p>            </figure><p><br/></p><p>步骤 02.此处是我准备的 jenkins 流水线代码, 在应用保存后即可。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> JOB_WORKSPACE = <span class="string">"$&#123;env.WORKSPACE&#125;"</span></span><br><span class="line"><span class="keyword">def</span> JOB_NAME = <span class="string">"$&#123;env.JOB_NAME&#125;-$&#123;env.BUILD_NUMBER&#125;"</span></span><br><span class="line"></span><br><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123;</span><br><span class="line">    label <span class="string">'docker-jnlp-1'</span></span><br><span class="line">  &#125;</span><br><span class="line">  environment &#123;</span><br><span class="line">    SONARQUBE_TIMEOUT = <span class="string">'10'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stages &#123;</span><br><span class="line">    stage (<span class="string">'Start Test'</span>) &#123;</span><br><span class="line">      steps &#123;</span><br><span class="line">        echo <span class="string">"[Test Jenkins JNLP Agent with docker]!"</span></span><br><span class="line">        echo <span class="string">"流水线环境变量输出: $&#123;env.JOB_NAME&#125;-$&#123;env.JOB_WORKSPACE&#125;-$&#123;env.SONARQUBE_TIMEOUT&#125;"</span></span><br><span class="line">        script &#123;</span><br><span class="line">          <span class="comment">// 命令执行</span></span><br><span class="line">          sh <span class="string">" echo -e '&lt;name&gt;weiyigeek&lt;/name&gt;\n&lt;addr&gt;https://weiyigeek.top&lt;/addr&gt;' &gt; demo.xml  &amp;&amp; cat demo.xml"</span></span><br><span class="line">          <span class="comment">// 返回命令执行结果</span></span><br><span class="line">          USERNAME=sh <span class="string">label:</span> <span class="string">'name'</span>,<span class="string">returnStdout:</span> <span class="literal">true</span>, <span class="string">script:</span> <span class="string">"""</span></span><br><span class="line"><span class="string">            awk '/&lt;\\/*name\\/*&gt;/&#123;gsub(/[[:space:]]*&lt;\\/*name\\/*&gt;/,"");print \$0&#125;' demo.xml | head -n 1</span></span><br><span class="line"><span class="string">          """</span></span><br><span class="line">          ADDRESS=sh <span class="string">label:</span> <span class="string">'name'</span>,<span class="string">returnStdout:</span> <span class="literal">true</span>, <span class="string">script:</span> <span class="string">"""</span></span><br><span class="line"><span class="string">            awk '/&lt;\\/*addr\\/*&gt;/&#123;gsub(/[[:space:]]*&lt;\\/*addr\\/*&gt;/,"");print \$0&#125;' demo.xml | head -n 1</span></span><br><span class="line"><span class="string">          """</span></span><br><span class="line">          sh <span class="string">"mkdir -vp test/demo &amp;&amp; ls &amp;&amp; pwd"</span></span><br><span class="line">        &#125;</span><br><span class="line">       echo <span class="string">"脚本执行返回结果输出 =&gt; $&#123;USERNAME&#125; =&gt; $&#123;ADDRESS&#125;"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     stage (<span class="string">'END Test'</span>) &#123;</span><br><span class="line">      steps &#123;</span><br><span class="line">        echo <span class="string">"跨阶段变量传递 =&gt; $&#123;USERNAME&#125;"</span></span><br><span class="line">        sh <span class="string">"ls &amp;&amp; pwd"</span></span><br><span class="line">        sh <span class="string">"java -version;mvn -version;release-cli -v;sonar-scanner --version"</span> </span><br><span class="line">        echo <span class="string">"[Test End Stage]!"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 03.返回到Test项目首页之中，点击立即构建，然后可以在阶段视图中查看到执行结果,我们可以通过Blue Ocean进行更加直观的展示。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230206174336.png" alt="WeiyiGeek.Jenkins agent连接运行测试图" title="" class="">                <p>WeiyiGeek.Jenkins agent连接运行测试图</p>            </figure><p><br/></p><h3 id="2-完整的pipeline流水线企业项目"><a href="#2-完整的pipeline流水线企业项目" class="headerlink" title="2.完整的pipeline流水线企业项目"></a>2.完整的pipeline流水线企业项目</h3><p>描述: 上一章节只是简单使用该镜像创建的容器，是否能被Jenkins正常调度，此章节为作者内部实践项目抽取的pipeline流水线，实现了’代码拉取’, ‘代码检测’, ‘项目构建’,’镜像构建’,’部署测试’,’成品归档’等阶段，供大家参考使用。</p><p>步骤 01.在登录Jenkins后，创建一个测试任务weiyigeek-oa，此处根据一个已经存在的任务内部OA系统进行复制创建，修改对应的流水线agent代码块为标签选择。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230207093031.png" alt="WeiyiGeek.创建weiyigeek-oa任务流水线图" title="" class="">                <p>WeiyiGeek.创建weiyigeek-oa任务流水线图</p>            </figure><p>温馨提示：由于 Jenkins Pipeline 流水线代码太长，需要的朋友可以关注【WeiyiGeek】公众号后回复【Jenkins流水线代码】即可下载 <code>Jenkins-Pipeline.groovy</code> 示例文件。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230207170309.png" alt="WeiyiGeek.Jenkins流水线代码图" title="" class="">                <p>WeiyiGeek.Jenkins流水线代码图</p>            </figure><p><br/></p><p>步骤 03.回到项目首页，点击 【build with Parameters】选择构建项目指定参数，点击【开始构建】便可进行构建任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从控制台输出看到当前 weiyigeek-oa 运行在我们使用docker部署的agent节点之上(docker-jenkins-jnlp)</span></span><br><span class="line">Started by user Jenkins 管理员</span><br><span class="line">[Pipeline] Start of Pipeline</span><br><span class="line">[Pipeline] node</span><br><span class="line">Running on docker-jenkins-jnlp <span class="keyword">in</span> /home/jenkins/agent/workspace/weiyigeek-oa</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230207093625.png" alt="WeiyiGeek.流水线任务构建参数设定与运行图" title="" class="">                <p>WeiyiGeek.流水线任务构建参数设定与运行图</p>            </figure><p><br/></p><p>步骤 04.任务运行完毕后可以通过 Blue Ocean 进行查看各阶段的执行情况，以及查看Jenkins发送在企业微信中构建信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jenkins-消息通知【weiyigeek-oa-1】任务开始 </span><br><span class="line">项目信息: overtime-leave-1.5.5.jar</span><br><span class="line">提交信息: 6f335ad 统计查询添加筛选条件</span><br><span class="line">构建版本: master - origin/master</span><br><span class="line">构建操作: None</span><br><span class="line">镜像构建: True</span><br><span class="line">部署环境: Prod</span><br><span class="line">成品归档: False</span><br><span class="line">质量测试: False</span><br><span class="line">镜像仓库1: harbor.weiyigeek.top/weiyigeek/oa:master</span><br><span class="line">镜像仓库2: harbor.weiyigeek.top/weiyigeek/oa:latest</span><br><span class="line">查看当前任务流水线</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230207094227.png" alt="WeiyiGeek.流水线任务阶段执行情况查看说明图" title="" class="">                <p>WeiyiGeek.流水线任务阶段执行情况查看说明图</p>            </figure><p>至此，在 Docker 中运行 Jenkins Agent 实践完毕！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="DevSecOps" scheme="https://blog.weiyigeek.top/categories/DevSecOps/"/>
    
    <category term="CICD" scheme="https://blog.weiyigeek.top/categories/DevSecOps/CICD/"/>
    
    
    <category term="Jenkins" scheme="https://blog.weiyigeek.top/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>18.计算机科学导论之人工智能初识学习笔记</title>
    <link href="https://blog.weiyigeek.top/2023/1-19-709.html"/>
    <id>https://blog.weiyigeek.top/2023/1-19-709.html</id>
    <published>2023-01-19T10:35:30.000Z</published>
    <updated>2023-02-13T08:02:27.234Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="计算机科学导论学习笔记"><a href="#计算机科学导论学习笔记" class="headerlink" title="计算机科学导论学习笔记"></a>计算机科学导论学习笔记</h1><h1 id="第-5-部分-数据安全与人工智能"><a href="#第-5-部分-数据安全与人工智能" class="headerlink" title="第 5 部分 数据安全与人工智能"></a>第 5 部分 数据安全与人工智能</h1><p>此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。</p><p>原文地址: <a href="https://mp.weixin.qq.com/s/Sa9dVU7JOS5zEddldf22mw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Sa9dVU7JOS5zEddldf22mw</a><br><a id="more"></a></p><h2 id="18-人工智能"><a href="#18-人工智能" class="headerlink" title="18.人工智能"></a>18.人工智能</h2><p>作为最后一章，我们将对人工智能（AI）作简单的介绍，当前人工智能不是即将实现，而是已经实现了，将主要介绍人工智能的简史和定义，以及AI需要了解的基础知识学习，最后介绍两种在人工智能中常用的编程语言。</p><h3 id="18-1-简单介绍"><a href="#18-1-简单介绍" class="headerlink" title="18.1 简单介绍"></a>18.1 简单介绍</h3><h4 id="0-人工智能简史"><a href="#0-人工智能简史" class="headerlink" title="(0) 人工智能简史"></a>(0) 人工智能简史</h4><p>虽然人工智能作为一门独立的学科是相对年轻的，但它还是经历了一段发展的时间，当2400年前希腊哲学家亚里多斯德发明了逻辑推理这个概念时，人工智能就开始了，接着莱布尼茨和牛顿完成了逻辑语言的定稿。</p><p>乔治•布尔在19世纪逐步提出的布尔代数（附录E）奠定计算机电子电路的基础。但是思维计算机的主要思想却来自于<code>阿兰•图灵</code>，他提出了图灵测试, “人工智能”这个术语是<code>John McCarthy</code> （约翰•麦卡思）在1956年首次提出的。</p><p><br/></p><h4 id="1-什么是人工智能AI"><a href="#1-什么是人工智能AI" class="headerlink" title="(1) 什么是人工智能AI?"></a>(1) 什么是人工智能AI?</h4><blockquote><p>答: 人工智能（AI,Artificial Intelligence）是对程序系统的研究，该程序系统在一定程度上能模仿人类的活动，如感知、思考、学习和反应。<br>简而言之，AI 即模仿人类行为和能力创建软件，</p></blockquote><p><br/></p><p><strong>人脑与人工智能对比</strong></p><ul><li>功耗：20W/几十万倍</li><li>鲁棒性：极强 / 弱</li><li>推广性：强 / 弱</li><li>犯大错误概率(原理): 没有 / 有</li><li>学习样本:少量 / 大量</li><li>可理解性(可解释性)：好 / 差</li></ul><p><br/></p><p>当前人工智能技术的五大局限性条件:</p><ul><li>拥有丰富的数据或(和)知识</li><li>完全信息</li><li>确定性</li><li>静态(按确定的规则演化)</li><li>有限领域于单任务</li></ul><p><br/></p><h4 id="2-人工智能AI应用场景有那些"><a href="#2-人工智能AI应用场景有那些" class="headerlink" title="(2) 人工智能AI应用场景有那些?"></a>(2) 人工智能AI应用场景有那些?</h4><p>当下AI应用场景多如以下情况:</p><ul><li>机器学习 - 它通常是 AI 系统的基础，也是我们“教”计算机模型进行预测并根据数据得出结论的方式。</li><li>异常情况检测 - 自动检测系统中的错误或异常活动的能力。</li><li>计算机视觉 - 软件通过相机、视频和图像直观地解释世界的能力。</li><li>自然语言处理 - 计算机理解书面或口头语言并作出相应反应的能力。</li><li>对话式 AI - 软件“代理”参与对话的能力。</li><li>知识挖掘 - 从大量通常非结构化数据中提取信息以创建可搜索的知识存储的功能。</li></ul><p><br/></p><p><strong>异常情况检测应用场景</strong><br>假设你要创建一个软件系统来监视信用卡交易，并检测可能表示欺诈的异常使用模式。</p><p>或者要创建一个应用程序来跟踪自动化生产线中的活动并识别故障。</p><p>或者要创建一个赛车遥测系统，使用传感器在潜在机械故障发生之前主动向工程师发出相关警告。</p><p>可以通过异常情况检测应对这些类型的场景。异常情况检测是一种基于机器学习的技术，可用于分析一段时间内的数据并标识异常更改。</p><p>让我们探讨一下异常情况检测如何在赛车场景中发挥作用, 我们可利用汽车内的传感器收集遥测数据，如发动机转速、刹车温度等。<br>异常情况检测模型经过训练，了解一段时间内遥测度量值的预期波动情况。</p><p>如果度量值在正常预期范围之外，则该模型将报告异常，用于提醒赛车工程师通知车手先进站修理，以免因该问题而被迫退赛。</p><figure class="image-box">                <img src="https://docs.microsoft.com/zh-cn/learn/wwl-data-ai/get-started-ai-fundamentals/media/anomaly-detection.gif" alt="异常情况检测应用场景" title="" class="">                <p>异常情况检测应用场景</p>            </figure><p><br/></p><p><strong>计算机视觉应用场景</strong></p><p>计算机视觉是 AI 的一个领域，它负责处理视觉对象，让我们了解一下计算机视觉带来的一些可能性。</p><p>例如，Seeing AI 应用是一个很好的计算机视觉示例，Seeing AI 应用专门面向盲人和弱视群体，它利用 AI 的力量来打开视觉世界，描述附近的人、文字和物体。</p><p>大多数计算机视觉解决方案都基于机器学习模型，这些模型可应用于来自相机、视频或图像的视觉输入，如下表描述了常见的计算机视觉任务。</p><table><thead><tr><th>任务</th><th>说明</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>图像分类 | 带有“出租车”标签的出租车图像，图像分类涉及训练机器学习模型，使其根据图像内容对图像进行分类。 <br/> 例如，你可以在交通监控解决方案中使用图像分类模型，根据图像所包含的车辆类型（例如出租车、公共汽车、骑自行车的人等）对图像进行分类。|<br>物体检测 | 用边界框突出显示公交车、汽车和自行车骑行者的街道图像，对象检测机器学习模型经过训练，可以对图像中的单个对象进行分类，并使用边界框确定其位置。 <br/> 例如，交通监控解决方案可使用对象检测来识别不同类别车辆的位置。|<br>语义分割 | 街道图像，其中已识别出属于公交车、汽车和骑行者的像素，语义分割是一种高级机器学习技术，其中图像中的各个|像素根据其所属的对象进行分类。 <br/> 例如，交通监控解决方案可能会在交通图像上覆盖“蒙版”图层，以使用特定颜色突出显示不同的车辆。<br>图像分析 | 显示遛狗人的街道图像，标题为“街道上的遛狗人”，可以创建结合使用机器学习模型和高级图像分析技术从图像中提取信息的解决方案，包括可以帮助对图像进行归类的“标签”，甚至可以归纳总结图像中所示场景的描述性标题。|<br>人脸检测、分析和识别 | 多个人站在城市街道上的图像，其中突出显示了这些人的人脸人脸检测是对象检测的一种特殊形式，可以在图像中找出人脸。 这可以与分类和面部几何分析技术相结合，用来推断出年龄和情绪状态等细节；甚至根据他们的面部特征来识别个人。|<br>光学字符识别 (OCR) | 突出显示“多伦多道明银行”标志的建筑物图像，光学字符识别是一种用于检测和读取图像中文本的技术。你可以使用 OCR 读取照片中的文字（例如：路标或店面），或从扫描的文档中提取信息，例如字母、发票或表格。 |</p><p><br/></p><p><strong>自然语言处理应用场景</strong></p><p>自然语言处理 (NLP) 是 AI 的一个领域，它负责创建能够理解书面和口头语言的软件。</p><p>NLP 使你能够创建可以执行以下操作的软件：</p><ul><li>分析和解释文档、电子邮件和其他来源中的文本。</li><li>解释口头语言，并合成语音响应。</li><li>将口头或书面短语在各种语言之间进行翻译（不用语言之间的同步翻译）。</li><li>解释命令并确定合适的操作。</li></ul><p>例如，星舰指挥官是一款由 Human Interact 开发的虚拟现实 (VR) 游戏，故事发生在科幻世界中, 该游戏使用自然语言处理让玩家能够控制对白，并与游戏中的人物和星舰系统交互。</p><p>例如，当前流行元宇宙（Metaverse），是人类运用数字技术构建的，由现实世界映射或超越现实世界，可与现实世界交互的虚拟世界 ，具备新型社会体系的数字生活空间。</p><p>如下表描述了自然语言处理常见的任务<br>| 任务 | 功能 |<br>|——|——|<br>文本分析 | 使用此服务可以分析文本文档并提取关键短语，检测实体（例如地点、日期和人物）并评估情绪（文档内容的正面或负面程度如何）。|<br>文本翻译 | 使用此服务可在 60 多种语言之间进行文本翻译。 |<br>语音 | 使用此服务可识别和合成语音，并翻译口语。 |<br>语言理解智能服务 (LUIS)     | 使用此服务可以训练能够理解口头或文本命令的语言模型。 |</p><p><br/></p><p><strong>对话式AI应用场景</strong><br>对话式 AI 这一术语用于描述 AI 代理参与人类对话的解决方案。 </p><p>通常，对话式 AI 解决方案使用机器人来管理与用户的对话, 对话可以通过网站界面、电子邮件、社交媒体平台、消息系统、电话和其他渠道进行。</p><p>机器人可以作为以下 AI 解决方案的基础：</p><ul><li>产品或服务的客户支持。</li><li>餐厅、航空公司、电影院和其他以预约为基础的业务的预订系统。</li><li>卫生保健咨询和自我诊断。</li><li>智能家居和个人数字助理。</li></ul><p>例如，当前最流行强大的ChatGPT(OpenAI)可模拟人类间的相互对话（问答），以及按照使用者的描述生成或者操作某一对象, 如生成图像。</p><p><br/></p><h4 id="3-那么人工智能AI如何学习？"><a href="#3-那么人工智能AI如何学习？" class="headerlink" title="(3) 那么人工智能AI如何学习？"></a>(3) 那么人工智能AI如何学习？</h4><p>当前是从数据中学习, 在当今世界，我们在日常生活中会创建大量数据。 </p><p>从我们发送的短信、电子邮件和社交媒体帖子，到我们用手机拍摄的照片和视频，我们产生了大量信息。 我们的房屋、汽车、城市、公共交通基础设施和工厂中的数百万个传感器也在创建更多数据。</p><p>数据科学家可使用所有这些数据来训练机器学习模型，这些模型可以根据它们在数据中找到的关系进行预测和推断。</p><p>例如，假设一个环境保护组织需要志愿者使用手机应用来对不同种类的野花进行识别和分类，以下动画展示了如何使用机器学习来实现此方案。</p><figure class="image-box">                <img src="https://docs.microsoft.com/zh-cn/learn/wwl-data-ai/get-started-ai-fundamentals/media/machine-learn.gif" alt="识别分类图" title="" class="">                <p>识别分类图</p>            </figure><p><strong>动画流程:</strong></p><ul><li>(1) 一个由植物学家和科学家组成的团队<code>收集</code>有关野花样本的数据。</li><li>(2) 并对样本的物种进行正确<code>标记</code>。</li><li>(3) 使用算法对标记的数据进行处理，该算法可以<code>提取样本特征与标记的物种之间的关系</code>。</li><li>(4) 该算法的结果内嵌在<code>模型</code>中。</li><li>(5) 志愿者发现新样本后，该模型可以正确<code>识别</code>物种标记。</li></ul><p><br/></p><h4 id="4-人工智能挑战和风险有那些"><a href="#4-人工智能挑战和风险有那些" class="headerlink" title="(4) 人工智能挑战和风险有那些?"></a>(4) 人工智能挑战和风险有那些?</h4><p>描述: 人工智能是一种强大的工具，可以极大地造福世界, 但是像任何工具一样, 其有好有坏,必须负责任地使用它。</p><p>AI 应用程序开发人员面临的一些潜在挑战，例如包括但不限于如下表所示：</p><table><thead><tr><th>挑战或风险</th><th>示例</th></tr></thead><tbody><tr><td>偏差可能会影响结果</td><td>贷款审批模型因训练数据中的偏差而产生性别歧视</td></tr><tr><td>错误可能会造成伤害</td><td>自动驾驶车辆遇到系统故障并引发碰撞</td></tr><tr><td>可以公开数据</td><td>医疗诊断机器人使用敏感患者数据进行训练，这些数据存储不安全</td></tr><tr><td>解决方案可能并不适用于所有人</td><td>家庭自动化助手不为视觉障碍用户提供音频输出</td></tr><tr><td>用户必须信任复杂系统</td><td>基于 AI 的金融服务工具提供投资建议 - 它们基于什么？</td></tr><tr><td>谁对 AI 驱动的决策负责？</td><td>一个无辜的人因为面部识别证据而被判有罪 - 谁该为此负责？</td></tr></tbody></table><p><br></p><p><strong>规避风险</strong></p><p>为了解决上述问题在我们进行 AI 软件的开发时，需要遵循六项原则，旨在确保 AI 应用程序能为棘手的问题提供出色的解决方案，而不产生任何意外的负面影响。</p><ul><li><p>(1) 公平性: AI 系统应该公平对待所有人。 例如，假设你创建了一个机器学习模型来为银行的贷款审批应用程序提供支持。 该模型应在不考虑任何基于性别、种族或其他因素的偏见的情况下，对是否应批准贷款做出预测，这些偏见可能导致特定的申请人群遭受不公平的差别待遇。<br>意味着公平性在 AI 提供的上下文中是一个基本的社会与技术双重挑战，也就是说我们必须有足够多样化的人来开发和部署 AI 系统。</p></li><li><p>(2) 可靠性和安全性 AI 系统应可靠且安全地运行。 例如，大家思考一下基于 AI 的自动驾驶软件系统；或诊断患者症状并推荐处方的机器学习模型这些案例。 这些系统一旦出现不可靠性，就可能会给生命安全带来重大风险。</p><p>基于 AI 的软件应用程序开发必须经过严格的测试和部署管理，以在发布前确保它们能达到预期。</p><p>确保自己开发的系统与我们的设计理念一致，并且符合我们的价值观和原则。系统和模型不会为世界带来损害。<br>考虑安全性时，我们首先想到的例子时自动驾驶汽车，但绝不限于这些物理系统、物理代理。</p></li><li><p>(3) 隐私和安全<br>AI 系统应该保护并尊重隐私。 AI 系统所基于的机器学习模型依赖于大量数据，这些数据可能包含必须保密的个人详细信息。 即使对模型进行了训练且系统已投入生产，它仍可能在使用新数据进行预测或采取行动时侵犯隐私或安全。</p><p>与日俱增的依赖性和数据对保持系统安全提出了新要求。</p><p>当考虑这些人工智能系统的安全性时，你需要考虑数据从何而来、是如何到来的，如果是用户提交的数据，或是预测中使用的公共数据源，你如何防止数据被破坏，并配备异常检测或其他用于检测数据变化的系统，这些变化可能表明有对手试图影响系统结果。</p></li><li><p>(4) 包容性<br>AI 系统应该成为人们的有力助手，并与人互动。 AI 应不分身体能力、性别、性取向、种族或其他因素，造福社会各个阶层。</p></li></ul><ul><li><p>(5) 透明度<br>AI 系统应该是可理解的。 应让用户能充分了解系统的用途、工作方式以及局限性。</p><p>透明度具有两面性；一方面，透明度意味着创建人工智能系统的人应该对他们使用人工智能的方式和原因持开放态度，同时也要对他们系统的局限性持开放态度。<br>另一方面，透明度意味着人们应能够理解人工智能系统的行为，这就是人们常说的可解释性或可理解性。</p></li><li><p>(6) 问责<br>应有相关人员对 AI 系统负责。 设计和开发基于 AI 的解决方案的人员应在管理和组织原则的框架内工作，以确保解决方案符合定义明确的道德和法律标准。</p></li></ul><p>总结: 所以，在将我们的面部识别原则用于整个公司都可以遵循的实践和过程时，我们必须要做的是设定大概的原则（例如对于公平性的承诺），并思考如何让开发团队秉持这些原则来审视开发生命周期的每个阶段。</p><p><strong>参考文章</strong></p><ul><li>Microsoft Azure AI 基础知识(人工智能入门) : <a href="https://learn.microsoft.com/zh-cn/training/paths/get-started-with-artificial-intelligence-on-azure/" target="_blank" rel="noopener">https://learn.microsoft.com/zh-cn/training/paths/get-started-with-artificial-intelligence-on-azure/</a></li></ul><p><br/></p><h3 id="18-2-基础知识"><a href="#18-2-基础知识" class="headerlink" title="18.2 基础知识"></a>18.2 基础知识</h3><h4 id="1-图灵测试"><a href="#1-图灵测试" class="headerlink" title="(1) 图灵测试"></a>(1) 图灵测试</h4><p>在1950年，阿兰•图灵提出了图灵测试, 该测试提出了机器具有智能的一个定义，测试的方式是简单地比较人类的智能行为和计算机的智能行为。</p><p>即一个询问者对计算机和人类都提出一组问题，然后询问者得到两组答案，但他不知道哪一组是来自人类，哪一组来自计算机。</p><p>在仔细检查两组答案后，如果询问者不能肯定地说出哪一组来自人类，哪一组来自计算机（计算机模拟人类回答），那么，计算机就通过了具有智能行为的图灵测试。</p><p><br/></p><h4 id="2-智能体"><a href="#2-智能体" class="headerlink" title="(2) 智能体"></a>(2) 智能体</h4><p><strong>什么是智能体?</strong></p><blockquote><p>智能体是一个能智能地感知环境、从环境中学习并与环境进行交互的系统。</p></blockquote><p>智能体可以分成两大类：软件智能体和物理智能体。</p><p><strong>1) 软件智能体</strong></p><blockquote><p>软件智能体是一组用来完成特殊任务的程序。<br>例如，有些智能系统能用来整理电子邮件（e-mail）,能检査收到的邮件的内容，然后把它们归到不同的类别中（垃圾、不重要、重要、非常重要等）, 另外一个软件智能体的例子是搜索引擎，它搜索万维网，发现能提供与查询主题相关信息的网址。</p></blockquote><p><strong>2) 物理智能体</strong></p><blockquote><p>物理智能体（机器人）是一个用来完成各项任务的可编程系统。简单的机器人可以用在制造行业，从事一些日常的工作，如装配、焊接或油漆。有些组织使用移动机器人去做一些日常的分发工作，如分发邮件或明信片到不同的房间, 移动机器人可以在水下探测石油。<br>人型机器人是一种自治的移动机器人，它模仿人类的行为。虽然人型机器人只在科幻小说中流行，但是要使这种机器人能合理地与周围环境交互并从环境里发生的事件中学习，这里面还有很多工作要做，在当前正在如火如荼的进行着，坚信通过不断的发展一定会成功的。</p></blockquote><p><br/></p><h4 id="3-编程语言"><a href="#3-编程语言" class="headerlink" title="(3) 编程语言"></a>(3) 编程语言</h4><p>描述: 虽然有些通用语言（如C、C++和Java、Python）能用来编写智能软件，但有两种语言是特别为人工智能设计的，它们是 LISP 和 PROLOG 语言</p><p><br/></p><p><strong>1) LISP</strong><br>LISP （LISt Programming）是约翰•麦卡思在1958年发明的，顾名思义，LISP是一种操纵表的编程语言。LISP把数据和程序都当成表，这就意味着LISP程序能改变它自身。这个特性与智能体的理念相吻合，智能体能从环境中学习并改善自身行为。<br>但是，LISP的一个缺点是它的行动迟缓。如果要处理的表比较长，LISP就变得很慢。另一个缺点是它的语法复杂。</p><p><strong>2) PROLOG</strong><br>PROLOG （PROgraming in LOGic）是一种能建立事实数据库和规则知识库的编程语言。使用PROLOG编程能使用逻辑推理来回答那些可或从知识库中推导出来的问题。但是，PROLOG不是一种效率很高的编程语言，有些复杂问题使用其他语言（如C、C++或Java） 来解决时，效率更高。</p><p><br/></p><p><strong>3) Python</strong></p><p>此处不得不提到Python编程语言，Python是人工智能中使用最广泛的编程语言之一，因为它简单易用，而且可以与数据结构和其他常用的AI算法无缝地使用。</p><p>Python是适用AI项目的原因是许多基于Python的有用库可以在AI中使用，比如Numpy提供科学计算能力，Scypy提供高级计算，Pybrain提供机器学习。</p><p><strong>4) Java</strong><br>Java也是AI项目的好选择。它是一种面向对象的编程语言，专注于提供AI项目所需的所有高级特性，是可移植的，并提供内置的垃圾收集。</p><p>Java社区也是一个优势，丰富的社区生态系统可以帮助开发人员随时随地查询和解决问题。</p><p>对于AI项目来说，算法是灵魂，无论是搜索算法、自然语言处理算法还是神经网络，Java都可以提供简单的编码算法。此外，Java可扩展性也是AI项目的一个基本特征。</p><p><strong>5) C++</strong><br>C++是世界上速度比较快的编程语言，其在硬件层面上的交流能力使开发人员能够改进程序执行时间。对于时间很敏感，这对于AI项目是非常有用的，例如，搜索引擎可以广泛使用C++。</p><p>在AI项目中，C++可以用于统计，比如神经网络。此外，该算法可以在C++被广泛地快速执行，游戏AI主要使用C++代码，以便更快地执行和响应时间。</p><p><br></p><h3 id="18-3-知识表示"><a href="#18-3-知识表示" class="headerlink" title="18.3 知识表示"></a>18.3 知识表示</h3><p>当下阶段常常使用人工智能体来解决现实世界中的一些问题，此时就需要他能够进行知识的表达，当知识<code>被表示成数据结构后就能被存储在计算机中的程序操纵</code>, 此小节中我们描述4种常见的知识表示方法<code>语义网、框架、谓词逻辑和基于规则的系统</code>。</p><h4 id="1-语义网"><a href="#1-语义网" class="headerlink" title="(1) 语义网"></a>(1) 语义网</h4><p>语义网是Richard H.Richens在20世纪60年代提出的, 其使用<code>有向图</code>表示知识。</p><p>正如在第12章讨论的，有向图由顶点（nodes）和边（arcs）构成, 语义网用顶点代表概念, 用边（用箭头表示）表示两个概念间的关系。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230131112201.png" alt="WeiyiGeek.简单的语义网图" title="" class="">                <p>WeiyiGeek.简单的语义网图</p>            </figure><p><strong>1) 概念</strong><br>描述: 为了给概念一个准确的定义，专家们把概念的定义与集合理论联系起来。因此，概念被看成一个集合或一个子集。</p><p>例如，“动物”是所有动物的集合，“马”是所有马的集合，也是“动物”的子集。对象是集合中的成员（实例），概念用顶点表示, 是不是与我们在学习对象编程语言中的类class相似。</p><p><strong>2) 关系</strong></p><p>描述: 我们使用关系（用边）, 表示一条边可以定义一个“子类”关系一条边从子类指向超类，一条边可以定义一个“实例”关系一条边从实例指向它所属的集合，一条边也可以定 义一个对象的属性（颜色、大小……）。</p><p>最后，一条边可以定义一个对象的所有权，例如拥有另外一个对象，语义网能很好定义的最重要的关系是“继承”，继承关系定义明了这样一个事实: 一个类的所有属性将出现在继承的类中。</p><p>这可以用来从用图表示的知识中推导出新的知识。</p><p><br/></p><h4 id="2-框架"><a href="#2-框架" class="headerlink" title="(2) 框架"></a>(2) 框架</h4><p>框架与语义网是紧密相关的，在语义网中，<code>图用来表示知识</code>；在框架中，<code>数据结构（记录）用来表示相同的知识</code>。</p><p>与语义网相比，框架的一个优点是程序更容易处理框架，而不是语义网。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230131112653.png" alt="WeiyiGeek.框架表示语义图" title="" class="">                <p>WeiyiGeek.框架表示语义图</p>            </figure><p><strong>1) 对象</strong><br>语义网中的一个节点变成了一组框架中的一个对象，所以一个对象可以定义一个类、一个子类或类的一个实例。例如上图中，爬行动物、哺乳动物、狗、Roxy 和 Ringo 都是对象。</p><p><strong>2) 槽</strong><br>语义网中的边被翻译成“槽”（数据结构中的域）, 槽的名字定义了关系的类型和构成关系的槽的值。例如上图中，动物是爬行动物对象的一个槽。</p><p><br/></p><h4 id="3-谓词逻辑"><a href="#3-谓词逻辑" class="headerlink" title="(3) 谓词逻辑"></a>(3) 谓词逻辑</h4><p>通常的知识表示是谓词逻辑, 谓词逻辑可以用来表示复杂的事实。</p><p>由于有了悠久历史的理论逻辑的支持，谓词逻辑成为一门良好定义的语言，此节我们先介绍简单一些的语言——命题逻辑，然后再介绍谓词逻辑。</p><p><strong>1) 命题逻辑</strong></p><p>命题逻辑是由对世界进行逻辑推理的一组句子组成的一种语言。</p><ul><li><strong>运算符</strong>: 命题逻辑使用5种运算符，如下所示：<blockquote><p>第一个运算符是一元运算符（运算符带一个句子），其他4个都是二元运算符（运算符带两个句子）, 每个句子的逻辑值（真或假）取决于原子句子的逻辑值，原子句子是不带运算符的构成复杂句子的特殊句子。图18-3显示了命题逻辑中每个运算符的真值表。</p></blockquote></li></ul><p><img src="https://img.weiyigeek.top/2023/1/20230131113004.png" alt="WeiyiGeek.命题逻辑运算符图"></p><ul><li><strong>句子</strong>: 在此种语言中的句子递归定义，如下所示:<blockquote><p>1) 大写字母（如A、B、S或T）表示在自然语言中的一个语句，它们是一个句子。<br>2) 两个常数值（真和假）中的任意一个都是句子。<br>3) 如果P是句子，则<code>非P</code>也是句子。<br>4）如果P和Q是句子，则 P V Q， P ^ Q, P -&gt; Q 和 P <-> Q 都是句子。</p></blockquote></li></ul><p>例如, 以下的是命题语言中的句子：<br>a. 今天是星期天（S）<br>b. 天在下雨（R）<br>c. 今天是星期天或者是星期一（S V M）<br>d. 天没下雨 （<code>非R</code>）<br>e. 如果狗是哺乳动物，那么猫也是哺乳动物（D→C）</p><ul><li><strong>推演</strong>: 在命题逻辑中需要从已知的事实中推导出新的事实此过程称为<code>推演</code>，给定两个假定为真的句子，我们能推演出新的为真的句子，前面两个句子称为前提，推演出的句子称为结论，而整个称为论断。</li></ul><blockquote><p>前提1：    他或者在家或者在办公室<br>前提2：    他不在家<br>结论    所以，他在办公室<br>如果我们用H代表 “他在家”，O代表 “他在办公室”，符号I-代表“所以”，那上面的论断可以表示成 <code>{H V O , 非 H}| - O</code>。</p></blockquote><p>我们是如何证明推演的论断是合法的，一个合法的论断是指它的结论是前提的必然延续。换言之，在一个合法的推演论断中，如果所有的前提都为真，而结论为假，这是不可能的。</p><p>验证论断合法性的一种方法是为前提和结论建立真值表，如果我们在其中发现了反例，那么结论就是非法的，反例就像所有的前提都为真，而结论却是假。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230131115140.png" alt="WeiyiGeek.推演图" title="" class="">                <p>WeiyiGeek.推演图</p>            </figure><p>所以当找不到反例时，论断就是合法的。</p><p><br/></p><p><strong>2) 谓词逻辑</strong></p><p>在命题逻辑中，表示句子的符号是原子的，我们不能分割开它而发现各个组成部分中所含的信息。</p><p>例如，如下这样的句子：<code>P1：&quot;琳达是玛丽的母亲”    P2： “玛丽是安妮的母亲”</code> , 我们可以用很多方法来组合这两个句子从而产生其他的句子, 但却不能抽取出琳达和安妮间的任何关系。</p><p>例如，我们不能从上面两个句子中推导出琳达是安妮的祖母, 若要进行这样的推导，我们就需要使用带谓词逻辑，这种逻辑定义了命题各部分间的关系。</p><p>在谓词逻辑中，句子被分成谓词和参数。例如，如下的句子被写成了谓词带两个参数的形式：</p><blockquote><p>P1： “琳达 是 玛丽 的母亲” 变成 母亲（琳达，玛丽）<br>P2： “玛丽 是 安妮 的母亲” 变成 母亲（玛丽，安妮）</p></blockquote><p>上面句子中的母亲关系是由谓词“母亲”来定义的，如果在两个句子中的玛丽是指同一 个人，我们可以推导出琳达和安妮间的新的关系：祖母（琳达，安妮）, 这就是谓词逻辑要实现的目的。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230131142855.png" alt="WeiyiGeek.谓词逻辑之句子、量词、推演图" title="" class="">                <p>WeiyiGeek.谓词逻辑之句子、量词、推演图</p>            </figure><p><br/></p><p><strong>3) 超谓词逻辑</strong></p><p>由于逻辑推理的需要，逻辑得到了进一步的发展，这些包括高阶逻辑、默认逻辑、模态逻辑和时态逻辑，此处只是简单地罗列一下这些名词。</p><p>1) 高阶逻辑: 扩展了谓词逻辑中量词 ∀（所有的）和 彐 (存在) 的范围, 这些谓词逻辑中的量词把变量x和y绑定到实例(在初始化时), 在高阶逻辑中我们能使用量词捆绑那些代表属性和关系的变量，这样在初始化的过程中，这些变量被换成了谓词。</p><blockquote><p>例如，我们可以有 ∀ P(Pj v Ps), 下标 j 和 a 表示 John 和 Anne, 意味着 John 和 Anne 具有完全相同的属性。</p></blockquote><p>2) 模态逻辑: 逻辑的一个快速发展的趋势是模态逻辑, 逻辑中包含了“could”“should”、“may”might”“ought”等这样的表达式，来表达句子中语法上的语气。在这样的逻辑中，我们有符号表示“it is possible that”这样的运算符。</p><p>3) 时态逻辑：像模态逻辑一样，用一套时态运算符扩展了谓词逻辑，如“from now on”或者“at some point in time”，它们包含了论断合法性中的时间因素。</p><p>4) 默认逻辑: 我们假定论断的默认结论可以被接收，只要论断与知识库中的内容相一致即可。例如，我们假定所有的鸟都会飞，除非知识库中有内容废除了这条通用的事实。</p><p><br/></p><h4 id="4-基于规则的系统"><a href="#4-基于规则的系统" class="headerlink" title="(4) 基于规则的系统"></a>(4) 基于规则的系统</h4><p>描述: 基于规则的系统使用一组规则来表示知识，这些规则能用来从已知的事实中推导出新的事实。</p><p>规则表示当指定条件满足时什么为真，基于规则的数据库是一组<code>if……then……</code>语句，它们的形式为：<code>if A then B 或 A → B</code>, 其中A称为前提,B为结论。</p><p>注意在基于规则的系统中，每条规则都是独立处理的，与其他规则没有关联。</p><p><strong>1) 组成</strong><br>描述: 一个基于规则的系统由三部分构成<code>解释器（或推理机）、知识库和事实库</code>, 其关系如下所示:</p><ul><li>知识库: 基于规则系统中的知识库部分就是规则的数据库（仓库）。它包含一组预先建立的规则，这些规则能从给定事实中得出结论。</li><li>事实库: 包含了知识库中的规则要使用的一组条件。</li><li>解释器:（推理机）是一个处理器或控制器（如一段程序），它把规则和事实组合在一起,解释器有两种类型<code>正向推理</code>和<code>反向推理</code>。</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230131145551.png" alt="WeiyiGeek.基于规则的系统三部分组成图" title="" class="">                <p>WeiyiGeek.基于规则的系统三部分组成图</p>            </figure><p><br/></p><p><strong>2) 正向推理</strong></p><p>正向推理是这样一个过程，解释器使用一组规则和一组事实来执行一个行动，此行动可能是向事实库中增加一条新的事实，或处理其他一些命令，如开启另一个程序或机器，解释器解释和执行规则，直到不再有要解释的规则。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230131145742.png" alt="WeiyiGeek.正向推理的流程图" title="" class="">                <p>WeiyiGeek.正向推理的流程图</p>            </figure><p>如果系统中有任何冲突发生，冲突是指有两条不同的规则可以应用到一个事实上，或一条规则可以应用到两个事实上，这时系统就要调用冲突处理过程来解决这个问题，这就保证了只有一个输出能被加到事实库中或一个行动被采取</p><p><br/></p><p><strong>3) 反向推理</strong></p><p>如果系统是证明一个结论，那么正向推理效率不高，面对给出的结论，所有的规则检査所有的事实。这种情况下如果使用反向推理，效率会高些。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230131150017.png" alt="WeiyiGeek.反向推理的流程图" title="" class="">                <p>WeiyiGeek.反向推理的流程图</p>            </figure><p>过程从一个结论（目标）开始，如果目标已在事实库中，则过程停止，结论得到验证，如果结论不在事实库中，那么系统査找目标在规则结论中的规则。</p><p>但是，反向推理不是触发这条规则，而是去验证这条规则中的每个事实（递归）。如果这条规则中的所有事实都在事实库中，那么原来的目标就得到验证。</p><p><br/></p><h3 id="18-4-专家系统"><a href="#18-4-专家系统" class="headerlink" title="18.4 专家系统"></a>18.4 专家系统</h3><p>专家系统使用前面所讨论的知识表示语言，来执行通常需要人类专家才能完成的任务。它们被用在需要人类专家，而人类专家却缺少、昂贵或不可用等场合。</p><p>例如，在医疗领域，可建立专家系统从一组症状中得到可能病因的子集，而这项任务通常是由医生来进行的。</p><h4 id="1-知识抽取"><a href="#1-知识抽取" class="headerlink" title="(1) 知识抽取"></a>(1) 知识抽取</h4><p>描述: 一个专家系统是建立在预先定义的关于领域专家经验的知识的基础上的, 因此建立专家系统的第一步就是从人类专家身上抽取知识, 抽取的知识就变成了我们前面讲到的知识库。</p><p>从专家身上抽取知识通常是困难的，这有几个原因：</p><ul><li>1）专家拥有的知识通常是启发式的，它们是基于概率的，而不是确定的。</li><li>2）专家常常发现用可以存放在知识库中的规则形式来描述知识是艰难的。<blockquote><p>例如，要一步一步地显示故障电动机是如何被诊断的，这对电气工程师来说是非常艰难的, 知识常常是直觉的。</p></blockquote></li><li>3）知识获取只能通过与专家个人会面才能进行, 如果会面者对这种会面并不擅长，那么会面将是累人的和枯燥的。</li></ul><p>所以说，知识抽取过程通常是由知识工程师来完成, 他可能并不是此领域的专家，但他有经验，知道如何去会面，如何去解释答案，所有这些工程师能用来建立知识库。</p><p><br/></p><h4 id="2-事实抽取"><a href="#2-事实抽取" class="headerlink" title="(2) 事实抽取"></a>(2) 事实抽取</h4><p>为了能推导新的事实或采取动作，除了需要用知识表示语言表示的知识库外，还需要事实库, 专家系统中的事实库是基于事例的，在事例中事实被收集或度量，然后进入系统，被推理机使用。</p><p><br/></p><h4 id="3-体系结构"><a href="#3-体系结构" class="headerlink" title="(3) 体系结构"></a>(3) 体系结构</h4><p>下图显示了一个专家系统体系结构背后的通常理念，该专家系统有7个部分构成：<code>用户、用户界面、推理机、知识库、事实库、解释系统和知识库编辑器</code>, 图中阴影的方框中通常它们被称为专家系统外壳。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230209151631.png" alt="WeiyiGeek.专家系统体系结构图" title="" class="">                <p>WeiyiGeek.专家系统体系结构图</p>            </figure><p>其中<code>推理机</code>是专家系统的心脏，它与<code>知识库、事实库和用户界面</code>进行通信, 专家系统中7个部分中的4个<code>（用户界面、推理机、解释系统和知识库编辑器）</code>是能一次建造，为多个应用使用的，因为它们并不依赖于特殊的知识库或事实库。</p><ul><li>用户: 使用系统，从所提供的专家经验中获益的实体。</li><li>用户界面: 允许用户与系统交互，用户界面能接收用户的自然语言，然后把它们翻译给系统。大多数用户界面提供用户友好的菜单系统。</li><li>推理机: 专家系统的心脏，它使用知识库和事实库推导出要釆取的动作。 </li><li>知识库: 是基于与相关领域专家的会面而得到的知识的集合。</li><li>事实库: 在专家系统中是基于事例的。对于每个事例，用户输入可用的或度量的数据进入事实库，推理机为这特殊的事例使用这些数据。</li><li>解释系统: 并不是所有的专家系统都有解释系统，它用来解释推理机得出的结论的合理性。</li><li>知识编辑器: 并不是所有的专家系统都有知识编辑器，当从领域专家那里获得新的经验时，用知识库编辑器来更新知识库。</li></ul><p><br/></p><h3 id="18-5-感知系统"><a href="#18-5-感知系统" class="headerlink" title="18.5 感知系统"></a>18.5 感知系统</h3><p>人工智能的一个目标是创建一台行为像专家的机器(<code>专家系统</code>), 另外一个目标是创建一台行为像普通人的机器。</p><p>通过模拟人类感知（视觉、听觉、触觉、 嗅觉、味觉）进行执行对应操作，例如人类通过眼睛看风景，头脑把它解释成在风景中抽取出来的对象类型。人类通过耳朵听到一组声音信号，头脑把它解释成有意思的句子等等。</p><p>如果一个智能体要表现得像人类，那它就应该有感知能力，当前人工智能已经初步完成两种感知<code>视觉和听觉</code>，并广泛应用在社会的各个层面，所以此处将主要讨论两种感知。</p><h4 id="1-图像处理"><a href="#1-图像处理" class="headerlink" title="(1) 图像处理"></a>(1) 图像处理</h4><p>图像处理或计算机视觉是人工智能的一个研究领域，它处理通过像摄像机这样的智能体的人工眼睛而获得的对对象的感知，一个图像传感器从外部世界获得二维图像，然后创建在场景中的这个对象的三维描述。</p><p>虽然，这对人类来说是容易的事情，但对智能体来说却是困难的事情，图像处理器的输入是一幅或多幅场景图像，而得到的输岀是场景中对象的描述（<code>抽取出对象的特征</code>）。</p><p><strong>1.边缘探测</strong></p><p>图像处理的第一步是边缘探测，去査找图像中的边缘在哪里，边缘定义了图像中的对象和背景间的边界。</p><p>例如，下图显示了一个非常简单的图像和用0〜9表示的像素点的亮度值，此处0表示黑，9表示白，<code>使用亮度较大的差异值去査找邻接像素点，就能找到边缘</code>(重点)。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230209173827.png" alt="WeiyiGeek.图像处理器与边缘探测处理图" title="" class="">                <p>WeiyiGeek.图像处理器与边缘探测处理图</p>            </figure><p><strong>2.分段</strong><br>分段把图像分成同构的段或区域，同构的定义随着方法的不同而不同，但是，通常同构的区域是其中像素点亮度值变化平滑的区域。</p><p>分段与边缘探测非常类似（区别）</p><ul><li>在边缘探测中，对象的边缘和背景被找到。</li><li>在分段中，对象中两个不同区域的边界被找到，经过分段后，对象被分成不同的区域。</li></ul><p>有几种方法进行分段，例如<code>阈值化</code>和<code>分割</code>与<code>合并</code>。</p><ul><li>阈值化: 它把指定亮度值的像素点选择出来，试图去发现所有具有相同或非常相近亮度值的像素点，通过这种方法找到的像素点形成了一个段。</li><li>分割: 选取一个非同构的区域，把它分成同构的区域。</li><li>合并: 它用来进行具有相同亮度值区域的合并。</li></ul><p><br/></p><p><strong>3.査找深度</strong></p><p>图像分析接下来的一步是查找对象的深度或是图像中的对象, 深度的查找可以<code>帮助智能体去测量对象距它多远</code>， 有两种常用的方法<code>立体视觉</code>和<code>运动</code>。</p><ul><li>立体视觉，(有时称为立体影像)使用人类眼睛的技术来发现对象的深度，识别对象距离的一种工具就是两只眼睛或两台摄像机，两台摄像机创建的图像能帮助智能体去判定对象是近还是远。</li><li>运动，当图中一个或多个对象移动时建立多幅图像，在场景中移动对象与其他对象间的相对位置能给出对象距离的提示。</li></ul><p><br/></p><p><strong>4.查找方向</strong></p><p>场景中的对象的方向可以使用两种技术来发现<code>光照和纹理</code>。</p><ul><li><p>光照: 光从物体表面反射的总量由多个因素来决定</p><blockquote><p>如何一个对象的不同表面的光学特性是相同的，那么反射光线的总量将取决于反射光源的物体表面(它的相对位置)的方向。(如下图所示)</p></blockquote></li><li><p>纹理: (有规律重复的图案)也能对査找方向或表面的曲率有所帮助, 如果智能体能识别图案，这将帮助它査找对象的方向或曲率。</p></li></ul><p><br/></p><p><strong>5.对象识别</strong><br>图像处理的最后一步是对象识别，智能体需要在它的记忆里有可进行比较的对象模型，但是，把所见的每个对象模型都进行创建和存储是一个不可能的任务。</p><p>一个解决方案是假定要识别的对象是一个复合的对象，它由一组简单的几何形状体组成，此时原始的形状能在智能体的记忆中创建并存储，我们需要智能体识别的对象类型能用这些对象的组合创建出来并保存起来。</p><p>当智能体“看”到对象，它就进行对象的分解，把对象分解成原始形状的组合，如果组合的对象对智能体来说是已知的，那对象就被识别了。（如下图所示）</p><p><img src="https://img.weiyigeek.top/2023/1/20230209174908.png" alt="WeiyiGeek.查找方向与对象识别图"></p><p><br/></p><p><strong>6.应用场景</strong></p><p>图像处理的一个应用领域是制造业，特别是在组装生产线上（工业控制），一个具有图像处理能力的机器人能用来测定组装生产线上的对象的位置。</p><p>在这样的环境下，需要感知的对象数目是有限的，所以图像处理就变得非常有帮助。</p><p><br/></p><h4 id="2-语言理解"><a href="#2-语言理解" class="headerlink" title="(2) 语言理解"></a>(2) 语言理解</h4><p>描述: 人类一个固有的能力是能理解（即解释）所感知的声音信号，一台能理解自然语言的机器在日常生活中是非常有用的。</p><p>例如，当前流行的智能AI语音接听单行，它能替代电话操作员（在大部分时间里），它还可以用在系统需要预先定义格式査询的场合，即送到数据库的查询必须遵循指定系统所用的格式。</p><p>机器理解自然语言的任务分成4个连续的步骤：<code>语音识别</code>、<code>语法分析</code>、<code>语义分析</code>和<code>语用分析</code>。</p><h5 id="1-语音识别"><a href="#1-语音识别" class="headerlink" title="1.语音识别"></a>1.语音识别</h5><p>在这一步中语音信号被分析，其中所含的单词序列被抽取出来。</p><p>语音识别子系统的输入是连续（模拟）的信号，输出是单词的序列，信号需要被分割成不同的声音，有时称为<code>“音素”</code>，而声音还需要组合到单词中。</p><h5 id="2-语法分析"><a href="#2-语法分析" class="headerlink" title="2.语法分析"></a>2.语法分析</h5><p>语法分析这一步用来定义单词在句子中是如何组织的, 这对于像英语这样的语言是非常困难的任务, 因为单词在句子的作用并不是由它在句中的位置决定的。</p><p>例如，下面两个句子 <code>Mary rewarded John.</code> 与 <code>John was rewarded by Mary.</code> 此两个句子中John都是受到奖励的，但在第一个句子中，John 在最后的位置，而 Mary 在第一个位置，此处机器需要进行语法分析解释，得到相同的结论。</p><p><strong>文法:</strong> 正确分析句子的第一工具是良好定义的文法。</p><blockquote><p>一种像英语这样的完全成熟的语言具有非常大的文法规则集合, 语言的文法定义可以使用多种方法, 我们可使用BNF （Backus-Naur范式）的一个简单的版本，Backus-Naur范式被用在计算机科学中，定义编程语言的语法。</p><ul><li>第一条规则定义了一个句子是一个名词短语跟着一个动词短语</li><li>第二条规则定义了名词短语有三个选择：单个名词、一个冠词跟一个名词，或者一个冠词跟一个形容词再跟一个名词。</li><li>第四条规则明确地定义了什么是一个名词, 在我们这个简单的语言里只定义了7个名词，而在像英语这样的语言里名词表是在词典中定义的。</li><li>第六条规则定义了形容词一个非常小的集合。</li><li>第七条规则定义了动词一个非常小的集合。</li></ul></blockquote><p>虽然我们的语言的语法非常原始，但我们能从中产生许多句子，例如，我们有:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">John comes home.  约翰回家了。</span><br><span class="line">Mary drinks water. </span><br><span class="line">John has a white dog. 约翰有一只白色的狗。</span><br><span class="line">John loves Mary. </span><br><span class="line">Mary loves John.</span><br></pre></td></tr></table></figure></p><p><strong>词法</strong>: 下图中定义了简单文法，即使使用不同的选项，它也将是非常清楚的，判定一个句子是否符合文法（语法）的机器在判定一个句子是否合法之前，并不需要检查所有可能的选项，此操作由<code>词法分析器</code>完成。</p><blockquote><p>词法分析器基于文法规则建立一棵词法分析树来判断一个句子的合法性。<br>例如，下图中显示了句子”John has a white dog”对应的词法分析树。</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230210111822.png" alt="WeiyiGeek.分析一个句子图" title="" class="">                <p>WeiyiGeek.分析一个句子图</p>            </figure><h5 id="3-语义分析"><a href="#3-语义分析" class="headerlink" title="3.语义分析"></a>3.语义分析</h5><p>义分析就是在句子被语法分析之后抽取出句子的意思。这种分析建立了句子中所涉及的对象的表示方法、它们的关系以及它们的属性。分析能用我们前面所讨论的任一种知识表示模式。</p><blockquote><p>例如，句子<code>John has a dog</code>可以用谓词逻辑表示成：<code>∃(存在)x dog(x) has(John,x)</code></p></blockquote><h5 id="4-语用分析"><a href="#4-语用分析" class="headerlink" title="4.语用分析"></a>4.语用分析</h5><p>前面的三个步骤<code>(语音识别、语法分析和语义分析)</code>能创建口语句子的知识表示, 此<code>语用分析</code>是用来进一步明确句子的意图和消除歧义。</p><p><strong>意图</strong>: 英语句子有许多种不同的意图，如告诉、请求、答应、询问等, 语用分析就是用来发现句子的这些意图的。</p><blockquote><p>例如，句子“Can you swim a mile?”问 的是听者的能力，而句子“Can you pass the salt?”(你能把盐递给我吗？)却只是一句礼貌的请求。</p></blockquote><p><strong>消除歧义</strong>: 有时句子在语义分析之后是有歧义的, 歧义的出现有不同的情况, 一个单词有多于一种的功能，如单词“hard”既能作形容词又能作副词,一个单词有多于一种的意思。</p><blockquote><p>例如，如单词“ball”在“football”和“ballroom”中是不同的含义，两个单词有着相同的发音，却有着不同的拼写和含义，一个句子在语法上可能是正确的，但在含义上却是没有道理的。<br>如，句子 <code>John ate the mountain</code> （<code>约翰吃了这座山</code>）语法分析时是合法的，语义分析时也是正确的，但含义却是毫无道理的</p></blockquote><p><br/></p><h3 id="18-6-搜索技术"><a href="#18-6-搜索技术" class="headerlink" title="18.6 搜索技术"></a>18.6 搜索技术</h3><p>AI人工智能解决问题的一种技术是搜索，搜索可以描述成用状态(情形)集合求解问题。<br>搜索过程开始于一个<code>起始状态，经过中间状态，最后到达目标状态</code>, 搜索过程所使用的全部状态的集合称为<code>搜索空间</code>。</p><blockquote><p>例如，在难题求解中，初始状态就是未解决的难题，中间状态就是对难题釆取的每一个步骤，目标状态就是难题被解决时的情形。</p></blockquote><p>例1.显不了一个具有5个状态的状态空间的例子。</p><blockquote><p>其中任一个状态都可能是初始状态或目标状态, 带箭头的线显示了采取合适的动作后，一个状态是如何从一个状态走到另一个状态的。<br>注意：如果没有动作或动作系列可被采取，那么从一个状态到另一个状态的转化也许就是不可能的。</p></blockquote><p>例2.显示搜索空间的难题的示例是著名的8数字游戏，难题是一个具有9个方块格子的盘子。</p><blockquote><p>方块有一个初始随机的安排（初始状态）.目标就是重新安排这些方块，直至实现方块的有序排列（目标状态）。</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230210115957.png" alt="WeiyiGeek.搜索空间示例图" title="" class="">                <p>WeiyiGeek.搜索空间示例图</p>            </figure><p>当前搜索，有两种常用的搜索方法，<code>蛮力搜索</code>和<code>启发式搜索</code>, 其中搜索本身又有<code>广度优先</code>和<code>深度优先</code>。</p><p><br/></p><h4 id="1-蛮力搜索"><a href="#1-蛮力搜索" class="headerlink" title="(1) 蛮力搜索"></a>(1) 蛮力搜索</h4><p>当对搜索没有任何先验的知识时，我们就使用蛮力搜索。例如，在图中，A和T 分别代表起点和终点，我们要在迷宫中找到从A到T的路，我们将其转为树形图。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230210130203.png" alt="WeiyiGeek.迷宫的树形图" title="" class="">                <p>WeiyiGeek.迷宫的树形图</p>            </figure><p>转换为树形结构后，我们就可以使用前面数据结构中学过的树搜索的两种方法，<code>广度优先搜索</code>与<code>深度优先搜索</code>。</p><h5 id="1-广度优先搜索（遍历）"><a href="#1-广度优先搜索（遍历）" class="headerlink" title="1.广度优先搜索（遍历）"></a>1.广度优先搜索（遍历）</h5><p>在这种方法中，我们从树的根开始，在我们走向下一层前，检查当前层中的所有节点，下图中显示了迷宫的从左到右的广度优先搜索。</p><p>温馨提示：在到达目标状态前，我们不得不搜索所有的节点，所以这种方法是低效的，如果我们的搜索是从右到左的，那么我们要搜索的节点数可能就不同了。</p><h5 id="2-深度优先搜索（纵深）"><a href="#2-深度优先搜索（纵深）" class="headerlink" title="2.深度优先搜索（纵深）"></a>2.深度优先搜索（纵深）</h5><p>在这种方法中，我们从树的根开始，做一个向前搜索，直至发现目标或到达一个死端。如果到达了死端，我们回溯到最近的分支，然后再次向前搜索，我们继续这样的过程直至达到目标。</p><p>温馨提示：针对迷宫问题这种搜索方法的效率比广度优先搜索要高。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230210130753.png" alt="WeiyiGeek.广度优先搜索深度优先搜索与图" title="" class="">                <p>WeiyiGeek.广度优先搜索深度优先搜索与图</p>            </figure><p><br/></p><h4 id="2-启发式搜索"><a href="#2-启发式搜索" class="headerlink" title="(2) 启发式搜索"></a>(2) 启发式搜索</h4><p>使用启发式搜索，我们给每个节点赋一个称为启发值（h值）的定量值。这个定量值显示了该节点与目标节点间的相对远近。</p><p>例如，考虑上图18-19中的要解决的8数字游戏，假定难题的初始和目标状态如图所示，每一个方块的启发值是它到目标状态要移动的最小步数，每个状态的启发值是这个状态中所有方块的启发值之和。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230210141105.png" alt="WeiyiGeek.启发式搜索示例图" title="" class="">                <p>WeiyiGeek.启发式搜索示例图</p>            </figure><p><br/></p><h3 id="18-7-神经网络"><a href="#18-7-神经网络" class="headerlink" title="18.7 神经网络"></a>18.7 神经网络</h3><p>神经网络试图使用神经元网络去模仿人脑的学习过程，我们知道学习是一种复杂的生物现象，即使是人类自己也没有完全理解, 要使人工智能体自我学习肯定不是件容易的事情。但是, 在过去已经有好几种方法为未来建立了希望，大多数方法使用了归纳学习或从例子中学习，这意味着把很大集合的问题和解法都给计算机，让计算机从中学习</p><p>本节我们只讨论其中一种方法，它可以不必使用复杂的数学概念来描述，它就是神经网络。</p><h4 id="1-生物神经元"><a href="#1-生物神经元" class="headerlink" title="(1) 生物神经元"></a>(1) 生物神经元</h4><p>人脑中有数以亿计的处理单元, 称为神经元, 每个神经元平均与数以千计的其他神经元相连, 神经元有三部分构成：<code>胞体、轴突和树突</code>。</p><ul><li><code>胞体（身体）</code>中含有细胞核：它是处理器</li><li><code>树突起到输入设备</code>的作用：它接收其他神经元的输入</li><li><code>轴突起到输出设备</code>的作用：它把输出送到其他神经元</li><li><code>神经键</code>是神经元的轴突和其他神经元的树突的连接点, 树突从相邻的神经元中收集电信号把它传给胞体。<blockquote><p>实际上神经键的工作就是给传到相邻神经元的信号上加上权重，它根据产生的化学物质的数量来判断是强连接还是弱连接。</p></blockquote></li></ul><p>一个神经元有两种状态：<code>兴奋和抑制</code>。<br>如果接收的信号总量达到一个阈值，身体就兴奋，并触发一个输出信号，该信号传给轴突，最终传给其他的神经元。<br>如果接收的信号总量没有达到阈值，神经元仍然处于抑制状态：它不触发或产生输出。</p><p><br/></p><h4 id="2-感知器"><a href="#2-感知器" class="headerlink" title="(2) 感知器"></a>(2) 感知器</h4><p>感知器是一个类似于单个生物的人工神经元的人工神经元，它是带有一组具有权重的输入，对输入求和，把结果与阈值进行比较，若结果大于阈值感知器触发（输出1），否则不触发（输出0）。</p><p>例如，下图中一个带有5个输入(x1~x5)和5个权重(w1~w5)的感知器，在此感知器中，如果T是阈值，输出值确定如下。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230210142701.png" alt="WeiyiGeek.感知器技术与权重图" title="" class="">                <p>WeiyiGeek.感知器技术与权重图</p>            </figure><p><br/></p><h4 id="3-多层网络"><a href="#3-多层网络" class="headerlink" title="(3) 多层网络"></a>(3) 多层网络</h4><p>几个层次的感知器可以组合起来，形成多层神经网络，每一层的输出变成下一层的输入，<code>第一层称为输入层，中间层称为隐藏层，最后一层称为输出层</code>。</p><blockquote><p>输入层中的节点不是神经元，它们是分配器，隐藏的节点通常用来给上一层的输出加上权重的，如下图所示显示了一个三层的神经网络。</p></blockquote><p><img src="https://img.weiyigeek.top/2023/1/20230210143858.png" alt="WeiyiGeek.一个多层神经网络图"></p><p><br/></p><h4 id="4-应用"><a href="#4-应用" class="headerlink" title="(4) 应用"></a>(4) 应用</h4><p>当有足够的预先定义的输入和输岀时，就可以使用神经网络。两个证明神经网络有用的领域是光学字符识别（OCR）（智能体读任何的手写体）和信用赋值（不同的因素赋予不同的权重去建立信用等级，例如用于贷款申请）。</p><p>本文作为【计算机科学导论学习】的最后一章，至此完毕，相信随着前面的学习，读者已经对计算机有了一个初步的了解，包括其发展、硬件组成、使用以及编程算法、数据结构、计算机安全、和计算机应用，针对于读者进行后续全栈相关技术的学习，提供了基础知识储备，当遇到相关概念或者问题时，可以快速了解并进行学习，希望能的帮助到各位看。</p><p>后续【WeiyiGeek】作者将持续推出，计算机全栈入门学习系列教程（学习笔记），希望大家多多支持!.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;计算机科学导论学习笔记&quot;&gt;&lt;a href=&quot;#计算机科学导论学习笔记&quot; class=&quot;headerlink&quot; title=&quot;计算机科学导论学习笔记&quot;&gt;&lt;/a&gt;计算机科学导论学习笔记&lt;/h1&gt;&lt;h1 id=&quot;第-5-部分-数据安全与人工智能&quot;&gt;&lt;a href=&quot;#第-5-部分-数据安全与人工智能&quot; class=&quot;headerlink&quot; title=&quot;第 5 部分 数据安全与人工智能&quot;&gt;&lt;/a&gt;第 5 部分 数据安全与人工智能&lt;/h1&gt;&lt;p&gt;此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://mp.weixin.qq.com/s/Sa9dVU7JOS5zEddldf22mw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/Sa9dVU7JOS5zEddldf22mw&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://blog.weiyigeek.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="计算机科学导论" scheme="https://blog.weiyigeek.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>17.计算机科学导论之计算理论学习笔记</title>
    <link href="https://blog.weiyigeek.top/2023/1-18-708.html"/>
    <id>https://blog.weiyigeek.top/2023/1-18-708.html</id>
    <published>2023-01-18T09:35:30.000Z</published>
    <updated>2023-02-13T08:02:38.885Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="计算机科学导论学习笔记"><a href="#计算机科学导论学习笔记" class="headerlink" title="计算机科学导论学习笔记"></a>计算机科学导论学习笔记</h1><h1 id="第-5-部分-数据安全与人工智能"><a href="#第-5-部分-数据安全与人工智能" class="headerlink" title="第 5 部分 数据安全与人工智能"></a>第 5 部分 数据安全与人工智能</h1><p>此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。</p><p>原文地址: <a href="https://mp.weixin.qq.com/s/rGfSNRqywE7cmKDFB3wEkQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rGfSNRqywE7cmKDFB3wEkQ</a></p><a id="more"></a><h2 id="17-计算理论"><a href="#17-计算理论" class="headerlink" title="17.计算理论"></a>17.计算理论</h2><p>在前面几章中,我们把计算机看成是一台问题求解机器，在此章节我们冋答一些诸如此类的问题：</p><p>哪些问题可以通过计算机解决？语言之间是否存在优劣？运行一个程序前，是否可以确定该程序将要停止(终止)还是一直运行？用一种特定的语言解决一个问题需要多长时间？</p><p>为了回答这些问题，我们求助于一门学科：计算理论。</p><p>在学习计算理论前对其做一个简要的介绍。</p><ul><li>首先，介绍一种语言，称为简单语言，通过它可以看到计算机解决任何问题所需要的最少语句是三条。</li><li>其次，介绍一种工具，一种称为图灵机的计算机模型，我们在第1章中提到过它。我们将看到，简单语言可以解决的问题也可以用图灵机解决。</li><li>第三，我们将证明没有任何程序可以知道另一个程序终止与否。证明本身表明有些问题计算机是无法解决的，最后简要地讨论算法的复杂性。本章中描绘的思想来自于计算机科学界的先驱们，如阿兰•图灵(Alan Turing),库尔特•哥德尔(Kurt Godel). 马文•明斯基(Marvin Minsky)、阿隆佐•邱奇(Alonzo Church)和斯蒂芬•科尔•克莱尼(Stephen Cole Kleene)。</li></ul><p><br/></p><h3 id="17-1-简单语言"><a href="#17-1-简单语言" class="headerlink" title="17.1 简单语言"></a>17.1 简单语言</h3><p>我们可以仅用三条语句来定义一种语言，它们是：<code>递増语句、递减语句和循环语句</code>, 在该语言中，只能使用非负整数数据类型。</p><p>这里不需要其他类型数据，因为本章的目标仅仅是说明计算理论中的一些思想。</p><h4 id="1-三条基本语句"><a href="#1-三条基本语句" class="headerlink" title="(1) 三条基本语句"></a>(1) 三条基本语句</h4><ul><li><p>递增语句对变量加1: <code>incr(x)</code></p></li><li><p>递减语句从变量中减1: <code>decr(x)</code></p></li><li><p>循环语句是在变量的值不为0时，重复进行一个动作(或一系列动作)。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">  decr(x)</span><br><span class="line">  Body of the loop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-简单语言的威力"><a href="#2-简单语言的威力" class="headerlink" title="(2) 简单语言的威力"></a>(2) 简单语言的威力</h4><p>使用上述三种语句的简单程序设计语言和我们现在使用的任何一种复杂语言(比如C) 一样强大(虽然从效率来说不一定)，为了证明这一点，可以演示一下如 何模拟当今流行语言中的某些语句。</p><p><strong>简单语言中的宏</strong><br>此处，我们将每次模拟称为一个宏，并且在其他模拟中使用时不需要再重复其代码。</p><p>什么是宏?</p><blockquote><p>宏(macro, macroinstruction 的简称)是高级语言中的一条指令，它等价于相同语言中的一条或多条指令的特定集合。</p></blockquote><p>示例1.使用简单语言的语来给一变量X赋值为0(有时叫做清空变量), 第一个宏 <code>X-0</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">  decr(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>示例2.使用简单语言的语句将一正整数赋值给变量X, 首先清空变量X，然后对X递增n次, 第二个宏: <code>X-n</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X &lt;- 0</span><br><span class="line">incr(X)</span><br><span class="line">incr(X)</span><br><span class="line">...</span><br><span class="line">incr(X)  // 重复n次</span><br></pre></td></tr></table></figure><p>示例3.使用简单语言的语句将额外代码行来恢复X的值，第三个宏: <code>Y &lt;- X</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y &lt;- 0</span><br><span class="line"><span class="keyword">while</span>(X) &#123;</span><br><span class="line">  decr(X)</span><br><span class="line">  incr(Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例4.使用简单语言的语句将额外代码行来恢复X的值, 使其恢复原来的原始值，第四个宏: <code>Y &lt;- Y + X</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(X) &#123;</span><br><span class="line">  decr(X)</span><br><span class="line">  incr(Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>示例5.模拟简单语言中的宏,我们可使用加法宏因为整数的乘法可以用重复的加法来模拟，注意我们需要把X的值保存在一个临时变量中，因为在每次的加法中我们需要把的原始值加到Y上, 第五个宏: <code>Y &lt;- Y * X</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TEMP &lt;- Y</span><br><span class="line">Y &lt;- 0</span><br><span class="line"><span class="keyword">while</span>(X) &#123;</span><br><span class="line">  decr(X)</span><br><span class="line">  Y &lt;- Y + TEMP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例6.我使用宏来完成它因为整的指数可以用重复的乘法来模拟，第六个宏: <code>Y &lt;- Y^X</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TEMP &lt;- Y</span><br><span class="line">Y &lt;- 1</span><br><span class="line"><span class="keyword">while</span>(X) &#123;</span><br><span class="line">  decr(X)</span><br><span class="line">  Y &lt;- Y * TEMP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例7.宏模了现代语言中的判断语 (if)在这个宏中，变量X的值只能是0或1这两个值之间的一个。如果的值不是0，在循环中A(一个动作或一系列动作)被执行。是该循只执行一次，因为第一轮行完后X的值变成0，从而跳出循环。如果的值是0循环被跳过，第七个宏: <code>if X then A</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x) &#123;</span><br><span class="line">  decr(x)</span><br><span class="line">  A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除此之外，还有需要其他宏，但是很显然，我们需要更多的宏来使简单语言与现代语言相匹配，建立其他宏是可能的，但却并不简单（较复杂）。</p><p><br/></p><p><strong>输入和输出</strong><br>描述: 在简单语言中 <code>Read X 语句</code> 可以使用（X←n）来模拟，我们也可模拟输出，即假定程序中使用的最后一个变量保存着将要打印的数据, 记住这不是实际的语言，而是仅仅用来证明计算机科学中的一些定理。</p><p><br/></p><h3 id="17-2-图灵机"><a href="#17-2-图灵机" class="headerlink" title="17.2 图灵机"></a>17.2 图灵机</h3><p>图灵机是在1936年由Alan M.Turning提出用来解决可计算问题的, 它是现代计算机的基础。</p><h4 id="1-组成部分介绍"><a href="#1-组成部分介绍" class="headerlink" title="(1) 组成部分介绍"></a>(1) 组成部分介绍</h4><p>图灵机由三部分组成：磁带、控制器和读/写头（如下图所示）。</p><p><strong>磁带</strong><br>尽管现代计算机中使用的随机存储设备容量是有限的，但我们假定图灵机中的内存是无限的，磁带任何时候只能保存一系列顺序字符，该字符来自计算机所能接收的字符集中。</p><p>为了我们的目的，假设图灵机只能接收两个符号：空白（b）和数字1，下述给出了这种机器磁带记录数据的一个例子。</p><p>磁带左手的空白定义了存储在磁带上的非负整数的开始，一个整数用1构成的串表示。磁带右手的空白定义了整数的结束。磁带的其他部分包含了空白字符。如磁带上存有多个整数，它们用至少一个空白字符隔开。</p><p>此外，还假设磁带处理一元算术中的正整数, 在一元算术中，正整数仅由1组成，例如整数4表示为<code>1111 （4个1）</code>, 7表示为<code>1111111 （7个1）</code>,没有1的地方表示0。</p><p><img src="https://img.weiyigeek.top/2023/1/20230130110655.png" alt="WeiyiGeek.图灵机由三部分组成与磁带图"></p><p><br/></p><p><strong>读/写头</strong><br>描述: 在任何时刻总是指向磁带上的一个符号，我们称这个符号为当前符号，读/写头每次在磁带上读写一个符号。每读写完一次后，它向左移、向右移, 读、写和移动都是在控制器指令下进行的。</p><p><br/></p><p><strong>控制器</strong></p><p>控制器是理论上功能作用类似于现代计算机中央处理单元（CPU）的一个部件，它是一个有限状态自动机，即该机器有预定的有限个状态并能根据输入从一个状态转移到另一个状态，但任何时候它只能处于这些状态中的一种。</p><p>下图给出了简单控制器作为有限状态自动机控制器的状态转移图。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130111125.png" alt="WeiyiGeek.有限状态自动机控制器的状态转移图" title="" class="">                <p>WeiyiGeek.有限状态自动机控制器的状态转移图</p>            </figure><p>在此图中, 自动机有三个状态（A、B和C）,虽然控制器通常有很多状态。图中给出了读入字符后所引起状态的改变, 每一行上的表达式（<code>x/y/L, x/y/R 和 x/y/N</code> ）显示了：控制器读入x后，它写符号y（改写x）,并将读/写头移到左边（L）、右边（R）或不动（N）。注意既然磁带上的符号只有空白或数字1,那么从每个状态出去的路径只有两条：要么读到的是空白符号，要么读到的是数字1。线（称为转移线）的起点显示的是当前状态，线的末端（箭头）显示的是一下状态。</p><p>我们可以建立一个每一行代表一个状态的状态转移表（表17-1）。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130111554.png" alt="WeiyiGeek.状态转移表图" title="" class="">                <p>WeiyiGeek.状态转移表图</p>            </figure><p>表有5栏表示当前状态、读入符号、所写符号、读/写头的移动方向和下一个符号，既然机器只能经历有限个状态, 那么我们能创建一个像我们在第5章中为简单计算机建立的指令集。</p><p>指令是把一行中的5列值放在一起，对于这台初级的机器，我们只有6条指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.（A, b, b, R, A）3.（B, b, 1, R, B） 5.（C, b, b, L, A）</span><br><span class="line">2.（A, 1, 1, R, B）4.（B, 1, b, N, C） 6.（C, 1, 1, L, B）</span><br></pre></td></tr></table></figure></p><p>例如，第一条指令是说：如果机器处于状态A, 读到了符号b, 它就用一个新的b改写符号，读/写头向右移到下一个符号上，机器的状态转移到状态A也就是保留在相同的状态中。</p><p>例如，一个图灵机只有两个状态和如下的4条指令：<code>1.(A, b, b, L, A)    2.(A, 1, 1, R, B)    3.(B, b, b, L, A) 4.(B, 1, b, R, A)</code>.</p><ul><li>开始时, 机器是处于状态A,当前符号是1,这就意味着只有第二条指令(A, 1, 1, R, B) 能被执行。</li><li>最后时, 注意控制器的状态已经变成了B,读/写头已经向右移动了一个符号。</li></ul><p><img src="https://img.weiyigeek.top/2023/1/20230130111815.png" alt="WeiyiGeek.示例代码4条指令图"></p><p><br/></p><h4 id="2-简单语言的模拟"><a href="#2-简单语言的模拟" class="headerlink" title="(2) 简单语言的模拟"></a>(2) 简单语言的模拟</h4><p>在图灵机中，我们能编写程序来实现简单的语句了，值得注意的是这些语句可以用多种方法来写，为了学习的目的，我们选择了最简单或最方便的，但它们不一定是最好的。</p><p><strong>1.incr(X)语句的图灵机</strong><br>控制器有4个状态，从S1到状态S4,状态S1是开始状态，状态S2是右移的状态，状态S3是左移的状态，状态S4是停机状态。如果到达停止状态，机器就停止：没有指令从这个状态开始。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130112818.png" alt="WeiyiGeek.incr(X)语句的图灵机图" title="" class="">                <p>WeiyiGeek.incr(X)语句的图灵机图</p>            </figure><p><strong>2.decr(X)语句的图灵机</strong><br>此处，我们使用最小的指令数目来实现<code>decr(X)</code>语句, 其原因是我们在下一条语句<code>(while循环)</code>中要用到这个语句，它也被用来实现所有的宏。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130113043.png" alt="WeiyiGeek.decr(X)语句的图灵机图" title="" class="">                <p>WeiyiGeek.decr(X)语句的图灵机图</p>            </figure><p><strong>3.while语句的图灵机</strong><br>为了模拟循环，我们假定X和循环体处理的数据存储在磁带上，中间以单个空白字符相隔，三个状态 Si、S和 S;控制了循环，它通过判断的值，如果X=0，就退出循环。把这三个状态与图 17-8 中减语句中使用的三个状态进行比较。状态 M把读/写头移过在每次重复中在处理数据开始时定义了数据开始位置的空白符号:状态M把读/写头移过在每次重复中在处理数据结束时定义了X的开始位置的空白符号;状态Bs定义了循环体的开始状态，而状态 B定义了循环体的停机状态。循环体在这两个状态间可能有几个状态。</p><p>下图中，还显示了语句的重复性质，状态图本身是一个只要X的值不为0就重复的循环，当X的值变成0,循环停止，状态S3 (停机状态)到达了。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130113148.png" alt="WeiyiGeek.while语句的图灵机图" title="" class="">                <p>WeiyiGeek.while语句的图灵机图</p>            </figure><p><br/></p><h4 id="3-邱奇-图灵论题"><a href="#3-邱奇-图灵论题" class="headerlink" title="(3) 邱奇-图灵论题"></a>(3) 邱奇-图灵论题</h4><p>上面我们演示了图灵机能模拟简单语言中的三个基本语句，也就意味着图灵机能模拟我们为简单语言定义的所有的宏。</p><p><strong>那么图灵机是否能解决一台计算机能解决的任何问题？</strong></p><blockquote><p>这个问题的答案可以在<code>邱奇-图灵论题(Church-Turing thesis)</code>中找到。</p></blockquote><p>基于这样的观点，能用写一个算法来完成的任何符号操纵任务也可以用图灵机完成。注意这只是论题，不是定理, 定理可以在数学上得到证明，但论题却不能, 虽然这个论题可能永远得不到证明，但有些强有力的论断在支持它。</p><ul><li>首先，尚未发现有图灵机不能模拟的算法；</li><li>其次，所有在数学上已经得到证明的计算机模型都与图灵机模型等价，这个论断是得到证明的。</li></ul><p><br/></p><h3 id="17-3-歌德尔数"><a href="#17-3-歌德尔数" class="headerlink" title="17.3 歌德尔数"></a>17.3 歌德尔数</h3><p>在计算机科学理论中，一个无符号数能被分配给任何用特定语言编写的程序，通常称为歌德尔数（用澳大利亚数学家Kurt G6del命名）, 这种分配有很多优点。</p><p>首先，程序可以作为单一数据项输入给其他程序。第二，程序可以通过它的整数表示来引用。第三，该编号方式可以用来证明有一些问题计算机并不能解决，从而说明世界上问题的数量远远比曾经编写的程序数量要多得多。</p><p>各种各样的方法被设计用来给程序编号, 我们用一个简单的变换给用简单语言编写的程序编号。假定简单语言仅使用15个标志符（表17-2 ）</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130114344.png" alt="WeiyiGeek.简单语言中的符号编码图" title="" class="">                <p>WeiyiGeek.简单语言中的符号编码图</p>            </figure><p>注意，在这种语言当中仅使用X, X1. X2,…，X9。作为变量。为了将变量编码，将Xn看成是由X和n两个符号组成来处理（X3是由X和3组成）。如果在宏中有其他类型变量，应将它们转换为Xn的形式。</p><h4 id="1-表示一个程序"><a href="#1-表示一个程序" class="headerlink" title="(1) 表示一个程序"></a>(1) 表示一个程序</h4><p>运用这个表，我们可以通过唯一的正整数表示用简单语言编写的任何程序, 按照以下步骤进行：<br>1）将每一个符号用表中所给的对应十六进制代码替代。<br>2）将最后的结果（十六进制）转化为无符号整数。</p><p>例如，对于incr(X)来说，用对应的十六进制代码替代每个符号, 此程序可以用数字175表述。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr X -&gt; (AF)16 -&gt; 175</span><br></pre></td></tr></table></figure></p><p><br/></p><h4 id="2-翻译一个数字"><a href="#2-翻译一个数字" class="headerlink" title="(2) 翻译一个数字"></a>(2) 翻译一个数字</h4><p>为了证明编号方式是唯一的，用以下步骤来解释歌德尔数：<br>1）将数字转换成十六进制数。<br>2）用表17-2将每个十六进制数翻译成对应的符号(忽略0 )。</p><p>注意，虽然用简单语言编写的一切程序都能用数字表述，但是，并不是所有的数字都能解释为合法程序。转换之后，如果符号不符合语法规则，这个数字就不是有效的程序。</p><p>例如，将 3058 翻译成程序，即将数字变成十六进制数并使用相应的符号代替。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3058 -&gt; (BF2)16 -&gt; decr X 2 -&gt; decr (X2)</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="17-4-程序停止问题"><a href="#17-4-程序停止问题" class="headerlink" title="17.4 程序停止问题"></a>17.4 程序停止问题</h3><p>几乎所有的简单语言编写的程序都包含某种形式的重复(循环或递归函数)。</p><p>一个重复结构可能永远都不会结束(停机)，这就是说一个含有无限循环的程序可以永远运行，但是程序开发者通常需按照需求进行设置跳出循环条件，否则可能导致死循环(严重时会导致系统崩溃😫)。</p><p>例如，下面的用简单语言编写的程序可以永不结束。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 1</span><br><span class="line"><span class="keyword">while</span> (x) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>我们能编写一个程序来测试任何可以用哥德尔数表示的程序是否会终止吗?</p><blockquote><p>答: 经过计算机科学家证实，停机问题是不可能解决的。</p></blockquote><p><br/></p><h3 id="17-5-问题复杂度"><a href="#17-5-问题复杂度" class="headerlink" title="17.5 问题复杂度"></a>17.5 问题复杂度</h3><p>既然我们已经证明, 至少有一个问题计算机无法解决，那么让我们在这个问题上再进一步深入。</p><p>在计算机科学领域，我们可以这么说，一般来说问题可以分为两类：<code>可解问题和不可解问题</code>,而可解问题又可以分为两种：<code>多项式问题</code>和<code>非多项式问题</code>。</p><h4 id="1-不可解问题"><a href="#1-不可解问题" class="headerlink" title="(1) 不可解问题"></a>(1) 不可解问题</h4><p>描述: 无法用计算机解决的问题有无穷无尽，停机问题是其中一个。</p><p>要证明一个问题是无法解决的，方法是证明如果它可以解决，那么停机问题也同样可以解决，换句话说，证明一个问题能否解决等同于证明停机问题能否解决。</p><p><br/></p><h4 id="2-可解问题"><a href="#2-可解问题" class="headerlink" title="(2) 可解问题"></a>(2) 可解问题</h4><p>描述: 能够被计算机解决的问题也是无穷无尽，平常我们关心的是：计算机需要花多长时间去解决一个问题。换言之，这个问题有多复杂？</p><p>问题的复杂度可以用不同的方法衡量，例如，运行时间、需要的内存等，其中一种衡量方法是运行时间，即运行一个程序需要花多长时间？</p><p>衡量可解问题复杂度的一个方法是找出计算机运行该程序时要执行的运算数量。</p><p>这样，复杂度问题不是依赖于运行程序的计算机速度，而是依赖于输入的数目。</p><p>例如，如果程序在处理一个列表(例如对列表中元素进行排序)，则复杂度依赖于该列表中元素的数目，通是使用大 O 表示法。</p><p><br/></p><p><strong>大 O 表示法</strong><br>通常我们会使用大O表示法来表示，算法代码片段的执行效率，在该表示法中，运行数量(或者一系列相关运算)，表示为输入量的函数。</p><p>例如, 符号 O(n) 表示有n个输入, 执行 n 次运算，符号 O(n^2) 表示有n个输入，执行n^2次运算。 </p><p><img src="https://img.weiyigeek.top/2023/1/20230130142504.png" alt="WeiyiGeek.大O表示法示例图"></p><p><br/></p><p><strong>多项式问题</strong><br>如果程序的复杂度为 0(logn)、O(n)、O(n^2) 或 O(n^k)(k为常数)，则被称为多项式问题。</p><p>以当今计算机的处理速度，对于一个有合理输入数量 的(如从1000到1000 000) 的多项式问题我们都能解决。</p><p><br/></p><p><strong>非多项式问题</strong><br>如果一个程序的复杂度远比多项式问题复杂, 例如 0(10^n) 或 O(n!)，当输入数很小(小于 100)时，这种问题可以解决。</p><p>如果输入数很大，则需要坐在计算机面前等上几个月的时间才能看到非多项式问题的解决结果。</p><p>但是，随着计算机处理速度的不断提高，我们也许能在更短的时间内解决非多项式问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;计算机科学导论学习笔记&quot;&gt;&lt;a href=&quot;#计算机科学导论学习笔记&quot; class=&quot;headerlink&quot; title=&quot;计算机科学导论学习笔记&quot;&gt;&lt;/a&gt;计算机科学导论学习笔记&lt;/h1&gt;&lt;h1 id=&quot;第-5-部分-数据安全与人工智能&quot;&gt;&lt;a href=&quot;#第-5-部分-数据安全与人工智能&quot; class=&quot;headerlink&quot; title=&quot;第 5 部分 数据安全与人工智能&quot;&gt;&lt;/a&gt;第 5 部分 数据安全与人工智能&lt;/h1&gt;&lt;p&gt;此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://mp.weixin.qq.com/s/rGfSNRqywE7cmKDFB3wEkQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/rGfSNRqywE7cmKDFB3wEkQ&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://blog.weiyigeek.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="计算机科学导论" scheme="https://blog.weiyigeek.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>16.计算机科学导论之网络信息安全学习笔记</title>
    <link href="https://blog.weiyigeek.top/2023/1-1-707.html"/>
    <id>https://blog.weiyigeek.top/2023/1-1-707.html</id>
    <published>2023-01-01T08:35:39.000Z</published>
    <updated>2023-02-13T08:02:43.873Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="计算机科学导论学习笔记"><a href="#计算机科学导论学习笔记" class="headerlink" title="计算机科学导论学习笔记"></a>计算机科学导论学习笔记</h1><h1 id="第-5-部分-数据安全与人工智能"><a href="#第-5-部分-数据安全与人工智能" class="headerlink" title="第 5 部分 数据安全与人工智能"></a>第 5 部分 数据安全与人工智能</h1><p>此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。</p><p>原文地址: <a href="https://mp.weixin.qq.com/s/CemNXNFZK_e0GzVuosfTDg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CemNXNFZK_e0GzVuosfTDg</a></p><a id="more"></a><h2 id="第16章-网络安全"><a href="#第16章-网络安全" class="headerlink" title="第16章 网络安全"></a>第16章 网络安全</h2><p>笔者作为一名资深的白帽子，来到了我熟悉喜欢的章节，对于网络安全我从高中开始接触，并自学到漏洞挖掘，记得挖的第一个漏洞是腾讯的存储型XSS，提交给了当时Wooyun平台，算是投名状吧，随后又浪迹在各众测平台、SRC，其中有学习的快乐，又有挖漏洞的煎熬，当然漏洞审核通过的那一瞬间，又感觉什么都值得了（money），支持者我不断的学习、不断的探索，直到遇到自身瓶颈时，对于我们非科班出生的网络安全人员，有必要进行基础知识的学习，为了走得更远遂，有了【大大神之路-起始篇 计算机科学导论】系列文章! </p><p>好，回归到本章正题《安全》，安全这个话题很宽泛并且包括数学中的某些特定领域，例如数论安全、网络信息(数据)安全、人身安全、材料安全，此处主要讲解的时是网络信息(数据)安全!</p><h3 id="16-1-安全三要素"><a href="#16-1-安全三要素" class="headerlink" title="16.1 安全三要素"></a>16.1 安全三要素</h3><p>你可能常常在新闻或者网警的公众号文章看到，某某黑客又攻击某某平台，并将个人信息数据进行售卖的违法行为，我们生活在信息时代需要保存生活中各方面的信息，其中我们的信息是一种有价值的资产，就像其他资产一样(存款)，我们要尽可能授权给可信机构，不要随意连接公共WIFI、不扫码来路不明的链接或者二维码，也不要贪小便宜将个人信息直接或者间接给他人使用。</p><p>个人信息作为一种资产，信息需要保护免受攻击。为了安全信息需要避开未授权的使用<code>（机密性）</code>，保护信息不受到未授权的篡改<code>（完整性）</code>，并且对于得到授权 的实体来说是需要时可用的<code>（可用性）</code>。</p><p>此节中，我们先讨论信息安全的三个主要目标（也称<code>安全三要素</code>），其次将探索攻击是如何威胁这三个目标的，然后我们将讨论和这些安全目标有关的安全服务，最后我们将定义两个实现安全目标并且防止攻击的技术。</p><p>作为网络安全中最基本的三个目标<code>机密性、完整性和可用性</code>，下面我们一一进行介绍。</p><h4 id="0-安全性"><a href="#0-安全性" class="headerlink" title="(0) 安全性"></a>(0) 安全性</h4><blockquote><p>通过加密、认证和访问控制等措施，确保个人信息安全，保护用户隐私数据保护。<br>例如, 银行卡设置的取款密码，APP关键操作中的人脸识别。</p></blockquote><h4 id="1-机密性"><a href="#1-机密性" class="headerlink" title="(1) 机密性"></a>(1) 机密性</h4><blockquote><p>信息安全的第一个部分是机密性(最通常的方面) , 使用数据加密技术，对个人信息进行保密，防止恶意用户拒绝、披露或窃取用户信息。<br>例如，当我们将一小段信息发送并存储至远程计算机或从远程计算机上检索一段信息时，需要在传输时对该信息进行隐藏。</p></blockquote><h4 id="2-完整性"><a href="#2-完整性" class="headerlink" title="(2) 完整性"></a>(2) 完整性</h4><blockquote><p>信息安全的第二个部分是完整性,使用完整性检查机制，确保个人信息的有效性和准确性，确保用户的安全性。<br>例如，当一个客户在银行存钱或取钱时, 他的账户余额需要根据存入或者取出操作进行变化, 原子性操作（要么成功，要么失败）。</p></blockquote><h4 id="3-可用性"><a href="#3-可用性" class="headerlink" title="(3) 可用性"></a>(3) 可用性</h4><p>信息安全的第三个部分是可用性，保证个人信息的可用性，以便随时及时访问并使用个人信息，以便更好地提升个人信息的安全性。<br>例如，当客户交易时不能访问他们的账户，这时银行会发生什么。</p><p><br/></p><h3 id="16-2-攻击目标"><a href="#16-2-攻击目标" class="headerlink" title="16.2 攻击目标"></a>16.2 攻击目标</h3><p>安全三要素（<code>机密性、完整性和可用性</code>）会受到安全攻击的威胁, 虽然文献中可能采用不同的方法来对攻击进行分类，但我们在这里将它们按照安全目标分为三类。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20230113093321.png" alt="WeiyiGeek.与安全模板有关的攻击分类图" title="" class="">                <p>WeiyiGeek.与安全模板有关的攻击分类图</p>            </figure><h4 id="1-威胁机密性的攻击"><a href="#1-威胁机密性的攻击" class="headerlink" title="(1) 威胁机密性的攻击"></a>(1) 威胁机密性的攻击</h4><p>通常有两种攻击威胁到信息的机密性<code>嗅探和流量分析</code>。</p><ol><li><p>嗅探 : 嗅探是指对数据的非授权访问或侦听, 一个通过因特网传输的文件可能含有机密的信息，一个非授权的实体可能侦听到传输, 为了防止嗅探，可以使用我们下面要讨论的加密技术，以使得数据对侦听者来说难以理解。</p><blockquote><p>例如，在后渗透测试中通常会在内网嗅探<code>其他服务器主机或者个人电脑</code>间传输的非加密信息，如嗅探ftp服务的账号密码，当前解决办法是使用sftp进行加密传输。</p></blockquote></li><li><p>流量分析：虽然通过加密技术我们可以使得数据对侦听者来说难以理解，但他们仍然可以通过在线流量监控收集其他类型的信息。</p><blockquote><p>例如，他们能找到发送者或接收者的电子地址（如电子邮件地址)，收集多对请求和响应，帮助猜测交易的本质。</p></blockquote></li></ol><p><br/></p><h4 id="2-威胁完整性的攻击"><a href="#2-威胁完整性的攻击" class="headerlink" title="(2) 威胁完整性的攻击"></a>(2) 威胁完整性的攻击</h4><p>数据的完整性会受到多种攻击的威胁：篡改、假冒、重放和抵赖。</p><ol><li><p>篡改: 侦听或访问信息后，攻击者篡改信息，使得信息有利于他们，通常在中间人攻击中常常用到。</p><blockquote><p>例如，一个客户可能向银行发送一消息去完成一些交易。攻击者侦听到信息，并为了自己的利益篡改了交易的类型。注意，有时攻击者可能仅仅是删除或延迟了这个消息来危害这个系统或者使他们自己受益。</p></blockquote></li><li><p>假冒: 当攻击者冒充其他人时，假冒或“哄骗”就发生了, 通常在社会工程学中常常用到。</p><blockquote><p>例如，一个攻击者可能盗窃银行卡和银行客户的PIN而假装是这个客户,有时攻击者则假冒接收实体。比如，一个用户尝试联系一家银行，但是另一个站点伪装成银行网站并从用户那里得到了一些信息。</p></blockquote></li><li><p>重放：重放是另一种类型的攻击, 攻击者得到用户发送的消息的副本，过后设法重放它, 通常在burpsuite中重放关键性的提交。</p><blockquote><p>例如，一个客户向他的银行发送了一条给攻击者付款的请求，攻击者侦听到这个消息，再次发送这条消息，想从银行得到另一次付款。</p></blockquote></li><li><p>抵赖: 抵赖是一种不同于其他类型的攻击，因为它是由通信双方中的一个来进行的发送者或接收者, 消息的发送者后来可能抵赖他发送了消息；消息的接收者后来也可能抵赖他接收到消息。</p><blockquote><p>例如，发送者抵赖，一个银行客户要求银行给第三方送钱，但后来他否认自己做过这样的请求; 接收者抵赖，某人向一制造商购买产品，并电子付款，但制造商后来否认已经收到付款而要求再付。</p></blockquote></li></ol><p><br/></p><h4 id="3-威胁可用性的攻击"><a href="#3-威胁可用性的攻击" class="headerlink" title="(3) 威胁可用性的攻击"></a>(3) 威胁可用性的攻击</h4><p>此只讨论一种威胁可用性的攻击<code>拒绝服务</code>。</p><p>拒绝服务(DoS)攻击是很常见的网络攻击手段，其目的是瘫痪网络服务或使其变得不可用，其原理是通过发送大量伪造的请求或数据包来淹没网络带宽或计算机资源，使其失去可用性。拒绝服务攻击通常可以通过利用系统漏洞来实施，或者利用病毒和僵尸计算机来发送大量的伪造请求或数据包。</p><p>当前拒绝服务攻击多为(分布式拒绝服务)DDOS攻击，攻击可能来自一台计算机或由许多计算机代理发起，通常是使用僵尸网络(物联网IOT大量被恶意者控制)，同时发送垃圾信息并阻断特定的网络服务，庞大的网络洪水，以使服务器变得不可用。</p><p><strong>如何避免或防御网络攻击?</strong><br>我们知道企业的网络安全都是木桶效应，内部安全情况取决于木桶中最短的木板，你在其他系统安全做得好，也免不了被攻击，所以在企业中需要从制定安全操作流程，以及按照不同的员工分配不同的权限。</p><ul><li>系统管理员 ：应定期检查他们的网络设备以确保它们具有最新的安全补丁; 此外，应确保安装并配置可以检测恶意活动的垃圾邮件过滤器，防火墙和入侵检测系统，以及软件来屏蔽易受攻击的端口号，同时还应加强账户管理，避免使用默认设置，以及定期检查日志来检测可疑活动。</li><li>开发工程师 ：应在系统安全测试以及内部安全测试反馈有安全问题需及时更改代码，此处在编写引用代码时最好做检查，建立内部漏洞Bug文档，防止其他系统开发时其他同事也遇到此漏洞Bug问题，此外在重点传输信息的系统，采用非对称密钥进行验证。</li><li>普通员工 : 定期进行安全培训，查看网络安全宣传短片，提高大家的安全意思，因为人才是企业中保证网络安全的基础，一旦人员被社会工程学中招后，往往可以直插企业内部某些系统，例如，邮件钓鱼、木马投放等。</li></ul><hr><h3 id="16-3-信息加密技术"><a href="#16-3-信息加密技术" class="headerlink" title="16.3 信息加密技术"></a>16.3 信息加密技术</h3><p>为了达到安全目标和防止安全攻击，ITU-T定义了一些安全服务的标准。这些服务中的每一个都是为了在维护安全目标时防止一个或多个攻击而设计的。</p><p>实际完成安全目标需要一些技术手段，现今流行两种技术：一种是非常普通的<code>密码术</code>,另外一种是特殊的<code>隐写术</code>。</p><p><br/></p><ol><li><p>密码术<br>有些安全服务可以使用密码术来(希腊起源的单词)意思是“秘密书写”实现。 但是，我们使用这个词是指为使消息安全并对攻击免疫而进行转换的科学和艺术。虽然在过去密码术只是指使用密钥进行消息的加密和解密，但如今它被定义成三种不同的机制：<code>对称密钥密码、非对称密钥密码和散列</code>。</p></li><li><p>隐写术<br>虽然本章和接下来的部分以密码术作为实现安全机制的一种技术，但另一种过去用于秘密通信的技术现在正在复苏，它就是隐写术。单词隐写术(起源于希腊语)意思是“掩饰书写”，而对应的密码术的意思是“秘密书写”。</p></li></ol><p>密码术就是通过加密把消息中的内容隐藏起来，而隐写术是通过在消息上覆盖其他内容而隐藏消息，例如，我们安全圈中常见的图片写隐术。</p><p><br/></p><p>现在我们来看第一个安全目标机密性，他可以通过使用密码达到，密码术可以分成两大类：<code>对称密钥密码术和非对称密钥密码术</code>。</p><h4 id="1-对称密钥密码术"><a href="#1-对称密钥密码术" class="headerlink" title="(1) 对称密钥密码术"></a>(1) 对称密钥密码术</h4><p>描述: 对称密钥密码术使用了同一个密钥（<code>这就是为什么它被称为对称的</code>）进行加密和解密，并且这个密钥可以用来进行双向通信，对称密钥密码术(<code>也称为保密密钥密码术</code>)。</p><p>下图，显示了对称密钥密码术的基本思想:</p><blockquote><p>例如 Alice通过一个不安全的通道向Bob发送一则消息，假设一个敌手Eve在通道上简单地偷听，通过加密算法她不能理解消息的内容。<br>从 Alice 到 Bob 的原始消息称为明文，而通过通道发送的消息称为密文，为了从明文创建密文，Alice使用了一个加密算法和一个共享的密钥。<br>然后为了从密文创建明文，Bob使用了一个解密算法和一个相同的密钥，从而将加密数据解密成明文。</p></blockquote><p><img src="https://img.weiyigeek.top/2022/10/20230113161115.png" alt="WeiyiGeek.对称密钥密码基本思想图"></p><p>注意，对称密钥加密对加密和解密使用一个密钥(密钥本身可以是一串数值)。此外， 加密算法和解密算法是互逆的。如果P为明文，C是密文，K是密钥，<code>加密算法Ek(x)从明文建立了密文，而解密算法Dk(x)从密文建立了明文</code>。</p><p>我们推断Ek(x)和Dk(x)是互逆的, 如果对一个输入依次施加<code>Ek(x)和Dk(x)</code>, 它们的作用会相互抵消, 在此处 <code>Dk(Ek(x)) = Ek(Dk(x)) = x</code>。</p><blockquote><p>加密：C=Ek(P)<br>解密：P=Dk(C)</p></blockquote><p>值得注意的是，最好可以将加密和解密算法公开但是把共享密钥保密，此时Alice和Bob需要另外一个(安全的)通道来交换密钥，后面我们会讲解到非对称加密。</p><p>简单的说明，我们可以把加密看作把消息锁进箱子，而解密可以看成打开箱子，在对称密钥加密中，用相同的密钥来锁和打开“箱子”，在下一节中我们会看到非对称密钥加密需要两个密钥，一个用于上锁而另一个则用于开锁。</p><p>当前，我们可以把对称密钥密码分成两大类，即<code>传统对称密钥密码和现代对称密钥密码</code>。</p><ul><li>传统密码, 实现很简单，面向字符的密码对现在的标准而言是不安全的。</li><li>现代密码, 是更为安全的复杂的面向位的密码。</li></ul><hr><p><br/></p><p><strong>1.传统对称密钥密码</strong><br>它是过去时了，但由于它是现代密码的构成要素，所以我们在这里对其进行简要讨论，通常我们把传统密码分为替换密码和移位密码。</p><p><strong>1) 替换密码</strong>：用一个符号替换另一个符号, 如果在明文中的符号是字母表的字符，我们用另一个字符来代替，而替换密码主要可以分成<code>单字母密码</code>和<code>多字母密码</code>。</p><blockquote><p>例如，我们能用字母D代替字母A, 用字母Z代替字母T, 如果符号是数字（0〜9 ）, 我们能用7代替3, 用6代替2。</p></blockquote><ul><li>1.1 单字面密码：此密码模式中，明文中相同的字符（或符号）在密文中用相同的字符（或符号）替换，与该字符在明文中的位置无关，明文和密文中的字符关系是一一对应的（你可以理解为电报机，两边都有密码本）, 最简单的单字母密码就是加法密码（或者移位密码）。<blockquote><p>例如，在密码学中恺撒密码, 尤利乌斯 • 凯撒（Julius Caesar）与他的军官是使用密钥为3的加法密码进行通信的，加密算法可以解释成“向下移位key个字符”，而解密算法可以解释成“向上移位key个字符”，<code>即当偏移量是 3 的时候，所有的字母 A 将被替换成D, B 变成 E。</code>, 因此加法密码有时也称为凯撤密码。</p></blockquote></li></ul><p>下面，我将使用C语言进行凯撤密码代码演示（编程语言学得太多，做的笔记也是各种语言的编程示例）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ch;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"请输入明文："</span>);</span><br><span class="line">  <span class="keyword">while</span> ((ch = getchar()) != <span class="string">'\n'</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>)&#123;</span><br><span class="line">          <span class="built_in">putchar</span>(<span class="string">'a'</span> + (ch - <span class="string">'a'</span> + <span class="number">3</span>) % <span class="number">26</span>);   <span class="comment">//这个是灵魂,利用取余来达到字母偏移，97 = a</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">          <span class="built_in">putchar</span>(<span class="string">'A'</span> + (ch - <span class="string">'A'</span> + <span class="number">3</span>) % <span class="number">26</span>);  <span class="comment">// 65 = A</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">putchar</span>(ch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="image-box">                <img src="https://img.weiyigeek.top/2019/1/20191011211531.png" alt="WeiyiGeek.C语言实现的恺撒密码" title="" class="">                <p>WeiyiGeek.C语言实现的恺撒密码</p>            </figure></p><p><br/></p><ul><li>1.2 多字母密码: 在多字母密码中，字符的每一次出现都使用不同的替换码, 明文中字符和密文中字符的关系是一对多。<blockquote><p>例如 <code>“a”</code> 既可以在文本开头加密成 <code>“D”</code> ，也可以在中间加密成 <code>“N”</code>多字母密码具有可以隐藏原有语言的字母频率的作用，即使通过单字母频率统计都无法破解密文。<br>为了更好地解释密钥的位置依赖性，我们先讨论一个叫做自动密钥密码的简单多字母密码, 在此密码中，密钥是一个子密流，在这个子密钥流中的每一个子密钥都用来对明文文本中的对应字符进行加密。<br>第一个子密是 Alice 和 Bob 事先同意并密设定的值，<br>第二个子密钥是明文中第一个字符的值(在0~25之间),<br>第三个是第二个明文字符的值以此类推。</p></blockquote></li></ul><p><img src="https://img.weiyigeek.top/2022/10/20230113164948.png" alt="WeiyiGeek.多字母密码图"></p><p><br/></p><p><strong>2) 移位密码</strong><br>移位密码不是用一个符号代替另一个符号，而是改变符号的位置, 明文第一个位置上的符号可能出现在密文的第十个位置上，而明文第八个位置上的符号可能出现在密文的第一个位置上, 简单的说，移位密码就是符号的重新排序。</p><p>假设，Alice 需要向Bob发送消息<code>&quot;Enemy attacks tonight&quot;</code>，其加密解密过程如下图所示，注意我们在消息的末尾加上一个额外的字符(z)这样字符个数就是5的倍数。</p><ul><li>首先，第一张表是Alice通过一行一行写明文创造的，每一列都利用同一个密钥进行变更。</li><li>然后，密文通过一列一列读第二张表得到。</li><li>最后, Bob将这三步操作反向进行来进行解密, 他将密文一列一列写入第一张表格中对每列进行变更，然后一行一行读第二张表</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20230113165757.png" alt="WeiyiGeek.移位密码图" title="" class="">                <p>WeiyiGeek.移位密码图</p>            </figure><p>注意，这里用来进行加密和解密的密钥是相同的，但是算法使用密钥的顺序是互逆的。</p><p><br></p><p><strong>3) 流密码&amp;分组密码</strong></p><p>文献中将对称密码分为两大组：流密码和分组密码。</p><ul><li><p>流密码: 加密和解密都是一次只对一个符号（例如一个字符或位）进行，假如，我们有一个明文流 P ，一个密文流 C 和一个密钥流 K。</p><blockquote><p>C1 = Ek1(P1) / C2 = Ek2(P2)</p></blockquote></li><li><p>分组密码: 在分组密码中，一组大小为m (m&gt;1 )的明文符号被加密在一起，创造一组同样大小的密文。</p><blockquote><p>基于定义，在一个分组密码中，整个分组是由一个单独的密钥进行加密，即使这个密钥由多个值构成。<br>在分组密码中，密文的分组取决于整个明文分组。</p></blockquote></li><li><p>组合密码: 在实际操作中，每个明文分组是分别加密的，但是同时密钥流被用来对整个消息按照分组依次加密。</p><blockquote><p>即: 当我们看每一个单独分组时，该密码是分组密码，但是从整个消息来看，这是一个以分组为单位进行加密的流密码。<br>每个分组都使用一个不同的密钥进行加密，这些密钥是在加密进行之前或进行过程中产生的。</p></blockquote></li></ul><p><br/></p><p><strong>2.现代对称密钥密码</strong><br>由于计算机技术发展进步，需要加密的信息已经不限于文本字符串、而有可能是数字、图表、音频或者视频数据。<br>在此种情况下，更方便的方法是把这些类型的数据转换成为比特流后再对其流进行加密，然后发送加密后的流，并且在进行处理时，每个字符会替换为8(或者16)位，这意味着字符数也变成原来的8(或者16)倍大, 将更多的字符混合可以提高安全性。</p><ul><li><p>2.1) 现代分组密码: 对称密钥现代分组密码对大小为 n 位的明文分组进行加密或对同样大小的密文分组进行解密。加密或解密算法使用《位的密钥,解密算法必须是加密算法的逆运算，并且两个操作必须使用相同的密钥，此样 Bob 可以检索到 Alice 发送的消息。</p><blockquote><p>当消息的长度小于n位时，消息后会加上补丁以使消息长度达到一个n位的分组; 如果消息长度超过n位，消息就会被分成几个长度为n 位的分组，如果必要，那么相应的补丁会添加到最后一个分组上, n 的常用数值是 64、128、256 和 512 位。</p></blockquote></li><li><p>2.2) 现代流密码: 除了现代分组密码以外，我们也可以使用现代流密码，其区别类似于我们在之前部分提到的传统的流密码和分组密码之间的差别。</p><blockquote><p>在现代流密码中，加密和解密都是每次对r位进行，我们有一个表示为 P=pn…p2p1的明文流，一个表为C=cn…c2c1的密文流和一个表示为 K=kk 的密钥流在这里p都是长度为r位的词，加密算法是 C=E(k，p) 解密则表现为Pi=(k，c)。<br>所以说流密码比分组密码更快，它的硬件实现也更简单一些，当我们需要对二进制流加密并将加密后的流匀速传输时，流密码是一个更好的选择，其对于传输中发生的损坏也有更好的免疫能力。</p></blockquote></li></ul><p>扩展说明: 最简单也最安全的同步流密码是<code>吉尔伯特·弗纳姆</code>发明并取得专利的一次一密乱码， 一次一密乱码每次加密时使用随机选择的密钥流，加密和解密都使用单一的异或操作，基于异或操作的性质，加密和解密的算法互为逆运算。</p><p><img src="https://img.weiyigeek.top/2022/10/20230116104049.png" alt="WeiyiGeek.现代分组、流密码示例图"></p><p><br></p><h4 id="2-非对称密钥密码术"><a href="#2-非对称密钥密码术" class="headerlink" title="(2) 非对称密钥密码术"></a>(2) 非对称密钥密码术</h4><p>描述: 对称与非对称加密实际上是相互相成，即可以取长补短，又可以相互补充，两者之间的差异:</p><ul><li>对称密钥在双方之间是共享的，而非对称密钥是个人独有(非共享的)。</li><li>对称密钥对字符进行排列或替换，非对称密钥密码对数字进行操作。</li><li>对称密钥对较长的信息加密，而非对称密钥针对少量信息加密（身份验证、数字签名）。</li></ul><p><strong>简单介绍</strong><br>描述: 非对称加密是一种加密方式，它使用一对被称为“公钥”和“私钥”的不同密钥。 公钥用于加密消息，而私钥用于解密消息。<br>此外，一个密钥可以用于加密消息，但却不能用于解密它。 因此只有拥有正确的秘钥（公钥或私钥）才能够解密它。</p><p>简单的说，非对称密钥加密使用两个独立的密钥，即<code>公钥</code>与<code>私钥</code>, 你可将其理解为公钥是进行加密信息的并且是公开的(加锁🔒)，而私钥是解密信息并且是需要保密的(解锁)。</p><p><strong>主要思想</strong><br>描述: 下图中展示了非对称密钥进行加密时的思想，<br>其关键点如下所示:</p><ul><li><p>明文/密文: 与对称密钥密码术不同，在非对称密钥密码术中，明文和密文被当作整数来对待, 在加密之前，消息必须被编码成一个整数（或一组整数），在解密之后整数（或一组整数）必须译码成消息, 非对称密钥密码术通常被用来加密或解密小段信息，例如对称密钥密码术中的密码密钥。</p><blockquote><p>换句话说，非对称性密钥密码术通常起到辅助目标而不是加密消息的作用，即非对称密钥密码术通常用来加密或解密小段信息。</p></blockquote></li><li><p>加密/解密: 在非对称密钥中的加密/解密是作用在表示明文和密文的数字上的数学函数，例如，密文可以被看做C=f(Kpublic*p)，而明文可以看成P=g(Kprivate*c), 其中解密函数f只能用来加密，而解密函数g只能用来解密。</p></li></ul><p><img src="https://img.weiyigeek.top/2022/10/20230116144030.png" alt="WeiyiGeek.非对称加密原理思想图"></p><p><br/></p><p><strong>RSA 非对称密码算法</strong><br>描述：虽然有几种非对称密钥系统，但是最常见的公钥算法之一是 RSA 密钥系统（以发明者 Ron Rivest、Shamir 和 Adleman 命名）。</p><p>RSA 使用两个指数 e 和 d，其中 e 是公钥，d 是私钥。</p><blockquote><p>假设P表示明文、C表示密文，那么Alice使用<code>C = P^e mod n</code>的算法从明文P中得到密文 C ，Bob 通过 <code>P = C^d mod n</code> 来检索 Alice 发送的明文，在密钥生成的过程中创造了一个很大的数作为模数n。</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20230116153045.png" alt="WeiyiGeek.RSA生成密钥图" title="" class="">                <p>WeiyiGeek.RSA生成密钥图</p>            </figure><ul><li>范例1.</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20230116162450.png" alt="WeiyiGeek.RSA范例1图" title="" class="">                <p>WeiyiGeek.RSA范例1图</p>            </figure><ul><li>范例2.</li><li><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20230116162729.png" alt="WeiyiGeek.RSA范例2图" title="" class="">                <p>WeiyiGeek.RSA范例2图</p>            </figure></li></ul><p><br/></p><p><strong>RSA 的应用场景</strong><br>描述: 虽然RSA可以用于对实际消息进行加密和解密，但如果消息很长加密的速度会很慢。因此，RSA加密适用于短消息，以及特定用于数字签名以及其他不需要使用对称密钥来对较短信息进行加密的密码，同时RSA也适用于身份验证。</p><p>实践示例.在Linux中生成一个rsa格式的公密钥文件并在主机间进行ssh登录认证。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.生成ras格式的公密钥</span></span><br><span class="line">$ /usr/bin/ssh-keygen -t rsa -P </span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):    <span class="comment"># 生成路径</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):  <span class="comment"># 密钥加密密码</span></span><br><span class="line">Enter same passphrase again:                 <span class="comment"># 密钥加密密码</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.    <span class="comment"># 私钥</span></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.    <span class="comment"># 公钥</span></span><br><span class="line">The key fingerprint is:</span><br><span class="line">30:f6:d7:2a:ac:56:eb:3f:fa:40:25:8d:90:96:68:cb root@localhost.localdomain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看生成的共密钥文件</span></span><br><span class="line">$ ls ~/.ssh/</span><br><span class="line">id_rsa  id_rsa.pub known_hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.配置A机器使用密钥登录到B机器，此时需要将公钥传到B机器的 authorized_keys 中。</span></span><br><span class="line">$ sftp weiyigeek@10.10.10.250 -P 22</span><br><span class="line">&gt; put /root/.ssh/id_rsa.pub</span><br><span class="line">&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">$ touch /root/.ssh/authorized_keys</span><br><span class="line">$ cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br><span class="line"><span class="comment"># 或者执行如下命令</span></span><br><span class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub weiyigeek@10.10.10.250 -p 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.然后就可以在A机器上使用密钥进行登录到B机器中</span></span><br><span class="line">$ ssh -i /root/.ssh/id_rsa weiyigeek@10.10.10.250 -p 22</span><br></pre></td></tr></table></figure></p><p><br/></p><h3 id="16-4-其他安全技术"><a href="#16-4-其他安全技术" class="headerlink" title="16.4 其他安全技术"></a>16.4 其他安全技术</h3><p>到目前为止我们研究的密码系统提供了机密性，但在现代通信中还需要考虑安全的其他方面，比如完整性、消息和实体验证、不可抵赖性和密钥管理。</p><h4 id="1-消息完整性"><a href="#1-消息完整性" class="headerlink" title="(1) 消息完整性"></a>(1) 消息完整性</h4><p>为了防止消息被篡改，我们在发送端/接收端进行验证信息完整性，通常使用如下方法一是消息和消息摘要，二是散列函数。</p><p><strong>消息和消息摘要</strong></p><blockquote><p>保证文档完整性的一种方法是通过使用指纹，来确保文档没被篡改过。例如，为了保证消息完整性，消息要通过一个称为密码散列函数的算法，生成文件的消息和摘要，接收方验证比对该文件的信息消息和摘要，如果相同则确保信息未被串改过。</p></blockquote><p><br/></p><p><strong>散列函数</strong></p><blockquote><p>将任意长度的消息加密成为固定长度的消息摘要, 所有的散列函数加密都需要从长度不一的消息中创造出长度固定的消息摘要, 建造这样一个功能最好由迭代完成，创造一个有着固定输入值并且可以使用必需的次数的函数，而不是使用输入值大小可变的散列函数。<br>这里的固定输人值函数指的是压缩函数，它将 n 位的一串字符缩并创造成 m 位的字符串，这里的 n 通常大于 m, 该方案被称为选代加密散列函数。</p></blockquote><p>罗恩·李维斯设计的几个列算法被称为<code>MD2、MD4和MD5</code>消息摘要, 当前最新的版本 MD5 是 MD4 的个加强版，它可以将消息分成长度为 512 位的分组并创造大小为 128 位的摘要, 然而事实证明大小为 128 位的消息要太小了以至于不能阻挡攻击（容易被碰撞检测）。</p><p>因此，为了解决 MD 散列算法的不安全性，安全散列算法诞生了，安全散列算法(SHA)是由国家标准与技术研究所(NIST)研制的一个标准。SHA 经过了几个版本, 从 sha1、sha224、sha256、sha384、sha512（当前最新）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># md5 摘要信息</span></span><br><span class="line">$ md5sum weiyigeek.png</span><br><span class="line">51644c3d7174702529c5706ddf8db020 weiyigeek.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># sha1sum 摘要信息</span></span><br><span class="line">$ sha1sum weiyigeek.png</span><br><span class="line">92ade000aed6c07b501a4c03374c0412bd33c716  weiyigeek.png</span><br><span class="line"></span><br><span class="line"><span class="comment"># sha256sum 摘要信息</span></span><br><span class="line">$ sha256sum weiyigeek.png</span><br><span class="line">07a041820e1dff2c48901828b2629275a301480adf804f55e63849849227ffb0  weiyigeek.png</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20230116172552.png" alt="WeiyiGeek.摘要信息与散列算法图" title="" class="">                <p>WeiyiGeek.摘要信息与散列算法图</p>            </figure><p><br/></p><h4 id="2-消息验证"><a href="#2-消息验证" class="headerlink" title="(2) 消息验证"></a>(2) 消息验证</h4><p>通过前面学习我们知道，消息摘要可以检验消息的完整性，保证消息没被篡改, 然而为了确保消息的完整性以及数据源的身份验证——这消息是真的来自于Alice而不是任何其他的人，我们需要在过程中包括一个Alice和Bob共享的秘密<code>（没有经过Eve）</code>, 我们需要创造一个消息验证码<code>（message authentication code, MAC）</code>。</p><p>即MAC通过散列函数和密钥的组合来保证消息的完整性和消息验证。</p><p><strong>消息验证流程:</strong></p><ul><li>1.Alice使用散列函数从密钥和消息连接中创建了一个MAC,即h(K+M）。</li><li>2.它在不安全的通道上把消息和MAC发送给Bob。</li><li>3.Bob把消息与MAC分开,然后从消息和密钥的连接中建立新的MAC。</li><li>4.Bob比较新建的MAC和收到的MAC, 如果两个MAC匹配，那么消息就得到验证，并没有被敌手篡改过。</li></ul><p>温馨提示: HMAC国家标准与技术研究所(NIST)发布了新一代MAC标准, 通常称为<code>HMAC (散列消息 验证码)</code>, HMAC的实施比简化的MAC更复杂,因此此处不再多做累述。</p><p><img src="https://img.weiyigeek.top/2022/10/20230116175204.png" alt="WeiyiGeek.消息验证码图"></p><p><br></p><h4 id="3-数字签名"><a href="#3-数字签名" class="headerlink" title="(3) 数字签名"></a>(3) 数字签名</h4><p>为了保证消息完整性和消息验证我们还可以使用的另一种方法是<code>数字签名</code>，数字签名使用一组公私钥。</p><p>为了方便大家理解，此处在讲解数字签名前，对签名概念进行描述，当一个人在文档上签名就表示该文档是起源于他或他已同意的，签名对接收者来说是文档来自正确实体的证据。</p><blockquote><p>例如，当客户签了一张支票，银行就需要确信支票是客户签署的，而不是其他人。换言之，文档上的签名是身份验证的标记，它验证通过，文档就可信, 此处签名概念也可以看做是艺术家在画上的签名，艺术上的签名如果得到验证通过，那么这幅画通常也是可验证通过的。</p></blockquote><p><br/></p><p><strong>究竟什么是数字签名?</strong></p><blockquote><p>数字签名是一种在数字环境中实现签名的方法（数字编码），其包含有用户的身份信息以及消息的原始数据，它可以确保发送方的身份，确认消息的完整性和原始性，以及消息的传输的安全性。 </p></blockquote><p><strong>数字签名的功能?</strong></p><blockquote><p>数字签名的功能主要有，保证发送者的身份、确认消息的完整性、确认消息抵达的可靠性、确认消息的原始性和保证消息的传输安全性。<br>简单的说就是, 验证所发送消息的真实性、完整性和可靠性。</p></blockquote><p><strong>那消息验证与数字签名的区别是什么?</strong></p><blockquote><p>MAC通过密钥来保护消息摘要，数字签名则使用一组公私钥.</p></blockquote><p><br/></p><p>当Alice向Bob发送消息时，Bob需要检査发送者的身份，他需要确信消息来自Alice 而不是Eve(其他人), Bob可以要求Alice对信息进行电子签名。 </p><p>换言之，一个电子签名能证明 Alice 作为消息发送者的身份, 我们把这种签名称为数字签名。</p><p><strong>1.对比</strong></p><ul><li><p>(1)包括<br>普通签名是包含在文档里的，是文档的一部分。当我们写支票时，签名就在支票上，而不是一个分开的文档。但是当对文档进行数字签名时，我们把签名作为一个单独的文档来发送。</p></li><li><p>(2) 验证手段<br>两种签名的第二点不同在于签名验证的方法不同。对于普通签名，当接收者接收到一个文档时，他们比较文档上的签名与文件中的签名，如果相同，文档就是可信的。接收者需要有一个文件上签名的副本来作比较。对于数字签名，接收者接收到消息和签名，签名的副本不再保存，接收者需要应用验证技术来组合消息和签名，从而验证发送者的身份。</p></li><li><p>(3) 关系<br>对于普通签名来说，签名和文档之间通常是一对多的关系，一个人使用相同的签名签署许多文档。但是对于数字签名来说，签名和消息之间是一对一的关系。每条消息有它自己的签名。一条消息的数字签名不能用在另一条消息上。如果Bob从Alice处接收到两条消息，一条接着一条，他不能用第一条消息的签名去验证第二条。每条消息都有新的签名。</p></li><li><p>(4) 复制性<br>两种签名的另一点不同是称为复制性的特质。普通签名允许签署文档的副本与文件中的原始件有点不同。对于数字签名，就没有这样的不同，除非在文档上有时间因子(如时间 戳)。例如，假设Alice发送文档，指示Bob给Eve付款，如果Eve截获到文档和签名，她可以随后重复这些文档和签名，再次从Bob处得到钱。</p></li></ul><p><br/></p><p><strong>2.过程</strong><br>下图中显示了签名过程，发送者使用签名算法去签署消息，消息和签名被发送给接收者。接收者收到消息和签名，对收到的内容应用验证算法，如果结果是真，消息被接受，否则消息被拒绝。</p><p>数字签名需要公钥系统，密码系统使用接收者的私钥和公钥，数字签名使用发送者的私钥和公钥，签署者用私钥签署，验证者用签署者的公钥验证。</p><p><img src="https://img.weiyigeek.top/2023/1/20230117160220.png" alt="WeiyiGeek.数字签名图"></p><p>我们能否用一个密钥（对称的）来签署和验证签名？</p><blockquote><p>答案是否定的，有以下几个原因。首先，密钥是只有双方知道的（这个例子中是Alice和Bob）因此如果 Alice 需要签署另一份文档，并发送给Ted, 那她就需要使用另外的密钥。<br>其次，我们将看到，为一个对话创建密钥涉及验证，而验证要使用数字签名, 因此，我们就遇到一个错误的循环。再次，Bob可以使用他和Alice间的密钥签署一个文档，把它发送给Tde,假装这是来自于Alice的。</p></blockquote><p><br/></p><p><strong>3.签署摘要</strong><br>在处理较长消息时，非对称密钥密码系统的效率低下，而在数字签名系统中，消息通常较长，但我们不得不使用非对称密钥模式, 解决方法是签署消息的摘要，该摘要比消息本身要短得多。</p><p>消息摘要与消息具有一对一的关系, 发送者可以签署消息摘要，接收者可以验证消息摘要，两者的效果是相同的。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230117161422.png" alt="WeiyiGeek.签署摘要图" title="" class="">                <p>WeiyiGeek.签署摘要图</p>            </figure><p><br></p><p><strong>4.服务</strong><br>此小节讨论几个安全服务，包括消息机密性、消息验证、消息完整性和不可抵赖性。</p><p>(1) 消息验证 ：一个安全的数字签名模式就像一个安全的普通签名(也就是说一个人不容易复制)一样 能提供消息验证，也称为数据源验证。Bob能验证Alice发送过来的信息是因为在验证过程中使用了Alice的公钥。Alice的公钥不能验证用Eve私钥签署的签名。</p><p>(2) 消息完整性 ：如果我们签署消息或消息的摘要，消息的完整性就能被保护，因为如果消息改变了，我们就不能得到相同的摘要。当今的数字签名模式在签署和验证算法中使用了散列函数，这样更好地保护了消息的完整性。</p><p>(3) 不可抵赖性 ：如果Alice签署了一个消息，然后否认它，Bob能否证明Alice实际上是签署了它呢？例如，如果Alice向银行(Bob)发送消息，要求从她的账户转10 000美元到Ted的账户，Alice能否事后否认她发送过这样的消息？使用我们目前为止介绍的模式，Bob可能会有一个问题。Bob必须先保存签名，然后用Alice的公钥去建立原始消息，去证明文件中的信息和新创建的消息是相同的。但这样并不可行，因为Alice这时可能已经更换了私钥或公钥。她也可以声称含有签名的文件是不可信的。</p><p><strong>如何解决不可抵赖性问题?</strong></p><blockquote><p>解决方案是: 可信的第三方, 人们可以在他们之间建立可信中心, 在本章的后面，我们将看到受到信任的第三方可以解决有关安全服务和密钥交换的很多问题。<br>例如: 展示了一个可靠的第三方如何防止Alice抵赖她发过的消息，此时是不是感觉下述流程与网站CA以及服务端、客户端证书的颁发使用原理是一致的</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230118105104.png" alt="WeiyiGeek.使用可信的第三方来达到不可抵赖性图" title="" class="">                <p>WeiyiGeek.使用可信的第三方来达到不可抵赖性图</p>            </figure><p>(4) 机密性<br>数字签名不提供机密通信，如果机密性是需要的，那么消息和签名就要使用对称密钥密码或非对称密钥密码进行加密。</p><p><br></p><h4 id="4-实体验证"><a href="#4-实体验证" class="headerlink" title="(4) 实体验证"></a>(4) 实体验证</h4><p>主要用来使得一方证明另一方标识的一种技术，一个实体可以是<code>一个人、一个过程、一个客户端或一个服务器</code>。</p><p>身份需要证明的实体称为<code>要求者</code>, 试图证明要求者身份的一方称为<code>证明者</code>。</p><p>(1) 实体与消息验证<br>在消息验证（数据源验证）和实体验证间有两点区别：</p><ul><li>1).消息验证（或数据源验证）可能不会发生在实时系统中，而实体验证是会的。在前面的例子中，Alice发送一条消息给Bob。在Bob验证消息的时候，Alice可能在或可能不在通信的过程中。在另一方面，当Alice要求实体验证时，没有实际消息通信被涉及，直到Alice的身份被Bob验证。Alice需要在线参加这个过程。只有她的身份被验证后，消息才能在Alice和Bob间传输。当一则电子邮件从Alice到Bob,这时需要的是数据源验证；当Alice从自动取款机上取现金时，这时需要实体验证。</li><li>2).消息验证简单地验证一则消息，这个过程需对每则新的消息重复。实体验证可在整个会话期间内验证要求者。</li></ul><p>(2) 验证分类<br>在实体验证中要求者必须向证明者标识自己,可以使用下面三种证据中的一种：</p><ul><li>1).所知道的: 只有要求者知道的秘密，证明者可以通过它来检査要求者, 例如：<code>密码、PIN码、密钥和私钥</code>。</li><li>2).所拥有的: 证明要求者的身份, 例如：<code>护照、驾驶证、身份证、信用卡和智能卡</code>。</li><li>3).所固有的: 要求者内在固有的生物特性, 例如：<code>普通签名、指纹、声音、面部特征、视网膜模型和手迹</code>。<br>在这部分我们只讨论第一种验证，所知道的, cu种验证通常用作远程（在线）实体验证。另外两个分类则通常在要求者个人出现时使用。</li></ul><p>(3) 密码认证<br>最简单且最古老的实体身份验证的方法是基于密码的身份验证，密码是要求者知道的一些东西。当用户需要访问系统资源时（登录），他就需要一个密码。每个用户都有一个用户标识，这是公开的；还有一个密码，这是私有的，然而密码在攻击面前很脆弱，密码可能被窃取、截获或猜出（<code>暴力破解</code>）等。</p><p>(4) 挑战回应<br>在密码验证中，要求者通过展示他们知道秘密（密码）来证明他们的身份。但是要求者暴露了这个秘密，就容易受到敌手的截获。在挑战-回应身份验证中，要求者能证明他知道 秘密而不需要暴露它。换言之，要求者没有把秘密发送给证明者，但证明者或者有它，或者 能找到它。<br>在挑战-回应身份验证中，要求者证明他们知道秘密，而不需要把秘密暴露给证 明者。<br>挑战是一个随时间变化的值，如随机数或一个时间戳，它由证明者发送给要求者。要求者对挑战运用一个函数，把结果（称为响应）发送给证明者。响应表明要求者知道秘密。</p><ul><li>1) 使用对称密钥密码<br>有几种方法可以利用对称密钥加密来挑战-回应。这里共享的秘密是要求者和证明者都 知道的共享密钥。使用对称密钥密码的作用是对挑战应用加密算法。虽然达到这个手段有几种方法，我们只给出最简单的一种来给出思想，下图展示了第一种方法。</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230118115237.png" alt="WeiyiGeek.单向对称密钥认证图" title="" class="">                <p>WeiyiGeek.单向对称密钥认证图</p>            </figure><p>第一个消息不是挑战-回应的一部分，他只告知证明者要求者想要进行挑战。第二个 消息是挑战。Rb是证明者（Bob）为了挑战要求者随便挑选的随机数（一定数量的缩写）。要求者将随机数通过只有要求者和证明者知道的秘密共享密钥进行加密并将结果发送给证明者。证明者对消息进行解密，如果得到的随机数和证明者发送的相同，Alice就得到许可进入。<br>注意在这个过程中，要求者和证明者需要在过程中对他们使用的对称密钥保密。证明者也必须保存给要求者进行鉴别的随机数值直到返回回应。</p><ul><li>2) 使用非对称密钥密码<br>下图展示了这个方法。我们可以使用非对称密钥密码代替对称密钥密码进行实体验证。在这里秘密必须是要求者的密钥。要求者必须显示她拥有的私钥和所有人都有的公钥相关。也就是说，证明者必须使用要求者的公钥对挑战进行加密；然后要求者使用她的私钥对消息解密，对该挑战的回应就是解密后的消息。</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230118115300.png" alt="WeiyiGeek.单向非对称密钥图" title="" class="">                <p>WeiyiGeek.单向非对称密钥图</p>            </figure><ul><li>3) 使用数字签名<br>实体验证也可以通过使用数字签名来达到。当数字签名用在实体验证时，要求者使用她的私钥进行签名。在第一种方法中，如图16-18所示，Bob使用明文挑战，然后Alice签署回应。</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230118115339.png" alt="WeiyiGeek.单向数字签名验证图" title="" class="">                <p>WeiyiGeek.单向数字签名验证图</p>            </figure><p><br/></p><h4 id="5-密钥管理"><a href="#5-密钥管理" class="headerlink" title="(5) 密钥管理"></a>(5) 密钥管理</h4><p>此小节将讨论对称密钥密码术中的密钥和非对称密钥密码术中公钥是如何分配和维持的?</p><p><strong>(1) 对称密钥分发</strong><br>在对大量消息进行加密时，对称密钥密码术的效率要比非对称密钥密码高，但是对称密钥密码需要在双方间共享(这是一个风险点)。</p><p>至此，我们需要一种有效的方法来维护和分发密钥。</p><ul><li><p>方法1.密钥分发中心(KDC): 减少密钥的数量，每个人与KDC建立一个共享密钥，一个密钥建立在KDC和每个成员间。</p></li><li><p>方法2.多密钥分发中心: 当使用同一个密钥分发中心的人数增多时，系统就会变得难以管理并导致瓶颈，此时我们可以创建多个密钥分发中心，将其划分区域，并且每个区域有一个或者多个KDC(主备防止故障)</p></li><li><p>方法3.会话密钥: KDC为每个成员创建一个密钥，这个密钥只能在成员和KDC间使用，而不两个成员间，一个双方间的会话对称密钥只能被使用一次。</p></li></ul><p><img src="https://img.weiyigeek.top/2023/1/20230118152016.png" alt="WeiyiGeek.KDC创建会话密钥图"></p><p><br/></p><p><strong>(2) 公钥分发</strong></p><p>在非对称加密中公钥往往是共享的，每个人有权访问每个人的公钥，公钥对公众可用，当然公钥也像密钥一样需要进行分发。</p><ul><li><p>方法1.公开声明：即将公钥放在网站上供需要进行消息通信的客户使用，但是此种方式并不安全容易被伪造。</p></li><li><p>方法2.认证机构: 建立公钥认证，为了解决将公钥给需要的人并且不能假冒其公钥，此时就可以去认证机构(CA), 它是一个把公钥和实体捆绑在一起并处理认证的政府机构。</p><blockquote><p>其流程如下: 首先 CA 中心检查 Bob 的身份，之后 CA 向 Bob 要公钥, 并把它写在证书上, 为了防止证书本身被伪造, CA 用它的私钥签署证书, 然后 Bob 可以上载签署的证书, 任何需要 Bob 公钥的人就可以下载签署的证书, 并使用中心的公钥来抽取出 Bob 的公钥。</p></blockquote></li><li><p>方法3.X509: CA可以解决公钥伪造的问题，但是它每个证书的格式可能都不一样，如果Alice想利用程序来自动下载不同的证书和不同人的消息摘要, 所以为了解决这个问题ITU设计了X.509，它是一个结构化描述证书的方法，它使用叫ASN.1的协议，此协议定义了计算机编程者一些熟悉的领域。</p></li></ul><p><img src="https://img.weiyigeek.top/2023/1/20230118161049.png" alt="WeiyiGeek.认证机构图"></p><p><br/></p><h3 id="16-5-硬件防火墙"><a href="#16-5-硬件防火墙" class="headerlink" title="16.5 硬件防火墙"></a>16.5 硬件防火墙</h3><p>我们知道，在企业互联网边界上一定会有一台防护墙，来防止公网上的常规的一些黑客攻击，过滤有害信息或者说是指令，其是为了推进一些数据包而过滤其他数据包而设计的。</p><p>例如，图中展示了企业中防火墙在网络拓扑中的位置。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130094001.png" alt="WeiyiGeek.防火墙图" title="" class="">                <p>WeiyiGeek.防火墙图</p>            </figure><p>防火墙实现功能很多，可以做NAT转发，也可以过滤所有到来的目标为特定主机或服务器（例如HTTP）的数据包，也可以用来阻拦对组织内特定主机或服务的访问（ACL访问限制），防火墙通常分为<code>包过滤防火墙</code>和<code>代理防火墙</code>。</p><h4 id="1-包过滤防火墙"><a href="#1-包过滤防火墙" class="headerlink" title="(1) 包过滤防火墙"></a>(1) 包过滤防火墙</h4><p>原理: 它可以基于网络层的信息和传输层的头部：源和目标IP地址，源和目标端口地址以及协议的种类（TCP或UDP）来推进或阻拦数据包。</p><p>包过滤防火墙是一个使用过滤表单决定哪些数据包应该丢弃（不推进）的路由器, 如下图所示根据过滤表，以下数据包被过滤：<br>1）来自网络131.34.0.0的数据包被阻拦了（安全预防措施）。注意*号代表“任何”。<br>2）终点为任何国际TELNET服务器（端口23）的外发数据包被阻拦了。<br>3）到来的目标为内部主机194.78.20.8的数据包被阻拦了，该组织希望这个主机只用于内部使用。<br>4）终点为HTTP服务器（端口80）的外发数据包被阻拦了，该组织不希望雇员浏览因特网。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130094521.png" alt="WeiyiGeek.包过滤防火墙图" title="" class="">                <p>WeiyiGeek.包过滤防火墙图</p>            </figure><p>总结:包过滤防火墙是基于网络层的有效信息和传输层头部（IP和TCP/UDP）建立的</p><p><br/></p><h4 id="2-代理防火墙"><a href="#2-代理防火墙" class="headerlink" title="(2) 代理防火墙"></a>(2) 代理防火墙</h4><p>目的：有时我们也需要基于消息自身携带的信息（应用层上）进行过滤，例如通过 VPN 代理访问。</p><p>比如，假设一个组织想对其网页试试以下几条政策, 只有那些之前与本公司建立商业联系的因特网用户可以访问；其他用户必须阻拦。</p><p>在此情况下，数据包过滤防火墙就不可行，因为它无法区分到达TCP端口80 （HTTP）的不同数据包，必须在应用层（通过URL）进行测试。</p><p>一个解决措施是安装代理计算机（有时也称为应用网关），代理计算机位于客户计算机和公司计算机之间。当用户客户进程发送消息时，应用网关运行服务器进程来接收请求。服务器在应用层打开数据包并且查找这个请求是否合法。如果是，那么服务器运行客户端进程并将消息发给公司中真正的服务器，否则这个消息会被丢弃并且错误消息会发给外部用户。通过这个方法，外部用户的请求基于内容在应用层进行筛选。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2023/1/20230130094855.png" alt="WeiyiGeek.代理防火墙图" title="" class="">                <p>WeiyiGeek.代理防火墙图</p>            </figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;计算机科学导论学习笔记&quot;&gt;&lt;a href=&quot;#计算机科学导论学习笔记&quot; class=&quot;headerlink&quot; title=&quot;计算机科学导论学习笔记&quot;&gt;&lt;/a&gt;计算机科学导论学习笔记&lt;/h1&gt;&lt;h1 id=&quot;第-5-部分-数据安全与人工智能&quot;&gt;&lt;a href=&quot;#第-5-部分-数据安全与人工智能&quot; class=&quot;headerlink&quot; title=&quot;第 5 部分 数据安全与人工智能&quot;&gt;&lt;/a&gt;第 5 部分 数据安全与人工智能&lt;/h1&gt;&lt;p&gt;此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://mp.weixin.qq.com/s/CemNXNFZK_e0GzVuosfTDg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/CemNXNFZK_e0GzVuosfTDg&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://blog.weiyigeek.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="计算机科学导论" scheme="https://blog.weiyigeek.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>15.计算机科学导论之数据压缩学习笔记</title>
    <link href="https://blog.weiyigeek.top/2023/1-1-706.html"/>
    <id>https://blog.weiyigeek.top/2023/1-1-706.html</id>
    <published>2023-01-01T08:35:30.000Z</published>
    <updated>2023-02-13T08:02:28.155Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="计算机科学导论学习笔记"><a href="#计算机科学导论学习笔记" class="headerlink" title="计算机科学导论学习笔记"></a>计算机科学导论学习笔记</h1><h1 id="第-5-部分-数据安全与人工智能"><a href="#第-5-部分-数据安全与人工智能" class="headerlink" title="第 5 部分 数据安全与人工智能"></a>第 5 部分 数据安全与人工智能</h1><p>此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。</p><p>原文地址: <a href="https://mp.weixin.qq.com/s/PCYbGRpnGXycczaMMJz3-A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PCYbGRpnGXycczaMMJz3-A</a></p><a id="more"></a><h2 id="第15章-数据压缩"><a href="#第15章-数据压缩" class="headerlink" title="第15章 数据压缩"></a>第15章 数据压缩</h2><h3 id="15-1-前言简述"><a href="#15-1-前言简述" class="headerlink" title="15.1 前言简述"></a>15.1 前言简述</h3><p>近年来，随着计算机技术以及硬件设备技术飞速发展，改变了我们传输和存储数据的方式。</p><p>例如，光纤电缆使我们能更加快速地传输数据，DVD技术使得在较小物理媒介上存储大量的数据成为可能, 此时人们的要求也正逐渐增加。<br>今天人们希望在更短的时间内下载更多的数据（如看哔哩哔哩视频、抖音、文件下载等），同样，人们也希望能在更小的空间存储更多的数据，即当在同一传输速率下，文件越小则下载越快，所以为了文件能传输更快更小，我们需要对其数据进行压缩传输，这将是本章讲解的重点。</p><p>敲黑板：压缩数据通过部分消除数据中内在的冗余来减少发送或存储的数据量。</p><p>当我们产生数据的同时，冗余也就产生了。通过数据压缩，提高了数据传输和存储的效率，同时保护了数据的完整性。</p><p>数据压缩意味着发送或是存储更少的位数，虽然有很多编码方式用于此目的，通常方法分为两大类<code>无损压缩和有损压缩</code>, 如下图所示两类以及每类中常用的一些方法。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109154203406.png" alt="WeiyiGeek.数据压缩方法" title="" class="">                <p>WeiyiGeek.数据压缩方法</p>            </figure><p><strong>Q: 无损压缩和有损压缩有何区别?</strong></p><ul><li><p>无损压缩方法中: 接收的数据是发送数据的完全复制。</p></li><li><p>有损压缩方法中: 接收的数据并不需要是所发送数据的完全复制。</p><blockquote><p>三种有损压缩方法分别是 JPEG、MPEG和MP3。</p></blockquote></li></ul><p><br/></p><h3 id="15-2-无损压缩"><a href="#15-2-无损压缩" class="headerlink" title="15.2 无损压缩"></a>15.2 无损压缩</h3><p><strong>Q: 什么是无损压缩?</strong></p><blockquote><p>无损压缩是一种数据存储技术，它可以把文件的大小缩小，同时保证文件的完整性和原始质量不变。</p><p>这是一种非常有用的技术，能够节省存储空间，减少上传和下载时间，还可以解决通过网络传输大文件时网络流量的问题。</p></blockquote><p>简单的说： 在无损数据压缩中，数据的完整性是受到保护的，原始数据与压缩和解压后的数据完全一样。</p><p>常见三种无损压缩方法分别是 <code>游程长度编码、赫夫曼编码 和 Lempel Ziv编码</code>。</p><p><br/></p><h4 id="1-游程长度编码"><a href="#1-游程长度编码" class="headerlink" title="(1) 游程长度编码"></a>(1) 游程长度编码</h4><p>它是最简单的压缩方法，可以用来压缩由任何符号组成的数据，它不需要知道字符出现频率的有关知识（赫夫曼编码则需要），并且当数据中由0和1表示时，该方式编码十分有效。</p><p>算法的大致思想是<code>将数据中连续重复出现的符号用一个字符和这个字符重复的次数来代替</code>。</p><p><strong>示例1</strong>，如AAAAAAAA可以用A08来代替，下图中显示此简单压缩方法，注意此处，我们使用固定位数（2位）的数字来表示数。<br><strong>示例2</strong>，在位模式中，如果数据只用两种符号（0和1）,并且一种符号比另一种符号使用更为频繁，那么这种压缩方法就更有效。例如，假设一段数据里面有很多的0而1很少，那么，就可以通过在发送（或存储）时只标记在两个1中间有多少个0来减少数据的位数，注意此处，我们使用4位二进制数（无符号整数）计数。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109155437902.png" alt="WeiyiGeek.游程长度编码示例" title="" class="">                <p>WeiyiGeek.游程长度编码示例</p>            </figure><p>温馨提示：用4位二进制压缩时，如果连续的0多于15个，它们将被分为2组或者更多的组。<br>例如，连续的25个0编码为1111 1010.现在的问题则是：接收者如何知道这是25个0而不是连续15个0后接着1个1,然后再接10个0?答案是，如果第一个计数是1111, 我们就默认下一个4位模式仍然是用于表示连续0的数目。<br>而另一个问题又产生了：假如2 个1之间刚好15个0时又怎么办呢？这种情况下的模式是1111后再紧跟0000。</p><p>总结：在游程长度编码中，重复出现的符号被该符号和表示该符号重复的数字所替换。</p><p><br/></p><h4 id="2-赫夫曼编码"><a href="#2-赫夫曼编码" class="headerlink" title="(2) 赫夫曼编码"></a>(2) 赫夫曼编码</h4><p>赫夫曼编码是一种数据压缩编码技术，它利用变长编码来将信息转换成可编码的数据序列。它把比特表示为0或1，然后根据给定信息的出现次数以及其他一些给定的因素，来定义不同的编码长度。</p><p>例如，如果给定信息出现频率较高，则可以使用更短的编码，而较低频率的信息可以使用更长的编码。</p><p>例如，假设有一篇文本文件只用到了5个字符（A, B, C, D, E），在给每个字符分配位模式前，首先根据每个字符的使用频率给它们分配相应的权值。</p><blockquote><p>假定，字符A出现的频率为17%，字符B出现的频率为12%，字符C出现的频率为12%，字符D出现的频率为27%，字符E出现的频率为32%等</p><p>A - 17 , B - 12 , C - 12 , D - 27，E - 32;</p></blockquote><p>一旦建立了各个字符的权值后，就可以根据这些值构造一棵树，它遵循以下三个基本步骤：</p><p>1）将全部字符排成一排。每个字符现在都是树的最底层节点。</p><p>2）找出权值最小的两个节点并由它们合成第三个节点，产生一棵简单的二层树。新节点的权值由最初的两个节点的权值结合而成。这个节点，在叶子节点的上一层，可以再与其他的节点结合。请记住，选择所结合的两个节点的权值和必须比其他所有可能的选择小。</p><p>3 ）重复步骤2,直到各个层上的所有节点结合成为一棵树。</p><p>当树的构造完成后，利用它来给各个字符分配编码。</p><p>首先，给每个分支分配1位，从根（顶部节点）开始，给左分支分配0,给右分支分配1。</p><p>然后，在其他各个节点重复这一模式。</p><p>此时，字符的编码是这样得到的，首先从根开始，沿着分支到达字符所在的位置，该字符的编码就是所经过的路径上各分支位值的顺序排列。如下图所示，给出了最终的生成树和相对应的编码，注意我们移动了叶子节点以使整棵树更像一棵二叉树。</p><p><img src="https://img.weiyigeek.top/2022/8/image-20230109160530223.png" alt="WeiyiGeek.赫夫曼编码"></p><p><strong>温馨提示:</strong><br>首先，出现<code>频率高的字符</code>（A、D和E）的编码要比出现<code>频率低的字符</code>（B和C）的<code>编码短</code>（层级少），此处可以通过比较分配给各个字符的编码适当的位长度看出。</p><p>其次，在这个编码系统中，没有一个编码是其他编码的前缀。图中2位编码00、10或者 11 都不是其他两种编码（<code>010, 011</code>）中任何一个的前缀。换句话说，不存在一个3位编码是以00、10或11开头的，这个特性使得赫夫曼编码是一种即时的编码，后续将会在讨论赫夫曼编码的编码和译码时解释这个问题。</p><h5 id="1-编码"><a href="#1-编码" class="headerlink" title="1)编码"></a>1)编码</h5><p>此处，假定也是使用5个字符的编码压缩文档，如下图所示是编码前后的文本<code>EAEBAECDEA</code>。</p><p>首先，注意，即使是这样小的不切实际的编码压缩也有其意义。如果想在不压缩成赫夫曼编码的情况下就发送这个文本，那么需要给每个字符一个3位编码，总共需传送30位，而用赫夫曼编码则只发送22位。</p><p>其次，注意，我们没有在每个字符的编码中间加上分隔符。我们只是一个接一个地写代码。赫夫曼编码的好处就是没有一个编码是其他编码的前缀，这样在编码过程中没有二义性，接收方接收到数据解压缩时也不会产生二义性。</p><h5 id="2-解码-译码"><a href="#2-解码-译码" class="headerlink" title="2)解码(译码)"></a>2)解码(译码)</h5><p>接收方译码十分容易，当接收方收到前2位数的时候，它不必等收到下一个位就可以译码。它知道应该译码为E。</p><p>其原因是，这两位不是任何3位码前缀（没有11开头的3位码）。同样，当接收方收到下两位时（00）时，它也知道应该翻译为A。再下两位以同样的方式翻译（11 一定是E）。然而，当收到第7和第8位时，计算机知道需要等下一位，<code>因为编码01不在编码表里</code>。当收到下一位（0）时，它将这3位连在一起（010）翻译为B。</p><p>这就是赫夫曼编码称为即时码的原因。译码器可以即时明确地翻译出编码（在最小位数下）。</p><p><img src="https://img.weiyigeek.top/2022/8/image-20230109161639412.png" alt="WeiyiGeek.赫夫曼编码与译码"></p><p>总结:  在赫夫曼编码中，编码的长度是符号频率的函数，出现频率越高的符号相对于出现频率较低的符号编码长度越短（层级更浅）。</p><p><br/></p><h4 id="3-Lempel-Ziv-编码"><a href="#3-Lempel-Ziv-编码" class="headerlink" title="(3) Lempel Ziv 编码"></a>(3) Lempel Ziv 编码</h4><p>Lempel-Ziv (LZ) 编码是由 Abraham Lempel 和 Jacob Ziv (用其开发者名字命名)在 1970 年代末开发的无损数据压缩算法的一类，此算法通常用于压缩和解压缩文件，如归档文件、图像和视频处理文件、文本和图形编辑文件以及音频和视频传输文件。该算法旨在通过创建一本密钥代码表来减少数据的大小，用于对数据进行编码和解码，这些代码是从数据本身生成的，通常用作熵编码的一种形式。</p><p>简单的说，该算法是基于字典的自适应编码的思想，在通信会话的时候它将产生一个字符串字典（一个表），如果接收和发送双方都有这样的字典，那么字符串可以由字典中的索引代替, 以减少通信的数据传输量。</p><p>尽管方案看似简单，但执行起来仍然有些困难。</p><p>首先，怎样为每一次通信会话产生一个字典（由于字符串的长度不定，很难找到通用的字典）？</p><p>其次，接收方怎样获得发送方的字典（如果同时发送字典，就增加了额外的数据，这样，与我们压缩的目的是相悖的）？</p><p>例如，针对 BAABABBBAABBBBAA 这个特殊的字符串进行讨论，使用LZ算法的简单版本，整个过程分为两个阶段，即<code>压缩字符串和解压缩字符串</code>。</p><h5 id="1-压缩"><a href="#1-压缩" class="headerlink" title="1)压缩"></a>1)压缩</h5><p>此阶段，建立字典索引和压缩字符串。</p><p>首先，算法从未压缩的字符串中选取最小的子字符串，这些子字符串在字典中不存在。</p><p>然后，将这个子字符串复制到字典（作为一个新的记录）并为它分配一个索引值。压缩时，除了最后一个字母之外，其他所有字符被字典中的索引代替。</p><p>最后，将索引和最后一个字母插入压缩字符串，比如ABBB,在字典中找到ABB和它的索引4,得到的压缩字符串就是4B。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109163420781.png" alt="WeiyiGeek.Lempel-Ziv-编码示例" title="" class="">                <p>WeiyiGeek.Lempel-Ziv-编码示例</p>            </figure><h5 id="2-解压"><a href="#2-解压" class="headerlink" title="2)解压"></a>2)解压</h5><p>解压是压缩的逆过程，该过程从压缩的字符串中取出子字符串，然后尝试按照字典中所列出的记录还原相应的索引号为对应的字符串。</p><p>字典开始为空，之后会逐渐地建立起来，该过程的总体思路是当一个索引号被接收时，在字典中已经存在了与其相应的记录。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109163641532.png" alt="WeiyiGeek.Lempel-Ziv 解码" title="" class="">                <p>WeiyiGeek.Lempel-Ziv 解码</p>            </figure><p>总结：在LZ编码中，重复的字符串或字以变量形式保存，字符串或字用变量的索引号代替，LZ编码在接收方和发送方都需要一个字典和一个算法。</p><p><br/></p><h3 id="15-3-有损压缩"><a href="#15-3-有损压缩" class="headerlink" title="15.3 有损压缩"></a>15.3 有损压缩</h3><p>有损压缩是指在压缩文件的同时，会牺牲一部分文件的质量来节省存储空间，有损压缩的文件在解压缩后，质量会有损失，但这也是为了节省存储空间，所以有损压缩通常用于图像和音频文件。</p><p>常见三种有损压缩方法分别是<code>联合图像专家组（JPEG）用来压缩图片和图像，运动图像专家组（MPEG）用来压缩视频，MPEG第三代音频压缩格式（MP3）则用来压缩声音</code>。</p><h4 id="1-图像压缩-JPEG"><a href="#1-图像压缩-JPEG" class="headerlink" title="(1) 图像压缩-JPEG"></a>(1) 图像压缩-JPEG</h4><p>通过前面学习，我们知道一幅图像可以通过一个二维数组（表）来表示图像元素（像素）, 例如，在JPEG中，一幅灰度图像将被分成许多8X8的像素块，假设图片尺寸<code>640(宽)X480(高)</code>则像素为<code>307 200</code>。</p><ul><li><p>如果图像是灰度的，那么像素可以由一个8位整数（256 个灰度级别）来表示，则<code>307 200像素图片 x 8 位，用2 457 600 位来表示</code>。</p></li><li><p>如果图像是彩色的，每个像素可以由24位表示（3X8位），其中每8位表示RBG颜色系统中的一个颜色，则<code>307 200像素的图片 x 24 位，用7 372 800位来表示</code>。</p></li></ul><p>然而，将图像划分成块的目的是考虑到减少计算量。显而易见，此时每幅图像的数学运算量是单元数的平方。也就是说，整个图像需要<code>307 200^2</code>次运算（<code>94 371 840 000</code>次运算），而如果使用JPEG则需要对每个块进行64^2次运算，总共是<code>64^2X(640/8)X(480/8)</code>,即<code>19 660 800</code> 次运算，这将原来的运算量减少到4800分之一。</p><p>其图像处理简约过程如下所示:</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109170609373.png" alt="WeiyiGeek.Jpeg处理过程" title="" class="">                <p>WeiyiGeek.Jpeg处理过程</p>            </figure><p>JPEG的整体思想是将图像变换成一个数的线性（矢量）集合来揭示冗余，这些冗余（缺乏变化的）可以通过使用前面学过的无损压缩的方法来除去。</p><h5 id="1-离散余弦变换"><a href="#1-离散余弦变换" class="headerlink" title="1)离散余弦变换"></a>1)离散余弦变换</h5><p><em>Q: 什么是离散余弦变换?</em></p><p>离散余弦变换（<code>Discrete Cosine Transform，DCT</code>）是一类函数变换，可以将一个信号（或图像）转换为其傅里叶变换（或频域）的一种类似形式，即此种变换改变了64个值以使相邻像素之间的关系得以保持，但同时又能够揭示冗余。</p><p>它是一种非常高效的图像压缩技术，具有良好的信号表示性能。它的数学表达式为：</p><p><code>F[u][v] = 2/N * sum(sum(f[x][y]*cos[(2*x+1)*u*(pi/2*N)),(2*y+1)*v*(pi/2*N)))</code></p><p>其中，F[u][v]是变换后的矩阵，f[x][y]是原矩阵，N是矩阵的大小，u,v是矩阵的行和列号。</p><p>为了理解该变换的本质，让我们研究以下三种情况变换后的结果，其中<code>P(x,y)</code>定义了每个块上的值；<code>T（m, n）</code>则定义了变换后的块的值。</p><ul><li>情况1</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109172647954.png" alt="WeiyiGeek.情况1" title="" class="">                <p>WeiyiGeek.情况1</p>            </figure><ul><li>情况2</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109172711466.png" alt="WeiyiGeek.情况2" title="" class="">                <p>WeiyiGeek.情况2</p>            </figure><ul><li>情况3</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230110090944711.png" alt="WeiyiGeek.情况3" title="" class="">                <p>WeiyiGeek.情况3</p>            </figure><p>从上述图中可知，转换从P表生成T表，DC值是像素的平均值，AC值显示变化，邻近像素缺少变化的生成0，但需要注意DCT是可逆的。</p><h5 id="2-量化"><a href="#2-量化" class="headerlink" title="2)量化"></a>2)量化</h5><p>生成T表后，这些值将被量化以减少需要编码的位数。量化过程用一个常量来除位数，然后舍弃小数部分。这样可以更加减少需要编码的位数。在大多数实现方法中，通过一张量化表（8X8 ）定义了如何量化每个值，其中除数取决于T表位置上的值。这样做可以对每一个特殊的应用程序优化位数和0的个数。<br>注意在整个过程中只有量化阶段是不可逆的。在这里所失去的一些信息是不能恢复的。事实上，JPEG之所以称为有损压缩就是因为量化过程所带来的损失。</p><h5 id="3-压缩"><a href="#3-压缩" class="headerlink" title="3)压缩"></a>3)压缩</h5><p>量化后，将表中的值读出并去掉多余的0。但是，为了把0 聚集起来，整个压缩过程以z字形按<code>对角线读取表</code>，而不是按行或列。原因是如果图像没有很好的变化，T表底部的右下角将全为0。</p><p>例如，下图所示JPEG在压缩阶段通常使用游程长度编码来压缩从Z字形线性化读取的位模式。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230109173916196.png" alt="WeiyiGeek.压缩读表" title="" class="">                <p>WeiyiGeek.压缩读表</p>            </figure><p>总结：联合图像专家组(JPEG)是一种用来压缩图形和图像的方法，JPEG过程包括划分块、离散余弦变换、量化以及无损压缩。</p><h4 id="2-视频压缩-MPEG"><a href="#2-视频压缩-MPEG" class="headerlink" title="(2) 视频压缩-MPEG"></a>(2) 视频压缩-MPEG</h4><p>在讲解前，我们需要先了解视频压缩(减少文件大小)有那些方式，其大致如下:</p><ol><li>降低视频的分辨率：主要通过降低水平和垂直像素分辨率来降低视频的分辨率，用较低的分辨率来表现相同的画面，节省视频文件的大小。</li><li>降低视频的帧率：也就是每秒钟播放多少张图像，通常情况下每秒钟播放的帧数越高，画面质量也越高，但是要想节省视频文件大小，可以选择降低帧率来节省视频的文件大小。</li><li>使用编码器压缩视频：视频文件随着视频画面的复杂性会变得越来越大，这种情况下可以使用编码器对视频进行压缩，通常可以采用H.264和H.265等编码器进行压缩，此方法可以明显地节省视频文件的大小。</li></ol><h5 id="空间与时间压缩"><a href="#空间与时间压缩" class="headerlink" title="空间与时间压缩"></a>空间与时间压缩</h5><p>今天讲解的<code>运动图像专家组(MPEG,Moving Picture Experts Group)</code>属于其中之一，它是一种专业的图像和视频编码标准，其原理是视频每一帧每个帧都是一幅图像，帧是像素在空间上的组合，视频是一幅接一幅发送的帧的时间组合，而压缩视频，就是对每帧空间上的压缩和对一系列帧时间上的压缩。</p><p><strong>空间压缩:</strong> 每一帧的空间压缩使用JPEG，每一帧都是一幅画可以独立压缩。</p><p><strong>时间压缩:</strong> 在此压缩中多余的镇将被丢弃，一般来说，人类可以感知<code>15-30</code>帧每秒的视频，而视频编辑常用的标准是<code>24-30</code>帧每秒，所以大多数连续帧几乎是一样的。</p><p>例如，一个 20:1 的 Jpeg 压缩图像每帧需要发送 368 640 位，每秒 30 帧则需要传输11 059 200 bit/s，显然我们需要减少该数量。</p><p>为了压缩时间数据，MPEG方法首先把帧分为三类：<code>I-帧、P-帧、B-帧</code>。</p><ul><li><p>I-帧 :即内部编码(I-帧 )，是一个独立帧，该帧与任何其他帧(即在其前发送的帧或者在其后发送的帧)无关。它们以周期性间隔出现(比如:每9个帧中有一个I-帧)。I- 帧必须周期性出现，因为该帧的突然变化将使得其前面的帧和后面的帧不能正常显示。同样，当播放视频的时候，观众可能会随时调整接收机。如果仅仅在播放开始时有一个1- 帧，那么随后调整频道的观众将不能收到完整的画面。I-帧独立于其他帧之外，而且不能由其他帧构造。</p></li><li><p>P-帧:即预(P-帧)与前面的  I-帧或者P-帧有关联。话说，每个P-帧都从前面帧变化而来，不过变化不能覆盖大的部分。</p><p>例如，对于一个快速移动的目标，新变化也许没有记录在P-帧中，P-帧可以通过先前I-帧的或P-帧产生。P-帧携带的信息比其他类型的帧少，而且压缩后会更少。</p></li><li><p>B-帧:即双向帧(B-帧)，与前面和后续的I-帧或P-帧有关系，换句话说，每个B顿都与过去和将来有关系，注意 B-帧不会与另一个 B -帧有关系。</p><p>下图显示了的样本序列以及它们是如何构造的，需注意一下译码，译码过程应该在 B-帧之前接收到 P-帧，基于这个原因，发送的顺序与它们显示在接收应用中的顺序不同。帧发送顺序为:<code>I，P，B，B，P，B，B，I</code>。</p></li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/8/image-20230110094915001.png" alt="WeiyiGeek.MPEG帧" title="" class="">                <p>WeiyiGeek.MPEG帧</p>            </figure><h5 id="MPEG-编码过程"><a href="#MPEG-编码过程" class="headerlink" title="MPEG 编码过程"></a>MPEG 编码过程</h5><p>分为三个主要步骤：<code>图像或视频的量化、分块和编码</code>。</p><p>1.量化：将图像或视频信号采样，并将所得信号转换成数字，消除不必要的量化误差。</p><p>2.分块：将图像或视频划分为不同的块，以便于编码。</p><p>3.编码：使用现有的压缩算法和编码器，按照设定的标准，将分块的图像或视频信号压缩，生成最终的数据流。</p><h5 id="MPEG-版本"><a href="#MPEG-版本" class="headerlink" title="MPEG 版本"></a>MPEG 版本</h5><p>上面我们讨论的是 MPEG-1版本，除此之外MPEG 有许多版本如下所示：</p><ol><li>MPEG-1：用于CD存储</li><li>MPEG-2：用于DVD存储</li><li>MPEG-3：用于HDTV存储</li><li>MPEG-4：用于多媒体应用，支持包括视频和音频在内的多种媒体格式</li><li>MPEG-7：用于多媒体数据中提取信息和特征的标准，使用XML描述元数据和对视频中所含内容的描述的标准。</li><li>MPEG-21：用于在多媒体环境下分享和交换数据的标准</li></ol><p>总结：运动图像专家组(MPEG)是一种用来压缩视频的方法，MPEG包括空间和时间压缩，前者和JPEG相似，后者则去掉了多余的帧。</p><h4 id="3-音频压缩"><a href="#3-音频压缩" class="headerlink" title="(3) 音频压缩"></a>(3) 音频压缩</h4><p>音频压缩可以用来处理语音和音乐，对于语音，我们需要压缩一个64 kHz的数字化信号，而对于音乐我们需要压缩一个1.411 MHz的信号。</p><p>有两类技术用来进行音频压缩：<code>预测编码</code>和<code>感知编码</code>。</p><ul><li><p>预测编码: 将样本间的差别被编码，而不是对所有的样本值进行编码，通常应用与语言之上，已经定义的标准有<code>GSM （13 kbps）、G.729 （8 kbps）和G.723.3（6.4 kbps 或5.3 kbps）</code>。</p></li><li><p>感知编码: 感知编码是基于心理声学的，心理声学是一门研究人类是如何感知声音的科学，用来创建CD质量音频最常用的压缩技术是基于感知编码技术的，此类型音频至少为1.411 Mbps，MP3 （MPEG第三代音频压缩格式，PS: 它是MPEG标准的一部分:card_index_dividers: ）使用的就是这种技术，MP3使用这两种现象（频率掩盖和时间掩盖）来压缩音频信号，该技术分析音谱并把音谱分成几个组，0位被赋给了那些频率范围被完全掩盖的，小数值的位被赋给了那些频率范围部分被掩盖的。</p><blockquote><p>例如，在一个有高音重金属演出的房间内，我们就不能听见我们舞伴的说话声。在时间掩盖中，一个高音可以短时间内降低我们听觉的灵敏度，甚至在声音停止之后。</p></blockquote></li></ul><p>MP3有三种速率：<code>96 kbps、128 kbps和160 kbps</code>，速率是基于原始模拟音频的频率范围的。</p><p><strong>音频压缩方式</strong></p><p>当前音频压缩方式有那些（PS:我们在前面第二章讨论过）：</p><ol><li><p>MP3（MPEG-1 Layer 3）；</p></li><li><p>AAC（Advanced Audio Coding）；</p></li><li><p>WMA（Windows Media Audio）；</p></li><li><p>OGG（Ogg Vorbis）；</p></li><li><p>FLAC（Free Lossless Audio Codec）；</p></li><li><p>ALAC（Apple Lossless Audio Codec）；</p></li><li><p>ATRAC3（Adaptive Transform Acoustic Coding 3）；</p></li><li><p>WV（WavPack）；</p></li><li><p>APE（Monkey’s Audio）。</p></li></ol><p>总结: MPEG第三代音频压缩格式(MP3)是MPEG标准的一部分。MP3使用感知编码技术压缩CD质量音频。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;计算机科学导论学习笔记&quot;&gt;&lt;a href=&quot;#计算机科学导论学习笔记&quot; class=&quot;headerlink&quot; title=&quot;计算机科学导论学习笔记&quot;&gt;&lt;/a&gt;计算机科学导论学习笔记&lt;/h1&gt;&lt;h1 id=&quot;第-5-部分-数据安全与人工智能&quot;&gt;&lt;a href=&quot;#第-5-部分-数据安全与人工智能&quot; class=&quot;headerlink&quot; title=&quot;第 5 部分 数据安全与人工智能&quot;&gt;&lt;/a&gt;第 5 部分 数据安全与人工智能&lt;/h1&gt;&lt;p&gt;此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://mp.weixin.qq.com/s/PCYbGRpnGXycczaMMJz3-A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/PCYbGRpnGXycczaMMJz3-A&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础知识" scheme="https://blog.weiyigeek.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="计算机科学导论" scheme="https://blog.weiyigeek.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>23-Kubernetes之企业运维实践操作笔记</title>
    <link href="https://blog.weiyigeek.top/2022/12-18-691.html"/>
    <id>https://blog.weiyigeek.top/2022/12-18-691.html</id>
    <published>2022-12-18T02:37:47.000Z</published>
    <updated>2023-02-06T14:03:37.756Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-实操1-记一次-Kubernetes-V1-23-x-集群证书过期或者延期处理操作实践案例"><a href="#0x00-实操1-记一次-Kubernetes-V1-23-x-集群证书过期或者延期处理操作实践案例" class="headerlink" title="0x00 实操1.记一次 Kubernetes V1.23.x 集群证书过期或者延期处理操作实践案例"></a>0x00 实操1.记一次 Kubernetes V1.23.x 集群证书过期或者延期处理操作实践案例</h2><p>描述: 下述操作主要用于处理K8S证书<code>已过期</code>或者<code>即将过期的kubernetes集群</code>实践案例，当然网上百度、CSDN（捡垃圾）大多数方法均是一知半解，不同的K8S版本操作有些许不同，若全部按照其操作，有可能你需要重建K8S了，别问我怎么知道的，因为我踩过坑( Ĭ ^ Ĭ )，所以建议在遇到问题时先查询K8S官方文档。</p><h3 id="1-前言简述"><a href="#1-前言简述" class="headerlink" title="1.前言简述"></a>1.前言简述</h3><p>在年后上班的第一天，我像往常一样，登录到K8S集群之中依次检查应用，在检查开发测试环境的k8s集群时，发现执行kubectl命令报证书过期错误，顿时心情都不好了，却也无可奈何，只能进行证书续签了，由于是高可用集群遇到了许多坑，为了方便自己以及广大的运维工作者，解决相关问题，遂整理了此篇文章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 Api-server 失败，报证书已过期不可用。</span></span><br><span class="line">$ kubectl get node,pod</span><br><span class="line">Unable to connect to the server: x509: certificate has expired or is not yet valid: current time 2023-01-31T16:55:27+08:00 is after 2023-01-16T04:47:34Z</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="2-实践环境"><a href="#2-实践环境" class="headerlink" title="2.实践环境"></a>2.实践环境</h3><p><strong>集群版本及其节点描述:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群版本</span></span><br><span class="line">$ kubeadm version</span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:<span class="string">"1"</span>, Minor:<span class="string">"23"</span>, GitVersion:<span class="string">"v1.23.1"</span>, GitCommit:<span class="string">"86ec240af8cbd1b60bcc4c03c20da9b98005b92e"</span>, GitTreeState:<span class="string">"clean"</span>, BuildDate:<span class="string">"2021-12-16T11:39:51Z"</span>, GoVersion:<span class="string">"go1.17.5"</span>, Compiler:<span class="string">"gc"</span>, Platform:<span class="string">"linux/amd64"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群节点</span></span><br><span class="line">$ data -s <span class="string">"2023-01-01"</span></span><br><span class="line">$ kubectl get node</span><br><span class="line">NAME       STATUS   ROLES                  AGE    VERSION</span><br><span class="line">weiyigeek-107   Ready    control-plane,master   381d   v1.23.1</span><br><span class="line">weiyigeek-108   Ready    control-plane,master   380d   v1.23.1</span><br><span class="line">weiyigeek-109   Ready    control-plane,master   380d   v1.23.1</span><br><span class="line">weiyigeek-223   Ready    work                   380d   v1.23.1</span><br><span class="line">weiyigeek-224   Ready    work                   380d   v1.23.1</span><br><span class="line">weiyigeek-225   Ready    work                   381d   v1.23.1</span><br><span class="line">weiyigeek-226   Ready    work                   220d   v1.23.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 论保存过程配置文件的重要性，在搭建k8s集群时建议备份资源清单。</span></span><br><span class="line">kubectl -n kube-system get cm kubeadm-config -o yaml &gt; kubeadm-config-v1.23.1.yaml</span><br></pre></td></tr></table></figure></p><p><br/></p><h3 id="3-证书续签"><a href="#3-证书续签" class="headerlink" title="3.证书续签"></a>3.证书续签</h3><p><strong>高可用K8S集群，证书续签操作流程步骤如下:</strong><br>0.在进行操作前一定要进行备份，便于回退处理，此处我在三台master节点之一的<code>weiyigeek-107</code>机器上操作，后续默认也在此机器上操作，若需在其他机器上操作我会进行说明<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份旧的配置文件。</span></span><br><span class="line">cp -a /etc/kubernetes&#123;,.bak&#125;</span><br><span class="line">cp -a /var/lib/kubelet&#123;,.bak&#125;</span><br><span class="line">cp -a /var/lib/etcd /var/lib/etcd.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份集群配置 (当证书到期时是无法执行的此步骤可跳过)但可以利用date命令将系统时间设置到过期前。</span></span><br><span class="line">data -s <span class="string">"2023-01-01"</span> || timedatectl <span class="built_in">set</span>-time <span class="string">"2023-01-01"</span></span><br><span class="line">kubectl -n kube-system get cm kubeadm-config -o yaml &gt; kubeadm-init-config.yaml     <span class="comment"># 后续会用到此原始配置文件。</span></span><br></pre></td></tr></table></figure></p><p><br/></p><p>1.使用openssl命令查询单个证书可用时间及其相关信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># k8s 集群的 ca.crt 证书有效期为 十年</span></span><br><span class="line"><span class="comment"># k8s 集群的 apiserver.crt 、kubelet.crt、etcd.crt 证书默认有效期为 一年，当然你也可以自行修改为十年（后续有文章进行讲解）</span></span><br><span class="line">$ <span class="keyword">for</span> i <span class="keyword">in</span> $(ls /etc/kubernetes/pki/*.crt /etc/kubernetes/pki/etcd/*.crt); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"===== <span class="variable">$i</span> ====="</span>; openssl x509 -<span class="keyword">in</span> <span class="variable">$i</span> -text -noout | grep -A 3 <span class="string">'Validity'</span> ; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># for item in `find /etc/kubernetes/pki -maxdepth 2 -name "*.crt"`;do echo ======================$item===============;openssl x509 -in $item -text -noout| grep -A 3 Not;done</span></span><br><span class="line">===== /etc/kubernetes/pki/apiserver.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:56 2022 GMT  <span class="comment"># 颁发时间</span></span><br><span class="line">            Not After : Jan 15 10:42:57 2023 GMT  <span class="comment"># 到期时间</span></span><br><span class="line">        Subject: CN = kube-apiserver              <span class="comment"># 通用名称</span></span><br><span class="line">===== /etc/kubernetes/pki/apiserver-etcd-client.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:58 2022 GMT</span><br><span class="line">            Not After : Jan 15 10:42:59 2023 GMT</span><br><span class="line">        Subject: O = system:masters, CN = kube-apiserver-etcd-client</span><br><span class="line">===== /etc/kubernetes/pki/apiserver-kubelet-client.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:56 2022 GMT</span><br><span class="line">            Not After : Jan 15 10:42:57 2023 GMT</span><br><span class="line">        Subject: O = system:masters, CN = kube-apiserver-kubelet-client</span><br><span class="line">===== /etc/kubernetes/pki/ca.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:56 2022 GMT</span><br><span class="line">            Not After : Jan 13 10:42:56 2032 GMT</span><br><span class="line">        Subject: CN = kubernetes</span><br><span class="line">===== /etc/kubernetes/pki/etcd/ca.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:58 2022 GMT</span><br><span class="line">            Not After : Jan 13 10:42:58 2032 GMT</span><br><span class="line">        Subject: CN = etcd-ca</span><br><span class="line">===== /etc/kubernetes/pki/etcd/healthcheck-client.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:58 2022 GMT</span><br><span class="line">            Not After : Jan 15 10:42:59 2023 GMT</span><br><span class="line">        Subject: O = system:masters, CN = kube-etcd-healthcheck-client</span><br><span class="line">===== /etc/kubernetes/pki/etcd/peer.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:58 2022 GMT</span><br><span class="line">            Not After : Jan 15 10:42:59 2023 GMT</span><br><span class="line">        Subject: CN = weiyigeek-107</span><br><span class="line">===== /etc/kubernetes/pki/etcd/server.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:58 2022 GMT</span><br><span class="line">            Not After : Jan 15 10:42:59 2023 GMT</span><br><span class="line">        Subject: CN = weiyigeek-107</span><br><span class="line">===== /etc/kubernetes/pki/front-proxy-ca.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:58 2022 GMT</span><br><span class="line">            Not After : Jan 13 10:42:58 2032 GMT</span><br><span class="line">        Subject: CN = front-proxy-ca</span><br><span class="line">===== /etc/kubernetes/pki/front-proxy-client.crt =====</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Jan 15 10:42:58 2022 GMT</span><br><span class="line">            Not After : Jan 15 10:42:58 2023 GMT</span><br><span class="line">        Subject: CN = front-proxy-client</span><br></pre></td></tr></table></figure></p><p><br/></p><p>2.查看当前集群证书相关信息，包含所有证书名称以及证书颁发机构、到期时间等, 此处可以看到均已经到期。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ sudo kubeadm certs check-expiration</span><br><span class="line">  <span class="comment"># [check-expiration] Reading configuration from the cluster...</span></span><br><span class="line">  <span class="comment"># [check-expiration] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'</span></span><br><span class="line">  <span class="comment"># [check-expiration] Error reading configuration from the Cluster. Falling back to default configuration</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># CERTIFICATE                EXPIRES(过期时间)         RESIDUAL TIME(剩余时间)   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED(是否是外部管理)</span></span><br><span class="line">  <span class="comment"># admin.conf                 Jan 15, 2023 10:43 UTC   &lt;invalid&gt;       ca                      no</span></span><br><span class="line">  <span class="comment"># apiserver                  Jan 15, 2023 10:42 UTC   &lt;invalid&gt;       ca                      no</span></span><br><span class="line">  <span class="comment"># apiserver-etcd-client      Jan 15, 2023 10:42 UTC   &lt;invalid&gt;       etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># apiserver-kubelet-client   Jan 15, 2023 10:42 UTC   &lt;invalid&gt;       ca                      no</span></span><br><span class="line">  <span class="comment"># controller-manager.conf    Jan 15, 2023 10:43 UTC   &lt;invalid&gt;       ca                      no</span></span><br><span class="line">  <span class="comment"># etcd-healthcheck-client    Jan 15, 2023 10:42 UTC   &lt;invalid&gt;       etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># etcd-peer                  Jan 15, 2023 10:42 UTC   &lt;invalid&gt;       etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># etcd-server                Jan 15, 2023 10:42 UTC   &lt;invalid&gt;       etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># front-proxy-client         Jan 15, 2023 10:42 UTC   &lt;invalid&gt;       front-proxy-ca          no</span></span><br><span class="line">  <span class="comment"># scheduler.conf             Jan 15, 2023 10:43 UTC   &lt;invalid&gt;       ca                      no</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span></span><br><span class="line">  <span class="comment"># ca                      Jan 13, 2032 10:42 UTC   8y              no</span></span><br><span class="line">  <span class="comment"># etcd-ca                 Jan 13, 2032 10:42 UTC   8y              no</span></span><br><span class="line">  <span class="comment"># front-proxy-ca          Jan 13, 2032 10:42 UTC   8y              no</span></span><br></pre></td></tr></table></figure></p><p>温馨提示: 如果 Etcd 是由Kubeadm创建和托管的此时也可以通过下面的方式进行证书的续期, 如果是外部高可用环境管理需要则手动进行更新证书配置;</p><p><br/></p><p>3.使用 certs 的 renew 子命令刷新集群所有证书的到期时间进行再续期一年, 此处 –config 参数指定的是我当初创建集群的初始化配置清单，若没有可以安装步骤0进行生成。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">~/.k8s$ sudo kubeadm certs renew all --config=./kubeadm-init-config.yaml</span><br><span class="line">  <span class="comment"># W1212 17:17:16.721037 1306627 configset.go:348] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]</span></span><br><span class="line">  <span class="comment"># certificate embedded in the kubeconfig file for the admin to use and for kubeadm itself renewed  # 嵌入在kubeconfig文件中的证书，供管理员使用，并对kubeadm本身进行更新 (admin.conf )</span></span><br><span class="line">  <span class="comment"># certificate for serving the Kubernetes API renewed               # 更新Kubernetes API服务证书</span></span><br><span class="line">  <span class="comment"># certificate the apiserver uses to access etcd renewed            # 服务器访问etcd所使用的证书已更新</span></span><br><span class="line">  <span class="comment"># certificate for the API server to connect to kubelet renewed     # API服务器连接到kubelet的证书已更新</span></span><br><span class="line">  <span class="comment"># certificate embedded in the kubeconfig file for the controller manager to use renewed  # 证书嵌入在kubeconfig文件中，供控制器管理器使用更新 (controller-manager.conf)</span></span><br><span class="line">  <span class="comment"># certificate for liveness probes to healthcheck etcd renewed        # 健康检查etcd激活探针证书续期</span></span><br><span class="line">  <span class="comment"># certificate for etcd nodes to communicate with each other renewed  # 用于etcd节点之间通信的证书更新</span></span><br><span class="line">  <span class="comment"># certificate for serving etcd renewed                               # 续期etcd“服务证书”</span></span><br><span class="line">  <span class="comment"># certificate for the front proxy client renewed                     # 前代理客户端的证书更新</span></span><br><span class="line">  <span class="comment"># certificate embedded in the kubeconfig file for the scheduler manager to use renewed # 证书嵌入在kubeconfig文件中，供调度器管理器使用更新 (scheduler.conf  )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 若看到已完成续订证书，您必须重新启动kube apiserver、kube控制器管理器、kube调度器等，以便它们可以使用新证书，表示证书续期成功</span></span><br><span class="line">Done renewing certificates. You must restart the kube-apiserver, kube-controller-manager, kube-scheduler and etcd, so that they can use the new certificates.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查证书续签以及到期时间</span></span><br><span class="line">~/.k8s$ kubeadm certs check-expiration</span><br><span class="line">  <span class="comment"># [check-expiration] Reading configuration from the cluster...</span></span><br><span class="line">  <span class="comment"># [check-expiration] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># CERTIFICATE                EXPIRES                  RESIDUAL TIME   CERTIFICATE AUTHORITY   EXTERNALLY MANAGED</span></span><br><span class="line">  <span class="comment"># admin.conf                 Jan 31, 2024 09:26 UTC   364d            ca                      no</span></span><br><span class="line">  <span class="comment"># apiserver                  Jan 31, 2024 09:26 UTC   364d            ca                      no</span></span><br><span class="line">  <span class="comment"># apiserver-etcd-client      Jan 31, 2024 09:26 UTC   364d            etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># apiserver-kubelet-client   Jan 31, 2024 09:26 UTC   364d            ca                      no</span></span><br><span class="line">  <span class="comment"># controller-manager.conf    Jan 31, 2024 09:26 UTC   364d            ca                      no</span></span><br><span class="line">  <span class="comment"># etcd-healthcheck-client    Jan 31, 2024 09:26 UTC   364d            etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># etcd-peer                  Jan 31, 2024 09:26 UTC   364d            etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># etcd-server                Jan 31, 2024 09:26 UTC   364d            etcd-ca                 no</span></span><br><span class="line">  <span class="comment"># front-proxy-client         Jan 31, 2024 09:26 UTC   364d            front-proxy-ca          no</span></span><br><span class="line">  <span class="comment"># scheduler.conf             Jan 31, 2024 09:26 UTC   364d            ca                      no</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># CERTIFICATE AUTHORITY   EXPIRES                  RESIDUAL TIME   EXTERNALLY MANAGED</span></span><br><span class="line">  <span class="comment"># ca                      Jan 13, 2032 10:42 UTC   8y              no</span></span><br><span class="line">  <span class="comment"># etcd-ca                 Jan 13, 2032 10:42 UTC   8y              no</span></span><br><span class="line">  <span class="comment"># front-proxy-ca          Jan 13, 2032 10:42 UTC   8y              no</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用stat命令查看 apiserver.key 与 apiserver.crt 证书修改时间</span></span><br><span class="line">/etc/kubernetes/pki$ <span class="built_in">stat</span> apiserver.key  apiserver.crt</span><br><span class="line">  <span class="comment">#   File: apiserver.key</span></span><br><span class="line">  <span class="comment">#   Size: 1675            Blocks: 8          IO Block: 4096   regular file</span></span><br><span class="line">  <span class="comment"># Device: fd00h/64768d    Inode: 3670556     Links: 1</span></span><br><span class="line">  <span class="comment"># Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line">  <span class="comment"># Access: 2022-04-28 12:55:13.456040564 +0800 最近访问：</span></span><br><span class="line">  <span class="comment"># Modify: 2023-01-31 17:26:51.108767670 +0800 最近更改：</span></span><br><span class="line">  <span class="comment"># Change: 2023-01-31 17:26:51.108767670 +0800 最近改动：</span></span><br><span class="line">  <span class="comment">#   Birth: -</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#   File: apiserver.crt</span></span><br><span class="line">  <span class="comment">#   Size: 1338            Blocks: 8          IO Block: 4096   regular file</span></span><br><span class="line">  <span class="comment"># Device: fd00h/64768d    Inode: 3670557     Links: 1</span></span><br><span class="line">  <span class="comment"># Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span></span><br><span class="line">  <span class="comment"># Access: 2023-01-31 17:28:58.104917185 +0800</span></span><br><span class="line">  <span class="comment"># Modify: 2023-01-31 17:26:51.108767670 +0800</span></span><br><span class="line">  <span class="comment"># Change: 2023-01-31 17:26:51.108767670 +0800</span></span><br><span class="line">  <span class="comment">#   Birth: -</span></span><br></pre></td></tr></table></figure></p><p><br/></p><p>4.完成证书更新后，此时我们需要重新生成新的K8S集群master节点所需的相关配置文件，例如 <code>/etc/kubernetes</code> 目录下的 <code>admin.conf / controller-manager.conf / kubelet.conf / scheduler.conf</code> 相关文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化所需配置文件 </span></span><br><span class="line">$ rm -rf /etc/kubernetes/*.conf</span><br><span class="line">$ kubeadm init phase kubeconfig all --config=kubeadm-init-config.yaml</span><br><span class="line">  <span class="comment"># [kubeconfig] Using kubeconfig folder "/etc/kubernetes"</span></span><br><span class="line">  <span class="comment"># [kubeconfig] Writing "admin.conf" kubeconfig file</span></span><br><span class="line">  <span class="comment"># [kubeconfig] Writing "kubelet.conf" kubeconfig file</span></span><br><span class="line">  <span class="comment"># [kubeconfig] Writing "controller-manager.conf" kubeconfig file</span></span><br><span class="line">  <span class="comment"># [kubeconfig] Writing "scheduler.conf" kubeconfig file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到文件时间已经发生变化</span></span><br><span class="line">$ ls -alh /etc/kubernetes/*.conf</span><br><span class="line">-rw------- 1 root root 5.6K Jan 31 21:53 /etc/kubernetes/admin.conf</span><br><span class="line">-rw------- 1 root root 5.6K Jan 31 21:53 /etc/kubernetes/controller-manager.conf</span><br><span class="line">-rw------- 1 root root 5.6K Jan 31 21:53 /etc/kubernetes/kubelet.conf</span><br><span class="line">-rw------- 1 root root 5.5K Jan 31 21:53 /etc/kubernetes/scheduler.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为防止 kubelet 客户端证书轮换失败，我们需要将（此处坑有点大）kubelet-client-* 进行删除，在kubelet服务重启时又会自动生成</span></span><br><span class="line"><span class="comment"># 如果此轮换过程失败，你可能会在 kube-apiserver 日志中看到诸如 x509: certificate has expired or is not yet valid 之类的错误</span></span><br><span class="line"><span class="comment"># https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#kubelet-client-cert</span></span><br><span class="line">rm -rf /var/lib/kubelet/pki/kubelet-client-*</span><br></pre></td></tr></table></figure></p><p>补充: 若要生成其他master节点的K8S配置文件请参考如下，例如，此处是 weiyigeek-108 控制平面节点的conf配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $ mkdir -vp /tmp/kubernetes/</span></span><br><span class="line"><span class="comment"># $ kubeadm init phase kubeconfig all --node-name weiyigeek-108 --kubeconfig-dir /tmp/kubernetes/</span></span><br></pre></td></tr></table></figure></p><p><br/></p><p>5.按照提示将当前操作集群 master（weiyigeek-107） 节点上重启 kube-apiserver, kube-controller-manager, kube-scheduler 以及 etcd 等相关服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将新生成的集群连接配置文件覆盖到 ~/.kube/config </span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'yes'</span> |  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 kube-apiserver, kube-controller-manager, kube-scheduler 及 etcd 等相关服务（建议一个一个pod删除，启动后再进行下一步操作）</span></span><br><span class="line">kubectl -n kube-system delete pod -l <span class="string">'component=kube-apiserver'</span></span><br><span class="line">kubectl -n kube-system delete pod -l <span class="string">'component=kube-controller-manager'</span></span><br><span class="line">kubectl -n kube-system delete pod -l <span class="string">'component=kube-scheduler'</span></span><br><span class="line">kubectl -n kube-system delete pod -l <span class="string">'component=etcd'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启节点上 kubelet 服务</span></span><br><span class="line">systemctl restart kubelet.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubelet 服务状态</span></span><br><span class="line">systemctl status -l kubelet.service </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubelet 服务运行日志有无异常（有异常请依次解决）</span></span><br><span class="line">journalctl -xefu kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 kubelet 后 kubelet 客户端证书轮换自动生成新的 pem 证书</span></span><br><span class="line">ls -alh /var/lib/kubelet/pki/kubelet-client-current.pem</span><br><span class="line">  <span class="comment"># lrwxrwxrwx 1 root root 59 Jan 31 22:29 /var/lib/kubelet/pki/kubelet-client-current.pem -&gt; /var/lib/kubelet/pki/kubelet-client-2023-01-31-22-29-20.pem</span></span><br></pre></td></tr></table></figure><p><br/></p><p>6.此时在（weiyigeek-107） 节点上运行kubectl相关命令，则不会报证书到期了，我们可正常使用相关命令.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">  <span class="comment"># NAME       STATUS   ROLES                  AGE     VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME</span></span><br><span class="line">  <span class="comment"># weiyigeek-107   Ready    control-plane,master   381d    v1.23.1   192.168.12.107   &lt;none&gt;        Ubuntu 20.04.1 LTS   5.4.0-137-generic   containerd://1.4.12</span></span><br><span class="line">  <span class="comment"># weiyigeek-108   Ready    control-plane,master   57m     v1.23.1   192.168.12.108   &lt;none&gt;        Ubuntu 20.04.3 LTS   5.4.0-137-generic   containerd://1.4.12</span></span><br><span class="line">  <span class="comment"># weiyigeek-109   Ready    control-plane,master   2m19s   v1.23.1   192.168.12.109   &lt;none&gt;        Ubuntu 20.04.3 LTS   5.4.0-137-generic   containerd://1.4.12</span></span><br><span class="line">  <span class="comment"># weiyigeek-223   Ready    work                   380d    v1.23.1   192.168.12.223   &lt;none&gt;        Ubuntu 20.04.3 LTS   5.4.0-94-generic    containerd://1.4.12</span></span><br><span class="line">  <span class="comment"># weiyigeek-224   Ready    work                   380d    v1.23.1   192.168.12.224   &lt;none&gt;        Ubuntu 20.04.3 LTS   5.4.0-42-generic    containerd://1.4.12</span></span><br><span class="line">  <span class="comment"># weiyigeek-225   Ready    work                   381d    v1.23.1   192.168.12.225   &lt;none&gt;        Ubuntu 20.04.3 LTS   5.4.0-94-generic    containerd://1.4.12</span></span><br><span class="line">  <span class="comment"># weiyigeek-226   Ready    work                   220d    v1.23.1   192.168.12.226   &lt;none&gt;        Ubuntu 20.04.3 LTS   5.4.0-80-generic    containerd://1.4.12</span></span><br><span class="line"></span><br><span class="line">$ kubectl get pod -n kube-system  | egrep <span class="string">"kube-apiserver|kube-controller-manager|kube-scheduler|etcd"</span></span><br><span class="line">  <span class="comment"># etcd-weiyigeek-107                             1/1     Running   1              380d</span></span><br><span class="line">  <span class="comment"># etcd-weiyigeek-108                             1/1     Running   0              96d</span></span><br><span class="line">  <span class="comment"># etcd-weiyigeek-109                             1/1     Running   0              380d</span></span><br><span class="line">  <span class="comment"># kube-apiserver-weiyigeek-107                   1/1     Running   0              380d</span></span><br><span class="line">  <span class="comment"># kube-apiserver-weiyigeek-108                   1/1     Running   0              380d</span></span><br><span class="line">  <span class="comment"># kube-apiserver-weiyigeek-109                   1/1     Running   0              380d</span></span><br><span class="line">  <span class="comment"># kube-controller-manager-weiyigeek-107          1/1     Running   2 (380d ago)   380d</span></span><br><span class="line">  <span class="comment"># kube-controller-manager-weiyigeek-108          1/1     Running   1 (15d ago)    380d</span></span><br><span class="line">  <span class="comment"># kube-controller-manager-weiyigeek-109          1/1     Running   1 (380d ago)   380d</span></span><br><span class="line">  <span class="comment"># kube-scheduler-weiyigeek-107                   1/1     Running   3 (15d ago)    380d</span></span><br><span class="line">  <span class="comment"># kube-scheduler-weiyigeek-108                   1/1     Running   2 (15d ago)    380d</span></span><br><span class="line">  <span class="comment"># kube-scheduler-weiyigeek-109                   1/1     Running   1 (380d ago)   380d</span></span><br></pre></td></tr></table></figure></p><p><br/></p><p>7.查看集群的健康状态，即调度器、控制器以及etcd数据库是否正常。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get cs</span><br><span class="line">Warning: v1 ComponentStatus is deprecated <span class="keyword">in</span> v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE                         ERROR</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">"health"</span>:<span class="string">"true"</span>,<span class="string">"reason"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure></p><p>你是否认为，实践到这里就结束了，当然不是由于此处是高可用K8S集群，更新证书后坑，远不止于此。</p><p>有兴趣的，请继续看下节。</p><hr><h3 id="4-集群证书更新后-calico-amp-amp-kube-proxy-相关操作"><a href="#4-集群证书更新后-calico-amp-amp-kube-proxy-相关操作" class="headerlink" title="4.集群证书更新后 calico &amp;&amp; kube-proxy 相关操作"></a>4.集群证书更新后 calico &amp;&amp; kube-proxy 相关操作</h3><p>描述：在进行该K8S高可用集群安装时，参照了我博客中的《在Ubuntu安装部署K8S高可用集群使用初体验》文章，我将文章链接地址( <a href="https://blog.weiyigeek.top/2020/4-27-470.html#0x04-高可用集群使用初体验">https://blog.weiyigeek.top/2020/4-27-470.html#0x04-高可用集群使用初体验</a> ), 其中在使用calico网络插件时选择将 Calico 数据存储在 etcd datastore 之中，所以在进行calico安装或者使用时需要将数据存储到etcd中，则肯定需要链接到etcd数据中，此处 calico-etcd.yaml 配置清单中的etcd-ca、etcd-cert、etcd-key 字段的值仍然为原证书，由于我们前面已经更新了所有组件证书，所以再进行数据的CURD肯定是无法链接到etcd，则此时我们需要重新该 <code>calico-etcd.yaml</code> 资源配置文件。</p><p>在更新集群证书后发现的calico以及业务应用的异常情况，其中最明显的就是calic无法正常启动。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n kube-system</span><br><span class="line">  NAME                                      READY   STATUS              RESTARTS        AGE</span><br><span class="line">  calico-kube-controllers-6cf9b574f-zlrjn   0/1     Running             0               3s</span><br><span class="line">  calico-node-5q8lq                         0/1     CrashLoopBackOff    11 (6s ago)     25m</span><br><span class="line">  calico-node-62zd9                         0/1     CrashLoopBackOff    9 (5m6s ago)    25m</span><br><span class="line">  calico-node-85b7k                         0/1     Running             11 (66s ago)    25m</span><br><span class="line">  calico-node-8mt8q                         0/1     Running             3 (66s ago)     4m43s</span><br><span class="line">  calico-node-cdkf8                         0/1     CrashLoopBackOff    9 (5m6s ago)    25m</span><br><span class="line">  calico-node-jgm6q                         0/1     CrashLoopBackOff    9 (4m56s ago)   25m</span><br><span class="line">  calico-node-x2b9q                         0/1     CrashLoopBackOff    9 (5m6s ago)    25m</span><br><span class="line">  coredns-65c54cc984-7vt8m                  0/1     ContainerCreating   0               7m5s</span><br><span class="line">  coredns-65c54cc984-hf774                  0/1     ContainerCreating   0               25m</span><br></pre></td></tr></table></figure></p><p><br/></p><p><strong>操作步骤:</strong><br>步骤 01.此处参考上面的文章进行更改etcd数据库证书链接字段。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (1) Install Calico with etcd datastore (使用etcd数据存储安装Calico) </span></span><br><span class="line">curl https://docs.projectcalico.org/manifests/calico-etcd.yaml -O</span><br><span class="line"></span><br><span class="line"><span class="comment"># calico-etcd 网络与etc集群连接修改(此处指定pod子网地址)</span></span><br><span class="line">ETCD_CA=`cat /etc/kubernetes/pki/etcd/ca.crt | base64 | tr -d <span class="string">'\n'</span>`</span><br><span class="line">ETCD_CERT=`cat /etc/kubernetes/pki/etcd/server.crt | base64 | tr -d <span class="string">'\n'</span>`</span><br><span class="line">ETCD_KEY=`sudo cat /etc/kubernetes/pki/etcd/server.key | base64 | tr -d <span class="string">'\n'</span>`</span><br><span class="line">POD_SUBNET=`sudo cat /etc/kubernetes/manifests/kube-controller-manager.yaml | grep cluster-cidr= | awk -F= <span class="string">'&#123;print $NF&#125;'</span>`</span><br><span class="line">sed -i <span class="string">"s@# etcd-key: null@etcd-key: <span class="variable">$&#123;ETCD_KEY&#125;</span>@g; s@# etcd-cert: null@etcd-cert: <span class="variable">$&#123;ETCD_CERT&#125;</span>@g; s@# etcd-ca: null@etcd-ca: <span class="variable">$&#123;ETCD_CA&#125;</span>@g"</span> calico-etcd.yaml</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">'s#etcd_ca: ""#etcd_ca: "/calico-secrets/etcd-ca"#g; s#etcd_cert: ""#etcd_cert: "/calico-secrets/etcd-cert"#g; s#etcd_key: "" #etcd_key: "/calico-secrets/etcd-key" #g'</span> calico-etcd.yaml</span><br><span class="line">sed -i <span class="string">'s#etcd_endpoints: "http://&lt;ETCD_IP&gt;:&lt;ETCD_PORT&gt;"#etcd_endpoints: "https://192.168.12.107:2379,https://192.168.12.108:2379,https://192.168.12.109:2379"#g'</span> calico-etcd.yaml</span><br><span class="line">sed -i <span class="string">'s@# - name: CALICO_IPV4POOL_CIDR@- name: CALICO_IPV4POOL_CIDR@g; s@#   value: "192.168.0.0/16"@  value: '</span><span class="string">"<span class="variable">$&#123;POD_SUBNET&#125;</span>"</span><span class="string">'@g'</span> calico-etcd.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) 覆盖部署calico到K8S集群中</span></span><br><span class="line">kubectl apply -f calico-etcd.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3) 此处对比两个配置清单文件即可发现证书的不同。</span></span><br><span class="line">diff calico-etcd.yaml calico-etcd.yaml.bak</span><br><span class="line">17,18c17,18</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 02.在master节点(weiyigeek-107)节点上执行如下命令，重启 calico 以及各节点中的 kube-proxy Pod 容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calico-node</span></span><br><span class="line">kubectl delete pod -n kube-system -l k8s-app=calico-node</span><br><span class="line"></span><br><span class="line"><span class="comment"># kube-proxy</span></span><br><span class="line">kubectl delete pod -n kube-system -l k8s-app=calico-node</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 03.等待一段时间后，验证 calico-node 、kube-proxy服务启动情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n kube-system  | egrep <span class="string">"calico|kube-proxy"</span></span><br><span class="line">calico-kube-controllers-6cf9b574f-42jnz   1/1     Running   0               98m</span><br><span class="line">calico-node-dvvxk                         1/1     Running   0               98m</span><br><span class="line">calico-node-g9svc                         1/1     Running   0               98m</span><br><span class="line">calico-node-ggxqp                         1/1     Running   0               98m</span><br><span class="line">calico-node-jps97                         1/1     Running   0               98m</span><br><span class="line">calico-node-qf7cj                         1/1     Running   0               92m</span><br><span class="line">calico-node-vvw9f                         1/1     Running   0               98m</span><br><span class="line">calico-node-zvz8r                         1/1     Running   0               98m</span><br><span class="line">kube-proxy-25p5s                          1/1     Running   0               220d</span><br><span class="line">kube-proxy-8bl7f                          1/1     Running   0               94m</span><br><span class="line">kube-proxy-8jxvr                          1/1     Running   0               93m</span><br><span class="line">kube-proxy-d79mp                          1/1     Running   0               381d</span><br><span class="line">kube-proxy-dtdtm                          1/1     Running   0               108m</span><br><span class="line">kube-proxy-l7jxp                          1/1     Running   0               93m</span><br><span class="line">kube-proxy-nlgln                          1/1     Running   0               381d</span><br></pre></td></tr></table></figure></p><p>步骤 04.访问通过nodePort暴露的业务系统验证是否可以从任意节点代理转发访问。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc,pod -n devops -l app=jenkins</span><br><span class="line">  <span class="comment"># NAME              TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)                          AGE</span></span><br><span class="line">  <span class="comment"># service/jenkins   NodePort   10.109.163.223   &lt;none&gt;        8080:30001/TCP,50000:30634/TCP   380d</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># NAME                           READY   STATUS    RESTARTS   AGE</span></span><br><span class="line">  <span class="comment"># pod/jenkins-7fc6f4fcf6-glqxj   1/1     Running   0          118m</span></span><br><span class="line"></span><br><span class="line">$ curl -sI 10.109.163.223:8080 | head -n 1</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">$ curl -s 10.109.163.223:8080  | grep -oP <span class="string">"&lt;title&gt;\S.+&lt;/title&gt;"</span></span><br><span class="line">$ curl -s 192.168.12.107:30001  | grep -oP <span class="string">"&lt;title&gt;\S.+&lt;/title&gt;"</span></span><br><span class="line">&lt;title&gt;Dashboard [Jenkins]&lt;/title&gt;</span><br></pre></td></tr></table></figure></p><p>好的，此问题也已经解决了。</p><p>下面继续来看，如何在更新证书后<code>删除或者新增</code>控制面板节点以及工作节点。</p><hr><h3 id="5-控制平面-Master-节点的移除-amp-amp-添加"><a href="#5-控制平面-Master-节点的移除-amp-amp-添加" class="headerlink" title="5.控制平面(Master)节点的移除&amp;&amp;添加"></a>5.控制平面(Master)节点的移除&amp;&amp;添加</h3><p>描述: 有时在更新集群证书后，某一个控制平面的节点可能一致不正常，我们也找不到解决办法时，最终解决方案就是重置该master节点并重新加入到K8S集群中。</p><p> <br/></p><p><strong>操作流程</strong></p><p>步骤 01.将需要master节点，例如此处(weiyigeek-108)节点设置不可调度，温馨提示操作前请注意备份该节点上的相关数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 weiyigeek-107 节点上执行如下命令，设置节点设置不可调度，此时节点状态变成：Ready,SchedulingDisabled</span></span><br><span class="line">kubectl drain weiyigeek-108 --delete-local-data  --delete-emptydir-data --force --ignore-daemonsets</span><br><span class="line">  <span class="comment"># node/weiyigeek-108 cordoned</span></span><br><span class="line">  <span class="comment"># WARNING: ignoring DaemonSet-managed Pods: kube-system/calico-node-qf7cj, kube-system/kube-proxy-8jxvr</span></span><br><span class="line">  <span class="comment"># node/weiyigeek-108 drained</span></span><br><span class="line"></span><br><span class="line">kubectl get node  weiyigeek-108</span><br><span class="line">  NAME       STATUS                     ROLES                  AGE     VERSION</span><br><span class="line">  weiyigeek-108   Ready,SchedulingDisabled   control-plane,master   3h50m   v1.23.1</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集群中移除 weiyigeek-108 节点</span></span><br><span class="line">kubectl delete node weiyigeek-109</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 02.生成master节点以及工作节点加入到K8S集群的认证Token及其命令示例（值得学习借鉴）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (1) 查看token是否失效默认是24H，如果失效过期可以重新进行生成token并打印加入命令</span></span><br><span class="line">kubeadm token list</span><br><span class="line">kubeadm token create --<span class="built_in">print</span>-join-command</span><br><span class="line">  <span class="comment"># kubeadm join slb-vip.k8s:16443 --token vkhqa1.t3gtrbowlalt8um5 --discovery-token-ca-cert-hash sha256:bfc86e13da79a1ec5f53cef99661e4e3f51adda59c525cb9377cfe59956b1e59 # 注意，配置清单中会使用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (2)从节点的 kubeadm 加入到k8s集群之中 (推荐)，使用此命令调用init工作流的单个阶段</span></span><br><span class="line">kubeadm init phase upload-certs --upload-certs</span><br><span class="line">  <span class="comment"># [upload-certs] Using certificate key:</span></span><br><span class="line">  <span class="comment"># c6a084cb06aaae2f4581145dbbe6057ce111c88fdac4ff4405a0a2db58882d76     # 注意，配置清单中会使用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) 获取CA（证书）公钥哈希值</span></span><br><span class="line">openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span class="string">'s/^ .* //'</span></span><br><span class="line"><span class="comment"># (stdin)= bfc86e13da79a1ec5f53cef99661e4e3f51adda59c525cb9377cfe59956b1e59  </span></span><br><span class="line"><span class="comment"># 此处是公钥哈希值(一台机器上ca证书不变就一直是该sha256的值)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (4) 进行收到组合加入集群的 master 节点的 join 命令如下:</span></span><br><span class="line">kubeadm join slb-vip.k8s:16443 --token ejwx62.vqwog6il5p83uk7y \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:bfc86e13da79a1ec5f53cef99661e4e3f51adda59c525cb9377cfe59956b1e59 \</span><br><span class="line">--control-plane --certificate-key c6a084cb06aaae2f4581145dbbe6057ce111c88fdac4ff4405a0a2db58882d76</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 03.通过ssh远程登录<code>weiyigeek-108</code>节点重置该节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop kubelet</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> y | kubeadm reset</span><br><span class="line">sudo rm -rf <span class="variable">$HOME</span>/.kube </span><br><span class="line">sudo rm -rf /var/lib/cni/ /etc/cni/ /var/lib/kubelet/* </span><br><span class="line">ipvsadm --clear</span><br><span class="line">iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</span><br><span class="line"></span><br><span class="line">systemctl start kubelet; systemctl status kubelet</span><br></pre></td></tr></table></figure><p>温馨提示: 如果主Master节点在初始化时候出错需要重新配置时候,请执行以上述命令进行重置;</p><p><br/></p><p>步骤 04.准备控制平面节点加入到集群的JoinConfiguration资源配置清单<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">vim</span> <span class="string">join-k8s.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">caCertPath:</span> <span class="string">/etc/kubernetes/pki/ca.crt</span></span><br><span class="line"><span class="attr">discovery:</span></span><br><span class="line"><span class="attr">  bootstrapToken:</span></span><br><span class="line"><span class="attr">    apiServerEndpoint:</span> <span class="string">slb-vip.k8s:16443</span>   <span class="comment"># 高可用的APIServer地址</span></span><br><span class="line"><span class="attr">    token:</span> <span class="string">vkhqa1.t3gtrbowlalt8um5</span>         <span class="comment"># 上述步骤生成Token</span></span><br><span class="line"><span class="attr">    caCertHashes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"sha256:bfc86e13da79a1ec5f53cef99661e4e3f51adda59c525cb9377cfe59956b1e59"</span>   <span class="comment"># 上述步骤获取到的CA（证书）公钥哈希值</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">5</span><span class="string">m0s</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">JoinConfiguration</span></span><br><span class="line"><span class="attr">controlPlane:</span></span><br><span class="line"><span class="attr">  certificateKey:</span> <span class="string">"c6a084cb06aaae2f4581145dbbe6057ce111c88fdac4ff4405a0a2db58882d76"</span>  <span class="comment"># 上述步骤获取到 certificate key</span></span><br><span class="line"><span class="attr">  localAPIEndpoint:</span></span><br><span class="line"><span class="attr">    advertiseAddress:</span> <span class="number">192.168</span><span class="number">.12</span><span class="number">.108</span>      <span class="comment"># 本地APIServer节点地址(即weiyigeek-108节点机器地址)</span></span><br><span class="line"><span class="attr">    bindPort:</span> <span class="number">6443</span>                        <span class="comment"># 本地APIServer节点端口</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line"><span class="attr">  criSocket:</span> <span class="string">/run/containerd/containerd.sock</span>  <span class="comment"># 重点，在1.24.x之前默认是使用docker-shim，此处我们指定使用containerd</span></span><br><span class="line"><span class="attr">  imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">weiyigeek-108</span>                              <span class="comment"># 重点，节点名称</span></span><br><span class="line"><span class="attr">  taints:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br></pre></td></tr></table></figure></p><p>温馨提示: 在 bootstrapToken 字段中也可跳过 caCertHashes 认证，请键值为<code>unsafeSkipCAVerification: true</code>。</p><p><br/></p><p>步骤 05.证书更新后原有的master节点移除加入前，需要针对久的etcd数据库进行处理操作。</p><p>此处有个小插曲，由于各master节点组成了一个高可用集群，每个master节点上都运行了etcd服务，以实现etcd数据库的高可用，有</p><p>Kubernetes 与 Etcd 版本与证书关联说明:</p><ul><li>ETCD 版本小于等于v1.9版本，etcd默认是不使用TLS连接，没有etcd相关证书，只需要更新master证书即可。</li><li>ETCD 版本大于等于v1.10版本，etcd默认开启TLS，需要更新etcd证书和master证书。</li></ul><p>此处我们的etcd版本是v3.5.x是开启TLS的，前面我们重启在master节点的etcd的相关pod后将会自动使用最新的证书，而在将master节点移除重新加入需进行如下操作，否则将会报错（查看尾部的错误实例）:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -n kube-system -it etcd-weiyigeek-107 /bin/sh</span><br><span class="line"><span class="comment"># etcd 集群成员列表</span></span><br><span class="line">$ etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member list</span><br><span class="line">  <span class="comment"># 2db31a5d67ec1034, started, weiyigeek-108, https://192.168.12.108:2380, https://192.168.12.108:2379, false</span></span><br><span class="line">  <span class="comment"># 42efe7cca897d765, started, weiyigeek-109, https://192.168.12.109:2380, https://192.168.12.109:2379, false</span></span><br><span class="line">  <span class="comment"># 471323846709334f, started, weiyigeek-107, https://192.168.12.107:2380, https://192.168.12.107:2379, false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd 集群节点数据状态</span></span><br><span class="line">$ etcdctl --endpoints https://192.168.12.107:2379,https://192.168.12.108:2379,https://192.168.12.109:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key endpoint status</span><br><span class="line">  <span class="comment"># https://192.168.12.107:2379, 471323846709334f, 3.5.1, 324 MB, true, false, 8, 109396908, 109396908,</span></span><br><span class="line">  <span class="comment"># https://192.168.12.108:2379, 2db31a5d67ec1034, 3.5.1, 324 MB, false, false, 8, 109396916, 109396916,</span></span><br><span class="line">  <span class="comment"># https://192.168.12.109:2379, 42efe7cca897d765, 3.5.1, 324 MB, false, false, 8, 109396922, 109396922,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  移除 2db31a5d67ec1034 成员（weiyigeek-108 旧节点）</span></span><br><span class="line">$ etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key member remove 7e66da9dd902d557</span><br><span class="line">Member 2db31a5d67ec1034 removed from cluster 3a7f4f11f646b97b</span><br></pre></td></tr></table></figure><p><br/></p><p>步骤 06.在 weiyigeek-108 节点上执行加入集群命令, 若加入成果可以通过<code>kubectl get nods</code>命令查看<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止该节点上所有 Pod 防止端口占用</span></span><br><span class="line">crictl stop $(crictl ps -a -q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照 JoinConfiguration 资源配置清单加入到集群中，--v=5显示更完整的操作过程日志，排错必备。</span></span><br><span class="line">kubeadm join --config=join-k8s.yaml --v=5</span><br><span class="line">  <span class="comment"># 若显示如下提示则加入成功，否则请排查异常情况。</span></span><br><span class="line">  <span class="comment"># This node has joined the cluster and a new control plane instance was created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To start administering your cluster from this node, you need to run the following as a regular user:</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">$ kubectl get node weiyigeek-108</span><br><span class="line">  <span class="comment"># NAME       STATUS     ROLES                  AGE     VERSION</span></span><br><span class="line">  <span class="comment"># weiyigeek-108   Ready      control-plane,master   3m9s    v1.23.1</span></span><br></pre></td></tr></table></figure></p><p>温馨提示: 如果加入主master节点时一直停留在 pre-flight 状态，请在第额外的几个节点上执行命令检查：<code>curl -ik https://设置APISERVER地址:6443/version</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ curl -ik https://slb-vip.k8s:16443/version</span><br><span class="line"><span class="comment"># 正常状态下的输出</span></span><br><span class="line">HTTP/2 200</span><br><span class="line">audit-id: 77c614cb-0c27-42f5-a852-b5ef8415361f</span><br><span class="line">cache-control: no-cache, private</span><br><span class="line">content-type: application/json</span><br><span class="line">x-kubernetes-pf-flowschema-uid: 41a01a35-c480-4cfd-8854-494261622406</span><br><span class="line">x-kubernetes-pf-prioritylevel-uid: 4cfd380c-d39c-490f-96b0-dd4ed07be4e0</span><br><span class="line">content-length: 263</span><br><span class="line">date: Wed, 01 Feb 2023 07:34:01 GMT</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"major"</span>: <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"minor"</span>: <span class="string">"23"</span>,</span><br><span class="line">  <span class="string">"gitVersion"</span>: <span class="string">"v1.23.0"</span>,</span><br><span class="line">  <span class="string">"gitCommit"</span>: <span class="string">"ab69524f795c42094a6630298ff53f3c3ebab7f4"</span>,</span><br><span class="line">  <span class="string">"gitTreeState"</span>: <span class="string">"clean"</span>,</span><br><span class="line">  <span class="string">"buildDate"</span>: <span class="string">"2021-12-07T18:09:57Z"</span>,</span><br><span class="line">  <span class="string">"goVersion"</span>: <span class="string">"go1.17.3"</span>,</span><br><span class="line">  <span class="string">"compiler"</span>: <span class="string">"gc"</span>,</span><br><span class="line">  <span class="string">"platform"</span>: <span class="string">"linux/amd64"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br/></p><p>至此，实践完毕!</p><hr><h3 id="6-工作平面-Work-节点的移除-amp-amp-添加"><a href="#6-工作平面-Work-节点的移除-amp-amp-添加" class="headerlink" title="6.工作平面(Work)节点的移除&amp;&amp;添加"></a>6.工作平面(Work)节点的移除&amp;&amp;添加</h3><p>描述: k8s集群中工作节点的添加与移除，和master节点移除添加方法基本一致，不同之处在于加入集群的配置清单，你可以对照一下master节点与node节点加入集群时的配置清单。</p><p>此处，也不在累述直接快速上脚本。</p><p>步骤 01.在master节点上执行，将设weiyigeek-226节点置不可调度,即不分配新的资源到该节点上，并且驱逐pod到其他工作节点上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 温馨提示: drain命令会自动把node设置为不可调度，所以可以省略上面执行的cordon命令</span></span><br><span class="line">kubectl cordon weiyigeek-226</span><br><span class="line">kubectl drain weiyigeek-226 --delete-emptydir-data --force --ignore-daemonsets</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 02.在weiyigeek-226工作节点上执行重置节点命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop kubelet</span><br><span class="line"><span class="built_in">echo</span> y | kubeadm reset</span><br><span class="line">sudo rm -rf <span class="variable">$HOME</span>/.kube; sudo rm -rf /var/lib/cni/ /etc/cni/ /var/lib/kubelet/* </span><br><span class="line">ipvsadm --clear; iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</span><br><span class="line">systemctl start kubelet; systemctl status kubelet</span><br></pre></td></tr></table></figure></p><p><br/></p><p>步骤 03.两种方式将工作节点加入K8S集群中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.命令行模式</span></span><br><span class="line">kubeadm join 192.168.80.137:6443 --token 新生成的Token填写此处 --discovery-token-ca-cert-hash sha256:获取的公钥哈希值填写此处</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.配置清单模式</span></span><br><span class="line">tee &gt; join-k8s.yaml &lt;&lt;EOF</span><br><span class="line">cat join-k8s.yaml</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">caCertPath: /etc/kubernetes/pki/ca.crt</span><br><span class="line">discovery:</span><br><span class="line">  bootstrapToken:</span><br><span class="line">    apiServerEndpoint: slb-vip.k8s:16443</span><br><span class="line">    token: vkhqa1.t3gtrbowlalt8um5</span><br><span class="line">    unsafeSkipCAVerification: <span class="literal">true</span></span><br><span class="line">  timeout: 5m0s</span><br><span class="line">  tlsBootstrapToken: vkhqa1.t3gtrbowlalt8um5</span><br><span class="line">kind: JoinConfiguration</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: weiyigeek-226</span><br><span class="line">  taints: null</span><br><span class="line">EOF</span><br><span class="line">kubeadm join --config=join-k8s.yaml --v=5</span><br></pre></td></tr></table></figure><p><br/></p><p>步骤 04.在master节点查看加入的工作的节点，此处设置其work标签。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes weiyigeek-226 node-role.kubernetes.io/work=<span class="built_in">test</span></span><br><span class="line">kubectl get nodes weiyigeek-226</span><br><span class="line">  <span class="comment"># NAME       STATUS   ROLES   AGE    VERSION</span></span><br><span class="line">  <span class="comment"># weiyigeek-226   Ready    work    10m   v1.23.1</span></span><br></pre></td></tr></table></figure></p><p>至此，完毕!</p><p><br/></p><h3 id="n-实践所遇问题"><a href="#n-实践所遇问题" class="headerlink" title="n.实践所遇问题"></a>n.实践所遇问题</h3><h4 id="问题1-在master节点上或者非master节点上执行kubectl命令报-The-connection-to-the-server-localhost-8080-was-refused-错误"><a href="#问题1-在master节点上或者非master节点上执行kubectl命令报-The-connection-to-the-server-localhost-8080-was-refused-错误" class="headerlink" title="问题1.在master节点上或者非master节点上执行kubectl命令报 The connection to the server localhost:8080 was refused -错误"></a>问题1.在master节点上或者非master节点上执行kubectl命令报 <code>The connection to the server localhost:8080 was refused -</code>错误</h4><p>错误信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get cs</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure></p><p>错误原因: 通常情况下是当前用户下没有<code>~/.kube/config</code>或者不存在环境变量<br>解决办法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1.复制 /etc/kubernetes 目录下 admin.conf 文件到 当前用户家目录下 /.kube/config</span></span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'yes'</span> |  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2.使用 KUBECONFIG 环境变量包含一个 kubeconfig 文件列表。</span></span><br><span class="line"><span class="built_in">export</span>  KUBECONFIG=/etc/kubernetes/admin.conf:~/.kube/devops.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3.在命令执行时使用--kubeconfig参数指定配置文件</span></span><br><span class="line">kubectl config --kubeconfig=/etc/kubernetes/admin.conf</span><br></pre></td></tr></table></figure></p><p><br/></p><h4 id="问题2-在某master节点上calico-node准备状态一直为0-1并提示-connect-connection-refusedcalico-node-is-not-ready-错误"><a href="#问题2-在某master节点上calico-node准备状态一直为0-1并提示-connect-connection-refusedcalico-node-is-not-ready-错误" class="headerlink" title="问题2.在某master节点上calico-node准备状态一直为0/1并提示 connect: connection refusedcalico/node is not ready: 错误"></a>问题2.在某master节点上calico-node准备状态一直为0/1并提示 <code>connect: connection refusedcalico/node is not ready:</code> 错误</h4><p>错误信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n kube-system calico-node-v52sv</span><br><span class="line">  <span class="comment"># NAME                READY   STATUS    RESTARTS   AGE</span></span><br><span class="line">  <span class="comment"># calico-node-v52sv   0/1     Running   0          31m</span></span><br><span class="line"></span><br><span class="line">$ kubectl describe pod -n kube-system calico-node-v52sv | grep <span class="string">"not ready"</span></span><br><span class="line">  <span class="comment"># Warning  Unhealthy    33m (x2 over 33m)  kubelet  Readiness probe failed: calico/node is not ready: BIRD is not ready: Error querying BIRD: unable to connect to BIRDv4 socket: dial unix /var/run/calico/bird.ctl: connect: connection refused</span></span><br><span class="line">  <span class="comment"># calico/node is not ready: BIRD is not ready: BGP not established with 192.168.12.107,192.168.12.109,192.168.12.223,192.168.12.224,192.168.12.225,192.168.12.226</span></span><br><span class="line"></span><br><span class="line">$ kubectl logs -f --tail 50  -n kube-system calico-node-v52sv | grep <span class="string">"interface"</span></span><br><span class="line">  <span class="comment"># 2023-02-01 08:40:57.583 [INFO][69] monitor-addresses/startup.go 714: Using autodetected IPv4 address on interface br-b92e9270f33c: 172.22.0.1/16</span></span><br><span class="line">  <span class="comment"># calico 对应的 Pod 启动失败，报错：</span></span><br><span class="line">  <span class="comment"># Number of node(s) with BGP peering established = 0</span></span><br></pre></td></tr></table></figure></p><p>错误原因: 由于该节点上安装了docker并创建了容器，Calico 选择了有问题的br网卡，导致 calico-node 的 Pod 不能启动。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Calico 提供了 IP 自动检测的方法，默认是使用第一个有效网卡上的第一个有效的 IP 地址：</span></span><br><span class="line">IP_AUTODETECTION_METHOD=first-found</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点上应该是出现了有问题的网卡，可以使用以下命令查看：</span></span><br><span class="line">ip link | grep br</span><br></pre></td></tr></table></figure><br>知识扩展: calico-node daemonset 默认的策略是获取第一个取到的网卡的 ip 作为 calico node 的ip, 由于集群中网卡名称不统一所以可能导致calico获取的网卡IP不对, 所以出现此种情况下就只能 IP_AUTODETECTION_METHOD 字段指定通配符网卡名称或者IP地址。</p><p>解决办法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1.修改 yaml 配置清单中 IP 自动检测方法，在 spec.containers.env 下添加以下两行。（推荐）</span></span><br><span class="line">  - name: IP_AUTODETECTION_METHOD</span><br><span class="line">    value: <span class="string">"interface=ens.*"</span>  <span class="comment"># ens 根据实际网卡开头配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2.删除有问题的网卡（推荐），即指定网卡名称（br 开头的问题网卡）删除。</span></span><br><span class="line">ifconfig br-b92e9270f33c down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3.假如环境不依赖docker情况下，可以卸载docker, 然后重启系统即可。</span></span><br><span class="line">sudo apt-get autoremove docker docker-ce docker-engine docker.io</span><br></pre></td></tr></table></figure></p><p>最后重新启动异常Pod即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod -n kube-system calico-node-v52sv</span><br><span class="line">kubectl get nodes weiyigeek-108</span><br><span class="line">  <span class="comment"># NAME       STATUS   ROLES                  AGE   VERSION</span></span><br><span class="line">  <span class="comment"># weiyigeek-108   Ready    control-plane,master   66m   v1.23.1</span></span><br></pre></td></tr></table></figure></p><p><br/></p><h4 id="问题3-在节点加入集群时报-bridge-nf-call-iptables-does-not-exist错误问题解决"><a href="#问题3-在节点加入集群时报-bridge-nf-call-iptables-does-not-exist错误问题解决" class="headerlink" title="问题3.在节点加入集群时报 bridge-nf-call-iptables does not exist错误问题解决"></a>问题3.在节点加入集群时报 <code>bridge-nf-call-iptables does not exist</code>错误问题解决</h4><p>错误信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[preflight] Some fatal errors occurred:</span><br><span class="line">  [ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables does not exist</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">error execution phase preflight</span><br></pre></td></tr></table></figure><br>解决办法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置</span></span><br><span class="line">$ cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line">$ cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">$ modprobe br_netfilter &amp;&amp; sudo sysctl --system</span><br></pre></td></tr></table></figure></p><p><br/></p><h4 id="问题4-在启动某个节点的kubelet报Unable-to-read-config-path-quot-err-quot-path-does-not-exist-ignoring错误解决办法"><a href="#问题4-在启动某个节点的kubelet报Unable-to-read-config-path-quot-err-quot-path-does-not-exist-ignoring错误解决办法" class="headerlink" title="问题4.在启动某个节点的kubelet报Unable to read config path&quot; err=&quot;path does not exist, ignoring错误解决办法"></a>问题4.在启动某个节点的kubelet报<code>Unable to read config path&quot; err=&quot;path does not exist, ignoring</code>错误解决办法</h4><p>错误信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jan 16 14:27:25 weiyigeek-226 kubelet[882231]: E0116 14:27:25.496423  882231 kubelet.go:2347] <span class="string">"Container runtime network not ready"</span> networkReady=<span class="string">"NetworkReady=false reason:NetworkPluginNotReady message:Network plugin returns e&gt;</span></span><br><span class="line"><span class="string">Jan 16 14:27:26 weiyigeek-226 kubelet[882231]: E0116 14:27:26.482369  882231 file_linux.go:61] "</span>Unable to <span class="built_in">read</span> config path<span class="string">" err="</span>path does not exist, ignoring<span class="string">" path="</span>/etc/kubernetes/manifests<span class="string">"</span></span><br><span class="line"><span class="string">J</span></span><br></pre></td></tr></table></figure><br>解决办法: 检查 /etc/kubernetes/manifests 目录是否存储及其权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -vp /etc/kubernetes/manifests</span><br></pre></td></tr></table></figure></p><p><br/></p><h4 id="问题5-在节点加入到集群中时报the-namespace-quot-kube-system-quot-error-downloading-the-secret-错误解决办法"><a href="#问题5-在节点加入到集群中时报the-namespace-quot-kube-system-quot-error-downloading-the-secret-错误解决办法" class="headerlink" title="问题5.在节点加入到集群中时报the namespace &quot;kube-system&quot; error downloading the secret 错误解决办法"></a>问题5.在节点加入到集群中时报<code>the namespace &quot;kube-system&quot; error downloading the secret</code> 错误解决办法</h4><p>错误信息:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I0116 04:39:41.428788  184219 checks.go:246] validating the existence and emptiness of directory /var/lib/etcd</span><br><span class="line">[preflight] Would pull the required images (like <span class="string">'kubeadm config images pull'</span>)</span><br><span class="line">[download-certs] Downloading the certificates <span class="keyword">in</span> Secret <span class="string">"kubeadm-certs"</span> <span class="keyword">in</span> the <span class="string">"kube-system"</span> Namespace</span><br><span class="line">secrets <span class="string">"kubeadm-certs"</span> is forbidden: User <span class="string">"system:bootstrap:20w21w"</span> cannot get resource <span class="string">"secrets"</span> <span class="keyword">in</span> API group <span class="string">""</span> <span class="keyword">in</span> the namespace <span class="string">"kube-system"</span></span><br><span class="line">error downloading the secret</span><br></pre></td></tr></table></figure><br>解决办法: 将证书上载到kubeadm证书。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init phase upload-certs --upload-certs</span><br><span class="line">  <span class="comment"># [upload-certs] Storing the certificates in Secret "kubeadm-certs" in the "kube-system" Namespace</span></span><br><span class="line">  <span class="comment"># [upload-certs] Using certificate key:</span></span><br><span class="line">  <span class="comment"># 3a3d7610038c9d14edf377d92b9c6b44e049566ddd25b0e69bf571af58227ae7</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="Containers" scheme="https://blog.weiyigeek.top/categories/Containers/"/>
    
    <category term="OperationTools" scheme="https://blog.weiyigeek.top/categories/Containers/OperationTools/"/>
    
    
    <category term="k8s" scheme="https://blog.weiyigeek.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>22-kubernetes集群中进行etcd数据快照的备份恢复</title>
    <link href="https://blog.weiyigeek.top/2022/10-15-690.html"/>
    <id>https://blog.weiyigeek.top/2022/10-15-690.html</id>
    <published>2022-10-15T06:36:30.000Z</published>
    <updated>2022-11-13T09:26:33.915Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p>描述：在 Kubernetes 集群中所有操作的资源数据都是存储在 etcd 数据库上, 所以防止集群节点瘫痪未正常工作或在集群迁移时，以及在出现异常的情况下能尽快的恢复集群数据，则我们需要定期针对etcd集群数据进行相应的容灾操作。</p><p>在K8S集群中或者Docker环境中，我们可以非常方便的针对 etcd 数据进行备份，通我们常在一个节点上对 etcd 做快照就能够实现etcd数据的备份，其快照文件包含所有 Kubernetes 状态和关键信息， 有了etcd集群数据备份后，例如在灾难场景(例如丢失所有控制平面节点)下也能快速恢复 Kubernetes 集群，Boss再也不同担心系统起不来呢。</p><p><br/></p><h2 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h2><h3 id="1-安装的二进制-etcdctl"><a href="#1-安装的二进制-etcdctl" class="headerlink" title="1.安装的二进制 etcdctl"></a>1.安装的二进制 etcdctl</h3><p>描述: etcdctl 二进制文件可以在 <code>github.com/coreos/etcd/releases</code> 选择对应的版本下载，例如可以执行以下 <code>install_etcdctl.sh</code> 的脚本，修改其中的版本信息。</p><p>install_etcdctl.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: WeiyiGeek</span></span><br><span class="line"><span class="comment"># Description: etcd 与 etcdctl 下载安装</span></span><br><span class="line">ETCD_VER=v3.5.5</span><br><span class="line">ETCD_DIR=etcd-download</span><br><span class="line">DOWNLOAD_URL=https://github.com/coreos/etcd/releases/download</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download</span></span><br><span class="line">mkdir <span class="variable">$&#123;ETCD_DIR&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;ETCD_DIR&#125;</span></span><br><span class="line">wget <span class="variable">$&#123;DOWNLOAD_URL&#125;</span>/<span class="variable">$&#123;ETCD_VER&#125;</span>/etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz </span><br><span class="line">tar -xzvf etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install</span></span><br><span class="line"><span class="built_in">cd</span> etcd-<span class="variable">$&#123;ETCD_VER&#125;</span>-linux-amd64</span><br><span class="line">cp etcdctl /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></p><p>验证安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl version</span><br><span class="line">etcdctl version: 3.5.5</span><br><span class="line">API version: 3.5</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="2-拉取带有-etcdctl-的-Docker-镜像"><a href="#2-拉取带有-etcdctl-的-Docker-镜像" class="headerlink" title="2.拉取带有 etcdctl 的 Docker 镜像"></a>2.拉取带有 etcdctl 的 Docker 镜像</h3><p>操作流程:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 镜像拉取与容器创建。</span></span><br><span class="line">docker run --rm \</span><br><span class="line">-v /data/backup:/backup      \</span><br><span class="line">-v /etc/kubernetes/pki/etcd:/etc/kubernetes/pki/etcd \</span><br><span class="line">--env ETCDCTL_API=3          \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.1-0 \</span><br><span class="line">/bin/sh -c <span class="string">"etcdctl version"</span></span><br></pre></td></tr></table></figure></p><p>安装验证:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3.5.1-0: Pulling from google_containers/etcd</span><br><span class="line">e8614d09b7be: Pull complete</span><br><span class="line">45b6afb4a92f: Pull complete</span><br><span class="line">.......</span><br><span class="line">Digest: sha256:64b9ea357325d5db9f8a723dcf503b5a449177b17ac87d69481e126bb724c263</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.1-0</span><br><span class="line">etcdctl version: 3.5.1</span><br><span class="line">API version: 3.5</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="3-Kubernetes-使用-etcdctl-镜像创建Pod"><a href="#3-Kubernetes-使用-etcdctl-镜像创建Pod" class="headerlink" title="3.Kubernetes 使用 etcdctl 镜像创建Pod"></a>3.Kubernetes 使用 etcdctl 镜像创建Pod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 镜像拉取</span></span><br><span class="line">crictl pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.5-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pod 创建以及安装验证</span></span><br><span class="line">$ kubectl run etcdctl --image=registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.5-0 --<span class="built_in">command</span> -- /usr/<span class="built_in">local</span>/bin/etcdctl version</span><br><span class="line">$ kubectl logs -f etcdctl</span><br><span class="line">etcdctl version: 3.5.5</span><br><span class="line">API version: 3.5</span><br><span class="line">$ kubectl delete pod etcdctl</span><br></pre></td></tr></table></figure><p><br/></p><h2 id="0x02-备份实践"><a href="#0x02-备份实践" class="headerlink" title="0x02 备份实践"></a>0x02 备份实践</h2><h3 id="1-使用二进制安装-etcdctl-客户端工具"><a href="#1-使用二进制安装-etcdctl-客户端工具" class="headerlink" title="1.使用二进制安装 etcdctl 客户端工具"></a>1.使用二进制安装 etcdctl 客户端工具</h3><p>温馨提示: 如果是单节点 Kubernetes 我们只需要对其的 etcd 数据库进行快照备份, 如果是多主多从的集群，我们则需依次备份多个 master 节点中 etcd，防止在备份时etc数据被更改！</p><p>此处实践环境为多master高可用集群节点, 即三主节点、四从工作节点，若你对K8s集群不了解或者项搭建高可用集群的朋友，关注 WeiyiGeek 公众号回复【<code>Kubernetes学习之路汇总</code>】即可获得学习资料：<br><a href="https://www.weiyigeek.top/wechat.html?key=Kubernetes学习之路汇总" target="_blank" rel="noopener">https://www.weiyigeek.top/wechat.html?key=Kubernetes学习之路汇总</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get node</span><br><span class="line">NAME       STATUS   ROLES                  AGE    VERSION</span><br><span class="line">weiyigeek-107   Ready    control-plane,master   279d   v1.23.1</span><br><span class="line">weiyigeek-108   Ready    control-plane,master   278d   v1.23.1</span><br><span class="line">weiyigeek-109   Ready    control-plane,master   278d   v1.23.1</span><br><span class="line">weiyigeek-223   Ready    work                   278d   v1.23.1</span><br><span class="line">weiyigeek-224   Ready    work                   278d   v1.23.1</span><br><span class="line">weiyigeek-225   Ready    work                   279d   v1.23.1</span><br><span class="line">weiyigeek-226   Ready    work                   118d   v1.23.1</span><br></pre></td></tr></table></figure><p><br/></p><p><strong>操作流程：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建etcd快照备份目录</span></span><br><span class="line">$ mkdir -pv /backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看etcd证书</span></span><br><span class="line">$ ls /etc/kubernetes/pki/etcd/</span><br><span class="line">ca.crt  ca.key  healthcheck-client.crt  healthcheck-client.key  peer.crt  peer.key  server.crt  server.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看 etcd 地址以及服务</span></span><br><span class="line">$ kubectl get pod -n kube-system  -o wide | grep <span class="string">"etcd"</span></span><br><span class="line">etcd-weiyigeek-107     1/1     Running   1   279d   192.168.12.107   weiyigeek-107   &lt;none&gt;&lt;none&gt;</span><br><span class="line">etcd-weiyigeek-108     1/1     Running   0   278d   192.168.12.108   weiyigeek-108   &lt;none&gt;&lt;none&gt;</span><br><span class="line">etcd-weiyigeek-109     1/1     Running   0   278d   192.168.12.109   weiyigeek-109   &lt;none&gt;&lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.此时在 107、 108 、109 主节点上查看你监听情况</span></span><br><span class="line">$ netstat -ano | grep <span class="string">"107:2379"</span></span><br><span class="line">tcp        0      0 192.168.12.107:2379     0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">$ netstat -ano | grep <span class="string">"108:2379"</span></span><br><span class="line">tcp        0      0 192.168.12.108:2379     0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line">$ netstat -ano | grep <span class="string">"109:2379"</span></span><br><span class="line">tcp        0      0 192.168.12.109:2379     0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 使用etcdctl客户端工具依次备份节点中的数据</span></span><br><span class="line">$ etcdctl --endpoints=https://10.20.176.212:2379 \</span><br><span class="line">--cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/healthcheck-client.key \</span><br><span class="line">snapshot save /backup/etcd-snapshot.db</span><br><span class="line">&#123;<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"ts"</span>:<span class="string">"2022-10-23T16:32:26.020+0800"</span>,<span class="string">"caller"</span>:<span class="string">"snapshot/v3_snapshot.go:65"</span>,<span class="string">"msg"</span>:<span class="string">"created temporary db file"</span>,<span class="string">"path"</span>:<span class="string">"/backup/etcd-snapshot.db.part"</span>&#125;</span><br><span class="line">&#123;<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"ts"</span>:<span class="string">"2022-10-23T16:32:26.034+0800"</span>,<span class="string">"logger"</span>:<span class="string">"client"</span>,<span class="string">"caller"</span>:<span class="string">"v3/maintenance.go:211"</span>,<span class="string">"msg"</span>:<span class="string">"opened snapshot stream; downloading"</span>&#125;</span><br><span class="line">&#123;<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"ts"</span>:<span class="string">"2022-10-23T16:32:26.034+0800"</span>,<span class="string">"caller"</span>:<span class="string">"snapshot/v3_snapshot.go:73"</span>,<span class="string">"msg"</span>:<span class="string">"fetching snapshot"</span>,<span class="string">"endpoint"</span>:<span class="string">"https://10.20.176.212:2379"</span>&#125;</span><br><span class="line">&#123;<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"ts"</span>:<span class="string">"2022-10-23T16:32:26.871+0800"</span>,<span class="string">"logger"</span>:<span class="string">"client"</span>,<span class="string">"caller"</span>:<span class="string">"v3/maintenance.go:219"</span>,<span class="string">"msg"</span>:<span class="string">"completed snapshot read; closing"</span>&#125;</span><br><span class="line">&#123;<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"ts"</span>:<span class="string">"2022-10-23T16:32:26.946+0800"</span>,<span class="string">"caller"</span>:<span class="string">"snapshot/v3_snapshot.go:88"</span>,<span class="string">"msg"</span>:<span class="string">"fetched snapshot"</span>,<span class="string">"endpoint"</span>:<span class="string">"https://10.20.176.212:2379"</span>,<span class="string">"size"</span>:<span class="string">"112 MB"</span>,<span class="string">"took"</span>:<span class="string">"now"</span>&#125;</span><br><span class="line">&#123;<span class="string">"level"</span>:<span class="string">"info"</span>,<span class="string">"ts"</span>:<span class="string">"2022-10-23T16:32:26.946+0800"</span>,<span class="string">"caller"</span>:<span class="string">"snapshot/v3_snapshot.go:97"</span>,<span class="string">"msg"</span>:<span class="string">"saved"</span>,<span class="string">"path"</span>:<span class="string">"/backup/etcd-snapshot.db"</span>&#125;</span><br><span class="line">Snapshot saved at /backup/etcd-snapshot.db</span><br></pre></td></tr></table></figure></p><p>通过etcdctl查询Kubernetes中etcd数据，由于Kubernetes使用etcd v3版本的API，而且etcd 集群中默认使用tls认证，所以先配置几个环境变量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.环境变量</span></span><br><span class="line"><span class="built_in">export</span> ETCDCTL_API=3</span><br><span class="line"><span class="built_in">export</span> ETCDCTL_CACERT=/etc/kubernetes/pki/etcd/ca.crt</span><br><span class="line"><span class="built_in">export</span> ETCDCTL_CERT=/etc/kubernetes/pki/etcd/peer.crt</span><br><span class="line"><span class="built_in">export</span> ETCDCTL_KEY=/etc/kubernetes/pki/etcd/peer.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查询集群中所有的key列表</span></span><br><span class="line"><span class="comment"># –-prefix：表示查找所有以/registry为前缀的key</span></span><br><span class="line"><span class="comment"># --keys-only=true：表示只给出key不给出value</span></span><br><span class="line">etcdctl --endpoints=https://10.20.176.212:2379 get /registry --prefix --keys-only=<span class="literal">true</span> | head -n 1</span><br><span class="line">/registry/apiextensions.k8s.io/customresourcedefinitions/bgpconfigurations.crd.projectcalico.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查询某个key的值</span></span><br><span class="line"><span class="comment"># -–keys-only=false : 表示要给出value，该参数默认值即为false，</span></span><br><span class="line"><span class="comment"># -w=json ：表示输出json格式</span></span><br><span class="line">etcdctl --endpoints=https://10.20.176.212:2379 get /registry/namespaces/default --prefix --keys-only=<span class="literal">false</span> -w=json | python3 -m json.tool</span><br><span class="line"></span><br><span class="line">etcdctl --endpoints=https://10.20.176.212:2379 get /registry/namespaces/default --prefix --keys-only=<span class="literal">false</span> -w=json | python3 -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"header"</span>: &#123;</span><br><span class="line">      <span class="string">"cluster_id"</span>: 11404821125176160774,</span><br><span class="line">      <span class="string">"member_id"</span>: 7099450421952911102,</span><br><span class="line">      <span class="string">"revision"</span>: 30240109,</span><br><span class="line">      <span class="string">"raft_term"</span>: 3</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"kvs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"key"</span>: <span class="string">"L3JlZ2lzdHJ5L25hbWVzcGFjZXMvZGVmYXVsdA=="</span>,</span><br><span class="line">        <span class="string">"create_revision"</span>: 192,</span><br><span class="line">        <span class="string">"mod_revision"</span>: 192,</span><br><span class="line">        <span class="string">"version"</span>: 1,</span><br><span class="line">        <span class="string">"value"</span>: <span class="string">"azhzAAoPCg.......XNwYWNlEGgAiAA=="</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"count"</span>: 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.其 Key / Value 都是采用 base64 编码</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"L3JlZ2lzdHJ5L25hbWVzcGFjZXMvZGVmYXVsdA=="</span> | base64 -d</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"azhzAAoPCgJ2MRIJTmFtZXNwYWNlEogCCu0BCgdkZWZhdWx0EgAaACIAKiQ5ZDQyYmYxMy03OGM0LTQ4NzQtOThiYy05NjNlMDg1MDYyZjYyADgAQggIo8yllQYQAFomChtrdWJlcm5ldGVzLmlvL21ldGFkYXRhLm5hbWUSB2RlZmF1bHR6AIoBfQoOa3ViZS1hcGlzZXJ2ZXISBlVwZGF0ZRoCdjEiCAijzKWVBhAAMghGaWVsZHNWMTpJCkd7ImY6bWV0YWRhdGEiOnsiZjpsYWJlbHMiOnsiLiI6e30sImY6a3ViZXJuZXRlcy5pby9tZXRhZGF0YS5uYW1lIjp7fX19fUIAEgwKCmt1YmVybmV0ZXMaCAoGQWN0aXZlGgAiAA=="</span> | base64 -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.实际上述value编码解码后的的内容如下:</span></span><br><span class="line">$ kubectl get ns default -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">"2022-06-15T04:54:59Z"</span></span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/metadata.name: default</span><br><span class="line">  name: default</span><br><span class="line">  resourceVersion: <span class="string">"192"</span></span><br><span class="line">  uid: 9d42bf13-78c4-4874-98bc-963e085062f6</span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.Pod 资源信息查看 </span></span><br><span class="line">etcdctl --endpoints=https://10.20.176.212:2379 get /registry/pods/default --prefix --keys-only=<span class="literal">true</span></span><br><span class="line"><span class="comment"># /registry/pods/default/nfs-dev-nfs-subdir-external-provisioner-cf7684f8b-fzl9h</span></span><br><span class="line"><span class="comment"># /registry/pods/default/nfs-local-nfs-subdir-external-provisioner-6f97d44bb8-424tk</span></span><br><span class="line"></span><br><span class="line">etcdctl --endpoints=https://10.20.176.212:2379 get /registry/pods/default --prefix --keys-only=<span class="literal">true</span> -w=json | python3 -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"header"</span>: &#123;</span><br><span class="line">      <span class="string">"cluster_id"</span>: 11404821125176160774,</span><br><span class="line">      <span class="string">"member_id"</span>: 7099450421952911102,</span><br><span class="line">      <span class="string">"revision"</span>: 30442415,</span><br><span class="line">      <span class="string">"raft_term"</span>: 3</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"kvs"</span>: [</span><br><span class="line">      &#123;   <span class="comment"># 实际上该编码是 /registry/pods/default/nfs-dev-nfs-subdir-external-provisioner-cf7684f8b-fzl9h</span></span><br><span class="line">          <span class="string">"key"</span>: <span class="string">"L3JlZ2lzdHJ5L3BvZHMvZGVmYXVsdC9uZnMtZGV2LW5mcy1zdWJkaXItZXh0ZXJuYWwtcHJvdmlzaW9uZXItY2Y3Njg0ZjhiLWZ6bDlo"</span>,  </span><br><span class="line">          <span class="string">"create_revision"</span>: 5510865,</span><br><span class="line">          <span class="string">"mod_revision"</span>: 5510883,</span><br><span class="line">          <span class="string">"version"</span>: 5</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="string">"key"</span>: <span class="string">"L3JlZ2lzdHJ5L3BvZHMvZGVmYXVsdC9uZnMtbG9jYWwtbmZzLXN1YmRpci1leHRlcm5hbC1wcm92aXNpb25lci02Zjk3ZDQ0YmI4LTQyNHRr"</span>,</span><br><span class="line">          <span class="string">"create_revision"</span>: 5510967,</span><br><span class="line">          <span class="string">"mod_revision"</span>: 5510987,</span><br><span class="line">          <span class="string">"version"</span>: 5</span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"count"</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br/></p><h3 id="2-使用Docker镜像安装-etcdctl-客户端工具"><a href="#2-使用Docker镜像安装-etcdctl-客户端工具" class="headerlink" title="2.使用Docker镜像安装 etcdctl 客户端工具"></a>2.使用Docker镜像安装 etcdctl 客户端工具</h3><p>描述: 在装有Docker环境的机器,我们可以非常方便的备份K8s集群中的etcd数据库，此处我已经安装好了Docker，若有不了解Docker或者需要搭建Docker环境中童鞋。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.Docker 实践环境</span></span><br><span class="line">$ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version           20.10.3</span><br><span class="line">.......</span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.etcd 备份文件存储的目录</span></span><br><span class="line">$ mkdir -vp /backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.执行docker创建容器，在备份数据库后便删除该容器。</span></span><br><span class="line">$ docker run --rm \</span><br><span class="line">-v /backup:/backup  \</span><br><span class="line">-v /etc/kubernetes/pki/etcd:/etc/kubernetes/pki/etcd \</span><br><span class="line">--env ETCDCTL_API=3   \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.1-0 \</span><br><span class="line">/bin/sh -c <span class="string">"etcdctl --endpoints=https://192.168.12.107:2379 \</span></span><br><span class="line"><span class="string">--cacert=/etc/kubernetes/pki/etcd/ca.crt  \</span></span><br><span class="line"><span class="string">--key=/etc/kubernetes/pki/etcd/healthcheck-client.key \</span></span><br><span class="line"><span class="string">--cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt \</span></span><br><span class="line"><span class="string">snapshot save /backup/etcd-snapshot.db"</span></span><br><span class="line"><span class="comment"># &#123;"level":"info","ts":1666515535.63076,"caller":"snapshot/v3_snapshot.go:68","msg":"created temporary db file","path":"/backup/etcd-snapshot.db.part"&#125;</span></span><br><span class="line"><span class="comment"># &#123;"level":"info","ts":1666515535.6411893,"logger":"client","caller":"v3/maintenance.go:211","msg":"opened snapshot stream; downloading"&#125;</span></span><br><span class="line"><span class="comment"># &#123;"level":"info","ts":1666515535.6419039,"caller":"snapshot/v3_snapshot.go:76","msg":"fetching snapshot","endpoint":"https://192.168.12.107:2379"&#125;</span></span><br><span class="line"><span class="comment"># &#123;"level":"info","ts":1666515535.9170482,"logger":"client","caller":"v3/maintenance.go:219","msg":"completed snapshot read; closing"&#125;</span></span><br><span class="line"><span class="comment"># &#123;"level":"info","ts":1666515535.931862,"caller":"snapshot/v3_snapshot.go:91","msg":"fetched snapshot","endpoint":"https://192.168.12.107:2379","size":"9.0 MB","took":"now"&#125;</span></span><br><span class="line"><span class="comment"># &#123;"level":"info","ts":1666515535.9322069,"caller":"snapshot/v3_snapshot.go:100","msg":"saved","path":"/backup/etcd-snapshot.db"&#125;</span></span><br><span class="line">Snapshot saved at /backup/etcd-snapshot.db</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看备份的etcd快照文件</span></span><br><span class="line">ls -alh /backup/etcd-snapshot.db</span><br><span class="line">-rw------- 1 root root 8.6M Oct 23 16:58 /backup/etcd-snapshot.db</span><br></pre></td></tr></table></figure><p>使用 Docker 容器查看 k8s 集群中的etcd数据库中的数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm \</span><br><span class="line">-v /backup:/backup  \</span><br><span class="line">-v /etc/kubernetes/pki/etcd:/etc/kubernetes/pki/etcd \</span><br><span class="line">--env ETCDCTL_API=3   \</span><br><span class="line">--env ETCDCTL_CACERT=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">--env ETCDCTL_CERT=/etc/kubernetes/pki/etcd/peer.crt \</span><br><span class="line">--env ETCDCTL_KEY=/etc/kubernetes/pki/etcd/peer.key \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.1-0 \</span><br><span class="line">/bin/sh -c <span class="string">"etcdctl --endpoints=https://192.168.12.107:2379 get /registry/namespaces/default -w=json"</span></span><br></pre></td></tr></table></figure></p><p>执行结果: </p><p><img src="https://img.weiyigeek.top/2022/10/20221023173507.png" alt="WeiyiGeek.Docker容器查询Kubernetes集群中etcd数据库中k/v示例图"></p><p><br></p><h3 id="3-在kubernetes集群中快速创建pod进行手动备份"><a href="#3-在kubernetes集群中快速创建pod进行手动备份" class="headerlink" title="3.在kubernetes集群中快速创建pod进行手动备份"></a>3.在kubernetes集群中快速创建pod进行手动备份</h3><p>准备一个Pod资源清单并部署<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cat</span> <span class="string">&lt;&lt;EOF</span> <span class="string">| kubectl apply -f -</span></span><br><span class="line"><span class="string"></span><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">etcd-backup</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    tool:</span> <span class="string">backup</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.5-0</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"etcd"</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">ETCDCTL_API</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">ETCDCTL_CACERT</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"/etc/kubernetes/pki/etcd/ca.crt"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">ETCDCTL_CERT</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"/etc/kubernetes/pki/etcd/healthcheck-client.crt"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">ETCDCTL_KEY</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"/etc/kubernetes/pki/etcd/healthcheck-client.key"</span></span><br><span class="line"><span class="attr">    volumeMounts:</span> </span><br><span class="line"><span class="attr">    - name:</span> <span class="string">"pki"</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/etc/kubernetes"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">"backup"</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">"/backup"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">pki</span></span><br><span class="line"><span class="attr">    hostPath:</span> </span><br><span class="line"><span class="attr">      path:</span> <span class="string">"/etc/kubernetes"</span>          <span class="comment"># 证书目录</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">"DirectoryOrCreate"</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">"backup"</span></span><br><span class="line"><span class="attr">    hostPath:</span>     </span><br><span class="line"><span class="attr">      path:</span> <span class="string">"/storage/dev/backup"</span>      <span class="comment"># 数据备份目录</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">"DirectoryOrCreate"</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">  nodeSelector:</span> </span><br><span class="line">    <span class="string">node-role.kubernetes.io/master:</span> <span class="string">""</span> <span class="comment"># 绑定在主节点中</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="string">pod/etcd-backup</span> <span class="string">created</span></span><br></pre></td></tr></table></figure></p><p><br/></p><p>进入到该Pod终端之中执行相应的备份命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">~$ kubectl <span class="built_in">exec</span> -it etcd-backup sh</span><br><span class="line"><span class="comment"># 快照备份</span></span><br><span class="line">sh-5.1<span class="comment"># export RAND=$RANDOM</span></span><br><span class="line">sh-5.1<span class="comment"># etcdctl --endpoints=https://192.168.12.107:2379 snapshot save /backup/etcd-107-$&#123;RAND&#125;-snapshot.db</span></span><br><span class="line">sh-5.1<span class="comment"># etcdctl --endpoints=https://192.168.12.108:2379 snapshot save /backup/etcd-108-$&#123;RAND&#125;-snapshot.db</span></span><br><span class="line">Snapshot saved at /backup/etcd-108-32616-snapshot.db</span><br><span class="line">sh-5.1<span class="comment"># etcdctl --endpoints=https://192.168.12.109:2379 snapshot save /backup/etcd-109-$&#123;RAND&#125;-snapshot.db</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd 节点成员</span></span><br><span class="line">sh-5.1<span class="comment"># etcdctl member list --endpoints=https://192.168.12.107:2379 --endpoints=https://192.168.12.108:2379 --endpoints=https://192.168.12.109:2379</span></span><br><span class="line"></span><br><span class="line">2db31a5d67ec1034, started, weiyigeek-108, https://192.168.12.108:2380, https://192.168.12.108:2379, <span class="literal">false</span></span><br><span class="line">42efe7cca897d765, started, weiyigeek-109, https://192.168.12.109:2380, https://192.168.12.109:2379, <span class="literal">false</span></span><br><span class="line">471323846709334f, started, weiyigeek-107, https://192.168.12.107:2380, https://192.168.12.107:2379, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd 节点健康信息</span></span><br><span class="line">sh-5.1<span class="comment"># etcdctl endpoint health --endpoints=https://192.168.12.107:2379 --endpoints=https://192.168.12.108:2379 --endpoints=https://192.168.12.109:2379</span></span><br><span class="line"></span><br><span class="line">https://192.168.12.107:2379 is healthy: successfully committed proposal: took = 11.930331ms</span><br><span class="line">https://192.168.12.109:2379 is healthy: successfully committed proposal: took = 11.930993ms</span><br><span class="line">https://192.168.12.108:2379 is healthy: successfully committed proposal: took = 109.515933ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd 节点状态及空间占用信息</span></span><br><span class="line">sh-5.1<span class="comment"># etcdctl endpoint status --endpoints=https://192.168.12.107:2379  --endpoints=https://192.168.12.108:2379  --endpoints=https://192.168.12.109:2379</span></span><br><span class="line"></span><br><span class="line">https://192.168.12.107:2379, 471323846709334f, 3.5.1, 9.2 MB, <span class="literal">false</span>, <span class="literal">false</span>, 4, 71464830, 71464830,</span><br><span class="line">https://192.168.12.108:2379, 2db31a5d67ec1034, 3.5.1, 9.2 MB, <span class="literal">false</span>, <span class="literal">false</span>, 4, 71464830, 71464830,</span><br><span class="line">https://192.168.12.109:2379, 42efe7cca897d765, 3.5.1, 9.2 MB, <span class="literal">true</span>, <span class="literal">false</span>, 4, 71464830, 71464830, <span class="comment"># 此处为主</span></span><br></pre></td></tr></table></figure><p>至此，手动备份etcd集群数据快照完毕!</p><p><br/></p><h3 id="4-在kubernetes集群中使用CronJob资源控制器进行定时备份"><a href="#4-在kubernetes集群中使用CronJob资源控制器进行定时备份" class="headerlink" title="4.在kubernetes集群中使用CronJob资源控制器进行定时备份"></a>4.在kubernetes集群中使用CronJob资源控制器进行定时备份</h3><p>首先准备一个cronJob资源清单：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; etcd-database-backup.yaml &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: CronJob </span><br><span class="line">metadata:</span><br><span class="line">  name: etcd-database-backup</span><br><span class="line">  annotations:</span><br><span class="line">    descript: <span class="string">"etcd数据库定时备份"</span></span><br><span class="line">spec:</span><br><span class="line">  schedule: <span class="string">"*/5 * * * *"</span>   <span class="comment"># 表示每5分钟运行一次</span></span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        spec:           </span><br><span class="line">          containers:    </span><br><span class="line">          - name: etcdctl</span><br><span class="line">            image: registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.5.5-0</span><br><span class="line">            env:</span><br><span class="line">            - name: ETCDCTL_API</span><br><span class="line">              value: <span class="string">"3"</span></span><br><span class="line">            - name: ETCDCTL_CACERT</span><br><span class="line">              value: <span class="string">"/etc/kubernetes/pki/etcd/ca.crt"</span></span><br><span class="line">            - name: ETCDCTL_CERT</span><br><span class="line">              value: <span class="string">"/etc/kubernetes/pki/etcd/healthcheck-client.crt"</span></span><br><span class="line">            - name: ETCDCTL_KEY</span><br><span class="line">              value: <span class="string">"/etc/kubernetes/pki/etcd/healthcheck-client.key"</span></span><br><span class="line">            <span class="built_in">command</span>:</span><br><span class="line">            - /bin/sh </span><br><span class="line">            - -c</span><br><span class="line">            - |</span><br><span class="line">              <span class="built_in">export</span> RAND=<span class="variable">$RANDOM</span></span><br><span class="line">              etcdctl --endpoints=https://192.168.12.107:2379 snapshot save /backup/etcd-107-<span class="variable">$&#123;RAND&#125;</span>-snapshot.db</span><br><span class="line">              etcdctl --endpoints=https://192.168.12.108:2379 snapshot save /backup/etcd-108-<span class="variable">$&#123;RAND&#125;</span>-snapshot.db</span><br><span class="line">              etcdctl --endpoints=https://192.168.12.109:2379 snapshot save /backup/etcd-109-<span class="variable">$&#123;RAND&#125;</span>-snapshot.db</span><br><span class="line">            volumeMounts: </span><br><span class="line">            - name: <span class="string">"pki"</span></span><br><span class="line">              mountPath: <span class="string">"/etc/kubernetes"</span></span><br><span class="line">            - name: <span class="string">"backup"</span></span><br><span class="line">              mountPath: <span class="string">"/backup"</span></span><br><span class="line">            imagePullPolicy: IfNotPresent</span><br><span class="line">          volumes:</span><br><span class="line">          - name: <span class="string">"pki"</span></span><br><span class="line">            hostPath: </span><br><span class="line">              path: <span class="string">"/etc/kubernetes"</span></span><br><span class="line">              <span class="built_in">type</span>: <span class="string">"DirectoryOrCreate"</span></span><br><span class="line">          - name: <span class="string">"backup"</span></span><br><span class="line">            hostPath: </span><br><span class="line">              path: <span class="string">"/storage/dev/backup"</span>  <span class="comment"># 数据备份目录</span></span><br><span class="line">              <span class="built_in">type</span>: <span class="string">"DirectoryOrCreate"</span></span><br><span class="line">          nodeSelector:  <span class="comment"># 将Pod绑定在主节点之中，否则只能将相关证书放在各个节点能访问的nfs共享存储中</span></span><br><span class="line">            node-role.kubernetes.io/master: <span class="string">""</span></span><br><span class="line">          restartPolicy: Never</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>创建cronjob资源清单:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f etcd-database-backup.yaml</span><br><span class="line"><span class="comment"># cronjob.batch/etcd-database-backup created</span></span><br></pre></td></tr></table></figure></p><p>查看创建的cronjob资源及其集群etcd备份:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME                                 SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">cronjob.batch/etcd-database-backup   */5 * * * *   False     0        21s             14m</span><br><span class="line"></span><br><span class="line">NAME                                      READY   STATUS      RESTARTS   AGE</span><br><span class="line">pod/etcd-database-backup-27776740-rhzkk   0/1     Completed   0          21s</span><br></pre></td></tr></table></figure></p><p>查看定时Pod日志以及备份文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs -f pod/etcd-database-backup-27776740-rhzkk</span><br><span class="line">Snapshot saved at /backup/etcd-107-25615-snapshot.db</span><br><span class="line">Snapshot saved at /backup/etcd-108-25615-snapshot.db</span><br><span class="line">Snapshot saved at /backup/etcd-109-25615-snapshot.db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ls -lt <span class="comment"># 显示最新备份的文件按照时间排序</span></span><br><span class="line">total 25M</span><br><span class="line">-rw------- 1 root root 8.6M Oct 24 21:12 etcd-107-25615-snapshot.db</span><br><span class="line">-rw------- 1 root root 7.1M Oct 24 21:12 etcd-108-25615-snapshot.db</span><br><span class="line">-rw------- 1 root root 8.8M Oct 24 21:12 etcd-109-25615-snapshot.db</span><br></pre></td></tr></table></figure></p><p>至此集群中的etcd快照数据备份完毕!</p><p><br/></p><h2 id="0x02-恢复实践"><a href="#0x02-恢复实践" class="headerlink" title="0x02 恢复实践"></a>0x02 恢复实践</h2><h3 id="1-单master节点恢复"><a href="#1-单master节点恢复" class="headerlink" title="1.单master节点恢复"></a>1.单master节点恢复</h3><p>描述: 当单master集群节点资源清单数据丢失时，我们可采用如下方式进行快速恢复数据。</p><p><strong>操作流程:</strong></p><p>温馨提示: 如果是单节点的k8S集群则使用如下命令恢复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> mv /etc/kubernetes/manifests/ /etc/kubernetes/manifests-backup/</span><br><span class="line"> mv /var/lib/etcd /var/lib/etcd.bak</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore /backup/etcd-212-32616-snapshot.db  --data-dir=/var/lib/etcd/ --endpoints=https://10.20.176.212:2379  --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key</span><br></pre></td></tr></table></figure><h3 id="2-多master节点恢复"><a href="#2-多master节点恢复" class="headerlink" title="2.多master节点恢复"></a>2.多master节点恢复</h3><p>1.温馨提示，此处的集群etcd数据库是安装在Kubernetes集群之中的，并非外部独立安装部署的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pod -n kube-system  etcd-devtest-master-212 etcd-devtest-master-213 etcd-devtest-master-214</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">etcd-devtest-master-212   1/1     Running   3          134d</span><br><span class="line">etcd-devtest-master-213   1/1     Running   0          134d</span><br><span class="line">etcd-devtest-master-214   1/1     Running   0          134d</span><br></pre></td></tr></table></figure></p><p>2.前面我们提到过，在进行恢复前需要查看 etcd 集群当前成员以及监控状态。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># etcd 集群成员列表</span></span><br><span class="line">ETCDCTL_API=3 etcdctl member list --endpoints=https://10.20.176.212:2379  --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key</span><br><span class="line">6286508b550016fe, started, devtest-master-212, https://10.20.176.212:2380, https://10.20.176.212:2379, <span class="literal">false</span></span><br><span class="line">9dd15f852caf8e05, started, devtest-master-214, https://10.20.176.214:2380, https://10.20.176.214:2379, <span class="literal">false</span></span><br><span class="line">e0f23bd90b7c7c0d, started, devtest-master-213, https://10.20.176.213:2380, https://10.20.176.213:2379, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd 集群节点状态查看主从节点</span></span><br><span class="line">ETCDCTL_API=3 etcdctl endpoint status --endpoints=https://10.20.176.212:2379 --endpoints=https://10.20.176.213:2379 --endpoints=https://10.20.176.214:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key   --write-out table</span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd 集群节点健康信息筛选出不健康的节点</span></span><br><span class="line">ETCDCTL_API=3 etcdctl endpoint health --endpoints=https://10.20.176.212:2379   --endpoints=https://10.20.176.213:2379  --endpoints=https://10.20.176.214:2379  --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key</span><br><span class="line">https://10.20.176.212:2379 is healthy: successfully committed proposal: took = 14.686875ms</span><br><span class="line">https://10.20.176.214:2379 is healthy: successfully committed proposal: took = 16.201187ms</span><br><span class="line">https://10.20.176.213:2379 is healthy: successfully committed proposal: took = 18.962462ms</span><br></pre></td></tr></table></figure></p><p>3.停掉所有Master机器的kube-apiserver和etcd ，然后在利用备份进行恢复该节点的etcd数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mv /etc/kubernetes/manifests/ /etc/kubernetes/manifests-backup/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在该节点上删除 /var/lib/etcd</span></span><br><span class="line">mv /var/lib/etcd /var/lib/etcd.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用快照进行恢复,注意etcd集群中可以用同一份snapshot恢复。</span></span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore /backup/etcd-212-32616-snapshot.db --data-dir=/var/lib/etcd --name=devtest-master-212 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/peer.crt --key=/etc/kubernetes/pki/etcd/peer.key  --initial-cluster-token=etcd-cluster-0 --initial-cluster=devtest-master-212=https://10.20.176.212:2380,devtest-master-213=https://10.20.176.213:2380,devtest-master-214=https://10.20.176.214:2380  --initial-advertise-peer-urls=https://10.20.176.212:2380</span><br></pre></td></tr></table></figure><p>温馨提示: 当节点加入控制平面 control-plane 后为 <code>API Server、Controller Manager 和 Scheduler</code> 生成静态Pod配置清单，主机上的kubelet服务会监视 <code>/etc/kubernetes/manifests</code>目录中的配置清单的创建、变动和删除等状态变动，并根据变动完成Pod创建、更新或删除操作。因此，这两个阶段创建生成的各配置清单将会启动Master组件的相关Pod</p><p>4.然后启动 etcd 和 apiserver 并查看 pods是否恢复正常。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 etcd pod</span></span><br><span class="line">$ kubectl get pod -n kube-system -l component=etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看组件健康状态</span></span><br><span class="line">$ kubectl get componentstatuses</span><br><span class="line">Warning: v1 ComponentStatus is deprecated <span class="keyword">in</span> v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE                         ERROR</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">"health"</span>:<span class="string">"true"</span>,<span class="string">"reason"</span>:<span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="3-K8S集群中etcd数据库节点数据不一致问题解决实践"><a href="#3-K8S集群中etcd数据库节点数据不一致问题解决实践" class="headerlink" title="3.K8S集群中etcd数据库节点数据不一致问题解决实践"></a>3.K8S集群中etcd数据库节点数据不一致问题解决实践</h3><p>发现etcd数据不一致，执行kubectl get pod -n xxx获取的信息资源不一样， etcdctl 直接查询了 etcd 集群状态和集群数据，返回结果显示 3 个节点状态都正常，且 RaftIndex 一致，观察 etcd 的日志也并未发现报错信息，唯一可疑的地方是 3 个节点的 dbsize 差别较大</p><p>etcd 数据不一致 ？</p><p>由于从 kube-apiserver 的日志中同样无法提取出能够帮助解决问题的有用信息，起初我们只能猜测可能是 kube-apiserver 的缓存更新异常导致的。正当我们要从这个切入点去解决问题时，该同事反馈了一个更诡异的问题——自己新创建的 Pod，通过 kubectl查询 Pod 列表，突然消失了！纳尼？这是什么骚操作？经过我们多次测试查询发现，通过 kubectl 来 list pod 列表，该 pod 有时候能查到，有时候查不到。那么问题来了，K8s api 的 list 操作是没有缓存的，数据是 kube-apiserver 直接从 etcd 拉取返回给客户端的，难道是 etcd 本身出了问题？</p><p>众所周知，etcd 本身是一个强一致性的 KV 存储，在写操作成功的情况下，两次读请求不应该读取到不一样的数据。怀着不信邪的态度，我们通过 etcdctl 直接查询了 etcd 集群状态和集群数据，返回结果显示 3 个节点状态都正常，且 RaftIndex 一致，观察 etcd 的日志也并未发现报错信息，唯一可疑的地方是 3 个节点的 dbsize 差别较大。接着，我们又将 client 访问的 endpoint 指定为不同节点地址来查询每个节点的 key 的数量，结果发现 3 个节点返回的 key 的数量不一致，甚至两个不同节点上 Key 的数量差最大可达到几千！而直接通过 etcdctl 查询刚才创建的 Pod，发现访问某些 endpoint 能够查询到该 pod，而访问其他 endpoint 则查不到。至此，基本可以确定 etcd 集群的节点之间确实存在数据不一致现象。</p><p>ETCDCTL_API=3 etcdctl endpoint status –endpoints=<a href="https://192.168.12.108:2379" target="_blank" rel="noopener">https://192.168.12.108:2379</a> –endpoints=<a href="https://192.168.12.107:2379" target="_blank" rel="noopener">https://192.168.12.107:2379</a> –endpoints=<a href="https://192.168.12.109:2379" target="_blank" rel="noopener">https://192.168.12.109:2379</a> –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/peer.crt –key=/etc/kubernetes/pki/etcd/peer.key </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://192.168.12.108:2379, 2db31a5d67ec1034, 3.5.1, 7.4 MB, <span class="literal">false</span>, <span class="literal">false</span>, 4, 72288139, 72288139,</span><br><span class="line">https://192.168.12.107:2379, 471323846709334f, 3.5.1, 9.0 MB, <span class="literal">false</span>, <span class="literal">false</span>, 4, 72288139, 72288139,</span><br><span class="line">https://192.168.12.109:2379, 42efe7cca897d765, 3.5.1, 9.2 MB, <span class="literal">true</span>, <span class="literal">false</span>, 4, 72288139, 72288139,</span><br></pre></td></tr></table></figure><p>root@weiyigeek-107:~# ETCDCTL_API=3  etcdctl get / –prefix –keys-only –endpoints=<a href="https://192.168.12.107:2379" target="_blank" rel="noopener">https://192.168.12.107:2379</a>  –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/peer.crt –key=/etc/kubernetes/pki/etcd/peer.key  | wc -l<br>1620</p><p>root@weiyigeek-107:~# ETCDCTL_API=3  etcdctl get / –prefix –keys-only –endpoints=<a href="https://192.168.12.108:2379" target="_blank" rel="noopener">https://192.168.12.108:2379</a>  –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/peer.crt –key=/etc/kubernetes/pki/etcd/peer.key  | wc -l<br>1620</p><p>root@weiyigeek-107:~# ETCDCTL_API=3  etcdctl get / –prefix –keys-only –endpoints=<a href="https://192.168.12.109:2379" target="_blank" rel="noopener">https://192.168.12.109:2379</a>  –cacert=/etc/kubernetes/pki/etcd/ca.crt –cert=/etc/kubernetes/pki/etcd/peer.crt –key=/etc/kubernetes/pki/etcd/peer.key  | wc -l<br>1620</p><p> l<br>+—————————–+——————+———+———+———–+———–+————+<br>|          ENDPOINT           |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |<br>+—————————–+——————+———+———+———–+———–+————+<br>| <a href="https://192.168.12.108:2379" target="_blank" rel="noopener">https://192.168.12.108:2379</a> | 2db31a5d67ec1034 |   3.5.1 |  7.4 MB |     false |         4 |   72291872 |<br>| <a href="https://192.168.12.107:2379" target="_blank" rel="noopener">https://192.168.12.107:2379</a> | 471323846709334f |   3.5.1 |  9.0 MB |     false |         4 |   72291872 |<br>| <a href="https://192.168.12.109:2379" target="_blank" rel="noopener">https://192.168.12.109:2379</a> | 42efe7cca897d765 |   3.5.1 |  9.2 MB |      true |         4 |   72291872 |<br>+—————————–+——————+———+———+———–+———–+————+</p><p> ETCDCTL_API=3 etcdctl endpoint status –endpoints=<a href="https://192.168.12.107:2379" target="_blank" rel="noopener">https://192.168.12.107:2379</a>    –endpoints=<a href="https://192.168.12.108:2379" target="_blank" rel="noopener">https://192.168.12.108:2379</a> –endpoints=<a href="https://192.168.12.109:2379" target="_blank" rel="noopener">https://192.168.12.109:2379</a>   –write-out table<br>+—————————–+——————+———+———+———–+————+———–+————+——————–+——–+<br>|          ENDPOINT           |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |<br>+—————————–+——————+———+———+———–+————+———–+————+——————–+——–+<br>| <a href="https://192.168.12.107:2379" target="_blank" rel="noopener">https://192.168.12.107:2379</a> | 471323846709334f |   3.5.1 |  9.0 MB |     false |      false |         4 |   72292452 |           72292452 |        |<br>| <a href="https://192.168.12.108:2379" target="_blank" rel="noopener">https://192.168.12.108:2379</a> | 2db31a5d67ec1034 |   3.5.1 |  7.4 MB |     false |      false |         4 |   72292452 |           72292452 |        |<br>| <a href="https://192.168.12.109:2379" target="_blank" rel="noopener">https://192.168.12.109:2379</a> | 42efe7cca897d765 |   3.5.1 |  9.2 MB |      true |      false |         4 |   72292452 |           72292452 |        |<br>+—————————–+——————+———+———+———–+————+———–+————+——————–+——–+</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="Containers" scheme="https://blog.weiyigeek.top/categories/Containers/"/>
    
    <category term="OperationTools" scheme="https://blog.weiyigeek.top/categories/Containers/OperationTools/"/>
    
    
    <category term="k8s" scheme="https://blog.weiyigeek.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>资源分享|每天白嫖两小时微软(Microsoft)学习实验虚拟机</title>
    <link href="https://blog.weiyigeek.top/2022/10-10-689.html"/>
    <id>https://blog.weiyigeek.top/2022/10-10-689.html</id>
    <published>2022-10-10T14:47:25.000Z</published>
    <updated>2022-10-13T08:26:41.054Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p>描述：在逛B站的时候发现可以每天白嫖两小时微软(Microsoft)学习实验虚拟机，对于没有国外VPS的我，又需要上Google查学习资料的我来说，简直是天上掉馅饼，不用白不用，下面简单描述说明一下免费申请使用微软(Microsoft)学习实验虚拟机的流程，</p><p>微软在在财务和运营应用中实施常见集成功能，提供了办公软件集成教学的虚拟机，我们可以利用此Windows虚拟机上外网找学习资料，只是每次只有两小时的时间限制，有可能你所处的地区连接其虚拟机延迟较高，所以白嫖还是得看运气。</p><p>温馨提示: 此 VM 模式提供了一个免费的、基于 Web 的虚拟机环境，微软出于教育目的提供此实验室体验和相关内容，所以大家还是不要滥用以及干非法的事。</p><p>温馨提示: 在实践之前如果你没有微软账户，你需要注册申请一个微软（Microsoft）账号，注册地址：<a href="https://signup.live.com/newuser.aspx" target="_blank" rel="noopener">https://signup.live.com/newuser.aspx</a></p><a id="more"></a><h2 id="0x01-操作流程"><a href="#0x01-操作流程" class="headerlink" title="0x01 操作流程"></a>0x01 操作流程</h2><p>步骤 01.建议使用edge浏览器访问微软在在财务和运营应用中实施常见集成功能学习页面[^1]，可在文章末尾获取该地址，此处我已登录微软学站点。</p><p><br/></p><p>步骤 02.点击选择“启动 VM 模式（<code>Launch VM mode</code>）”或“登录”以在此单元中启动 VM 模式。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012224644.png" alt="WeiyiGeek.Launch VM mode图" title="" class="">                <p>WeiyiGeek.Launch VM mode图</p>            </figure><p><br/></p><p>步骤 03.等待短暂的几秒钟后，虚拟机便启动成果，此时我们在实验室侧栏上的“资源”选项卡中，选择 MININT 框中“密码”旁边的 T 图标，以便为你输入虚拟机的管理员密码，此时延迟在 400 多左右，对于国内来说这个访问速度还算好的了。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012225043.png" alt="WeiyiGeek.登录学习虚拟机图" title="" class="">                <p>WeiyiGeek.登录学习虚拟机图</p>            </figure><p><br/></p><p>步骤 04.点击➡箭头即可登录该服务器，然后便可进入查看如下桌面，其服务器以及配置如下,其服务器IP通常在英国。</p><blockquote><p>CPU : Inter Xeon Gload 6230R CPU @ 2.10Ghz (双核 6线程)<br>内存：12G<br>磁盘: 126 GB<br>Ethernet: 10G </p></blockquote><p><img src="https://img.weiyigeek.top/2022/10/20221012225818.png" alt="WeiyiGeek.微软学习机配置图"></p><p><br/></p><p>步骤 05.虽然机器的延迟较高但是上上Google还是没有问题的，但是不能上脸书、推特以及youtobe。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012231910.png" alt="WeiyiGeek.图" title="" class="">                <p>WeiyiGeek.图</p>            </figure><p><br/></p><p>步骤 06.白嫖后该学习机后，我顺带将我博客站点的Google 广告开启，对于我们计算机爱好者来说有一笔收入支持我博客站点( <a href="https://weiyigeek.top" target="_blank" rel="noopener">https://weiyigeek.top</a> )的运行，还是不错的。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012231924.png" alt="WeiyiGeek.图" title="" class="">                <p>WeiyiGeek.图</p>            </figure><p><br/></p><p>至此，白嫖实践完毕，请大家多多关注，支持博主哟。</p><p>[^1]: 财务和运营应用中实施常见集成功能学习学习虚拟机: <a href="https://learn.microsoft.com/en-us/training/modules/implement-common-integration-features-finance-ops/10-exercise-1?source=learn" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/training/modules/implement-common-integration-features-finance-ops/10-exercise-1?source=learn</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;0x00-前言简述&quot;&gt;&lt;a href=&quot;#0x00-前言简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言简述&quot;&gt;&lt;/a&gt;0x00 前言简述&lt;/h2&gt;&lt;p&gt;描述：在逛B站的时候发现可以每天白嫖两小时微软(Microsoft)学习实验虚拟机，对于没有国外VPS的我，又需要上Google查学习资料的我来说，简直是天上掉馅饼，不用白不用，下面简单描述说明一下免费申请使用微软(Microsoft)学习实验虚拟机的流程，&lt;/p&gt;
&lt;p&gt;微软在在财务和运营应用中实施常见集成功能，提供了办公软件集成教学的虚拟机，我们可以利用此Windows虚拟机上外网找学习资料，只是每次只有两小时的时间限制，有可能你所处的地区连接其虚拟机延迟较高，所以白嫖还是得看运气。&lt;/p&gt;
&lt;p&gt;温馨提示: 此 VM 模式提供了一个免费的、基于 Web 的虚拟机环境，微软出于教育目的提供此实验室体验和相关内容，所以大家还是不要滥用以及干非法的事。&lt;/p&gt;
&lt;p&gt;温馨提示: 在实践之前如果你没有微软账户，你需要注册申请一个微软（Microsoft）账号，注册地址：&lt;a href=&quot;https://signup.live.com/newuser.aspx&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://signup.live.com/newuser.aspx&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="网络资源分享" scheme="https://blog.weiyigeek.top/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="虚拟主机" scheme="https://blog.weiyigeek.top/tags/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>资源分享|免费注册申请永久的eu.org顶级域名创建属于自己的域名,再也不用给博客域名续费了!</title>
    <link href="https://blog.weiyigeek.top/2022/10-9-688.html"/>
    <id>https://blog.weiyigeek.top/2022/10-9-688.html</id>
    <published>2022-10-09T14:47:25.000Z</published>
    <updated>2022-10-13T06:40:53.519Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p>描述：在逛B站的时候发现可以免费注册申请永久的eu.org顶级网域，一想到自己现在域名【weiyigeek.top】后续续费要上百人民币, 所以我随手就马上去注册了一个（白嫖谁不爱），下面将快速申请注册 eu.org 域名注意事项进行说明，帮助需要申请免费 eu.org 域名的朋友。</p><p>EU.org 是一个从1996开始提供免费域名的组织, 其官网地址是 <a href="https://nic.eu.org/" target="_blank" rel="noopener">https://nic.eu.org/</a> ，他帮助学生、爱好者或者非营利组织不用花费购买域名就可能拥有自己的免费域名，虽然 <a href="https://nic.eu.org/" target="_blank" rel="noopener">eu.org</a> 网域切确来说这是一个子域名（Subdomain）或者二级域名，但是根据一些网站的资讯，有许多大型互联网公司，像是 Google, Cloudflare, Bing 等厂商都已经将eu.org域名当成是一个顶级网域了。</p><p>值得注意的是，我们虽然可以进行免费申请，但不要滥用申请，作为申请者应该必须遵守互联网标准(Rfc)，不要利用其来发送垃圾邮件或网络钓鱼以及分发恶意软件，毕竟提供免费的域名的组织，谁也不想其取消免费服务，其次不要多次注册申请占用域名，尽量只是注册需要的域名，通常来说注册两个域名基本就满足日常使用，一个正式站点域名和一个测试站点域名。</p><a id="more"></a><p>EU.org 开域和政策参考地址：<a href="https://nic.eu.org/opendomains.html" target="_blank" rel="noopener">https://nic.eu.org/opendomains.html</a></p><hr><h2 id="0x01-注册申请"><a href="#0x01-注册申请" class="headerlink" title="0x01 注册申请"></a>0x01 注册申请</h2><p>在注册一个eu.org免费域名前，你需要先准备<code>好一个邮箱地址和注册一个Hostry账号</code>才能保证在注册的过程中不会遇到任何的阻碍。</p><ul><li>邮箱地址: google Gmail 、foxmail、QQ 都是可以的邮箱注册（此处相信大家都有邮箱）</li><li>注册Hostry账号以获取免费DNS解析服务（在申请时不建议采用 dnspod ）</li></ul><h3 id="如何注册Hostry获取免费DNS解析服务"><a href="#如何注册Hostry获取免费DNS解析服务" class="headerlink" title="如何注册Hostry获取免费DNS解析服务?"></a>如何注册Hostry获取免费DNS解析服务?</h3><p>描述：HOSTRY 作为一家可靠且成熟的托管服务提供商，HOSTRY为在线企业提供了大量不同的托管选项，专注于内容交付网络（CDN）、虚拟专用服务器（VPS）、专用服务器和其他解决方案，以确保为客户提供高质量的web托管服务。<br>此处我们主要使用 HOSTRY 其 DNS 解析服务来加快域名申请所占用审核的时间，没有选择 dnspod 是因为有可能在申请免费域名验证解析时会产生错误从而增加审核时间，其次是使用 dnspod 需要进行实名认证，所以推荐使用 HOSTRY 在域名审批通过后再使用 dnspod 来进行解析。</p><ol><li>访问 hostry 官网进行注册用户, 注册地址: <a href="https://hostry.com/register/" target="_blank" rel="noopener">https://hostry.com/register/</a>, 输入注册邮箱以及相关的注册信息（反正只用一次信息不一定填真的），然后你再邮箱中会收到一条激活信息进行（<code>ACTIVATE ACCOUNT</code>）即可。</li></ol><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009114727.png" alt="WeiyiGeek.注册hostry" title="" class="">                <p>WeiyiGeek.注册hostry</p>            </figure><p>温馨提示：注册地址邮编自行Google、百度即可。</p><ol start="2"><li>注册完毕后即可进行创建免费的DNS解析，创建地址：<a href="https://hostry.com/products/dns/，其无主机DNS使您的DNS更快、更安全，并且对条目或请求的数量没有限制。" target="_blank" rel="noopener">https://hostry.com/products/dns/，其无主机DNS使您的DNS更快、更安全，并且对条目或请求的数量没有限制。</a><blockquote><p>例如，输入要注册的域名 <code>wygk.eu.org &gt; CREATE</code> 进行创建即可。</p></blockquote></li></ol><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009124252.png" alt="WeiyiGeek.创建需要申请的域名解析" title="" class="">                <p>WeiyiGeek.创建需要申请的域名解析</p>            </figure><p>温馨提示：此处需要验证一下eu.org要注册的域名是否被注册过了，如果出现如下图片中的情况表示已注册 (此处这是我已经申请下的免费域名)，验证地址：<a href="https://tool.dnspod.cn/" target="_blank" rel="noopener">https://tool.dnspod.cn/</a></p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009115711.png" alt="WeiyiGeek.dnspod验证eu.org域名是否被注册" title="" class="">                <p>WeiyiGeek.dnspod验证eu.org域名是否被注册</p>            </figure><p>至此，注册完毕!</p><p><br/></p><h3 id="如何注册eu-org域名"><a href="#如何注册eu-org域名" class="headerlink" title="如何注册eu.org域名?"></a>如何注册eu.org域名?</h3><ol><li>在 Google Chrome 或其他浏览器 输入eu.org 然后登入 <a href="https://nic.eu.org/，点击" target="_blank" rel="noopener">https://nic.eu.org/，点击</a> Register 进行创建用户，输入如下账户邮箱、姓名、地址等相关信息,然后将会在邮箱里收到一封验证账户的短信。</li></ol><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009125606.png" alt="WeiyiGeek.注册验证 eu.org 账户" title="" class="">                <p>WeiyiGeek.注册验证 eu.org 账户</p>            </figure><p>温馨提示：输入Name时姓名首字母要大写，并且中间有空格，里面的地址随意在百度中找寻一个英文地址即可。</p><ol start="2"><li>注册成功登录后，点击 new Domain 创建上述自定义的域名，此处还是以<code>wygk.eu.org</code>申请的域名为例，填写如下信息以及NameServers信息，填写完毕后点击submit进行提交。</li></ol><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009131006.png" alt="WeiyiGeek.创建自定义eu.org二级域名" title="" class="">                <p>WeiyiGeek.创建自定义eu.org二级域名</p>            </figure><ol start="3"><li>提交后将进行域名 <code>server names + replies on SOA + replies on NS</code> 认证记录，如出现下图所示则表示申请提交验证域名NS记录成功审核审核下发，我在两天后便收到了成功的邮件信息。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">---- Servers and domain names check</span><br><span class="line">Getting IP <span class="keyword">for</span> NS1.HOSTRY.COM: 185.186.246.19</span><br><span class="line">Getting IP <span class="keyword">for</span> NS2.HOSTRY.COM: 206.54.189.187</span><br><span class="line">Getting IP <span class="keyword">for</span> NS3.HOSTRY.COM: 195.123.233.100</span><br><span class="line">Getting IP <span class="keyword">for</span> NS4.HOSTRY.COM: 45.32.157.198</span><br><span class="line"></span><br><span class="line">---- Checking SOA records <span class="keyword">for</span> WYGK.EU.ORG</span><br><span class="line">SOA from NS1.HOSTRY.COM at 185.186.246.19: serial 2022100702 (12.916 ms)</span><br><span class="line">SOA from NS2.HOSTRY.COM at 206.54.189.187: serial 2022100702 (114.235 ms)</span><br><span class="line">SOA from NS3.HOSTRY.COM at 195.123.233.100: serial 2022100702 (74.804 ms)</span><br><span class="line">SOA from NS4.HOSTRY.COM at 45.32.157.198: serial 2022100702 (99.779 ms)</span><br><span class="line"></span><br><span class="line">---- Checking NS records <span class="keyword">for</span> WYGK.EU.ORG</span><br><span class="line">NS from NS1.HOSTRY.COM at 185.186.246.19: ok (12.374 ms)</span><br><span class="line">NS from NS2.HOSTRY.COM at 206.54.189.187: ok (114.638 ms)</span><br><span class="line">NS from NS3.HOSTRY.COM at 195.123.233.100: ok (75.439 ms)</span><br><span class="line">NS from NS4.HOSTRY.COM at 45.32.157.198: ok (101.228 ms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">No error, storing <span class="keyword">for</span> validation...  <span class="comment"># 表示申请提交验证域名NS记录成功</span></span><br><span class="line">Saved as request 20221007160025-arf-37642</span><br><span class="line"></span><br><span class="line">Done</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009131635.png" alt="WeiyiGeek.域名申请审核成功" title="" class="">                <p>WeiyiGeek.域名申请审核成功</p>            </figure><hr><h2 id="0x02-解析配置"><a href="#0x02-解析配置" class="headerlink" title="0x02 解析配置"></a>0x02 解析配置</h2><h3 id="如何将注册eu-org域名解析改为Cloudflare并指向Github-Pages"><a href="#如何将注册eu-org域名解析改为Cloudflare并指向Github-Pages" class="headerlink" title="如何将注册eu.org域名解析改为Cloudflare并指向Github Pages?"></a>如何将注册eu.org域名解析改为Cloudflare并指向Github Pages?</h3><p>描述：此处dnspod实名认证不在累述，你不一定要选择dnspod你也可以继续使用HOSTRY提供的免费DNS服务，或者选择Cloudflare提供的DNS解析服务都是可以的，此处以Cloudflare为例（此处假设你已经有了Cloudflare账号，没有的朋友去注册一个即可）。</p><ol><li>访问并登录 cloudflare 面板，地址：<a href="https://dash.cloudflare.com/login" target="_blank" rel="noopener">https://dash.cloudflare.com/login</a> , 然后添加刚才注册的站点，选择 Free 套餐即可，点击继续。</li></ol><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009132752.png" alt="WeiyiGeek.在cloudflare添加域名" title="" class="">                <p>WeiyiGeek.在cloudflare添加域名</p>            </figure><ol start="2"><li>设置完成后我们需要到 eu.org 注册机构帐户中将,将 HOSTRY 替换为 Cloudflare 的名称服务器。</li></ol><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009133321.png" alt="WeiyiGeek.在注册机构中域名替换为 Cloudflare 的名称服务器" title="" class="">                <p>WeiyiGeek.在注册机构中域名替换为 Cloudflare 的名称服务器</p>            </figure><ol start="3"><li>验证 eu.org 域名修改后的 NameServer 服务器地址。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;nslookup -qt=ns wygk.eu.org</span><br><span class="line">服务器:  public2.alidns.com</span><br><span class="line">Address:  223.6.6.6</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">wygk.eu.org     nameserver = bayan.ns.cloudflare.com</span><br><span class="line">wygk.eu.org     nameserver = vita.ns.cloudflare.com</span><br></pre></td></tr></table></figure><ol start="4"><li>在 DNS 提供商 cloudflare 面板中添加 cname 记录解析，指向我 Github Pages 的 weiyigeek.github.io 博主主页。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nslookup -qt=a www.wygk.eu.org 223.6.6.6</span><br><span class="line">服务器:  public2.alidns.com</span><br><span class="line">Address:  223.6.6.6</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    weiyigeek.github.io</span><br><span class="line">Addresses:  185.199.111.153</span><br><span class="line">          185.199.110.153</span><br><span class="line">          185.199.109.153</span><br><span class="line">          185.199.108.153</span><br><span class="line">Aliases:  www.wygk.eu.org</span><br></pre></td></tr></table></figure><p>打开浏览器访问 <a href="https://www.wygk.eu.org/index.html" target="_blank" rel="noopener">https://www.wygk.eu.org/index.html</a> 站点，至此一个免费的域名申请到使用成果</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20221009143134.png" alt="WeiyiGeek.免费域名使用" title="" class="">                <p>WeiyiGeek.免费域名使用</p>            </figure><p>至此，实践完毕 !</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;0x00-前言简述&quot;&gt;&lt;a href=&quot;#0x00-前言简述&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言简述&quot;&gt;&lt;/a&gt;0x00 前言简述&lt;/h2&gt;&lt;p&gt;描述：在逛B站的时候发现可以免费注册申请永久的eu.org顶级网域，一想到自己现在域名【weiyigeek.top】后续续费要上百人民币, 所以我随手就马上去注册了一个（白嫖谁不爱），下面将快速申请注册 eu.org 域名注意事项进行说明，帮助需要申请免费 eu.org 域名的朋友。&lt;/p&gt;
&lt;p&gt;EU.org 是一个从1996开始提供免费域名的组织, 其官网地址是 &lt;a href=&quot;https://nic.eu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nic.eu.org/&lt;/a&gt; ，他帮助学生、爱好者或者非营利组织不用花费购买域名就可能拥有自己的免费域名，虽然 &lt;a href=&quot;https://nic.eu.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;eu.org&lt;/a&gt; 网域切确来说这是一个子域名（Subdomain）或者二级域名，但是根据一些网站的资讯，有许多大型互联网公司，像是 Google, Cloudflare, Bing 等厂商都已经将eu.org域名当成是一个顶级网域了。&lt;/p&gt;
&lt;p&gt;值得注意的是，我们虽然可以进行免费申请，但不要滥用申请，作为申请者应该必须遵守互联网标准(Rfc)，不要利用其来发送垃圾邮件或网络钓鱼以及分发恶意软件，毕竟提供免费的域名的组织，谁也不想其取消免费服务，其次不要多次注册申请占用域名，尽量只是注册需要的域名，通常来说注册两个域名基本就满足日常使用，一个正式站点域名和一个测试站点域名。&lt;/p&gt;</summary>
    
    
    
    <category term="网络资源分享" scheme="https://blog.weiyigeek.top/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="域名申请" scheme="https://blog.weiyigeek.top/tags/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7/"/>
    
  </entry>
  
  <entry>
    <title>MobaXterm远程连接工具脆弱性</title>
    <link href="https://blog.weiyigeek.top/2022/10-8-688.html"/>
    <id>https://blog.weiyigeek.top/2022/10-8-688.html</id>
    <published>2022-10-08T01:32:30.000Z</published>
    <updated>2022-10-13T08:26:38.804Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p><strong>什么是MobaXterm?</strong></p><blockquote><p>MobaX 术语是远程计算的终极工具箱, 适用于 Windows 的增强型终端，带有 X11 服务器、选项卡式 SSH 客户端、网络工具以及快速监控远程系统运行状况等<br>Enhanced terminal for Windows with X11 server, tabbed SSH client, network tools and much more</p></blockquote><p>官网地址: <a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">https://mobaxterm.mobatek.net/</a></p><p><strong>有什么用?</strong></p><blockquote><p>MobaXterm 提供了所有重要的远程网络工具（SSH，X11，RDP，VNC，FTP，MOSH等）和Unix命令（bash，ls，猫，sed，grep，awk，rsync等）到Windows桌面，在一个便携式exe文件中，开箱即用.</p></blockquote><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012090931.png" alt="WeiyiGeek.MobaXterm图" title="" class="">                <p>WeiyiGeek.MobaXterm图</p>            </figure><p><strong>有那些主要特点?</strong></p><ul><li>嵌入式 X 服务器: 基于 X.org 的完全配置的 X 服务器</li><li>轻松导出显示器 : 显示从远程 Unix 导出到本地窗口</li><li>X11 转发功能: 您的远程显示器使用 SSH 实现安全传输</li><li>带固态混合的选项卡式终端 : 基于 PuTTY，具有抗锯齿字体和宏支持</li><li>视窗上的许多Unix/Linux命令 :基本 Cygwin 命令（bash, grep, awk, sed, rsync,……）</li><li>附加组件和插件 :您可以使用插件扩展 MobaX 术语功能</li><li>多功能会话管理器 :您的所有网络工具都在一个应用程序中：Rdp，Vnc，Ssh，Mosh，X11，…</li><li>便携式轻便应用 : MobaXterm 已被打包为单个可执行文件，不需要管理员权限，您可以从 U 盘启动</li><li>专业应用 : 专业版 MobaX 术语专为安全性和稳定性而设计</li></ul><p>MobaXterm 功能参考：[^features.html] </p><p><strong>版本区别</strong></p><ul><li>Home Edition（家庭版）：免费,基本功能都有知识最多存储12 session、2条 ssh 隧道，4个宏的限制。</li><li>Professional Edition （专业版）：永久$69, 包含家庭全部功能并且无会话限制以及无限数量的隧道和宏，并且可修改配置文件脚本和自定义启动消息和徽标，并且可以直接查看session存储的账号密码。 (花了钱的就是不一样)</li></ul><p>MobaXterm 版本下载地址: [^download.html] </p><p><strong>插件列表与安装</strong><br>为了安装这些插件，只需下载它们并将它们放在与MobaXterm可执行文件相同的目录中即可。</p><p>MobaXterm 插件下载地址: [^plugins.html]</p><hr><h2 id="0x01-使用总结"><a href="#0x01-使用总结" class="headerlink" title="0x01 使用总结"></a>0x01 使用总结</h2><h3 id="1-忘记-MobaXterm-主密码如何重置"><a href="#1-忘记-MobaXterm-主密码如何重置" class="headerlink" title="1.忘记 MobaXterm 主密码如何重置?"></a>1.忘记 MobaXterm 主密码如何重置?</h3><p>描述: 当 MobaXterm 从一台机器复制到另外一台机器上或者重新安装后，需要重新输入主密码（master password），如果此时忘记了则可使用官网提供的 ResetMasterPassword工具进行重置主密码 。</p><p>密码重置工具: <a href="https://mobaxterm.mobatek.net/resetmasterpassword.html" target="_blank" rel="noopener">https://mobaxterm.mobatek.net/resetmasterpassword.html</a></p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012180455.png" alt="WeiyiGeek.使用ResetMasterPassword工具图" title="" class="">                <p>WeiyiGeek.使用ResetMasterPassword工具图</p>            </figure><p>温馨提示：如果你重新设置你的主控密码使用这个工具，所有你的连接密码之前保存在MobaXterm将会丢失。 </p><hr><h2 id="0x02-脆弱性一览"><a href="#0x02-脆弱性一览" class="headerlink" title="0x02 脆弱性一览"></a>0x02 脆弱性一览</h2><h3 id="1-如何查看MobaXterm中存储的Session密码"><a href="#1-如何查看MobaXterm中存储的Session密码" class="headerlink" title="1.如何查看MobaXterm中存储的Session密码"></a>1.如何查看MobaXterm中存储的Session密码</h3><p>描述: 今天在登录某个服务器时，发现当时修改的某个服务器的密码，无法登陆到服务器(应该是自己修改的密码记错了)，然而我想起当时修改密码时是使用的MobaxTerm，并且记录了其会话密码，我便开心的以为我找到突破口，好在结果是可以登录的，然后我就想查看其存储密码，发现家庭版本居然不能查看保存的明文密码，坑呀.</p><p>在工作中为了方便登录会存储session账户密码，但时间一久就会忘记，如果没有备份密码，此时再想查看密码还真是件麻烦事, 遂有了此篇文章。</p><p><strong>MobaXterm忘记Session密码,如何查看已保存的密码?</strong></p><blockquote><p>通常情况下游两种方式，一种是将其版本升级到 <code>MobaXterm professional Edition</code> 直接查看存储的session密码（No money）, 另外一种是针对家庭版使用基于python的开源工具反向解析密码.</p></blockquote><ul><li>方式1.专业版查看存储的 session 密码, 注意家庭版是不可以使用此方法，必须进行升级</li></ul><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012093355.png" alt="WeiyiGeek.MobaXterm professional Edition 图" title="" class="">                <p>WeiyiGeek.MobaXterm professional Edition 图</p>            </figure><ul><li>方式2.使用 how-does-MobaXterm-encrypt-password 开源工具反向解析密码。<blockquote><p>项目地址: <a href="https://github.com/HyperSine/how-does-MobaXterm-encrypt-password" target="_blank" rel="noopener">https://github.com/HyperSine/how-does-MobaXterm-encrypt-password</a><br>fork 修改代码后的地址（推荐，不是还有进行修改代码）: <a href="https://github.com/WeiyiGeek/how-does-MobaXterm-encrypt-password" target="_blank" rel="noopener">https://github.com/WeiyiGeek/how-does-MobaXterm-encrypt-password</a></p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.拉取项目</span></span><br><span class="line">WeiyiGeek@WeiyiGeek MINGW64 ~/Downloads</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/WeiyiGeek/how-does-MobaXterm-encrypt-password.git</span><br><span class="line">$ ls</span><br><span class="line">MobaXtermCipher.py</span><br><span class="line">ShowMobaXterm.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装环境依赖</span></span><br><span class="line"><span class="comment"># 例如，在CentOS上安装 Python3 以及 开源工具依赖模块（此处由于我是Windows的，Python环境都已经配置号楼的，所以我只安装相关依赖模块）</span></span><br><span class="line">yum install -y git</span><br><span class="line">yum install python3</span><br><span class="line">yum install python3-pip</span><br><span class="line">pip3 install pycryto</span><br><span class="line"><span class="comment"># 上一个命令有可能会出错，请使用这个命令</span></span><br><span class="line">pip3 install pycryptodome</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.如果密码是存储在文件中, 可以找到 MobaXterm 安装目录下 MobaXterm.ini 文件，打开后找到Passwords模块，显示格式为: 登录名@ip=加密密码</span></span><br><span class="line">$ dir D:\Program Files\MobaXterm</span><br><span class="line">CygUtils.plugin        MobaXterm.ini  MobaXterm_Personal_20.1.exe</span><br><span class="line">MobaXterm\ backup.zip  MobaXterm.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.如果密码是存储在计算机密码中，可以查看如下【 计算机\HKEY_CURRENT_USER\SOFTWARE\Mobatek\MobaXterm】下的三个注册表地址。</span></span><br><span class="line">&gt; regedit  <span class="comment"># 打开注册表</span></span><br><span class="line">HKEY_CURRENT_USER\SOFTWARE\Mobatek\MobaXterm\C  <span class="comment"># 存储的自己创建认证票据</span></span><br><span class="line">HKEY_CURRENT_USER\SOFTWARE\Mobatek\MobaXterm\M  <span class="comment"># 存储的Master管理员密码(以经过加密的)</span></span><br><span class="line">HKEY_CURRENT_USER\SOFTWARE\Mobatek\MobaXterm\P  <span class="comment"># 存储了使用过程中记录的session会话IP端口，账号密码信息</span></span><br><span class="line"><span class="comment"># 例如，存储 session 会话信息格式</span></span><br><span class="line"><span class="comment"># Name             Type        Data</span></span><br><span class="line"><span class="comment"># example.com      REG_SZ      root:0XROpGmLAYVx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值名称 ：weiyigeek@10.0.30.70</span></span><br><span class="line"><span class="comment"># 数据类型 ：REG_SZ</span></span><br><span class="line"><span class="comment"># 数据值 ：7FzQQ12lpX7g2s8O39zquyQ=</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.也可以采用PowerShell命令进行查看</span></span><br><span class="line">Get-Item <span class="string">'HKCU:\SOFTWARE\Mobatek\MobaXterm\'</span></span><br><span class="line"><span class="comment"># 获取 SessionP 值</span></span><br><span class="line">(Get-ItemProperty <span class="string">'HKCU:\SOFTWARE\Mobatek\MobaXterm\'</span>).SessionP</span><br><span class="line">2493068723790</span><br><span class="line"><span class="comment"># Master/自创建的服务器账号密码/session会话记录的账号密码</span></span><br><span class="line">Get-ItemProperty <span class="string">'HKCU:\SOFTWARE\Mobatek\MobaXterm\m'</span></span><br><span class="line">Get-ItemProperty <span class="string">'HKCU:\SOFTWARE\Mobatek\MobaXterm\c'</span></span><br><span class="line">Get-ItemProperty <span class="string">'HKCU:\SOFTWARE\Mobatek\MobaXterm\p'</span></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012100126.png" alt="WeiyiGeek.MobaXterm注册表图" title="" class="">                <p>WeiyiGeek.MobaXterm注册表图</p>            </figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6.开源工具的使用帮助</span></span><br><span class="line"><span class="built_in">cd</span> how-does-MobaXterm-encrypt-password</span><br><span class="line">MobaXtermCipher.py &lt;enc|dec&gt; &lt;-sp SessionP&gt; &lt;plaintext|ciphertext&gt;</span><br><span class="line">MobaXtermCipher.py &lt;enc|dec&gt; &lt;-p master_password&gt; &lt;plaintext|ciphertext&gt;</span><br><span class="line">&lt;-sp SessionP&gt;           The value `SessionP` stored <span class="keyword">in</span> key HKCU\Software\Mobatek\MobaXterm</span><br><span class="line">&lt;-p master_password&gt;     The master password <span class="built_in">set</span> <span class="keyword">in</span> MobaXterm.</span><br><span class="line">&lt;plaintext|ciphertext&gt;   Plaintext string or ciphertext string.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在已知道自己设置Master密码的情况下可直接(此处假设我的 master密码是 weiyigeek)，将 plaintext|ciphertext 接到 -p 指定 master密码参数后。</span></span><br><span class="line">&gt; python MobaXtermCipher.py dec -p weiyigeek 8wCf+h+v2OpB0IrTPg==</span><br><span class="line">Hlwdmm94bngsn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 SessionP 加密解密</span></span><br><span class="line">C:\Users\WeiyiGeek\Downloads\how-does-MobaXterm-encrypt-password\python3&gt;python MobaXtermCipher.py enc -sp 2493068723790 weiyigeek</span><br><span class="line">31RwmZeeGndNigeRo0cud++YU8tNF8MTbZcoA3l3ThUnK</span><br><span class="line">C:\Users\WeiyiGeek\Downloads\how-does-MobaXterm-encrypt-password\python3&gt;python MobaXtermCipher.py dec -sp 2493068723790 31RwmZeeGndNigeRo0cud++YU8tNF8MTbZcoA3l3ThUnK</span><br><span class="line">weiyigeek</span><br><span class="line"></span><br><span class="line"><span class="comment"># ShowMobaXterm.py: 所有凭据和密码都可以通过 (注意该脚本只能在 Windows 上运行)</span></span><br><span class="line">python ShowMobaXterm.py</span><br><span class="line">python ShowMobaXterm.py weiyigeek</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012104737.png" alt="WeiyiGeek.ShowMobaXterm.py 图" title="" class="">                <p>WeiyiGeek.ShowMobaXterm.py 图</p>            </figure><p>官方参考地址：<a href="https://github.com/HyperSine/how-does-MobaXterm-encrypt-password#3-example" target="_blank" rel="noopener">https://github.com/HyperSine/how-does-MobaXterm-encrypt-password#3-example</a></p><p>温馨提示：如果在执行 <code>python ShowMobaXterm.py weiyigeek</code> 出现如下错误时，请将第 232 与 231 行的  <code>ConnHostname.encode(&#39;ansi&#39;),  ConnUsername.encode(&#39;ansi&#39;)</code> 删除，如果存储编码错误提示请将 encode 中 ansi 参数变成 uft8编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------------Passwords--------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"ShowMobaXterm.py"</span>, line 232, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ConnUsername.encode(<span class="string">'ansi'</span>)</span><br><span class="line">TypeError: DecryptPassword() takes 2 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><p>解决办法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ShowMobaXterm.py 中的 229 行</span></span><br><span class="line">ConnPassword = cipher.DecryptPassword(</span><br><span class="line">  Value</span><br><span class="line">).decode(<span class="string">"utf8"</span>,<span class="string">"ignore"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有中文编码</span></span><br><span class="line">encode(<span class="string">'ansi'</span>) =&gt; decode(<span class="string">"utf8"</span>,<span class="string">"ignore"</span>)</span><br></pre></td></tr></table></figure></p><p>然后顺手提交了一个 PR。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/10/20221012214713.png" alt="WeiyiGeek.在源项目中查看提交的PR图" title="" class="">                <p>WeiyiGeek.在源项目中查看提交的PR图</p>            </figure><p>[^features.html]: MobaXterm 功能参考 : <a href="https://mobaxterm.mobatek.net/features.html" target="_blank" rel="noopener">https://mobaxterm.mobatek.net/features.html</a><br>[^download.html]: MobaXterm 版本下载地址 : <a href="https://mobaxterm.mobatek.net/download.html" target="_blank" rel="noopener">https://mobaxterm.mobatek.net/download.html</a><br>[^plugins.html]:  MobaXterm 插件下载地址 : <a href="https://mobaxterm.mobatek.net/plugins.html" target="_blank" rel="noopener">https://mobaxterm.mobatek.net/plugins.html</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="Vulnerable" scheme="https://blog.weiyigeek.top/categories/Vulnerable/"/>
    
    <category term="Security" scheme="https://blog.weiyigeek.top/categories/Vulnerable/Security/"/>
    
    
    <category term="MobaXterm" scheme="https://blog.weiyigeek.top/tags/MobaXterm/"/>
    
  </entry>
  
  <entry>
    <title>个人规划/Untitled</title>
    <link href="https://blog.weiyigeek.top/2022/10-6-index.html"/>
    <id>https://blog.weiyigeek.top/2022/10-6-index.html</id>
    <published>2022-10-06T03:58:07.936Z</published>
    <updated>2022-10-06T03:58:07.936Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>9.使用RedisInsight工具对Redis集群CURD操作及数据可视化和性能监控</title>
    <link href="https://blog.weiyigeek.top/2022/9-20-686.html"/>
    <id>https://blog.weiyigeek.top/2022/9-20-686.html</id>
    <published>2022-09-20T14:35:30.000Z</published>
    <updated>2023-01-31T02:29:07.992Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-快速介绍"><a href="#0x00-快速介绍" class="headerlink" title="0x00 快速介绍"></a>0x00 快速介绍</h2><p><strong>什么是RedisInsight?</strong></p><blockquote><p>RedisInsight 是一个直观而高效的 Redis GUI (<code>可视化工具</code>)，它提供了设计、开发和优化 Redis 应用程序的功能，查询、分析您的 Redis 数据并与之交互，简化您的 Redis 应用程序开发 。（必备）<br>RedisInsight 现在采用了基于流行的 <code>Electron</code> 框架的全新技术堆栈, 它可以跨平台运行，支持 Linux、Windows 和 MacOS。 </p></blockquote><p><strong>为啥用RedisInsight?</strong><br>描述：RedisInsight 提供直观的 Redis 管理 GUI，有助于优化您在应用程序中对 Redis 的使用，相比于其他可视化工具，其实现的功能更强大、执行效率更改，通用性更好等特定，</p><p>下面列举出 RedisInsight 的亮点功能：</p><ul><li>唯一支持 Redis Cluster 的 GUI 工具；</li><li>可以基于 Browser 的界面来进行搜索键、查看和编辑数据；</li><li>支持基于 SSL/TLS 的连接，同时还可以在界面上进行内存分析；</li><li>支持连接 Redis Open Source、 Redis Stack 、 Redis Enterprise Software 、 Redis Enterprise Cloud 和 Amazon ElastiCache等系统；</li><li>支持自定义扩展插件实现更多功能。</li></ul><p><br/></p><p>RedisInsight 支持的功能：</p><ul><li>直观且高效的 GUI: 允许您与数据库交互、监控和管理您的数据。</li><li>CRUD支持更广泛：允许对列表、哈希、字符串、集、排序集以及流Stream 数据库结构支持 CRUD 。</li><li>多行查询编辑器：进行构建查询、探索结果、优化和快速迭代，支持 JSON 、 Search 、 Graph 、 Streams 、 Time Series 和 RedisGears 。 </li><li>内存分析：通过密钥模式、过期密钥和高级搜索来分析内存使用情况，以识别内存问题， 利用建议来减少内存使用量。 </li><li>命令调试: 识别顶部键、键模式和命令，按集群所有节点的客户端 IP 地址、密钥或命令进行过滤，有效地调试 Lua 脚本，并利用 Redis CLI 提供语法突出显示和自动完成功能，并采用集成帮助来提供直观的即时帮助。</li><li>指标监控：通过界面深入了解实时性能指标、检查慢速命令并管理 Redis 配置。 </li><li>发布/订阅：支持 Redis 发布/订阅，支持订阅频道并将消息发布到频道</li><li>数据浏览：浏览、筛选、可视化您的键值 Redis 数据结构，并查看不同格式（包括 JSON、十六进制、ASCII 等）的键值</li><li>平台兼容：适用于苹果操作系统（包括 M1）、Windows和 Linux</li></ul><p>补充：官方推荐的其他Redis数据库相关工具查看 [ <a href="https://redis.io/docs/tools/" target="_blank" rel="noopener">https://redis.io/docs/tools/</a> ]，当然你也可以可以选择客户端桌面管理工具(例如，AnotherRedisDesktopManage [ <a href="https://github.com/qishibo/AnotherRedisDesktopManager" target="_blank" rel="noopener">https://github.com/qishibo/AnotherRedisDesktopManager</a> ] )</p><hr><h2 id="0x01-安装部署"><a href="#0x01-安装部署" class="headerlink" title="0x01 安装部署"></a>0x01 安装部署</h2><p>描述：redis-insight 与现在大多数软件一样，有多种安装方式其中用得比较多的就是二进制、源码编译以及容器化部署的方式。</p><h3 id="二进制方式"><a href="#二进制方式" class="headerlink" title="二进制方式"></a>二进制方式</h3><p>描述：我们需要在Redis官方进行下载 redis-insight 二进制包然后进行安装部署，有可能国内下载比较缓慢，此时我已将其打包下来，方便大家下载。</p><p>Redis GUI redis-insight 工具 下载: </p><ul><li><a href="https://share.weiyigeek.top/d/36158960-51461225-1d5ee1?p=2088" target="_blank" rel="noopener">https://share.weiyigeek.top/d/36158960-51461225-1d5ee1?p=2088</a> (访问密码: 2088)</li><li><a href="https://url60.ctfile.com/d/36158960-51461225-1d5ee1?p=2088" target="_blank" rel="noopener">https://url60.ctfile.com/d/36158960-51461225-1d5ee1?p=2088</a> (访问密码: 2088)</li></ul><p><strong>环境依赖</strong></p><table><thead><tr><th style="text-align:center">Requirement</th><th style="text-align:center">Ubuntu</th><th style="text-align:center">MacOS</th><th style="text-align:center">Windows</th></tr></thead><tbody><tr><td style="text-align:center">Operating System</td><td style="text-align:center">Ubuntu 18.04 LTS or later</td><td style="text-align:center">MacOS 10.13 or later</td><td style="text-align:center">Windows 10</td></tr><tr><td style="text-align:center">Memory (RAM)</td><td style="text-align:center">8GB</td><td style="text-align:center">8GB</td><td style="text-align:center">8GB</td></tr><tr><td style="text-align:center">Processor</td><td style="text-align:center">64 bit</td><td style="text-align:center">64 bit</td><td style="text-align:center">32 bit or 64 bit</td></tr></tbody></table><p><br/></p><p><strong>安装环境</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release  -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.3 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br><span class="line"></span><br><span class="line">$ lscpu  | grep <span class="string">"CPU(s)"</span></span><br><span class="line">CPU(s):                          4</span><br><span class="line">On-line CPU(s) list:             0-3</span><br><span class="line"></span><br><span class="line">$ lsmem  | grep <span class="string">"Total online memory"</span></span><br><span class="line">Total online memory:       8G</span><br></pre></td></tr></table></figure></p><p><br/></p><p><strong>安装流程</strong></p><p>步骤 01.官网下载 RedisInsight 上传到 /usr/local/bin 目录 并打开 shell 终端赋予其下载权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line">mv redisinsight-linux64-1.13.0 redisinsight-linux64</span><br><span class="line">chmod +x redisinsight-linux64</span><br></pre></td></tr></table></figure></p><p>步骤 02.设置Redisinsight启动所需的环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/.redisinsight</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export RIHOST=0.0.0.0"</span> &gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export RIPORT=8081"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export RIHOMEDIR=~/.redisinsight"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export RILOGDIR=~/.redisinsight"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>温馨提示：如果使用了<code>REDISINSIGHT_HOST, REDISINSIGHT_PORT, REDISINSIGHT_HOME_DIR and LOG_DIR</code>等环境变量便会出现如下提示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING 2022-09-20 05:56:33,461 redisinsight_startup REDISINSIGHT_HOST, REDISINSIGHT_PORT, REDISINSIGHT_HOME_DIR and LOG_DIR environment variables will be deprecated in the version v1.9.</span><br><span class="line">Please use RIHOST, RIPORT, RIHOMEDIR and RILOGDIR environment variables for setting host, port, db directory and log directory respectively.</span><br></pre></td></tr></table></figure></p><p>步骤 03.启动Redisinsight并后台运行它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  后台运行</span></span><br><span class="line">nohup /usr/<span class="built_in">local</span>/bin/redisinsight-linux64 &gt; ~/.redisinsight/console.log 2&gt;&amp;1 &amp;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">步骤 04.查看 redisinsight 进程运行情况</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">root@weiyigeek:~<span class="comment"># ps aux | grep "redisinsight"</span></span><br><span class="line">root        6592  8.0  0.0   3220  2212 pts/0    S    13:59   0:00 /usr/<span class="built_in">local</span>/bin/redisinsight-linux64</span><br><span class="line">root        6593  8.9  0.9 602080 74616 pts/0    Sl   13:59   0:00 /usr/<span class="built_in">local</span>/bin/redisinsight-linux64</span><br><span class="line">root        6602  0.0  0.0   6432   724 pts/0    S+   13:59   0:00 grep redisinsight</span><br><span class="line">root@weiyigeek:~<span class="comment"># netstat -ano | grep ":8081"</span></span><br><span class="line">tcp        0      0 0.0.0.0:8081            0.0.0.0:*               LISTEN      off (0.00/0/0)</span><br></pre></td></tr></table></figure><p>步骤 05.访问部署的redisinsight站点 <a href="http://10.20.172.201:8081/" target="_blank" rel="noopener">http://10.20.172.201:8081/</a> 进行下一步配置，继续配置你的 Redis 数据库，此处我已经搭建好了一个redis数据库如需搭建请参考此篇文章【<a href="https://blog.weiyigeek.top/2022/4-24-653.html">https://blog.weiyigeek.top/2022/4-24-653.html</a>】，点击连接到 Redis 数据库进入到下一步。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920143243.png" alt="WeiyiGeek.redisinsight站点" title="" class="">                <p>WeiyiGeek.redisinsight站点</p>            </figure><p>步骤 06.进行配置Redis数据库信息，此处我是单节点进行演示，输入主机、端口、名称、以及redis密码。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920143416.png" alt="WeiyiGeek.配置Redis数据库信息" title="" class="">                <p>WeiyiGeek.配置Redis数据库信息</p>            </figure><p>至此安装配置完成，使用将在后续实践！</p><p><br/></p><h3 id="容器化方式"><a href="#容器化方式" class="headerlink" title="容器化方式"></a>容器化方式</h3><p>描述：当下大多数企业的应用都是在容器环境中运行，所以redis官方也提供了相应容器镜像以及在kubernetes中部署的资源清单，下述将演示在 Kubernetes 上安装 RedisInsight，安装高可用的K8S可以参照此篇文章 【 <a href="https://blog.weiyigeek.top/2022/6-7-664.html">https://blog.weiyigeek.top/2022/6-7-664.html</a> 】</p><p>镜像主页：<a href="https://hub.docker.com/r/redislabs/redisinsight/tags" target="_blank" rel="noopener">https://hub.docker.com/r/redislabs/redisinsight/tags</a><br>镜像名称：<code>docker pull redislabs/redisinsight:1.13.0</code></p><p><strong>部署方式</strong></p><p>步骤 01.在 k8s 集群中创建一个 RedisInsight 部署和服务 YAML 文件资源清单，注意此处我使用了动态存储卷，如果有需要的部署nfs动态存储卷可参考此篇文章（ <a href="https://blog.weiyigeek.top/2022/6-7-664.html">https://blog.weiyigeek.top/2022/6-7-664.html</a> ）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tee</span> <span class="string">redisinsight-1.13.0.yaml</span> <span class="string">&lt;&lt;'EOF'</span></span><br><span class="line"><span class="comment"># RedisInsight service with name 'redisinsight-service'</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">redisinsight-service</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">redisinsight</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># RedisInsight persistant storage </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">redisinsight-pv-claim</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">redisinsight</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">2</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">managed-nfs-storage</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># RedisInsight deployment with name 'redisinsight'</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">redisinsight</span>   <span class="comment"># deployment name</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">redisinsight</span>  <span class="comment"># deployment label</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span>          <span class="comment"># a single replica pod</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">Recreate</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">redisinsight</span> <span class="comment"># which pods is the deployment managing, as defined by the pod template</span></span><br><span class="line"><span class="attr">  template:</span>             <span class="comment"># pod template</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">redisinsight</span> <span class="comment"># label for pod/s</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">db</span></span><br><span class="line"><span class="attr">          persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">            claimName:</span> <span class="string">redisinsight-pv-claim</span></span><br><span class="line"><span class="attr">      initContainers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">init</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">/bin/sh</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">'-c'</span></span><br><span class="line"><span class="bullet">            -</span> <span class="string">|</span></span><br><span class="line"><span class="string">                            chown -R 1001 /db</span></span><br><span class="line"><span class="string"></span><span class="attr">          resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">db</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/db</span></span><br><span class="line"><span class="attr">          terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line"><span class="attr">          terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span>  <span class="string">redisinsight</span>                  <span class="comment"># Container name (DNS_LABEL, unique)</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">redislabs/redisinsight:1.13.0</span> <span class="comment"># Hub Image</span></span><br><span class="line"><span class="attr">          imagePullPolicy:</span> <span class="string">IfNotPresent</span>        <span class="comment"># Pull Policy</span></span><br><span class="line"><span class="attr">          env:</span> </span><br><span class="line"><span class="attr">          - name:</span> <span class="string">RIHOST</span></span><br><span class="line"><span class="attr">            value:</span> <span class="string">"0.0.0.0"</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">RIPORT</span></span><br><span class="line"><span class="attr">            value:</span> <span class="string">"8001"</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">db</span> </span><br><span class="line"><span class="attr">            mountPath:</span> <span class="string">/db</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">          - containerPort:</span> <span class="number">8001</span>        <span class="comment"># exposed container port and protocol</span></span><br><span class="line"><span class="attr">            protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          livenessProbe:</span></span><br><span class="line"><span class="attr">            httpGet:</span></span><br><span class="line">              <span class="string">path</span> <span class="string">:</span> <span class="string">/healthcheck/</span>     <span class="comment"># exposed RI endpoint for healthcheck</span></span><br><span class="line"><span class="attr">              port:</span> <span class="number">8001</span>               <span class="comment"># exposed container port</span></span><br><span class="line"><span class="attr">            initialDelaySeconds:</span> <span class="number">5</span>      <span class="comment"># number of seconds to wait after the container starts to perform liveness probe</span></span><br><span class="line"><span class="attr">            periodSeconds:</span> <span class="number">5</span>            <span class="comment"># period in seconds after which liveness probe is performed</span></span><br><span class="line"><span class="attr">            failureThreshold:</span> <span class="number">1</span>         <span class="comment"># number of liveness probe failures after which container restarts</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>步骤02.在k8s集群中部署 redisinsight v1.13.0 应用、服务以及持久化卷，查看其部署状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create namespace dev</span><br><span class="line">namespace/dev created</span><br><span class="line"></span><br><span class="line">$ kubectl apply -f redisinsight-1.13.0.yaml</span><br><span class="line">service/redisinsight-service created</span><br><span class="line">persistentvolumeclaim/redisinsight-pv-claim created</span><br><span class="line">deployment.apps/redisinsight created</span><br><span class="line"></span><br><span class="line">$ kubectl get pod,svc -n dev -o wide</span><br><span class="line">NAME                               READY   STATUS    RESTARTS   AGE     IP              NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">pod/redisinsight-55d44b5bb-xzggg   1/1     Running   0          3m22s   10.66.182.217   weiyigeek-226   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">NAME                           TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE     SELECTOR</span><br><span class="line">service/redisinsight-service   LoadBalancer   10.108.198.8   &lt;pending&gt;     80:31793/TCP   3m22s   app=redisinsight</span><br><span class="line"></span><br><span class="line">$ curl -I 10.66.182.217:8001</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: max-age=0, no-cache, no-store, must-revalidate, private</span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口转发</span></span><br><span class="line">$ kubectl -n dev port-forward deployment/redisinsight --address 0.0.0.0 30081:8001</span><br><span class="line">Forwarding from 0.0.0.0:30081 -&gt; 8001</span><br><span class="line">Handling connection <span class="keyword">for</span> 30081</span><br><span class="line">Handling connection <span class="keyword">for</span> 30081</span><br></pre></td></tr></table></figure><p>步骤 03.成功应用并完成部署和服务，我们可通过浏览器访问 192.168.1.107:31793 便可看到如下图所示界面。<br><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920143243.png" alt="WeiyiGeek.redisinsight站点" title="" class="">                <p>WeiyiGeek.redisinsight站点</p>            </figure></p><p>至此，在k8s集群中部署完毕</p><hr><h2 id="0x02-实践应用"><a href="#0x02-实践应用" class="headerlink" title="0x02 实践应用"></a>0x02 实践应用</h2><h3 id="1-配置连接的Redis数据库"><a href="#1-配置连接的Redis数据库" class="headerlink" title="1.配置连接的Redis数据库"></a>1.配置连接的Redis数据库</h3><p>描述：在使用任何工具处理数据库之前，必须先添加数据库（Add Database），以便 RedisInsight 可以连接到该数据库，添加独立的 Redis 数据库 这是只有一台 Redis 服务器的 Redis 数据库最简单的设置，当然也支持独立 Redis 集群 Redis Sentinel 或者 具有TLS认证的Redis数据库。<br>注意：目前 RedisInsight 支持 Redis 版本 4 及更高版本。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920143416.png" alt="WeiyiGeek.配置Redis数据库信息" title="" class="">                <p>WeiyiGeek.配置Redis数据库信息</p>            </figure><h3 id="2-查看Redis数据库实时统计信息"><a href="#2-查看Redis数据库实时统计信息" class="headerlink" title="2.查看Redis数据库实时统计信息"></a>2.查看Redis数据库实时统计信息</h3><p>描述：点击配置好的Redis数据目标，即可看到如下overview页面</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920173633.png" alt="WeiyiGeek.此Redis数据库的实时统计信息" title="" class="">                <p>WeiyiGeek.此Redis数据库的实时统计信息</p>            </figure><h3 id="3-操作Redis数据库中的数据"><a href="#3-操作Redis数据库中的数据" class="headerlink" title="3.操作Redis数据库中的数据"></a>3.操作Redis数据库中的数据</h3><p>描述: 可以通过使用 Browser（图形） 或者 cli（命令行）进行Redis数据库的CURD，如下图所示</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920174712.png" alt="WeiyiGeek.Redis数据库的CURD操作" title="" class="">                <p>WeiyiGeek.Redis数据库的CURD操作</p>            </figure><h3 id="4-操作Redis数据库中的流Streams数据"><a href="#4-操作Redis数据库中的流Streams数据" class="headerlink" title="4.操作Redis数据库中的流Streams数据"></a>4.操作Redis数据库中的流Streams数据</h3><p>描述: 可以通过使用 Streams 选项进行 Redis 流操作。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920174755.png" alt="WeiyiGeek.Redis数据库的流操作" title="" class="">                <p>WeiyiGeek.Redis数据库的流操作</p>            </figure><h3 id="5-性能内存、慢查询分析"><a href="#5-性能内存、慢查询分析" class="headerlink" title="5.性能内存、慢查询分析"></a>5.性能内存、慢查询分析</h3><p>描述：RedisInsight 提供了强大的分析功能，支持内存使用分析、分析器(<code>在Redis中执行的命令过程摘要分析</code>)以及慢日志查询。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920180241.png" alt="WeiyiGeek.Redis数据库分析" title="" class="">                <p>WeiyiGeek.Redis数据库分析</p>            </figure><h3 id="6-可视化配置redis数据库"><a href="#6-可视化配置redis数据库" class="headerlink" title="6.可视化配置redis数据库"></a>6.可视化配置redis数据库</h3><p>描述：在Database选项卡中我们可以直接配置Redis数据库，包括其网络配置、通用配置以及快照、配置等等。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220920175742.png" alt="WeiyiGeek.在线配置redis数据库" title="" class="">                <p>WeiyiGeek.在线配置redis数据库</p>            </figure><p>当然对应devops来说使用最多的还是CURD以及性能分析以及优化，此工具还是非常方便的，如需解更多其它功能需的朋友，可参考 redisinsight 用户使用文档：<a href="https://docs.redis.com/latest/ri/using-redisinsight/" target="_blank" rel="noopener">https://docs.redis.com/latest/ri/using-redisinsight/</a></p><hr><h2 id="0x03-入坑出坑"><a href="#0x03-入坑出坑" class="headerlink" title="0x03 入坑出坑"></a>0x03 入坑出坑</h2><h3 id="问题1-运行-RedisInsight-v2-linux-x86-64-时出现不存在libatk-1-0-so-0-libatk-bridge-2-0-so-0-libcups-so-2-libgtk-3-so-0等错误"><a href="#问题1-运行-RedisInsight-v2-linux-x86-64-时出现不存在libatk-1-0-so-0-libatk-bridge-2-0-so-0-libcups-so-2-libgtk-3-so-0等错误" class="headerlink" title="问题1.运行 RedisInsight-v2-linux-x86_64 时出现不存在libatk-1.0.so.0/libatk-bridge-2.0.so.0/libcups.so.2/libgtk-3.so.0等错误"></a>问题1.运行 RedisInsight-v2-linux-x86_64 时出现不存在<code>libatk-1.0.so.0/libatk-bridge-2.0.so.0/libcups.so.2/libgtk-3.so.0</code>等错误</h3><ul><li><p>错误信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@weiyigeek:/usr/<span class="built_in">local</span>/bin<span class="comment"># wget https://download.redisinsight.redis.com/latest/RedisInsight-v2-linux-x86_64.AppImage</span></span><br><span class="line">root@weiyigeek:/usr/<span class="built_in">local</span>/bin<span class="comment"># mv RedisInsight-v2-linux-x86_64.AppImage RedisInsight</span></span><br><span class="line">root@weiyigeek:/usr/<span class="built_in">local</span>/bin<span class="comment"># chmod +x RedisInsight</span></span><br><span class="line">root@weiyigeek:/usr/<span class="built_in">local</span>/bin<span class="comment"># ./RedisInsight</span></span><br><span class="line">/tmp/.mount_RedisIuCY68M/redisinsight: error <span class="keyword">while</span> loading shared libraries: libatk-1.0.so.0: cannot open shared object file: No such file or directory</span><br><span class="line">/tmp/.mount_RedisIbwUuBs/redisinsight: error <span class="keyword">while</span> loading shared libraries: libatk-bridge-2.0.so.0: cannot open shared object file: No such file or directory</span><br><span class="line">/tmp/.mount_RedisIb3qNiD/redisinsight: error <span class="keyword">while</span> loading shared libraries: libcups.so.2: cannot open shared object file: No such file or directory</span><br><span class="line">/tmp/.mount_RedisI9GZsHC/redisinsight: error <span class="keyword">while</span> loading shared libraries: libgtk-3.so.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure></li><li><p>解决办法：由于我的测试系统是Ubuntu的则使用apt命令安装错误提示中的依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install libatk1.0-dev</span><br><span class="line">apt install libatk-bridge2.0-dev</span><br><span class="line">apt install libcups2-dev</span><br><span class="line">apt install libgtk-3-dev</span><br></pre></td></tr></table></figure></li></ul><p><br/></p><h3 id="问题2-运行-RedisInsight-v2-linux-x86-64-时出现-root-without-no-sandbox-is-not-supported-错误提示："><a href="#问题2-运行-RedisInsight-v2-linux-x86-64-时出现-root-without-no-sandbox-is-not-supported-错误提示：" class="headerlink" title="问题2.运行 RedisInsight-v2-linux-x86_64 时出现 root without --no-sandbox is not supported 错误提示："></a>问题2.运行 RedisInsight-v2-linux-x86_64 时出现 <code>root without --no-sandbox is not supported</code> 错误提示：</h3><p>错误信息：<code>[0920/133850.852943:FATAL:electron_main_delegate.cc(292)] Running as root without --no-sandbox is not supported. See https://crbug.com/638180.</code><br>解决办法：在低权限用户中执行<code>./RedisInsight</code>启动RedisInsight服务即可。</p><hr><h2 id="0x0n-参考来源"><a href="#0x0n-参考来源" class="headerlink" title="0x0n 参考来源"></a>0x0n 参考来源</h2><p>官网地址：<a href="https://redis.com/redis-enterprise/redis-insight/" target="_blank" rel="noopener">https://redis.com/redis-enterprise/redis-insight/</a><br>项目源码：<a href="https://github.com/RedisInsight/RedisInsight" target="_blank" rel="noopener">https://github.com/RedisInsight/RedisInsight</a><br>项目文档：<a href="https://docs.redis.com/latest/ri" target="_blank" rel="noopener">https://docs.redis.com/latest/ri</a><br>下载地址：<a href="https://redis.com/redis-enterprise/redis-insight/#insight-form" target="_blank" rel="noopener">https://redis.com/redis-enterprise/redis-insight/#insight-form</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="Database" scheme="https://blog.weiyigeek.top/categories/Database/"/>
    
    
    <category term="Redis" scheme="https://blog.weiyigeek.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Kaniko在Kubernetes集群中快速构建推送容器镜像</title>
    <link href="https://blog.weiyigeek.top/2022/9-1-684.html"/>
    <id>https://blog.weiyigeek.top/2022/9-1-684.html</id>
    <published>2022-09-01T09:37:47.000Z</published>
    <updated>2023-01-31T02:29:10.641Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><h3 id="快速介绍"><a href="#快速介绍" class="headerlink" title="快速介绍"></a>快速介绍</h3><h4 id="什么是Kaniko"><a href="#什么是Kaniko" class="headerlink" title="什么是Kaniko?"></a>什么是Kaniko?</h4><blockquote><p>kaniko 是一个在 containerd 或 Kubernetes 集群内从 Dockerfile 构建容器镜像的工具 ( Build Container Images In Kubernetes )。</p></blockquote><figure class="image-box">                <img src="https://raw.githubusercontent.com/GoogleContainerTools/kaniko/main/docs/demo.gif" alt="官方介绍" title="" class="">                <p>官方介绍</p>            </figure><p>温馨提示: kaniko不是谷歌官方发布支持的产品.</p><h4 id="为啥用Kaniko"><a href="#为啥用Kaniko" class="headerlink" title="为啥用Kaniko?"></a>为啥用Kaniko?</h4><blockquote><p>由于 kaniko 不依赖于 Docker 守护进程，并且完全在用户空间中执行 Dockerfile 中的每个命令，这使得能够在轻松或安全地运行在<code>无Docker守护程序的环境</code>（如标准Kubernetes集群 V1.24.x）中构建容器映像。<br>在 Kubernetes V1.24.x 版本之后默认采用 containerd.io 作为缺省的cri，不在支持 docker-shim 意味着我们不需要安装 docker 环境</p></blockquote><h4 id="Kaniko-是如何工作的"><a href="#Kaniko-是如何工作的" class="headerlink" title="Kaniko 是如何工作的?"></a>Kaniko 是如何工作的?</h4><p>kaniko 执行器镜像负责从 Dockerfile 构建镜像并将其推送到注册表，其流程大致如下：</p><ul><li>首先在执行者图像中，我们提取基础镜像的文件系统（Dockerfile 中的 FROM 镜像）。 </li><li>其次我们执行 Dockerfile 中的命令，之后在用户空间中对文件系统进行快照每一个。 </li><li>然后在每个命令之后，我们将一层更改的文件附加到基础 图像（如果有）并更新图像元数据。 </li></ul><h4 id="Kaniko-已知功能问题"><a href="#Kaniko-已知功能问题" class="headerlink" title="Kaniko 已知功能问题"></a>Kaniko 已知功能问题</h4><ul><li>kaniko 不支持构建 Windows 容器。 </li><li>kaniko 不支持 v1 Registry API。(由于其不安全性当前基本都是使用V2协议, 例如 Harbor)</li><li>kaniko 不支持在除官方kaniko映像之外的任何Docker映像中运行二进制Kanico可执行文件（即YMMV）。</li></ul><h4 id="kaniko-构建上下文"><a href="#kaniko-构建上下文" class="headerlink" title="kaniko 构建上下文"></a>kaniko 构建上下文</h4><p>描述: kaniko 的构建上下文与您发送 Docker 守护程序以进行映像构建的构建上下文非常相似；它代表一个包含 Dockerfile 的目录，kaniko 将使用它来构建您的图像。<br>例如, Dockerfile 中的 COPY 命令应该引用构建上下文中的文件, 所以您需要将构建上下文存储在 kaniko 可以访问的位置。 </p><p>目前kaniko 支持以下存储解决方案：</p><ul><li>GCS Bucket</li><li>S3 Bucket</li><li>Azure Blob Storage</li><li>Local Directory</li><li>Local Tar</li><li>Standard Input</li><li>Git Repository</li></ul><p>运行 kaniko 时，使用 <code>--context</code> 带有适当前缀的标志指定构建上下文的位置, 如果您不指定前缀 kaniko 将假定一个本地目录, 该参数可用值：</p><table><thead><tr><th style="text-align:left">Source</th><th>Prefix</th><th>Example</th></tr></thead><tbody><tr><td style="text-align:left">Local Directory</td><td>dir://[path to a directory in the kaniko container]</td><td><code>dir:///workspace</code></td></tr><tr><td style="text-align:left">Local Tar Gz</td><td>tar://[path to a .tar.gz in the kaniko container]</td><td><code>tar://path/to/context.tar.gz</code></td></tr><tr><td style="text-align:left">Standard Input</td><td>tar://[stdin]</td><td><code>tar://stdin</code></td></tr><tr><td style="text-align:left">GCS Bucket</td><td>gs://[bucket name]/[path to .tar.gz]</td><td><code>gs://kaniko-bucket/path/to/context.tar.gz</code></td></tr><tr><td style="text-align:left">S3 Bucket</td><td>s3://[bucket name]/[path to .tar.gz]</td><td><code>s3://kaniko-bucket/path/to/context.tar.gz</code></td></tr><tr><td style="text-align:left">Azure Blob Storage</td><td>https://[account].[azureblobhostsuffix]/[container]/[path to .tar.gz]</td><td><code>https://myaccount.blob.core.windows.net/container/path/to/context.tar.gz</code></td></tr><tr><td style="text-align:left">Git Repository</td><td>git://[repository url][#reference][#commit-id]</td><td><code>git://github.com/acme/myproject.git#refs/heads/mybranch#</code></td></tr></tbody></table><p>例如，要使用名为 kaniko-bucket 的 GCS 存储桶，您需要传入 <code>--context=gs://kaniko-bucket/path/to/context.tar.gz</code> 。</p><p>温馨提示：kaniko 允许的唯一标准输入是 <code>.tar.gz</code> 格式, 如果要创建压缩 tar，您可以运行 <code>tar -C &lt;path to build context&gt; -zcvf context.tar.gz .</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ls cache/</span><br><span class="line">Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩上下文目录</span></span><br><span class="line">$ tar -C cache/ -zcvf context.tar.gz .</span><br><span class="line">./</span><br><span class="line">./Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看压缩文件</span></span><br><span class="line">$ tar -ztvf context.tar.gz</span><br><span class="line">drwxr-xr-x root/root         0 2022-09-08 23:03 ./</span><br><span class="line">-rw-r--r-- root/root        52 2022-09-08 23:04 ./Dockerfile</span><br></pre></td></tr></table></figure><h4 id="kaniko-缓存构建"><a href="#kaniko-缓存构建" class="headerlink" title="kaniko 缓存构建"></a>kaniko 缓存构建</h4><ul><li>Caching Layers ：kaniko 可以在远程存储库中缓存由RUN（由flag–cache-RUN-layers配置）和COPY（由flag–cache-COPY-layeers配置）命令创建的层。<blockquote><p>在执行命令之前 kaniko 会检查层的缓存，如果存在 kaniko将拉取并提取缓存层，而不是执行命令。如果没有 kaniko将执行命令，然后将新创建的层推送到缓存。<br>用户可以通过设置 <code>--cache=true</code> 标志选择缓存,并且可以通过<code>--cache-repo</code> 标志提供用于存储缓存层的远程存储库, 如果未提供此标志则将从提供的<code>--destination</code>推断缓存的repo。<br>温馨提示: 在缓存未命中后，kaniko无法从缓存中找到读取层，所有后续层都将在本地构建，而无需咨询缓存。</p></blockquote></li><li>Caching Base Images: kaniko 可以将图像缓存在本地目录中，该目录可以卷装载到KanikoPod中。为此必须首先填充缓存, 我们在 <code>gcr.io/kaniko-project/warmer</code> 提供了一个kaniko缓存预热映像：<blockquote><p>–image : 指定所需任意数量的图像, 填充缓存后 使用与上述相同的 <code>--cache=true</code> 标志选择缓存, 本地缓存的位置通过 <code>--cache-dir</code> 标志提供，默认为 <code>/cache</code> 与缓存预热器一样, 在实践中通常与 Kubernetes 集群和持久缓存卷一起使用。<br>示例： <code>docker run -v $(pwd):/workspace gcr.io/kaniko-project/warmer:latest --cache-dir=/workspace/cache --image=&lt;image to cache&gt; --image=&lt;another image to cache&gt;</code></p></blockquote></li></ul><hr><h2 id="0x01-部署使用"><a href="#0x01-部署使用" class="headerlink" title="0x01 部署使用"></a>0x01 部署使用</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><ul><li>kaniko 图像镜像</li><li>一个 Kubernetes 集群 或者 一个 Containerd 容器运行环境。</li><li>一个 dockerhub 帐户 用于将构建的图像公开。</li></ul><p><br/></p><h3 id="小试牛刀之在Kubernetes集群中构建并发布镜像"><a href="#小试牛刀之在Kubernetes集群中构建并发布镜像" class="headerlink" title="小试牛刀之在Kubernetes集群中构建并发布镜像"></a>小试牛刀之在Kubernetes集群中构建并发布镜像</h3><p>描述: 此处我们准备在一个K8S集群中使用kaniko提供的镜像，按照提供的Dockerfile指令进行镜像构建，并上传到 docker hub 仓库中，以下为操作流程、</p><p><strong>操作流程</strong><br>步骤 01.首先, 为了加快构建速度, 我们提前在集群中拉取 <code>gcr.io/kaniko-project/executor</code> 镜像到本地, 由于国内无法直接拉取此处我采用这篇<a href="https://blog.weiyigeek.top/2022/6-1-663.html">【使用Aliyun容器镜像服务对海外gcr、quay仓库镜像进行镜像拉取构建】</a> 文章中的方法进行拉取构建国外gcr.io仓库中的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处我已经创建了国内可以访问拉取的 executor 镜像, 不想在Aliyun容器镜像服务中进行创建拉取的朋友可以直接使用如下仓库地址。</span></span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ctr 或者 crictl 进行镜像拉取</span></span><br><span class="line">$ crictl pull registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span><br><span class="line">$ crictl images | grep <span class="string">"kaniko-executor"</span></span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor  latest  da9592dbe1de3   25.8MB</span><br></pre></td></tr></table></figure><p>步骤 02.准备一个 Dockerfile 此处将 <code>registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor</code> 镜像打包上传到hub中作为演示。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建存放dockerfile目录以及持久化缓存目录</span></span><br><span class="line">mkdir -vp /storage/dev/soft/kaniko/&#123;cache,demo&#125;</span><br><span class="line"><span class="built_in">cd</span> /storage/dev/soft/kaniko/demo</span><br><span class="line">tee dockerfile &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">FROM registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span><br><span class="line">LABEL MAINTAINER=master@weiyigeeek.top BUILDTYPE=kaniko</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>步骤 03.创建一个授权令牌的 Secret , 此处以公共的docker hub为例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法:</span></span><br><span class="line">~$ kubectl create secret docker-registry dockerhub --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数值:</span></span><br><span class="line"><span class="comment"># &lt;your-registry-server&gt; is your Private Docker Registry FQDN. (https://index.docker.io/v1/ for DockerHub)</span></span><br><span class="line"><span class="comment"># &lt;your-name&gt; is your Docker username.</span></span><br><span class="line"><span class="comment"># &lt;your-pword&gt; is your Docker password.</span></span><br><span class="line"><span class="comment"># &lt;your-email&gt; is your Docker email.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建示例: 此 docker-registry 将在 pod.yaml 配置中使用</span></span><br><span class="line">~$ kubectl create secret docker-registry dockerhub \</span><br><span class="line">--docker-server=https://index.docker.io/v1/ \</span><br><span class="line">--docker-username=weiyigeek \</span><br><span class="line">--docker-password=PASSWORD \</span><br><span class="line">--docker-email=master@weiyigeek.top</span><br><span class="line"><span class="comment"># secret/dockerhub created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的 secrets 情况</span></span><br><span class="line">~$ kubectl get secrets dockerhub</span><br><span class="line">NAME        TYPE                             DATA   AGE</span><br><span class="line">dockerhub   kubernetes.io/dockerconfigjson   1      16s</span><br><span class="line"></span><br><span class="line">~$ kubectl get secrets dockerhub -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  .dockerconfigjson: eyJhdXRo*******VhsbE1qQXhPUT09In19fQ==</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: dockerhub</span><br></pre></td></tr></table></figure></p><p>步骤 04.创建一个在k8s集群中运行的Pod，其资源清单如下所示：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">tee</span> <span class="string">kaniko.yaml</span> <span class="string">&lt;&lt;'EOF'</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kaniko</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kaniko</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">DOCKERHUB</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"docker.io"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">AUTHOR</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"weiyigeek"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">IMAGE_NAME</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"kaniko-executor"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">IMAGE_VERSION</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"v1.9.0"</span></span><br><span class="line"><span class="attr">    args:</span> <span class="string">[</span> <span class="string">"--dockerfile=/workspace/dockerfile"</span><span class="string">,</span></span><br><span class="line">            <span class="string">"--context=dir://workspace"</span><span class="string">,</span></span><br><span class="line">            <span class="string">"--destination=docker.io/weiyigeek/kaniko-executor:v1.9.0"</span><span class="string">,</span></span><br><span class="line">            <span class="string">"--cache"</span><span class="string">,</span></span><br><span class="line">            <span class="string">"--cache-dir=/cache"</span><span class="string">]</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kaniko-secret</span></span><br><span class="line"><span class="attr">        mountPath:</span> <span class="string">/kaniko/.docker</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">dockerfile-storage</span></span><br><span class="line"><span class="attr">        mountPath:</span> <span class="string">/workspace</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">kaniko-cache</span></span><br><span class="line"><span class="attr">        mountPath:</span> <span class="string">/cache</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line">    <span class="string">kubernetes.io/hostname:</span> <span class="string">"weiyigeek-226"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kaniko-secret</span></span><br><span class="line"><span class="attr">      secret:</span></span><br><span class="line"><span class="attr">        secretName:</span> <span class="string">dockerhub</span></span><br><span class="line"><span class="attr">        items:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">.dockerconfigjson</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">config.json</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">dockerfile-storage</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/storage/dev/soft/kaniko/demo</span></span><br><span class="line"><span class="attr">        type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kaniko-cache</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/storage/dev/soft/kaniko/cache</span></span><br><span class="line"><span class="attr">        type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># args 参数说明</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-dockerfile=/workspace/dockerfile</span>   <span class="comment"># 指定 dockerfile 路径</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-context=dir://workspace</span>            <span class="comment"># 指定构建上下文</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-destination=docker.io/weiyigeek/kaniko-executor:v1.9.0</span>  <span class="comment"># 指定生成镜像的tag</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-cache</span>     <span class="comment"># 使用缓存</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-cache-dir</span> <span class="comment"># 指定缓存目录</span></span><br></pre></td></tr></table></figure><p>温馨提示: kaniko 中的二进制可执行文件 executor 支持的参数详解(<a href="https://github.com/GoogleContainerTools/kaniko/#additional-flags" target="_blank" rel="noopener">https://github.com/GoogleContainerTools/kaniko/#additional-flags</a>)</p><p>步骤 05.执行 <code>kubectl apply</code> 部署资源清单生成运行 pod , 此处通过 <code>kubectl logs</code> 日志命令可以发现kaniko执行镜像构建，以及上传镜像到docker hub之中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kaniko.yaml</span><br><span class="line"><span class="comment"># pod/kaniko created</span></span><br><span class="line"></span><br><span class="line">kubectl logs -f kaniko</span><br><span class="line"><span class="comment"># INFO[0005] Retrieving image manifest registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span></span><br><span class="line"><span class="comment"># INFO[0005] Retrieving image registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest from registry registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="comment"># INFO[0006] Built cross stage deps: map[]</span></span><br><span class="line"><span class="comment"># INFO[0006] Retrieving image manifest registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span></span><br><span class="line"><span class="comment"># INFO[0006] Returning cached image manifest</span></span><br><span class="line"><span class="comment"># INFO[0006] Executing 0 build triggers</span></span><br><span class="line"><span class="comment"># INFO[0006] Building stage 'registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest' [idx: '0', base-idx: '-1']</span></span><br><span class="line"><span class="comment"># INFO[0006] Skipping unpacking as no commands require it.</span></span><br><span class="line"><span class="comment"># INFO[0006] LABEL MAINTAINER=master@weiyigeeek.top BUILDTYPE=kaniko</span></span><br><span class="line"><span class="comment"># INFO[0006] Applying label MAINTAINER=master@weiyigeeek.top</span></span><br><span class="line"><span class="comment"># INFO[0006] Applying label BUILDTYPE=kaniko</span></span><br><span class="line"><span class="comment"># INFO[0006] Pushing image to docker.io/weiyigeek/kaniko-executor:v1.9.0</span></span><br></pre></td></tr></table></figure><p>步骤 06.在客户端中可以使用 docker 或者 ctr 、crictl 命令将上传到hub中的镜像进行拉取, 并且查看hub仓库中的 <code>kaniko-executor:v1.9.0</code> 镜像信息（<a href="https://hub.docker.com/r/weiyigeek/kaniko-executor）。" target="_blank" rel="noopener">https://hub.docker.com/r/weiyigeek/kaniko-executor）。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull weiyigeek/kaniko-executor:v1.9.0</span><br><span class="line">9d4299bbd943: Already exists</span><br><span class="line">..............</span><br><span class="line">a8dae3110e38: Already exists</span><br><span class="line">v1.9.0: Pulling from weiyigeek/kaniko-executor</span><br><span class="line">Digest: sha256:9b0ef02e7650d00d24bbca683e317bc103d6d842311ff13ec6daee60c37b1e62</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> weiyigeek/kaniko-executor:v1.9.0</span><br><span class="line">docker.io/weiyigeek/kaniko-executor:v1.9.0</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220908153522.png" alt="WeiyiGeek.K8S集群中kaniko-executor" title="" class="">                <p>WeiyiGeek.K8S集群中kaniko-executor</p>            </figure><p>步骤 07.扩展补充，除了上述方式指定dockerfile文件和上下文外，我们还可以在运行 kaniko 时使用标准输入构建上下文，但需要添加 <code>-i, --interactive</code>参数, 一旦kaniko运行它将从STDIN获取数据，并将构建上下文创建为压缩tar，然后它将在启动映像构建之前解包构建上下文的压缩tar。</p><p>如何使用 .tar.gz 标准输入数据交互运行 kaniko 的完整示例，使用带有临时容器和完全无 docker 环境的 Kubernetes 命令行来进行镜像构建与发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">'FROM alpine \nRUN echo "created from standard input"'</span> &gt; Dockerfile | tar -cf - Dockerfile | gzip -9 | kubectl run kaniko-executor \</span><br><span class="line">--rm --stdin=<span class="literal">true</span> \</span><br><span class="line">--image=registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest --restart=Never \</span><br><span class="line">--overrides=<span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "apiVersion": "v1",</span></span><br><span class="line"><span class="string">  "spec": &#123;</span></span><br><span class="line"><span class="string">    "containers": [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "name": "kaniko-executor",</span></span><br><span class="line"><span class="string">        "image": "registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest",</span></span><br><span class="line"><span class="string">        "stdin": true,</span></span><br><span class="line"><span class="string">        "stdinOnce": true,</span></span><br><span class="line"><span class="string">        "args": [</span></span><br><span class="line"><span class="string">          "--dockerfile=Dockerfile",</span></span><br><span class="line"><span class="string">          "--context=tar://stdin",</span></span><br><span class="line"><span class="string">          "--destination=docker.io/weiyigeek/alpine:v4.2"</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        "volumeMounts": [</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">            "name": "kaniko-secret",</span></span><br><span class="line"><span class="string">            "mountPath": "/kaniko/.docker/"</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    "nodeSelector": &#123; </span></span><br><span class="line"><span class="string">      "kubernetes.io/hostname": "weiyigeek-226"</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "volumes": [</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "name": "kaniko-secret",</span></span><br><span class="line"><span class="string">        "secret": &#123;</span></span><br><span class="line"><span class="string">          "secretName": "dockerhub",</span></span><br><span class="line"><span class="string">          "items": [&#123;"key":".dockerconfigjson", "path": "config.json"&#125;]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "name": "dockerfile-storage",</span></span><br><span class="line"><span class="string">        "hostPath": &#123;</span></span><br><span class="line"><span class="string">          "path": "/storage/dev/soft/kaniko/demo",</span></span><br><span class="line"><span class="string">          "type": "DirectoryOrCreate"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        "name": "kaniko-cache",</span></span><br><span class="line"><span class="string">        "hostPath": &#123;</span></span><br><span class="line"><span class="string">          "path": "/storage/dev/soft/kaniko/cache",</span></span><br><span class="line"><span class="string">          "type": "DirectoryOrCreate"</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>执行结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INFO[0003] Retrieving image manifest alpine</span><br><span class="line">INFO[0003] Retrieving image alpine from registry index.docker.io</span><br><span class="line">INFO[0009] Built cross stage deps: map[]</span><br><span class="line">INFO[0009] Retrieving image manifest alpine</span><br><span class="line">INFO[0009] Returning cached image manifest</span><br><span class="line">INFO[0009] Executing 0 build triggers</span><br><span class="line">INFO[0009] Building stage <span class="string">'alpine'</span> [idx: <span class="string">'0'</span>, base-idx: <span class="string">'-1'</span>]</span><br><span class="line">INFO[0009] Unpacking rootfs as cmd RUN <span class="built_in">echo</span> <span class="string">"created from standard input"</span> requires it.</span><br><span class="line">INFO[0036] RUN <span class="built_in">echo</span> <span class="string">"created from standard input"</span></span><br><span class="line">INFO[0036] Initializing snapshotter ...</span><br><span class="line">INFO[0036] Taking snapshot of full filesystem...</span><br><span class="line">INFO[0036] Cmd: /bin/sh</span><br><span class="line">INFO[0036] Args: [-c <span class="built_in">echo</span> <span class="string">"created from standard input"</span>]</span><br><span class="line">INFO[0036] Running: [/bin/sh -c <span class="built_in">echo</span> <span class="string">"created from standard input"</span>]</span><br><span class="line">created from standard input</span><br><span class="line">INFO[0036] Taking snapshot of full filesystem...</span><br><span class="line">INFO[0037] No files were changed, appending empty layer to config. No layer added to image.</span><br><span class="line">INFO[0037] Pushing image to docker.io/weiyigeek/alpine:v4.2</span><br><span class="line">INFO[0042] Pushed index.docker.io/weiyigeek/alpine@sha256:0ef53bcc0a6f261124e5f292fa17041d7e5f81f5542802b89c249351597167e4</span><br><span class="line">pod <span class="string">"kaniko-executor"</span> deleted</span><br></pre></td></tr></table></figure></p><p>至此在 K8s 集群中使用 kaniko 构建镜像简单演示结束。</p><p><br/></p><h3 id="小试牛刀之在Containerd-io中构建并发布镜像"><a href="#小试牛刀之在Containerd-io中构建并发布镜像" class="headerlink" title="小试牛刀之在Containerd.io中构建并发布镜像"></a>小试牛刀之在Containerd.io中构建并发布镜像</h3><p>描述：当我们的环境中只安装了containerd.io 容器运行时没有 Docker 或者 Kubernetes 环境时，我们也可以采用kaniko进行镜像构建与发布，具体操作流程步骤如下：</p><p><strong>环境说明</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.3 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br><span class="line"></span><br><span class="line">$ containerd -v</span><br><span class="line">containerd containerd.io 1.4.12 7b11cfaabd73bb80907dd23182b9347b4245eb5d</span><br><span class="line"></span><br><span class="line">$ ctr -v</span><br><span class="line">ctr containerd.io 1.4.12</span><br></pre></td></tr></table></figure></p><p>温馨提示: 此处使用的是 Ubuntu 20.04 操作系统, 该系统已做安全加固和内核优化符合等保2.0要求【<a href="https://github.com/WeiyiGeek/SecOpsDev/blob/master/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu/Ubuntu-InitializeSecurity.sh" target="_blank" rel="noopener">SecOpsDev/Ubuntu-InitializeSecurity.sh at master · WeiyiGeek/SecOpsDev</a> 】, 如你的Linux未进行相应配置环境可能与读者有些许差异, 如需要进行(windows server、Ubuntu、CentOS)安全加固请参照如下加固脚本进行加固, <span style="color:red">请大家疯狂的star </span>。<br>加固脚本地址:【 <a href="https://github.com/WeiyiGeek/SecOpsDev/blob/master/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu/Ubuntu-InitializeSecurity.sh" target="_blank" rel="noopener">https://github.com/WeiyiGeek/SecOpsDev/blob/master/OS-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu/Ubuntu-InitializeSecurity.sh</a> 】</p><p>温馨提示：如果你使用的是最新 Ubuntu 22.04 操作系统，并需要对其安全加固和内核优化以满足等保2.0要求可参考如下加固脚本 【<a href="https://github.com/WeiyiGeek/SecOpsDev/tree/master/OperatingSystem/Security/Ubuntu" target="_blank" rel="noopener">https://github.com/WeiyiGeek/SecOpsDev/tree/master/OperatingSystem/Security/Ubuntu</a>】。</p><figure class="image-box">                <img src="https://github.com/WeiyiGeek/SecOpsDev/raw/master/OperatingSystem/Security/Ubuntu/Readme.assets/image-20220823143235577.png" alt="Ubuntu 22.04加固脚本示例图" title="" class="">                <p>Ubuntu 22.04加固脚本示例图</p>            </figure><p><br/></p><p><strong>操作流程</strong></p><p>步骤 01.此处假设你已经安装配置好containerd.io了，如果没有安装配置请参考此篇文章【 1.Containerd容器运行时初识与尝试 - <a href="https://blog.weiyigeek.top/2021/6-27-570.html">https://blog.weiyigeek.top/2021/6-27-570.html</a> 】，此处不再累述。</p><p>步骤 02.验证 containerd.io 服务状态以及提前拉取 <code>kaniko-executor:latest</code> 镜像以加快构建速度，此处将镜像拉到默认的名称空间下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status containerd.service</span><br><span class="line">● containerd.service - containerd container runtime</span><br><span class="line">     Loaded: loaded (/lib/systemd/system/containerd.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Thu 2022-09-08 11:48:30 CST; 4h 49min ago</span><br><span class="line">       Docs: https://containerd.io</span><br><span class="line">    Process: 561811 ExecStartPre=/sbin/modprobe overlay (code=exited, status=0/SUCCESS)</span><br><span class="line">   Main PID: 561812 (containerd)</span><br><span class="line">      Tasks: 106</span><br><span class="line">     Memory: 4.0G</span><br><span class="line"></span><br><span class="line">$ ctr -n default images pull registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span><br></pre></td></tr></table></figure><p>步骤 03.准备登录 hub docker 的账号以及密码，你可以按照下述的流程进行生成config.json文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mkdir /storage/dev/soft/kaniko/&#123;config,demo1&#125;</span><br><span class="line"><span class="built_in">cd</span> /storage/dev/soft/kaniko/config</span><br><span class="line"><span class="comment"># 生成认证所需的凭据</span></span><br><span class="line"><span class="comment"># BASE64 编码，注意下述为格式为 你的hub账号:你的hub密码</span></span><br><span class="line">AUTH=$(<span class="built_in">echo</span> -n <span class="string">"weiyigeek:password"</span> | base64)</span><br><span class="line"><span class="comment"># BASE64 解码</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;AUTH&#125;</span> | base64 -d</span><br><span class="line"><span class="comment"># 使用该方法可以解析变量 AUTH (值得注意)</span></span><br><span class="line">cat &gt; config.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"auths"</span>: &#123;</span><br><span class="line">    <span class="string">"https://index.docker.io/v1/"</span>: &#123;</span><br><span class="line">        <span class="string">"auth"</span>: <span class="string">"<span class="variable">$&#123;AUTH&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成结果</span></span><br><span class="line">cat config.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"auths"</span>: &#123;</span><br><span class="line">    <span class="string">"https://index.docker.io/v1/"</span>: &#123;</span><br><span class="line">        <span class="string">"auth"</span>: <span class="string">"d2VpeWlnZ************AxOQ=="</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤 04.准备dockerfile文件，此处将<code>busybox:1.35.0</code>镜像重新构建后上传到我的账户下的hub仓库中，该文件示例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /storage/dev/soft/kaniko/demo1</span><br><span class="line">tee dockerfile &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">FROM docker.io/library/busybox:1.35.0</span><br><span class="line">LABEL MAINTAINER=master@weiyigeeek.top BUILDTOOLS=kaniko BUILDENV=containerd.io;</span><br><span class="line">ENTRYPOINT [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo hello,busybox"</span>]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>步骤 05.当上述都准备完成后我们便可以执行containerd.io提供的ctr客户端工具直接创建容器，例如如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ctr -n default run --rm --net-host --env DOCKERHUB=docker.io \</span><br><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=/storage/dev/soft/kaniko/config,dst=/kaniko/.docker,options=rbind:ro \</span><br><span class="line">--mount <span class="built_in">type</span>=<span class="built_in">bind</span>,src=/storage/dev/soft/kaniko/demo1,dst=/workspace,options=rbind:rw \</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest kaniko-executor \</span><br><span class="line">/kaniko/executor --dockerfile=/workspace/dockerfile --context=dir://workspace --destination=docker.io/weiyigeek/busybox:1.35.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-n 指定名称空间</span><br><span class="line">--rm 在退出容器时删除容器</span><br><span class="line">--net-host 使用主机网络</span><br><span class="line">--env 指定容器内部shell变量</span><br><span class="line">--mount 指定挂载到容器内部的本地文件，src是指定宿主机上文件目录路径，而dst是指定容器内部目录。</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INFO[0002] Retrieving image manifest docker.io/library/busybox:1.35.0</span><br><span class="line">INFO[0002] Retrieving image docker.io/library/busybox:1.35.0 from registry index.docker.io</span><br><span class="line">INFO[0006] Built cross stage deps: map[]</span><br><span class="line">INFO[0006] Retrieving image manifest docker.io/library/busybox:1.35.0</span><br><span class="line">INFO[0006] Returning cached image manifest</span><br><span class="line">INFO[0006] Executing 0 build triggers</span><br><span class="line">INFO[0006] Building stage <span class="string">'docker.io/library/busybox:1.35.0'</span> [idx: <span class="string">'0'</span>, base-idx: <span class="string">'-1'</span>]</span><br><span class="line">INFO[0006] Skipping unpacking as no commands require it.</span><br><span class="line">INFO[0006] LABEL MAINTAINER=master@weiyigeeek.top BUILDTOOLS=kaniko BUILDENV=containerd.io;</span><br><span class="line">INFO[0006] Applying label MAINTAINER=master@weiyigeeek.top</span><br><span class="line">INFO[0006] Applying label BUILDTOOLS=kaniko</span><br><span class="line">INFO[0006] Applying label BUILDENV=containerd.io;</span><br><span class="line">INFO[0006] ENTRYPOINT [<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo hello,busybox"</span>]</span><br><span class="line">INFO[0006] Pushing image to docker.io/weiyigeek/busybox:1.35.0</span><br><span class="line">INFO[0010] Pushed index.docker.io/weiyigeek/busybox@sha256:d6ed480cc7864b9e19b40f09263abfad4689a9244a5abeb2e3eaf14a439cc55f</span><br></pre></td></tr></table></figure></p><p>步骤 06.查看上传到docker hub中 的 busybox:1.35.0 镜像信息以及拉取到本地进行运行测试验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctr -n default images pull docker.io/weiyigeek/busybox:1.35.0</span><br><span class="line">ctr -n default run --rm docker.io/weiyigeek/busybox:1.35.0 busybox</span><br><span class="line">hello,busybox</span><br></pre></td></tr></table></figure><p><img src="https://img.weiyigeek.top/2022/5/20220908214417.png" alt="WeiyiGeek.在containerd.io进行镜像构建并发布到hub中"></p><p>至此，在containerd.io 环境中，进行镜像构建并发布到hub中实践完毕!</p><p><br/></p><h3 id="小试牛刀之在Docker中使用kaniko构建并发布镜像"><a href="#小试牛刀之在Docker中使用kaniko构建并发布镜像" class="headerlink" title="小试牛刀之在Docker中使用kaniko构建并发布镜像"></a>小试牛刀之在Docker中使用kaniko构建并发布镜像</h3><p>描述：前面说到kaniko的出现实际是为了在没有docker环境的情况之下，按照 Dockerfile 文件中的指令进行镜像构建，不过此处还是简单的介绍一下在docker环境中的使用。 (实际情况中不建议如此多此一举)</p><p>步骤 01.执行如下命令生成 docker hub 认证票据（存储路径为 ~/.docker/config.json）以及提前拉取 kaniko 项目中 executor:latest 镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker login -u weiyigeek</span><br><span class="line"><span class="comment"># Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.</span></span><br><span class="line"><span class="comment"># Login Succeeded</span></span><br><span class="line"></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</span><br></pre></td></tr></table></figure></p><p>步骤 02.创建 dockerfile 文件其中 FROM 指定 K8S 集群中常用的NFS动态持久卷镜像，我们将其上传到 hub 仓库中的WeiyiGeek账户下面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /storage/dev/soft/kaniko/demo2</span><br><span class="line"><span class="built_in">cd</span> /storage/dev/soft/kaniko/demo2</span><br><span class="line">tee dockerfile &lt;&lt;<span class="string">'EOF'</span></span><br><span class="line">FROM registry.cn-hangzhou.aliyuncs.com/weiyigeek/nfs-subdir-external-provisioner:latest</span><br><span class="line">LABEL MAINTAINER=master@weiyigeeek.top BUILDTOOLS=kaniko BUILDENV=docker;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>步骤 03.使用如下示例命令进行 kaniko-executor 容器的创建运行，并进行镜像构建并上传到公共的docker hub 仓库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f kaniko-executor</span><br><span class="line">docker run --rm --name kaniko-executor \</span><br><span class="line">    -v <span class="variable">$HOME</span>/.docker/:/kaniko/.docker \</span><br><span class="line">    -v /storage/dev/soft/kaniko/demo2:/workspace \</span><br><span class="line">    registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest \</span><br><span class="line">    --dockerfile=/workspace/dockerfile --context=dir://workspace --destination=docker.io/weiyigeek/nfs-subdir-external-provisioner:latest</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INFO[0002] Retrieving image manifest registry.cn-hangzhou.aliyuncs.com/weiyigeek/nfs-subdir-external-provisioner:latest</span><br><span class="line">INFO[0002] Retrieving image registry.cn-hangzhou.aliyuncs.com/weiyigeek/nfs-subdir-external-provisioner:latest from registry registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">INFO[0003] Built cross stage deps: map[]</span><br><span class="line">INFO[0003] Retrieving image manifest registry.cn-hangzhou.aliyuncs.com/weiyigeek/nfs-subdir-external-provisioner:latest</span><br><span class="line">INFO[0003] Returning cached image manifest</span><br><span class="line">INFO[0003] Executing 0 build triggers</span><br><span class="line">INFO[0003] Building stage <span class="string">'registry.cn-hangzhou.aliyuncs.com/weiyigeek/nfs-subdir-external-provisioner:latest'</span> [idx: <span class="string">'0'</span>, base-idx: <span class="string">'-1'</span>]</span><br><span class="line">INFO[0003] Skipping unpacking as no commands require it.</span><br><span class="line">INFO[0003] LABEL MAINTAINER=master@weiyigeeek.top BUILDTOOLS=kaniko BUILDENV=docker;</span><br><span class="line">INFO[0003] Applying label MAINTAINER=master@weiyigeeek.top</span><br><span class="line">INFO[0003] Applying label BUILDTOOLS=kaniko</span><br><span class="line">INFO[0003] Applying label BUILDENV=docker;</span><br><span class="line">INFO[0003] Pushing image to docker.io/weiyigeek/nfs-subdir-external-provisioner:latest</span><br><span class="line">INFO[0012] Pushed index.docker.io/weiyigeek/nfs-subdir-external-provisioner@sha256:4dc0d27b8fa4608c9e2d8a6f2368d2029df32b9b55f96f27a9218a620ea14828</span><br></pre></td></tr></table></figure><p>步骤 04.查看上传到docker hub 仓库中的 nfs-subdir-external-provisioner:latest 信息 (<a href="https://hub.docker.com/r/weiyigeek/nfs-subdir-external-provisioner" target="_blank" rel="noopener">https://hub.docker.com/r/weiyigeek/nfs-subdir-external-provisioner</a>) 。</p><p><img src="https://img.weiyigeek.top/2022/5/20220908215842.png" alt="WeiyiGeek.在 Docker 中使用 kaniko 进行镜像构建与发布"></p><p>步骤 05.当然我们也可以在安装有docker环境中使用上下文使用标准输入，并采用docker进行创建kaniko-executor容器，从标准输入接收dockerfile文件并进行镜像构建与推送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /storage/dev/soft/kaniko/demo3</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">'FROM alpine \nRUN echo "created from standard input"'</span> &gt; Dockerfile | tar -cf - Dockerfile | gzip -9 | docker run \</span><br><span class="line">  --interactive -v /storage/dev/soft/kaniko/demo3:/workspace  -v <span class="variable">$HOME</span>/.docker/:/kaniko/.docker \</span><br><span class="line">  registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest \</span><br><span class="line">  --context tar://stdin \</span><br><span class="line">  --destination=docker.io/weiyigeek/alpine:4.2</span><br></pre></td></tr></table></figure><p>执行结果: 如果在交互运行期间没有数据管道传输，则需要按Ctrl+D自行发送EOF信号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INFO[0000] To simulate EOF and <span class="built_in">exit</span>, press <span class="string">'Ctrl+D'</span></span><br><span class="line">INFO[0002] Retrieving image manifest alpine</span><br><span class="line">INFO[0002] Retrieving image alpine from registry index.docker.io</span><br><span class="line">INFO[0005] Built cross stage deps: map[]</span><br><span class="line">INFO[0005] Retrieving image manifest alpine</span><br><span class="line">INFO[0005] Returning cached image manifest</span><br><span class="line">INFO[0005] Executing 0 build triggers</span><br><span class="line">INFO[0005] Building stage <span class="string">'alpine'</span> [idx: <span class="string">'0'</span>, base-idx: <span class="string">'-1'</span>]</span><br><span class="line">INFO[0005] Unpacking rootfs as cmd RUN <span class="built_in">echo</span> <span class="string">"created from standard input"</span> requires it.</span><br><span class="line">INFO[0008] RUN <span class="built_in">echo</span> <span class="string">"created from standard input"</span></span><br><span class="line">INFO[0008] Initializing snapshotter ...</span><br><span class="line">INFO[0008] Taking snapshot of full filesystem...</span><br><span class="line">INFO[0008] Cmd: /bin/sh</span><br><span class="line">INFO[0008] Args: [-c <span class="built_in">echo</span> <span class="string">"created from standard input"</span>]</span><br><span class="line">INFO[0008] Running: [/bin/sh -c <span class="built_in">echo</span> <span class="string">"created from standard input"</span>]</span><br><span class="line">created from standard input</span><br><span class="line">INFO[0008] Taking snapshot of full filesystem...</span><br><span class="line">INFO[0008] No files were changed, appending empty layer to config. No layer added to image.</span><br><span class="line">INFO[0008] Pushing image to docker.io/weiyigeek/alpine:4.2</span><br><span class="line">INFO[0016] Pushed index.docker.io/weiyigeek/alpine@sha256:49360dc74ecf57ea94fbec9d7a3b5cf59dfba8aa5e60f8802cc6299e668a3e1e</span><br></pre></td></tr></table></figure></p><p>至此，在 Docker 中使用 kaniko 进行镜像构建与发布实践完毕。</p><hr><h2 id="0x0n-参考来源"><a href="#0x0n-参考来源" class="headerlink" title="0x0n 参考来源"></a>0x0n 参考来源</h2><p>项目地址: <a href="https://github.com/GoogleContainerTools/kaniko" target="_blank" rel="noopener">https://github.com/GoogleContainerTools/kaniko</a><br>kaniko 图像镜像仓库: gcr.io/kaniko-project/executor<br>kaniko 国内镜像仓库源：<code>weiyigeek/kaniko-executor:latest</code> 或者 <code>registry.cn-hangzhou.aliyuncs.com/weiyigeek/kaniko-executor:latest</code></p><p>首发地址：<br>原文地址: <a href="https://blog.weiyigeek.top/2022/9-1-684.html">https://blog.weiyigeek.top/2022/9-1-684.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="kubernetes" scheme="https://blog.weiyigeek.top/categories/kubernetes/"/>
    
    <category term="Containers" scheme="https://blog.weiyigeek.top/categories/kubernetes/Containers/"/>
    
    <category term="OperationTools" scheme="https://blog.weiyigeek.top/categories/kubernetes/Containers/OperationTools/"/>
    
    
    <category term="Kaniko" scheme="https://blog.weiyigeek.top/tags/Kaniko/"/>
    
  </entry>
  
  <entry>
    <title>Gitalk-基于Github项目issue的评论系统在博客系统中实践</title>
    <link href="https://blog.weiyigeek.top/2022/8-17-682.html"/>
    <id>https://blog.weiyigeek.top/2022/8-17-682.html</id>
    <published>2022-08-17T05:34:30.000Z</published>
    <updated>2023-01-31T02:29:10.670Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-Gitalk-基于Github的评论系统"><a href="#0x00-Gitalk-基于Github的评论系统" class="headerlink" title="0x00 Gitalk - 基于Github的评论系统"></a>0x00 Gitalk - 基于Github的评论系统</h2><p>描述: 我想对于所有使用hexo、Hugo或者WordPress自建博客的博主来说GitTalk应该不陌生，GitTalk通过Github的OpenAPI以及issues功能实现社区评论确实还是很方便的，除开对国内访问速度较慢就没啥毛病，但是考虑到新手朋友此处还是简单介绍一下。</p><h3 id="1-快速介绍"><a href="#1-快速介绍" class="headerlink" title="1.快速介绍"></a>1.快速介绍</h3><p>描述: Gitalk 是一个基于 Github Issue 和 Preact 的现代评论组件。<br>功能： </p><ul><li>使用 github 帐号进行身份验证</li><li>无服务器，所有评论将存储为 github 问题</li><li>个人和组织的github项目都可以用来存储评论</li><li>本地化，支持多国语言 [en, zh-CN, zh-TW, es-ES, fr, ru, de, pl, ko, fa, ja]</li><li>类似 Facebook 的无干扰模式（可以通过 DistentionFreeMode 选项启用）</li><li>热键提交评论（cmd|ctrl + enter）</li></ul><p>项目地址：<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">https://github.com/gitalk/gitalk</a><br>帮助文档：<a href="https://github.com/gitalk/gitalk/blob/master/readme-cn.md" target="_blank" rel="noopener">https://github.com/gitalk/gitalk/blob/master/readme-cn.md</a></p><p>温馨提示: 当前 Gitalk 最新版本为 1.7.2 (Mar 3, 2021), 如后续随着时间推移，可能会有些许变化，建议参考官网（<a href="https://github.com/gitalk/gitalk/tags）" target="_blank" rel="noopener">https://github.com/gitalk/gitalk/tags）</a></p><p><br/></p><h3 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2.安装部署"></a>2.安装部署</h3><p>描述：安装引用Gitalk评论系统的两种方式，</p><p><strong>安装实践</strong></p><ul><li>方式1.在你的HTML页面中使用 link 与 script 标签引入。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- or --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>方式2.使用 npm 安装 gital 模块。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模块安装</span></span><br><span class="line">npm i --save gitalk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目导入</span></span><br><span class="line">import <span class="string">'gitalk/dist/gitalk.css'</span></span><br><span class="line">import Gitalk from <span class="string">'gitalk'</span></span><br></pre></td></tr></table></figure><p><br/></p><p><strong>配置实践</strong></p><p>首先，您需要为商店评论选择一个公共 github 存储库（已存在或创建一个新存储库），然后创建一个 GitHub 应用程序，如果你没有，点击这里 (<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a>) 注册一个新的。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name : BlogTalk</span><br><span class="line">Homepage URL : https://blog.weiyigeek.top</span><br><span class="line">Application description : 欢迎访问 WeiyiGeek blog\<span class="string">'s [blog.weiyigeek.top] talk about , 欢迎留言骚扰哟，亲!</span></span><br><span class="line"><span class="string">Authorization callback URL : https://blog.weiyigeek.top</span></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817100949.png" alt="WeiyiGeek.Register a new OAuth application" title="" class="">                <p>WeiyiGeek.Register a new OAuth application</p>            </figure><p>注意：您必须在授权回调 URL 字段中指定网站域 url。</p><p>然后，创建完成后你将获取Client ID 与 Client Secret，如下所示：</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817101619.png" alt="WeiyiGeek.application ID and Secret" title="" class="">                <p>WeiyiGeek.application ID and Secret</p>            </figure><p>注意：后续更新修改可以进行访问 <code>Settings/Developer settings</code> ( <a href="https://github.com/settings/developers" target="_blank" rel="noopener">https://github.com/settings/developers</a> )</p><p>最后，创建一个公共仓库此处我创建的是<a href="https://github.com/WeiyiGeek/blogtalk" target="_blank" rel="noopener">blogtalk</a>，创建完后在项目的(<a href="https://github.com/WeiyiGeek/blogtalk/settings)中启用" target="_blank" rel="noopener">https://github.com/WeiyiGeek/blogtalk/settings)中启用</a> issue 即可</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817102221.png" alt="WeiyiGeek.blogtalk" title="" class="">                <p>WeiyiGeek.blogtalk</p>            </figure><p><br/></p><p><strong>使用方式1.将如下代码添加到您的页面：</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span></span><br><span class="line"><span class="actionscript">          clientID: <span class="string">'GitHub Application Client ID'</span>,          <span class="comment">// 8d8e96********797026d3</span></span></span><br><span class="line"><span class="actionscript">          clientSecret: <span class="string">'GitHub Application Client Secret'</span>,  <span class="comment">// secrets**********secrets</span></span></span><br><span class="line"><span class="actionscript">          repo: <span class="string">'GitHub repo'</span>,          <span class="comment">// blogtalk</span></span></span><br><span class="line"><span class="actionscript">          owner: <span class="string">'GitHub repo owner'</span>,   <span class="comment">// WeiyiGeek</span></span></span><br><span class="line"><span class="actionscript">          admin: [<span class="string">'GitHub repo owner and collaborators, only these guys can initialize github issues'</span>], <span class="comment">// ['WeiyiGeek']</span></span></span><br><span class="line"><span class="actionscript">          id: location.pathname,      <span class="comment">// Ensure uniqueness and length less than 50</span></span></span><br><span class="line"><span class="actionscript">          distractionFreeMode: <span class="literal">false</span>  <span class="comment">// Facebook-like distraction free mode</span></span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="actionscript">        gitalk.render(<span class="string">'gitalk-container'</span>)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><br></p><p><strong>使用方式2.在React中使用</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GitalkComponent <span class="keyword">from</span> <span class="string">"gitalk/dist/gitalk-component"</span>;</span><br><span class="line"><span class="comment">// 并使用类似的组件</span></span><br><span class="line">&lt;GitalkComponent options=&#123;&#123;</span><br><span class="line">  clientID: <span class="string">"..."</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// options below</span></span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>温馨提示: Gitalk 对象实例化参数参考 (<a href="https://github.com/gitalk/gitalk#options" target="_blank" rel="noopener">https://github.com/gitalk/gitalk#options</a>)</p><p><br/></p><h3 id="3-使用实践"><a href="#3-使用实践" class="headerlink" title="3.使用实践"></a>3.使用实践</h3><p><strong>在 Hexo 中使用</strong><br>描述: 此处以我的博客[<a href="https://blog.weiyigeek.top]">https://blog.weiyigeek.top]</a> 为例进行演示配置，此处笔者使用的是 hexo + mellow 主题 , 已经经过二次魔改（有需要该博客主题请在公众号回复【mellow博客主题】或者访问 <a href="https://weiyigeek.top/wechat.html?key=mellow博客主题" target="_blank" rel="noopener">https://weiyigeek.top/wechat.html?key=mellow博客主题</a> ）。</p><ul><li>Step 1.在 Hexo 主题中的 _config.yaml 配置加入如下配置片段。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gittalk 评论系统</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">WeiyiGeek</span>  <span class="comment"># github账号</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">blogtalk</span>    <span class="comment"># 留言仓库</span></span><br><span class="line"><span class="attr">  proxy:</span> <span class="string">/github/login/oauth/access_token</span> <span class="comment"># 反向代理解决跨域问题,后续将会主要讲解哦。</span></span><br><span class="line"><span class="attr">  oauth:</span></span><br><span class="line"><span class="attr">    client_id:</span> <span class="number">8</span><span class="string">d8e965c******97026d3</span>       <span class="comment"># Github App Auth ID </span></span><br><span class="line"><span class="attr">    client_secret:</span> <span class="string">e9c6141cb1f02f721********d01cb4d7a8f069</span> <span class="comment">#  Github App Auth secret</span></span><br><span class="line"><span class="attr">  perPage:</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><ul><li>Step 2.在主题文档引擎中加入如下片段。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitalk-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实际上是将 &lt;script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"&gt;&lt;/script&gt; js 下载到了本地 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&lt;%- url_for(theme_js('/js/plugins/gitalk.min', cache)) %&gt;"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&lt;%- url_for(theme_js('/js/custom/gitalk.init', cache)) %&gt;"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- themes\mellow\source\js\custom\gitalk.init.js --&gt;</span></span><br><span class="line">var gitalk = new Gitalk(&#123;</span><br><span class="line">  clientID: '<span class="tag">&lt;<span class="name">%-</span> <span class="attr">theme.gitalk.oauth.client_id</span> %&gt;</span>',</span><br><span class="line">  clientSecret: '<span class="tag">&lt;<span class="name">%-</span> <span class="attr">theme.gitalk.oauth.client_secret</span> %&gt;</span>',</span><br><span class="line">  repo: '<span class="tag">&lt;<span class="name">%-</span> <span class="attr">theme.gitalk.repo</span> %&gt;</span>',</span><br><span class="line">  owner: '<span class="tag">&lt;<span class="name">%-</span> <span class="attr">theme.gitalk.owner</span> %&gt;</span>',</span><br><span class="line">  admin: ['<span class="tag">&lt;<span class="name">%-</span> <span class="attr">theme.gitalk.owner</span> %&gt;</span>'],</span><br><span class="line">  id: location.pathname,</span><br><span class="line">  proxy: '<span class="tag">&lt;<span class="name">%-</span> <span class="attr">theme.gitalk.proxy</span> %&gt;</span>',</span><br><span class="line">  distractionFreeMode: true</span><br><span class="line">&#125;)</span><br><span class="line">#  hexo g 生成静态文件后的样子</span><br><span class="line"># var gitalk = new Gitalk(&#123;</span><br><span class="line">#   clientID: '8d8e965c******97026d3',</span><br><span class="line">#   clientSecret: 'e9c6141cb1f02f721********d01cb4d7a8f069',</span><br><span class="line">#   repo: 'blogtalk',</span><br><span class="line">#   owner: 'WeiyiGeek',</span><br><span class="line">#   admin: ['WeiyiGeek'],</span><br><span class="line">#   id: location.pathname,</span><br><span class="line">#   proxy: '/github/login/oauth/access_token',</span><br><span class="line">#   distractionFreeMode: false</span><br><span class="line"># &#125;)</span><br><span class="line"></span><br><span class="line"># 创建 gitalk-container </span><br><span class="line">gitalk.render('gitalk-container')</span><br></pre></td></tr></table></figure><p>温馨提示: 建议将<code>distractionFreeMode</code>设置为false,因为True真心难看。<br>温馨提示: 为了 Github Apps ID 与 Secrets 的安全，我们需要针对上面 <code>new Gitalk</code> 实例化参数进行js加密混淆 (<a href="http://www.esjson.com/jsEncrypt.html" target="_blank" rel="noopener">http://www.esjson.com/jsEncrypt.html</a>)</p><p><br/></p><h3 id="n-入坑出坑"><a href="#n-入坑出坑" class="headerlink" title="n.入坑出坑"></a>n.入坑出坑</h3><h4 id="1-使用Gitalk进行Github的Oauth认证无法跨域获取Token问题解决办法"><a href="#1-使用Gitalk进行Github的Oauth认证无法跨域获取Token问题解决办法" class="headerlink" title="1.使用Gitalk进行Github的Oauth认证无法跨域获取Token问题解决办法"></a>1.使用Gitalk进行Github的Oauth认证无法跨域获取Token问题解决办法</h4><p>描述: 在最开始之初我们也是使用官方演示代码中，使用的第三方提供的CORS代理服务，他会默认放行所有CORS请求，但是随着而来的问题是登陆会出现网络错误 Error: Network Error 或者在使用时出现 Forbidden 错误 (<a href="https://github.com/gitalk/gitalk/issues/514" target="_blank" rel="noopener">https://github.com/gitalk/gitalk/issues/514</a>) 。</p><p>目前由于该CORS代理服务遭到滥用，因此做了限制，导致GitTalk失效，在实践中发现如下CORS代理服务其要么有限制要么根本不能使用，所以实践的朋友们就不要像使用如下CORS代理服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限流</span></span><br><span class="line">https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token</span><br><span class="line"><span class="comment"># 被墙</span></span><br><span class="line">https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</span><br></pre></td></tr></table></figure><p>温馨提示: CORS Anywhere 是一个 NodeJS 代理，它将 CORS 标头添加到代理请求中。 项目地址 (<a href="https://github.com/Rob--W/cors-anywhere" target="_blank" rel="noopener">https://github.com/Rob--W/cors-anywhere</a>)</p><p><br/></p><p>在 百度 CSDN 中捡了一圈垃圾之后，还是没有最好的解决方案，然后通过某种方式Google了一下，找到两种替代的方式<code>利用cloudflare worker (不幸得是默认的cf worker的域名workers.dev被墙了)或者 Vercel 搭建在线代理（无vps推荐使用Vercel）</code> 或者 <code>使用VPS中的nginx服务器来反代 https://github.com (比较推荐-当前博主正在使用)</code>。</p><p><strong>方式1.没有VPS或者自己的服务器（想白嫖的）</strong><br>描述: 在 cloudflare (<a href="https://dash.cloudflare.com/login/" target="_blank" rel="noopener">https://dash.cloudflare.com/login/</a>) 上创建一个免费的在线代理来解决gitalk授权登录跨域问题，利用CloudFlare Worker创建在线代理，不需要我们有服务器，也不需要搭建Node.js服务，只需要注册一个CloudFlare账号，创建一个Worker，部署一个JS脚本就可以了，简单方便，下面我们就来看看如何创建吧。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817113313.png" alt="WeiyiGeek.cloudflare-cors-anywhere" title="" class="">                <p>WeiyiGeek.cloudflare-cors-anywhere</p>            </figure><p>创建好之后我们便可编辑其 Worker 服务代码，如下代码也可通过 <a href="https://github.com/WeiyiGeek/SecOpsDev/tree/master/Application/Blog/Hexo/Gitalk" target="_blank" rel="noopener">https://github.com/WeiyiGeek/SecOpsDev/tree/master/Application/Blog/Hexo/Gitalk</a> 获得。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exclude = [];     <span class="comment">// Regexp for blacklisted urls</span></span><br><span class="line"><span class="keyword">const</span> include = [<span class="regexp">/^https?:\/\/.*weiyigeek\.top$/</span>, /^https?:\/\/localhost/]; <span class="comment">// Regexp for whitelisted origins e.g.</span></span><br><span class="line"><span class="keyword">const</span> apiKeys = &#123;</span><br><span class="line">  EZWTLwVEqFnaycMzdhBz: &#123;</span><br><span class="line">    name: <span class="string">'Test App'</span>,</span><br><span class="line">    expired: <span class="literal">false</span>,</span><br><span class="line">    expiresAt: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2023-01-01'</span>),</span><br><span class="line">    exclude: [], <span class="comment">// Regexp for blacklisted urls</span></span><br><span class="line">    include: [<span class="string">"^http.?://www.weiyigeek.top$"</span>, <span class="string">"weiyigeek.top$"</span>, <span class="string">"^https?://localhost/"</span>], <span class="comment">// Regexp for whitelisted origins</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Config is all above this line.</span></span><br><span class="line"><span class="comment">// It should not be necessary to change anything below.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verifyCredentials</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Throws exception on verification failure.</span></span><br><span class="line">  <span class="keyword">const</span> requestApiKey = request.headers.get(<span class="string">'x-cors-proxy-api-key'</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(apiKeys).includes(requestApiKey)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedException(<span class="string">'Invalid authorization key.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (apiKeys[requestApiKey].expired) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedException(<span class="string">'Expired authorization key.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (apiKeys[requestApiKey].expiresAt &amp;&amp; apiKeys[requestApiKey].expiresAt.getTime() &lt; <span class="built_in">Date</span>.now()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedException(<span class="string">`Expired authorization key.\nKey was valid until: <span class="subst">$&#123;apiKeys[requestApiKey].expiresAt&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> apiKeys[requestApiKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkRequiredHeadersPresent</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Throws exception on verification failure.</span></span><br><span class="line">  <span class="keyword">if</span> (!request.headers.get(<span class="string">'Origin'</span>) &amp;&amp; !request.headers.get(<span class="string">'x-requested-with'</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Missing required request header. Must specify one of: origin,x-requested-with'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UnauthorizedException</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.status = <span class="number">401</span>;</span><br><span class="line">  <span class="keyword">this</span>.statusText = <span class="string">'Unauthorized'</span>;</span><br><span class="line">  <span class="keyword">this</span>.reason = reason;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BadRequestException</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.status = <span class="number">400</span>;</span><br><span class="line">  <span class="keyword">this</span>.statusText = <span class="string">'Bad Request'</span>;</span><br><span class="line">  <span class="keyword">this</span>.reason = reason;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isListed</span>(<span class="params">uri, listing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> returnValue = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(uri);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> uri === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> m <span class="keyword">of</span> listing) &#123;</span><br><span class="line">      <span class="keyword">if</span> (uri.match(m) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        returnValue = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//   Decide what to do when Origin is null</span></span><br><span class="line">    returnValue = <span class="literal">true</span>; <span class="comment">// True accepts null origins false rejects them.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fix</span>(<span class="params">myHeaders, request, isOPTIONS</span>) </span>&#123;</span><br><span class="line">  myHeaders.set(<span class="string">'Access-Control-Allow-Origin'</span>, request.headers.get(<span class="string">'Origin'</span>));</span><br><span class="line">  <span class="keyword">if</span> (isOPTIONS) &#123;</span><br><span class="line">    myHeaders.set(<span class="string">'Access-Control-Allow-Methods'</span>, request.headers.get(<span class="string">'access-control-request-method'</span>));</span><br><span class="line">    <span class="keyword">const</span> acrh = request.headers.get(<span class="string">'access-control-request-headers'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acrh) &#123;</span><br><span class="line">      myHeaders.set(<span class="string">'Access-Control-Allow-Headers'</span>, acrh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    myHeaders.delete(<span class="string">'X-Content-Type-Options'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> myHeaders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseURL</span>(<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> match = requestUrl.match(<span class="regexp">/^(?:(https?:)?\/\/)?(([^/?]+?)(?::(\d&#123;0,5&#125;)(?=[/?]|$))?)([/?][\S\s]*|$)/i</span>);</span><br><span class="line">  <span class="comment">//                              ^^^^^^^          ^^^^^^^^      ^^^^^^^                ^^^^^^^^^^^^</span></span><br><span class="line">  <span class="comment">//                            1:protocol       3:hostname     4:port                 5:path + query string</span></span><br><span class="line">  <span class="comment">//                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span><br><span class="line">  <span class="comment">//                                            2:host</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'no match'</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Invalid URL for proxy request.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'parseURL:match:'</span>, match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!match[<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nothing in match group 1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^https?:/i</span>.test(requestUrl)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The pattern at top could mistakenly parse "http:///" as host="http:" and path=///.'</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Invalid URL for proxy request.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scheme is omitted.</span></span><br><span class="line">    <span class="keyword">if</span> (requestUrl.lastIndexOf(<span class="string">'//'</span>, <span class="number">0</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'"//" is omitted'</span>);</span><br><span class="line">      requestUrl = <span class="string">'//'</span> + requestUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestUrl = (match[<span class="number">4</span>] === <span class="string">'443'</span> ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + requestUrl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parsed = <span class="keyword">new</span> URL(requestUrl);</span><br><span class="line">  <span class="keyword">if</span> (!parsed.hostname) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'"http://:1/" and "http:/notenoughslashes" could end up here.'</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Invalid URL for proxy request.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parsed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">proxyRequest</span>(<span class="params">request, activeApiKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOPTIONS = (request.method === <span class="string">'OPTIONS'</span>);</span><br><span class="line">  <span class="keyword">const</span> originUrl = <span class="keyword">new</span> URL(request.url);</span><br><span class="line">  <span class="keyword">const</span> origin = request.headers.get(<span class="string">'Origin'</span>);</span><br><span class="line">  <span class="comment">// ParseURL throws when the url is invalid</span></span><br><span class="line">  <span class="keyword">const</span> fetchUrl = parseURL(request.url.replace(originUrl.origin, <span class="string">''</span>).slice(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Throws if it fails the check</span></span><br><span class="line">  checkRequiredHeadersPresent(request);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Excluding urls which are not allowed as destination urls</span></span><br><span class="line">  <span class="comment">// Exclude origins which are not int he included ones</span></span><br><span class="line">  <span class="keyword">if</span> (isListed(fetchUrl.toString(), [...exclude, ...(activeApiKey?.exclude || [])]) || !isListed(origin, [...include, ...(activeApiKey?.include || [])])) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Origin or Destination URL is not allowed.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> corsHeaders = request.headers.get(<span class="string">'x-cors-headers'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (corsHeaders !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      corsHeaders = <span class="built_in">JSON</span>.parse(corsHeaders);</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!originUrl.pathname.startsWith(<span class="string">'/'</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Pathname does not start with "/"'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> recvHpaireaders = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> request.headers.entries()) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pair[<span class="number">0</span>].match(<span class="string">'^origin'</span>) === <span class="literal">null</span>)</span><br><span class="line">        &amp;&amp; (pair[<span class="number">0</span>].match(<span class="string">'eferer'</span>) === <span class="literal">null</span>)</span><br><span class="line">        &amp;&amp; (pair[<span class="number">0</span>].match(<span class="string">'^cf-'</span>) === <span class="literal">null</span>)</span><br><span class="line">        &amp;&amp; (pair[<span class="number">0</span>].match(<span class="string">'^x-forw'</span>) === <span class="literal">null</span>)</span><br><span class="line">        &amp;&amp; (pair[<span class="number">0</span>].match(<span class="string">'^x-cors-headers'</span>) === <span class="literal">null</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      recvHpaireaders[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (corsHeaders !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="built_in">Object</span>.entries(corsHeaders)) &#123;</span><br><span class="line">      recvHpaireaders[c[<span class="number">0</span>]] = c[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newRequest = <span class="keyword">new</span> Request(request, &#123;</span><br><span class="line">    headers: recvHpaireaders,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(fetchUrl, newRequest);</span><br><span class="line">  <span class="keyword">let</span> myHeaders = <span class="keyword">new</span> Headers(response.headers);</span><br><span class="line">  <span class="keyword">const</span> newCorsHeaders = [];</span><br><span class="line">  <span class="keyword">const</span> allh = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> response.headers.entries()) &#123;</span><br><span class="line">    newCorsHeaders.push(pair[<span class="number">0</span>]);</span><br><span class="line">    allh[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  newCorsHeaders.push(<span class="string">'cors-received-headers'</span>);</span><br><span class="line">  myHeaders = fix(myHeaders, request, isOPTIONS);</span><br><span class="line"></span><br><span class="line">  myHeaders.set(<span class="string">'Access-Control-Expose-Headers'</span>, newCorsHeaders.join(<span class="string">','</span>));</span><br><span class="line"></span><br><span class="line">  myHeaders.set(<span class="string">'cors-received-headers'</span>, <span class="built_in">JSON</span>.stringify(allh));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> body = isOPTIONS ? <span class="literal">null</span> : <span class="keyword">await</span> response.arrayBuffer();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Response(body, &#123;</span><br><span class="line">    headers: myHeaders,</span><br><span class="line">    status: (isOPTIONS ? <span class="number">200</span> : response.status),</span><br><span class="line">    statusText: (isOPTIONS ? <span class="string">'OK'</span> : response.statusText),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">homeRequest</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isOPTIONS = (request.method === <span class="string">'OPTIONS'</span>);</span><br><span class="line">  <span class="keyword">const</span> originUrl = <span class="keyword">new</span> URL(request.url);</span><br><span class="line">  <span class="keyword">const</span> origin = request.headers.get(<span class="string">'Origin'</span>);</span><br><span class="line">  <span class="keyword">const</span> remIp = request.headers.get(<span class="string">'CF-Connecting-IP'</span>);</span><br><span class="line">  <span class="keyword">const</span> corsHeaders = request.headers.get(<span class="string">'x-cors-headers'</span>);</span><br><span class="line">  <span class="keyword">let</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line">  myHeaders = fix(myHeaders, request, isOPTIONS);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> country = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> colo = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> request.cf !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    country = <span class="keyword">typeof</span> request.cf.country === <span class="string">'undefined'</span> ? <span class="literal">false</span> : request.cf.country;</span><br><span class="line">    colo = <span class="keyword">typeof</span> request.cf.colo === <span class="string">'undefined'</span> ? <span class="literal">false</span> : request.cf.colo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Response(</span><br><span class="line">    <span class="string">'CLOUDFLARE-CORS-ANYWHERE\n\n'</span></span><br><span class="line">        + <span class="string">'Source:\nhttps://github.com/chrisspiegl/cloudflare-cors-anywhere\n\n'</span></span><br><span class="line">        + <span class="string">'Usage:\n'</span></span><br><span class="line">        + originUrl.origin + <span class="string">'/&#123;uri&#125;\n'</span></span><br><span class="line">        + <span class="string">'Header x-cors-proxy-api-key must be set with valid api key\n'</span></span><br><span class="line">        + <span class="string">'Header origin or x-requested-with must be set\n\n'</span></span><br><span class="line">        <span class="comment">// + 'Limits: 100,000 requests/day\n'</span></span><br><span class="line">        <span class="comment">// + '          1,000 requests/10 minutes\n\n'</span></span><br><span class="line">        + (origin === <span class="literal">null</span> ? <span class="string">''</span> : <span class="string">'Origin: '</span> + origin + <span class="string">'\n'</span>)</span><br><span class="line">        + <span class="string">'Ip: '</span> + remIp + <span class="string">'\n'</span></span><br><span class="line">        + (country ? <span class="string">'Country: '</span> + country + <span class="string">'\n'</span> : <span class="string">''</span>)</span><br><span class="line">        + (colo ? <span class="string">'Datacenter: '</span> + colo + <span class="string">'\n'</span> : <span class="string">''</span>) + <span class="string">'\n'</span></span><br><span class="line">        + ((corsHeaders === <span class="literal">null</span>) ? <span class="string">''</span> : <span class="string">'\nx-cors-headers: '</span> + <span class="built_in">JSON</span>.stringify(corsHeaders)),</span><br><span class="line">    &#123;<span class="attr">status</span>: <span class="number">200</span>, <span class="attr">headers</span>: myHeaders&#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleRequest</span>(<span class="params">request</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;protocol, pathname&#125; = <span class="keyword">new</span> URL(request.url);</span><br><span class="line">  <span class="comment">// In the case of a "Basic" authentication, the exchange MUST happen over an HTTPS (TLS) connection to be secure.</span></span><br><span class="line">  <span class="keyword">if</span> (protocol !== <span class="string">'https:'</span> || request.headers.get(<span class="string">'x-forwarded-proto'</span>) !== <span class="string">'https'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadRequestException(<span class="string">'Must use a HTTPS connection.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (pathname) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/favicon.ico'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/robots.txt'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="literal">null</span>, &#123;<span class="attr">status</span>: <span class="number">204</span>&#125;);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">      <span class="keyword">return</span> homeRequest(request);</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="comment">// Not 100% sure if this is a good idea…</span></span><br><span class="line">      <span class="comment">// Right now all OPTIONS requests are just simply replied to because otherwise they fail.</span></span><br><span class="line">      <span class="comment">// This is necessary because apparently, OPTIONS requests do not carry the `x-cors-proxy-api-key` header so this can not be authorized.</span></span><br><span class="line">      <span class="keyword">if</span> (request.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="literal">null</span>, &#123;</span><br><span class="line">          headers: fix(<span class="keyword">new</span> Headers(), request, <span class="literal">true</span>),</span><br><span class="line">          status: <span class="number">200</span>,</span><br><span class="line">          statusText: <span class="string">'OK'</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The "x-cors-proxy-api-key" header is sent when authenticated.</span></span><br><span class="line">      <span class="comment">//if (request.headers.has('x-cors-proxy-api-key')) &#123;</span></span><br><span class="line">        <span class="comment">// Throws exception when authorization fails.</span></span><br><span class="line">        <span class="comment">//const activeApiKey = verifyCredentials(request);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only returns this response when no exception is thrown.</span></span><br><span class="line">        <span class="keyword">return</span> proxyRequest(request);</span><br><span class="line">      <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Not authenticated.</span></span><br><span class="line">      <span class="comment">//throw new UnauthorizedException('Valid x-cors-proxy-api-key header has to be provided.');</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">'fetch'</span>, <span class="keyword">async</span> event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    handleRequest(event.request).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> message = error.reason || error.stack || <span class="string">'Unknown Error'</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response(message, &#123;</span><br><span class="line">        status: error.status || <span class="number">500</span>,</span><br><span class="line">        statusText: error.statusText || <span class="literal">null</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">'Content-Type'</span>: <span class="string">'text/plain;charset=UTF-8'</span>,</span><br><span class="line">          <span class="comment">// Disables caching by default.</span></span><br><span class="line">          <span class="string">'Cache-Control'</span>: <span class="string">'no-store'</span>,</span><br><span class="line">          <span class="comment">// Returns the "Content-Length" header for HTTP HEAD requests.</span></span><br><span class="line">          <span class="string">'Content-Length'</span>: message.length,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>部署结果: <a href="https://cors-anywhere.weiyigeek.workers.dev/" target="_blank" rel="noopener">https://cors-anywhere.weiyigeek.workers.dev/</a></p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817113707.png" alt="WeiyiGeek.cloudflare-cors-anywhere-code" title="" class="">                <p>WeiyiGeek.cloudflare-cors-anywhere-code</p>            </figure><p>温馨提示: cloudflare 构建无服务器应用程序免费版本每天限额10万次请求，所有为了避免其它 people 恶意使用，请在使用时设置访问白名单, 上述源码来源于 (<a href="https://github.com/chrisspiegl/cloudflare-cors-anywhere)。" target="_blank" rel="noopener">https://github.com/chrisspiegl/cloudflare-cors-anywhere)。</a></p><p>温馨提示: 除了使用 cloudflare 还可以使用 Vercel 免费部署node.js项目解决跨域问题，你可参考该项目 (<a href="https://github.com/Dedicatus546/cors-server" target="_blank" rel="noopener">https://github.com/Dedicatus546/cors-server</a>) ，此处就不在累述。</p><p><br/> </p><p><strong>方式2.有公网VPS、服务器</strong><br>描述: 由于我自己有VPS所以就不借用 cloudflare 与 Vercel，因为其国内网络原因，时而通畅时而有缓慢 , 此处我将使用Nginx服务在blog.conf配置Nginx文件中加入如下location指令片段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https - www.weiyigeek.top</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  listen       443 ssl http2;</span><br><span class="line">  server_name  blog.weiyigeek.top;</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># CORS</span></span><br><span class="line">  add_header Access-Control-Allow-Origin <span class="string">'*.weiyigeek.top'</span>;</span><br><span class="line">  add_header Access-Control-Allow-Methods <span class="string">'GET,POST,OPTIONS'</span>;</span><br><span class="line">  add_header Access-Control-Allow-Headers <span class="string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Gitalk Auth Use</span></span><br><span class="line">  location /github &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> 204;</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass https://github.com/; <span class="comment"># 注意尾部斜杠不能少</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  error_page  403          /warn/403.html;</span><br><span class="line">  error_page  404          /warn/404.html;</span><br><span class="line">  error_page  500 502 503  /warn/500.html;</span><br><span class="line">  error_page  504          /warn/504.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后检测blog.conf配置以及重载nginx服务 <code>nginx -t &amp;&amp; nginx -s reload</code>, 然后修改Hexo 主题中的 _config.yaml 将 Gitalk 的 proxy 配置为 <code>proxy: /github/login/oauth/access_token</code> 即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gittalk 评论系统</span></span><br><span class="line">gitalk:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  owner: WeiyiGeek  <span class="comment"># github账号</span></span><br><span class="line">  repo: blogtalk    <span class="comment"># 留言仓库</span></span><br><span class="line">  proxy: /github/login/oauth/access_token <span class="comment"># 关键点 （前台请求是https://blog.weiyigeek.top/github/login/oauth/access_token, 而实际请求是https://github.com/login/oauth/access_token，所以解决了跨域问题）</span></span><br><span class="line">  oauth:</span><br><span class="line">    client_id: 8d8e965c******97026d3       <span class="comment"># Github App Auth ID </span></span><br><span class="line">    client_secret: e9c6141cb1f02f721********d01cb4d7a8f069 <span class="comment">#  Github App Auth secret</span></span><br><span class="line">  perPage: 15</span><br></pre></td></tr></table></figure><p>之后，我们需要批量初始每篇文章issue根据其路径<code>/2020/3-20-658.html</code>，此处采用了<code>gitalk-auto-init.js</code>脚本进行批量初始化文章issue。</p><p>温馨提示: 下述 <code>gitalk-auto-init.js</code> 脚本可以通过如下连接( <a href="https://github.com/WeiyiGeek/SecOpsDev/tree/master/Application/Blog/Hexo/Gitalk" target="_blank" rel="noopener">https://github.com/WeiyiGeek/SecOpsDev/tree/master/Application/Blog/Hexo/Gitalk</a> )进行获取</p><p>脚本依赖:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -S hexo-generator-sitemap</span><br><span class="line">$ npm i -D md5 moment request xml-parser</span><br><span class="line">+ moment@2.29.2</span><br><span class="line">+ request@2.88.2</span><br><span class="line">+ md5@2.3.0</span><br><span class="line">+ xml-parser@1.2.1</span><br><span class="line">added 55 packages from 70 contributors in 8.467s</span><br></pre></td></tr></table></figure></p><p>配置运行:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gitalk-auto-init.js 脚本部分片段</span></span><br><span class="line"><span class="comment">// 配置信息</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  username: <span class="string">'weiyigeek'</span>,   <span class="comment">// GitHub repository 所有者，可以是个人或者组织。对应Gitalk配置中的owner</span></span><br><span class="line">  repo: <span class="string">"blogtalk"</span>,         <span class="comment">// 储存评论issue的github仓库名，仅需要仓库名字即可。对应 Gitalk配置中的repo</span></span><br><span class="line">  token: <span class="string">'ghp_wnpWqL********6RIf0NR5iD'</span>,   <span class="comment">// 前面在Github中的 personal access token</span></span><br><span class="line">  sitemap: path.join(__dirname, <span class="string">'./public/sitemap.xml'</span>), <span class="comment">// 自己站点的 sitemap 文件地址</span></span><br><span class="line">  cache: <span class="literal">true</span>, <span class="comment">// 是否启用缓存，启用缓存会将已经初始化的数据写入配置的 gitalkCacheFile 文件，下一次直接通过缓存文件判断</span></span><br><span class="line">  gitalkCacheFile: path.join(__dirname, <span class="string">'./gitalk-init-cache.json'</span>), <span class="comment">// 用于保存 gitalk 已经初始化的 id 列表</span></span><br><span class="line">  gitalkErrorFile: path.join(__dirname, <span class="string">'./gitalk-init-error.json'</span>), <span class="comment">// 用于保存 gitalk 初始化报错的数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sitemap.xml 示例</span></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;urlset xmlns=<span class="string">"http://www.sitemaps.org/schemas/sitemap/0.9"</span>&gt;</span><br><span class="line">    &lt;url&gt;</span><br><span class="line">    &lt;loc&gt;https:<span class="comment">//blog.weiyigeek.top/2020/5-28-588.html&lt;/loc&gt;</span></span><br><span class="line">    &lt;lastmod&gt;<span class="number">2022</span><span class="number">-08</span><span class="number">-15</span>T14:<span class="number">39</span>:<span class="number">08.638</span>Z&lt;<span class="regexp">/lastmod&gt;</span></span><br><span class="line"><span class="regexp">    &lt;title&gt;Ingress-Nginx进阶学习实践扩充配置记录&lt;/</span>title&gt;</span><br><span class="line">  &lt;<span class="regexp">/url&gt;</span></span><br><span class="line"><span class="regexp">    ....</span></span><br><span class="line"><span class="regexp">&lt;/u</span>rlset&gt;</span><br></pre></td></tr></table></figure><br><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817123646.png" alt="WeiyiGeek.批量初始化文章issue" title="" class="">                <p>WeiyiGeek.批量初始化文章issue</p>            </figure></p><p>执行结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------- 运行结果 ---------</span><br><span class="line"></span><br><span class="line">报错数据： 1 条。参考文件 /mnt/e/githubProject/blog/gitalk-init-error.json。</span><br><span class="line">本次成功： 27 条。</span><br><span class="line">写入缓存： 90 条，已初始化 63 条，本次成功： 27 条。参考文件 /mnt/e/githubProject/blog/gitalk-init-cache.json。</span><br></pre></td></tr></table></figure></p><p>我们也可以通过 blogtalk 项目中 issue (<a href="https://github.com/WeiyiGeek/blogtalk/issues" target="_blank" rel="noopener">https://github.com/WeiyiGeek/blogtalk/issues</a>) 查看初始化结果以及最新评论。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817125424.png" alt="WeiyiGeek.blogtalk-issue" title="" class="">                <p>WeiyiGeek.blogtalk-issue</p>            </figure><p>在初始化issue完成之后，我们可以找到一篇 <a href="https://blog.weiyigeek.top/about/">https://blog.weiyigeek.top/about/</a> 文章进行留言验证。</p><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220817124230.png" alt="WeiyiGeek.Gitalk 留言验证" title="" class="">                <p>WeiyiGeek.Gitalk 留言验证</p>            </figure><p><strong>首发地址</strong>: <a href="https://mp.weixin.qq.com/s/2LLVDf7Fj4cX3IRZUtUfnA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2LLVDf7Fj4cX3IRZUtUfnA</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="Blog" scheme="https://blog.weiyigeek.top/categories/Blog/"/>
    
    
    <category term="Hexo" scheme="https://blog.weiyigeek.top/tags/Hexo/"/>
    
    <category term="Gitalk" scheme="https://blog.weiyigeek.top/tags/Gitalk/"/>
    
  </entry>
  
  <entry>
    <title>网安等保-Linux服务器之最新Ubuntu-22.04-LTS系统内核优化与安全加固配置脚本分享</title>
    <link href="https://blog.weiyigeek.top/2022/8-13-683.html"/>
    <id>https://blog.weiyigeek.top/2022/8-13-683.html</id>
    <published>2022-08-13T06:36:30.000Z</published>
    <updated>2023-01-31T02:29:10.669Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h2 id="0x00-前言简述"><a href="#0x00-前言简述" class="headerlink" title="0x00 前言简述"></a>0x00 前言简述</h2><p>描述: Ubuntu 22.04 LTS 是Canonical于2022年4月21日发布的操作系统，代号为Jammy Jellyfish（果酱水母）, 其采用GNOME电源配置文件和流线型工作空间过渡，提高优化图形驱动程序上的桌面帧速率，使用新的加密算法迁移到OpenSSL v3以提高安全性,并且为内存安全的系统级编程添加了Rus。</p><p>而又由于CentOS发行版在最近几年时内将不在进行维护更新了，所以为了考虑到系统的安全性、可维护性、以及后期运维成本，我们企业内部在2020年时就已经将ubuntu作为主要的服务器系统，所以在我公司新上的业务系统基本采用debian系的发行版服务器来承载基础应用业务，而使用最多当然是Ubuntu此发行版。</p><p>现在 Ubuntu 推出了22.04 ， 想到原来每次都需要手动一台一台的进行主机安全加固以符合等保要求，所以了节约工作时间提高工作效率，有更多时间进行学习进步，则需要将将我们公司所使用的系统基线镜像进行更新迭代，编写适用于ubuntu 22.04系统的安全加固脚本，并且总结此篇文章并在文章末尾附上自动化安全加固脚本，谢谢大家支持。</p><p>此处我依据在我从前编写的 Ubuntu 20.04 系统安全加固脚本中对其根据最新的22.04版本进行更新了等保相关规定策略，以及更新适用最新版本的 Ubuntu，针对脚本进行结构调整，更加方便大家一起参参与维护，若脚本有Bug请大家发送到我的邮箱 <a href="mailto:&#x6d;&#97;&#x73;&#x74;&#101;&#114;&#x40;&#x77;&#101;&#x69;&#121;&#x69;&#103;&#x65;&#x65;&#107;&#x2e;&#x74;&#111;&#112;">&#x6d;&#97;&#x73;&#x74;&#101;&#114;&#x40;&#x77;&#101;&#x69;&#121;&#x69;&#103;&#x65;&#x65;&#107;&#x2e;&#x74;&#111;&#112;</a>。</p><p>想要获取该加固脚本的朋友可以在WX公众号【WeiyiGeek】中回复【ubuntu系统加固】即可获得，或者访问【<a href="https://weiyigeek.top/wechat.html?key=ubuntu%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA" target="_blank" rel="noopener">https://weiyigeek.top/wechat.html?key=ubuntu系统加固</a>】</p><p>​<br><strong>首发地址</strong>: <a href="https://mp.weixin.qq.com/s/dO1bV0tfXKn4ZmqlMcUrrQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dO1bV0tfXKn4ZmqlMcUrrQ</a><br><strong>实践视频</strong>：<a href="https://www.bilibili.com/video/BV1fe4y1o7ov" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1fe4y1o7ov</a></p><hr><h2 id="0x01-加固实践"><a href="#0x01-加固实践" class="headerlink" title="0x01 加固实践"></a>0x01 加固实践</h2><p>描述: Ubuntu 22.04 主机系统安全加固的 <code>Ubuntu22.04-InitializeReinforce.sh</code> 脚本相关上的使用说明以及实践。</p><h3 id="book-​-帮助文档"><a href="#book-​-帮助文档" class="headerlink" title=":book:​ 帮助文档"></a>:book:​ 帮助文档</h3><p>描述: 本工具集主要针对于 Ubuntu 22.04 、20.04  LTS 操作系统进行安全加固以及系统初始化操作。</p><p>:hammer_and_wrench: <strong>脚本说明:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@Ubuntu-Security:/home/ubuntu/Ubuntu<span class="comment"># ./Ubuntu22.04-InitializeReinforce.sh</span></span><br><span class="line">     __          __  _       _  _____           _</span><br><span class="line">     \ \        / / (_)     (_)/ ____|         | |</span><br><span class="line">     \ \  /\  / /__ _ _   _ _| |  __  ___  ___| | __</span><br><span class="line">       \ \/  \/ / _ \ | | | | | | |_ |/ _ \/ _ \ |/ /</span><br><span class="line">       \  /\  /  __/ | |_| | | |__| |  __/  __/   &lt;</span><br><span class="line">         \/  \/ \___|_|\__, |_|\_____|\___|\___|_|\_\</span><br><span class="line">                      __/ |</span><br><span class="line">                      |___/</span><br><span class="line">======================================================================</span><br><span class="line">@ Desc: Ubuntu 22.04 Security Reinforce and System initialization</span><br><span class="line">@ Mail bug reports: master@weiyigeek.top or pull request (pr)</span><br><span class="line">@ Author : WeiyiGeek</span><br><span class="line">@ Follow me on Blog   : https://blog.weiyigeek.top/</span><br><span class="line">@ Follow me on Wechat : https://weiyigeek.top/wechat.html?key=欢迎关注</span><br><span class="line">@ Communication group : https://weiyigeek.top/visit.html</span><br><span class="line">======================================================================</span><br><span class="line"></span><br><span class="line">Usage: ./Ubuntu22.04-InitializeReinforce.sh [--start ] [--network] [--<span class="keyword">function</span>] [--clear] [--version] [--<span class="built_in">help</span>]</span><br><span class="line">Option:</span><br><span class="line">  --start            Start System initialization and security reinforcement.</span><br><span class="line">  --network          Configure the system network and DNS resolution server.</span><br><span class="line">  --<span class="keyword">function</span>         PCall the specified shell <span class="keyword">function</span>.</span><br><span class="line">  --clear            Clear all system logs, cache and backup files.</span><br><span class="line">  --version          Print version and <span class="built_in">exit</span>.</span><br><span class="line">  --<span class="built_in">help</span>             Print <span class="built_in">help</span> and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line">Mail bug reports or suggestions to &lt;master@weiyigeek.top&gt; or pull request (pr).</span><br><span class="line">current version : 1.0</span><br><span class="line"></span><br><span class="line">WARNING: 温馨提示：使用前先请配置机器上网环境,若没有配置请在 Ubuntu22.04.conf 文件中进行网络配置.</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220823140038.png" alt="WeiyiGeek.运行加固脚本" title="" class="">                <p>WeiyiGeek.运行加固脚本</p>            </figure><p><br/></p><p>:atom_symbol:<strong>脚本函数:</strong></p><p>描述: 如下脚本将根据参数在 <code>Ubuntu22.04-InitializeReinforce.sh</code> 分别进行调用执行, 也可采用<code>--function</code>参数进行指定调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">❯ grep -r -n  <span class="string">"函数名称"</span> -A 1 *</span><br><span class="line">scripts/os-base.sh:26:<span class="comment"># 函数名称: base_hostname</span></span><br><span class="line">scripts/os-base.sh-27-<span class="comment"># 函数用途: 主机名称设置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-base.sh:55:<span class="comment"># 函数名称: ubuntu_mirror</span></span><br><span class="line">scripts/os-base.sh-56-<span class="comment"># 函数用途: ubuntu 系统主机软件仓库镜像源</span></span><br><span class="line">--</span><br><span class="line">scripts/os-base.sh:126:<span class="comment"># 函数名称: ubuntu_software</span></span><br><span class="line">scripts/os-base.sh-127-<span class="comment"># 函数用途: ubuntu 系统主机内核版本升级以常规软件安装</span></span><br><span class="line">--</span><br><span class="line">scripts/os-base.sh:153:<span class="comment"># 函数名称: base_timezone</span></span><br><span class="line">scripts/os-base.sh-154-<span class="comment"># 函数用途: 主机时间同步校准与时区设置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-base.sh:192:<span class="comment"># 函数名称: base_banner</span></span><br><span class="line">scripts/os-base.sh-193-<span class="comment"># 函数用途: 远程本地登陆主机信息展示</span></span><br><span class="line">--</span><br><span class="line">scripts/os-base.sh:345:<span class="comment"># 函数名称: base_reboot</span></span><br><span class="line">scripts/os-base.sh-346-<span class="comment"># 函数用途: 是否进行重启或者关闭服务器</span></span><br><span class="line">--</span><br><span class="line">scripts/os-clean.sh:27:<span class="comment"># 函数名称: system_clean</span></span><br><span class="line">scripts/os-clean.sh-28-<span class="comment"># 函数用途: 删除安全加固过程临时文件清理为基线镜像做准备</span></span><br><span class="line">--</span><br><span class="line">scripts/os-exceptions.sh:26:<span class="comment"># 函数名称: problem_usercrond</span></span><br><span class="line">scripts/os-exceptions.sh-27-<span class="comment"># 函数用途: 解决普通用户定时任务无法定时执行问题</span></span><br><span class="line">--</span><br><span class="line">scripts/os-exceptions.sh:45:<span class="comment"># 函数名称: problem_multipath</span></span><br><span class="line">scripts/os-exceptions.sh-46-<span class="comment"># 函数用途: 解决 ubuntu multipath add missing path 错误</span></span><br><span class="line">--</span><br><span class="line">scripts/os-network.sh:27:<span class="comment"># 函数名称: net_config</span></span><br><span class="line">scripts/os-network.sh-28-<span class="comment"># 函数用途: 主机IP地址与网关设置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-network.sh:70:<span class="comment"># 函数名称: net_dns</span></span><br><span class="line">scripts/os-network.sh-71-<span class="comment"># 函数用途: 设置主机DNS解析服务器</span></span><br><span class="line">--</span><br><span class="line">scripts/os-optimize.sh:27:<span class="comment"># 函数名称: optimize_kernel</span></span><br><span class="line">scripts/os-optimize.sh-28-<span class="comment"># 函数用途: 系统内核参数的优化配置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-optimize.sh:84:<span class="comment"># 函数名称: resources_limits</span></span><br><span class="line">scripts/os-optimize.sh-85-<span class="comment"># 函数用途: 系统资源文件打开句柄数优化配置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-optimize.sh:115:<span class="comment"># 函数名称: swap_partition</span></span><br><span class="line">scripts/os-optimize.sh-116-<span class="comment"># 函数用途: 创建系统swap分区</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:27:<span class="comment"># 函数名称: sec_usercheck</span></span><br><span class="line">scripts/os-security.sh-28-<span class="comment"># 函数用途: 用于锁定或者删除多余的系统账户</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:65:<span class="comment"># 函数名称: sec_userconfig</span></span><br><span class="line">scripts/os-security.sh-66-<span class="comment"># 函数用途: 针对拥有ssh远程登陆权限的用户进行密码口令设置。</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:131:<span class="comment"># 函数名称: sec_passpolicy</span></span><br><span class="line">scripts/os-security.sh-132-<span class="comment"># 函数用途: 用户密码复杂性策略设置 (密码过期周期0~90、到期前15天提示、密码长度至少12、复杂度设置至少有一个大小写、数字、特殊字符、密码三次不能一样、尝试次数为三次）</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:166:<span class="comment"># 函数名称: sec_sshdpolicy</span></span><br><span class="line">scripts/os-security.sh-167-<span class="comment"># 函数用途: 系统sshd服务安全策略设置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:194:<span class="comment"># 函数名称: sec_loginpolicy</span></span><br><span class="line">scripts/os-security.sh-195-<span class="comment"># 函数用途: 用户登陆安全策略设置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:230:<span class="comment"># 函数名称: sec_historypolicy</span></span><br><span class="line">scripts/os-security.sh-231-<span class="comment"># 函数用途: 用户终端执行的历史命令记录安全策略设置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:261:<span class="comment"># 函数名称: sec_grubpolicy</span></span><br><span class="line">scripts/os-security.sh-262-<span class="comment"># 函数用途: 系统 GRUB 安全设置防止物理接触从grub菜单中修改密码</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:304:<span class="comment"># 函数名称: sec_firewallpolicy</span></span><br><span class="line">scripts/os-security.sh-305-<span class="comment"># 函数用途: 系统防火墙策略设置, 建议操作完成后重启计算机.</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:335:<span class="comment"># 函数名称: sec_ctrlaltdel</span></span><br><span class="line">scripts/os-security.sh-336-<span class="comment"># 函数用途: 禁用 ctrl+alt+del 组合键对系统重启 (必须要配置我曾入过坑)</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:355:<span class="comment"># 函数名称: sec_recyclebin</span></span><br><span class="line">scripts/os-security.sh-356-<span class="comment"># 函数用途: 设置文件删除回收站别名(防止误删文件)(必须要配置,我曾入过坑)</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:405:<span class="comment"># 函数名称: sec_supolicy</span></span><br><span class="line">scripts/os-security.sh-406-<span class="comment"># 函数用途: 切换用户日志记录和切换命令更改名称为SU(可选)</span></span><br><span class="line">--</span><br><span class="line">scripts/os-security.sh:425:<span class="comment"># 函数名称: sec_privilegepolicy</span></span><br><span class="line">scripts/os-security.sh-426-<span class="comment"># 函数用途: 系统用户sudo权限与文件目录创建权限策略设置</span></span><br><span class="line">--</span><br><span class="line">scripts/os-service.sh:26:<span class="comment"># 函数名称: svc_apport</span></span><br><span class="line">scripts/os-service.sh-27-<span class="comment"># 函数用途: 禁用烦人的apport错误报告</span></span><br><span class="line">--</span><br><span class="line">scripts/os-service.sh:52:<span class="comment"># 函数名称: svc_snapd</span></span><br><span class="line">scripts/os-service.sh-53-<span class="comment"># 函数用途: 不使用snapd容器的环境下禁用或者卸载多余的snap软件及其服务</span></span><br><span class="line">--</span><br><span class="line">scripts/os-service.sh:75:<span class="comment"># 函数名称: svc_cloud-init</span></span><br><span class="line">scripts/os-service.sh-76-<span class="comment"># 函数用途: 非云的环境下禁用或者卸载多余的cloud-init软件及其服务</span></span><br><span class="line">--</span><br><span class="line">scripts/os-service.sh:101:<span class="comment"># 函数名称: svc_debugshell</span></span><br><span class="line">scripts/os-service.sh-102-<span class="comment"># 函数用途: 在系统启动时禁用debug-shell服务</span></span><br><span class="line">--</span><br><span class="line">scripts/os-software.sh:26:<span class="comment"># 函数名称: install_chrony</span></span><br><span class="line">scripts/os-software.sh-27-<span class="comment"># 函数用途: 安装配置 chrony 时间同步服务器</span></span><br><span class="line">--</span><br><span class="line">scripts/os-software.sh:79:<span class="comment"># 函数名称: install_java</span></span><br><span class="line">scripts/os-software.sh-80-<span class="comment"># 函数用途: 安装配置java环境</span></span><br><span class="line">--</span><br><span class="line">scripts/os-software.sh:110:<span class="comment">## 函数名称: install_docker</span></span><br><span class="line">scripts/os-software.sh-111-<span class="comment">## 函数用途: 在 Ubuntu 主机上安装最新版本的Docker</span></span><br><span class="line">--</span><br><span class="line">scripts/os-software.sh:201:<span class="comment">## 函数名称: install_cockercompose</span></span><br><span class="line">scripts/os-software.sh-202-<span class="comment">## 函数用途: 在 Ubuntu 主机上安装最新版本的Dockercompose</span></span><br></pre></td></tr></table></figure><p><br></p><p>​:coffee:​ <strong>配置文件:</strong><br>描述: 在 Ubuntu22.04.conf 配置文件中定义脚本所需的安全策略以及日志、历史记录存放路径, 以模板的初始密码与防火墙配置等，其中最主要的是一定要配置好IP地址，以成功拉取软件仓库中的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">$ vim Ubuntu22.04.conf</span><br><span class="line"><span class="comment"># Show  Script Execute result (Y/N)</span></span><br><span class="line">VAR_VERIFY_RESULT=Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify Script vertify timeout (unit s)</span></span><br><span class="line">VAR_VERIFY_TIMEOUT=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify Script run time</span></span><br><span class="line">VAR_RUNDATE=$(date +%Y%m%d-%s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify Path to logfile.</span></span><br><span class="line">LOGFILE=/var/<span class="built_in">log</span>/weiyigeek-<span class="variable">$&#123;VAR_RUNDATE&#125;</span>.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify Path to Backup directory.</span></span><br><span class="line">BACKUPDIR=/var/<span class="built_in">log</span>/.backup/<span class="variable">$&#123;VAR_RUNDATE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify Path to history record directory.</span></span><br><span class="line">HISTORYDIR=/var/<span class="built_in">log</span>/.<span class="built_in">history</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify su command execute log file path.</span></span><br><span class="line">SU_LOG_FILE=<span class="variable">$&#123;HISTORYDIR&#125;</span>/su.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the hostname</span></span><br><span class="line">VAR_HOSTNAME=<span class="string">"Ubuntu-Security"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the IP/MASK and Gateway</span></span><br><span class="line">VAR_IP=10.20.172.152/24</span><br><span class="line">VAR_GATEWAY=10.20.172.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the DNS server</span></span><br><span class="line"><span class="comment"># DNSPod: 119.29.29.29      Alidns: 223.5.5.5 223.6.6.6</span></span><br><span class="line"><span class="comment"># Google: 8.8.8.8 8.8.4.4   Cloudflare: 1.1.1.1 1.0.0.1</span></span><br><span class="line"><span class="comment"># Internal : Your intranet domain name resolution server</span></span><br><span class="line">VAR_DNS_SERVER=(<span class="string">"223.5.5.5"</span> <span class="string">"223.6.6.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the SSHD server</span></span><br><span class="line">VAR_SSHD_PORT=20221</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the super user and normal user</span></span><br><span class="line"><span class="comment"># 建议将密码设置最小长度10（最好设置为12以上，等保要求），数字、大写字母、小写字母、特殊符号，密码包含三种及以上, 且无规律。</span></span><br><span class="line"><span class="comment"># 温馨提示: 下面设置的密码为初始密码，在系统登陆后会要求更改。</span></span><br><span class="line">VAR_SUPER_USER=root</span><br><span class="line">VAR_SUPER_PASS=R2022.weiyigeek.top</span><br><span class="line"><span class="comment"># normal user</span></span><br><span class="line">VAR_USER_NAME=ubuntu</span><br><span class="line">VAR_USER_PASS=U2022.weiyigeek.top</span><br><span class="line"><span class="comment"># low privilege application users</span></span><br><span class="line">VAR_APP_USER=app</span><br><span class="line">VAR_APP_PASS=A2022.weiyigeek.top</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the NTP server</span></span><br><span class="line">VAR_NTP_SERVER=( <span class="string">"ntp.aliyun.com"</span> <span class="string">"ntp.tencent.com"</span> <span class="string">"192.168.10.254"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify the timezone</span></span><br><span class="line">VAR_TIMEZONE=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify Password policy</span></span><br><span class="line"><span class="comment"># 默认密码最大使用为90天、过期前15天提示, 密码最小长度为12</span></span><br><span class="line">PASS_MIN_DAYS=1</span><br><span class="line">PASS_MAX_DAYS=90</span><br><span class="line">PASS_WARN_AGE=15</span><br><span class="line">PASS_MIN_LEN=12</span><br><span class="line"><span class="comment"># 默认加密方式为SHA512, 重试次数为3, 新密码与旧密码至少有6个字符不同, 至少包含3种密码类型，不限制密码中包含大写字母、小写字母、数字、特殊符号的最大数量，记住三次旧密码。</span></span><br><span class="line">VAR_PASS_ENCRYPT=SHA512</span><br><span class="line">VAR_PASS_RETRY=3</span><br><span class="line">VAR_PASS_DIFOK=6</span><br><span class="line">VAR_PASS_MINCLASS=3</span><br><span class="line">VAR_PASS_UCREDIT=-1</span><br><span class="line">VAR_PASS_LCREDIT=-1</span><br><span class="line">VAR_PASS_DCREDIT=-1</span><br><span class="line">VAR_PASS_OCREDIT=-1</span><br><span class="line">VAR_PASS_REMEMBER=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止没有主目录的用户登录</span></span><br><span class="line">VAR_DEFAULT_HOME=no</span><br><span class="line"><span class="comment"># 删除用户时禁止同步删除用户组</span></span><br><span class="line">VAR_USERGROUPS_ENAB=no</span><br><span class="line"><span class="comment"># 启用成功登录的日志记录</span></span><br><span class="line">VAR_LOG_OK_LOGINS=yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify file or Dirctory privilege policy</span></span><br><span class="line">VAR_UMASK=022</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify user login failed count policy</span></span><br><span class="line"><span class="comment"># 默认在5分钟之内登陆失败次数超过6次将锁定10分钟,终端超时10分钟</span></span><br><span class="line">VAR_LOGIN_FAIL_COUNT=6</span><br><span class="line">VAR_LOGIN_FAIL_INTERVAL=300</span><br><span class="line">VAR_LOGIN_LOCK_TIME=600</span><br><span class="line">VAR_LOGIN_TIMEOUT=300</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify history record count policy</span></span><br><span class="line">VAR_HISTSIZE=128</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modify firewall policy tcp or udp port .</span></span><br><span class="line">VAR_ALLOW_PORT=(<span class="string">"22,80,443,<span class="variable">$&#123;VAR_SSHD_PORT&#125;</span>/tcp"</span> <span class="string">"53/udp"</span>)</span><br></pre></td></tr></table></figure><p><br/></p><h3 id="​-running-​-脚本使用"><a href="#​-running-​-脚本使用" class="headerlink" title="​:running:​ 脚本使用"></a>​:running:​ 脚本使用</h3><ul><li><p>Step 1.上传到需要加固的主机服务器中，此处我上传到ubuntu用户的家目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OperatingSystem\Security&gt; scp -r .\Ubuntu\ ubuntu@10.20.172.152:~</span><br><span class="line">ubuntu@10.20.172.152\<span class="string">'s password:</span></span><br><span class="line"><span class="string">Ubuntu22.04.conf                                                                      100% 2979   976.9KB/s   00:00</span></span><br><span class="line"><span class="string">os-base.sh                                                                            100%   14KB   5.4MB/s   00:00</span></span><br><span class="line"><span class="string">os-clean.sh                                                                           100% 2446     2.1MB/s   00:00</span></span><br><span class="line"><span class="string">os-exceptions.sh                                                                      100% 2634     2.5MB/s   00:00</span></span><br><span class="line"><span class="string">os-info.sh                                                                            100% 1169     1.3MB/s   00:00</span></span><br><span class="line"><span class="string">os-manual.sh                                                                          100% 1860     2.0MB/s   00:00</span></span><br><span class="line"><span class="string">os-network.sh                                                                         100% 3774     1.8MB/s   00:00</span></span><br><span class="line"><span class="string">os-optimize.sh                                                                        100% 7752     3.7MB/s   00:00</span></span><br><span class="line"><span class="string">os-security.sh                                                                        100% 23KB     5.7MB/s   00:00</span></span><br><span class="line"><span class="string">os-service.sh                                                                         100% 3969     2.0MB/s   00:00</span></span><br><span class="line"><span class="string">os-software.sh                                                                        100% 8007     3.3MB/s   00:00</span></span><br><span class="line"><span class="string">Ubuntu22.04-InitializeReinforce.sh                                                    100% 7989     5.0MB/s   00:00</span></span><br></pre></td></tr></table></figure></li><li><p>Step 2.登陆服务器并切换到root用户, 查看 <code>/home/ubuntu</code> 目录下上传的加固版本。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 22 ubuntu@10.20.172.152</span><br><span class="line">ubuntu@Ubuntu-Security:~$ tree Ubuntu/</span><br><span class="line">Ubuntu/</span><br><span class="line">├── Readme.assets</span><br><span class="line">│   ├── image-20220823143235577.png</span><br><span class="line">│   └── image-20220823143354742.png</span><br><span class="line">├── Readme.md</span><br><span class="line">├── Ubuntu22.04-InitializeReinforce.sh</span><br><span class="line">├── config</span><br><span class="line">│   └── Ubuntu22.04.conf</span><br><span class="line">├── example</span><br><span class="line">│   └── 22.04</span><br><span class="line">│       ├── 00-custom-header</span><br><span class="line">│       ├── common-auth</span><br><span class="line">│       ├── common-password</span><br><span class="line">│       ├── issue</span><br><span class="line">│       ├── issue.net</span><br><span class="line">│       ├── login.defs</span><br><span class="line">│       ├── profile</span><br><span class="line">│       ├── resolved.conf</span><br><span class="line">│       ├── sshd_config</span><br><span class="line">│       └── su</span><br><span class="line">└── scripts</span><br><span class="line">    ├── os-base.sh</span><br><span class="line">    ├── os-clean.sh</span><br><span class="line">    ├── os-exceptions.sh</span><br><span class="line">    ├── os-info.sh</span><br><span class="line">    ├── os-manual.sh</span><br><span class="line">    ├── os-network.sh</span><br><span class="line">    ├── os-optimize.sh</span><br><span class="line">    ├── os-security.sh</span><br><span class="line">    ├── os-service.sh</span><br><span class="line">    └── os-software.sh</span><br><span class="line"></span><br><span class="line">ubuntu@Ubuntu-Security:~$ sudo -i</span><br></pre></td></tr></table></figure><ul><li>Step 3.切换root用户后进入 <code>/home/ubuntu/Ubuntu</code>，安全加固脚本存放目录，首先将所有的sh文件赋予可执行去那些，其次需要在 <code>Ubuntu22.04.conf</code> 中进行相应配置，最后运行<code>Ubuntu22.04-InitializeReinforce.sh  --start</code>即可，最后等待系统重启即可。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/ubuntu/Ubuntu</span><br><span class="line">chmod +x -R *</span><br><span class="line">Ubuntu22.04-InitializeReinforce.sh  --start</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220823140038.png" alt="WeiyiGeek.运行加固脚本" title="" class="">                <p>WeiyiGeek.运行加固脚本</p>            </figure><ul><li>Step 4.中途请根据需求输入Y/N，然后等待重启即可，在重启后请注意sshd服务端口更改为20221所以此时你需要指定ssh连接端口。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 20221 ubuntu@10.20.172.152  <span class="comment"># Ubuntu22.04.conf 定义的 ubuntu 初始化密码，登陆后会提示你进行更改。</span></span><br><span class="line">su - root  <span class="comment"># 只能有ubuntu用户切换到root用户，其它低权限以及app用户无法通过su进行用户切换</span></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="https://img.weiyigeek.top/2022/5/20220823115958.png" alt="WeiyiGeek.加固结果" title="" class="">                <p>WeiyiGeek.加固结果</p>            </figure><p>温馨提示: 如果执行到密码更新策略时，选择输入了(N) 否将不会更新其在<code>Ubuntu22.04.conf</code>脚本中定义的密码。</p><p>温馨提示：脚本中默认root密码为R2022.weiyigeek.top。</p><p>温馨提示: 防火墙策略只开放了80，443，22，20221等端口。</p><p><br/></p><p>:hammer_and_wrench: <strong>脚本视频演示:</strong></p><p>[<figure class="image-box">                <img src="https://www.bilibili.com/video/BV1fe4y1o7ov" alt="企业网络安全-等保2.0主机安全测评之Linux-Ubuntu22.04服务器系统安全加固实践与基线系统制作](http://i2.hdslb.com/bfs/archive/a6739f92517a8cd7b0f0e7bbbd1dd610cdf9ab12.jpg)" title="" class="">                <p>企业网络安全-等保2.0主机安全测评之Linux-Ubuntu22.04服务器系统安全加固实践与基线系统制作](http://i2.hdslb.com/bfs/archive/a6739f92517a8cd7b0f0e7bbbd1dd610cdf9ab12.jpg)</p>            </figure></p><iframe src="//player.bilibili.com/player.html?bvid=BV1fe4y1o7ov&cid=813962656&page=1" scrolling="no" border="0" frameborder="no" framespacing="0"></iframe><p>温馨提示: 点击上方图像进行观看视频。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="安全加固" scheme="https://blog.weiyigeek.top/categories/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
    
    <category term="Host_Security" scheme="https://blog.weiyigeek.top/categories/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/Host-Security/"/>
    
    
    <category term="Linux" scheme="https://blog.weiyigeek.top/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.weiyigeek.top/tags/Ubuntu/"/>
    
  </entry>
  
</feed>
