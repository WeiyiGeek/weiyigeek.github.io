{"title":"16.计算机科学导论之网络信息安全学习笔记","slug":"书籍笔记/计算机科学导论/16.计算机科学导论之网络信息安全学习笔记","date":"2023-01-01T08:35:30.000Z","updated":"2023-01-31T02:29:07.990Z","url":"2023/1-1-707.html","path":"api/articles/2023/1-1-707.html.json","covers":["https://img.weiyigeek.top/2022/10/20230113093321.png","https://img.weiyigeek.top/2022/10/20230113161115.png","https://img.weiyigeek.top/2019/1/20191011211531.png","https://img.weiyigeek.top/2022/10/20230113164948.png","https://img.weiyigeek.top/2022/10/20230113165757.png","https://img.weiyigeek.top/2022/10/20230116104049.png","https://img.weiyigeek.top/2022/10/20230116144030.png","https://img.weiyigeek.top/2022/10/20230116153045.png","https://img.weiyigeek.top/2022/10/20230116162450.png","https://img.weiyigeek.top/2022/10/20230116162729.png","https://img.weiyigeek.top/2022/10/20230116172552.png","https://img.weiyigeek.top/2022/10/20230116175204.png","https://img.weiyigeek.top/2023/1/20230117160220.png","https://img.weiyigeek.top/2023/1/20230117161422.png","https://img.weiyigeek.top/2023/1/20230118105104.png","https://img.weiyigeek.top/2023/1/20230118115237.png","https://img.weiyigeek.top/2023/1/20230118115300.png","https://img.weiyigeek.top/2023/1/20230118115339.png","https://img.weiyigeek.top/2023/1/20230118152016.png","https://img.weiyigeek.top/2023/1/20230118161049.png","https://img.weiyigeek.top/2023/1/20230130094001.png","https://img.weiyigeek.top/2023/1/20230130094521.png","https://img.weiyigeek.top/2023/1/20230130094855.png"],"content":"<p>[TOC]</p>\n<h1 id=\"计算机科学导论学习笔记\"><a href=\"#计算机科学导论学习笔记\" class=\"headerlink\" title=\"计算机科学导论学习笔记\"></a>计算机科学导论学习笔记</h1><h2 id=\"第-5-部分-数据安全与人工智能\"><a href=\"#第-5-部分-数据安全与人工智能\" class=\"headerlink\" title=\"第 5 部分 数据安全与人工智能\"></a>第 5 部分 数据安全与人工智能</h2><p>此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。</p>\n<p>原文地址: </p>\n<a id=\"more\"></a>\n<h3 id=\"第16章-网络安全\"><a href=\"#第16章-网络安全\" class=\"headerlink\" title=\"第16章 网络安全\"></a>第16章 网络安全</h3><p>笔者作为一名资深的白帽子，来到了我熟悉喜欢的章节，对于网络安全我从高中开始接触，并自学到漏洞挖掘，记得挖的第一个漏洞是腾讯的存储型XSS，提交给了当时Wooyun平台，算是投名状吧，随后又浪迹在各众测平台、SRC，其中有学习的快乐，又有挖漏洞的煎熬，当然漏洞审核通过的那一瞬间，又感觉什么都值得了（money），支持者我不断的学习、不断的探索，直到遇到自身瓶颈时，对于我们非科班出生的网络安全人员，有必要进行基础知识的学习，为了走得更远遂，有了【大大神之路-起始篇 计算机科学导论】系列文章! </p>\n<p>好，回归到本章正题《安全》，安全这个话题很宽泛并且包括数学中的某些特定领域，例如数论安全、网络信息(数据)安全、人身安全、材料安全，此处主要讲解的时是网络信息(数据)安全!</p>\n<h4 id=\"16-1-安全三要素\"><a href=\"#16-1-安全三要素\" class=\"headerlink\" title=\"16.1 安全三要素\"></a>16.1 安全三要素</h4><p>你可能常常在新闻或者网警的公众号文章看到，某某黑客又攻击某某平台，并将个人信息数据进行售卖的违法行为，我们生活在信息时代需要保存生活中各方面的信息，其中我们的信息是一种有价值的资产，就像其他资产一样(存款)，我们要尽可能授权给可信机构，不要随意连接公共WIFI、不扫码来路不明的链接或者二维码，也不要贪小便宜将个人信息直接或者间接给他人使用。</p>\n<p>个人信息作为一种资产，信息需要保护免受攻击。为了安全信息需要避开未授权的使用<code>（机密性）</code>，保护信息不受到未授权的篡改<code>（完整性）</code>，并且对于得到授权 的实体来说是需要时可用的<code>（可用性）</code>。</p>\n<p>此节中，我们先讨论信息安全的三个主要目标（也称<code>安全三要素</code>），其次将探索攻击是如何威胁这三个目标的，然后我们将讨论和这些安全目标有关的安全服务，最后我们将定义两个实现安全目标并且防止攻击的技术。</p>\n<p>作为网络安全中最基本的三个目标<code>机密性、完整性和可用性</code>，下面我们一一进行介绍。</p>\n<h5 id=\"0-安全性\"><a href=\"#0-安全性\" class=\"headerlink\" title=\"(0) 安全性\"></a>(0) 安全性</h5><blockquote>\n<p>通过加密、认证和访问控制等措施，确保个人信息安全，保护用户隐私数据保护。<br>例如, 银行卡设置的取款密码，APP关键操作中的人脸识别。</p>\n</blockquote>\n<h5 id=\"1-机密性\"><a href=\"#1-机密性\" class=\"headerlink\" title=\"(1) 机密性\"></a>(1) 机密性</h5><blockquote>\n<p>信息安全的第一个部分是机密性(最通常的方面) , 使用数据加密技术，对个人信息进行保密，防止恶意用户拒绝、披露或窃取用户信息。<br>例如，当我们将一小段信息发送并存储至远程计算机或从远程计算机上检索一段信息时，需要在传输时对该信息进行隐藏。</p>\n</blockquote>\n<h5 id=\"2-完整性\"><a href=\"#2-完整性\" class=\"headerlink\" title=\"(2) 完整性\"></a>(2) 完整性</h5><blockquote>\n<p>信息安全的第二个部分是完整性,使用完整性检查机制，确保个人信息的有效性和准确性，确保用户的安全性。<br>例如，当一个客户在银行存钱或取钱时, 他的账户余额需要根据存入或者取出操作进行变化, 原子性操作（要么成功，要么失败）。</p>\n</blockquote>\n<h5 id=\"3-可用性\"><a href=\"#3-可用性\" class=\"headerlink\" title=\"(3) 可用性\"></a>(3) 可用性</h5><p>信息安全的第三个部分是可用性，保证个人信息的可用性，以便随时及时访问并使用个人信息，以便更好地提升个人信息的安全性。<br>例如，当客户交易时不能访问他们的账户，这时银行会发生什么。</p>\n<p><br/></p>\n<h4 id=\"16-2-攻击目标\"><a href=\"#16-2-攻击目标\" class=\"headerlink\" title=\"16.2 攻击目标\"></a>16.2 攻击目标</h4><p>安全三要素（<code>机密性、完整性和可用性</code>）会受到安全攻击的威胁, 虽然文献中可能采用不同的方法来对攻击进行分类，但我们在这里将它们按照安全目标分为三类。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/10/20230113093321.png\" alt=\"WeiyiGeek.与安全模板有关的攻击分类图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.与安全模板有关的攻击分类图</p>\n            </figure>\n<h5 id=\"1-威胁机密性的攻击\"><a href=\"#1-威胁机密性的攻击\" class=\"headerlink\" title=\"(1) 威胁机密性的攻击\"></a>(1) 威胁机密性的攻击</h5><p>通常有两种攻击威胁到信息的机密性<code>嗅探和流量分析</code>。</p>\n<ol>\n<li><p>嗅探 : 嗅探是指对数据的非授权访问或侦听, 一个通过因特网传输的文件可能含有机密的信息，一个非授权的实体可能侦听到传输, 为了防止嗅探，可以使用我们下面要讨论的加密技术，以使得数据对侦听者来说难以理解。</p>\n<blockquote>\n<p>例如，在后渗透测试中通常会在内网嗅探<code>其他服务器主机或者个人电脑</code>间传输的非加密信息，如嗅探ftp服务的账号密码，当前解决办法是使用sftp进行加密传输。</p>\n</blockquote>\n</li>\n<li><p>流量分析：虽然通过加密技术我们可以使得数据对侦听者来说难以理解，但他们仍然可以通过在线流量监控收集其他类型的信息。</p>\n<blockquote>\n<p>例如，他们能找到发送者或接收者的电子地址（如电子邮件地址)，收集多对请求和响应，帮助猜测交易的本质。</p>\n</blockquote>\n</li>\n</ol>\n<p><br/></p>\n<h5 id=\"2-威胁完整性的攻击\"><a href=\"#2-威胁完整性的攻击\" class=\"headerlink\" title=\"(2) 威胁完整性的攻击\"></a>(2) 威胁完整性的攻击</h5><p>数据的完整性会受到多种攻击的威胁：篡改、假冒、重放和抵赖。</p>\n<ol>\n<li><p>篡改: 侦听或访问信息后，攻击者篡改信息，使得信息有利于他们，通常在中间人攻击中常常用到。</p>\n<blockquote>\n<p>例如，一个客户可能向银行发送一消息去完成一些交易。攻击者侦听到信息，并为了自己的利益篡改了交易的类型。注意，有时攻击者可能仅仅是删除或延迟了这个消息来危害这个系统或者使他们自己受益。</p>\n</blockquote>\n</li>\n<li><p>假冒: 当攻击者冒充其他人时，假冒或“哄骗”就发生了, 通常在社会工程学中常常用到。</p>\n<blockquote>\n<p>例如，一个攻击者可能盗窃银行卡和银行客户的PIN而假装是这个客户,有时攻击者则假冒接收实体。比如，一个用户尝试联系一家银行，但是另一个站点伪装成银行网站并从用户那里得到了一些信息。</p>\n</blockquote>\n</li>\n<li><p>重放：重放是另一种类型的攻击, 攻击者得到用户发送的消息的副本，过后设法重放它, 通常在burpsuite中重放关键性的提交。</p>\n<blockquote>\n<p>例如，一个客户向他的银行发送了一条给攻击者付款的请求，攻击者侦听到这个消息，再次发送这条消息，想从银行得到另一次付款。</p>\n</blockquote>\n</li>\n<li><p>抵赖: 抵赖是一种不同于其他类型的攻击，因为它是由通信双方中的一个来进行的发送者或接收者, 消息的发送者后来可能抵赖他发送了消息；消息的接收者后来也可能抵赖他接收到消息。</p>\n<blockquote>\n<p>例如，发送者抵赖，一个银行客户要求银行给第三方送钱，但后来他否认自己做过这样的请求; 接收者抵赖，某人向一制造商购买产品，并电子付款，但制造商后来否认已经收到付款而要求再付。</p>\n</blockquote>\n</li>\n</ol>\n<p><br/></p>\n<h5 id=\"3-威胁可用性的攻击\"><a href=\"#3-威胁可用性的攻击\" class=\"headerlink\" title=\"(3) 威胁可用性的攻击\"></a>(3) 威胁可用性的攻击</h5><p>此只讨论一种威胁可用性的攻击<code>拒绝服务</code>。</p>\n<p>拒绝服务(DoS)攻击是很常见的网络攻击手段，其目的是瘫痪网络服务或使其变得不可用，其原理是通过发送大量伪造的请求或数据包来淹没网络带宽或计算机资源，使其失去可用性。拒绝服务攻击通常可以通过利用系统漏洞来实施，或者利用病毒和僵尸计算机来发送大量的伪造请求或数据包。</p>\n<p>当前拒绝服务攻击多为(分布式拒绝服务)DDOS攻击，攻击可能来自一台计算机或由许多计算机代理发起，通常是使用僵尸网络(物联网IOT大量被恶意者控制)，同时发送垃圾信息并阻断特定的网络服务，庞大的网络洪水，以使服务器变得不可用。</p>\n<p><strong>如何避免或防御网络攻击?</strong><br>我们知道企业的网络安全都是木桶效应，内部安全情况取决于木桶中最短的木板，你在其他系统安全做得好，也免不了被攻击，所以在企业中需要从制定安全操作流程，以及按照不同的员工分配不同的权限。</p>\n<ul>\n<li>系统管理员 ：应定期检查他们的网络设备以确保它们具有最新的安全补丁; 此外，应确保安装并配置可以检测恶意活动的垃圾邮件过滤器，防火墙和入侵检测系统，以及软件来屏蔽易受攻击的端口号，同时还应加强账户管理，避免使用默认设置，以及定期检查日志来检测可疑活动。</li>\n<li>开发工程师 ：应在系统安全测试以及内部安全测试反馈有安全问题需及时更改代码，此处在编写引用代码时最好做检查，建立内部漏洞Bug文档，防止其他系统开发时其他同事也遇到此漏洞Bug问题，此外在重点传输信息的系统，采用非对称密钥进行验证。</li>\n<li>普通员工 : 定期进行安全培训，查看网络安全宣传短片，提高大家的安全意思，因为人才是企业中保证网络安全的基础，一旦人员被社会工程学中招后，往往可以直插企业内部某些系统，例如，邮件钓鱼、木马投放等。</li>\n</ul>\n<hr>\n<h4 id=\"16-3-信息加密技术\"><a href=\"#16-3-信息加密技术\" class=\"headerlink\" title=\"16.3 信息加密技术\"></a>16.3 信息加密技术</h4><p>为了达到安全目标和防止安全攻击，ITU-T定义了一些安全服务的标准。这些服务中的每一个都是为了在维护安全目标时防止一个或多个攻击而设计的。</p>\n<p>实际完成安全目标需要一些技术手段，现今流行两种技术：一种是非常普通的<code>密码术</code>,另外一种是特殊的<code>隐写术</code>。</p>\n<p><br/></p>\n<ol>\n<li><p>密码术<br>有些安全服务可以使用密码术来(希腊起源的单词)意思是“秘密书写”实现。 但是，我们使用这个词是指为使消息安全并对攻击免疫而进行转换的科学和艺术。虽然在过去密码术只是指使用密钥进行消息的加密和解密，但如今它被定义成三种不同的机制：<code>对称密钥密码、非对称密钥密码和散列</code>。</p>\n</li>\n<li><p>隐写术<br>虽然本章和接下来的部分以密码术作为实现安全机制的一种技术，但另一种过去用于秘密通信的技术现在正在复苏，它就是隐写术。单词隐写术(起源于希腊语)意思是“掩饰书写”，而对应的密码术的意思是“秘密书写”。</p>\n</li>\n</ol>\n<p>密码术就是通过加密把消息中的内容隐藏起来，而隐写术是通过在消息上覆盖其他内容而隐藏消息，例如，我们安全圈中常见的图片写隐术。</p>\n<p><br/></p>\n<p>现在我们来看第一个安全目标机密性，他可以通过使用密码达到，密码术可以分成两大类：<code>对称密钥密码术和非对称密钥密码术</code>。</p>\n<h5 id=\"1-对称密钥密码术\"><a href=\"#1-对称密钥密码术\" class=\"headerlink\" title=\"(1) 对称密钥密码术\"></a>(1) 对称密钥密码术</h5><p>描述: 对称密钥密码术使用了同一个密钥（<code>这就是为什么它被称为对称的</code>）进行加密和解密，并且这个密钥可以用来进行双向通信，对称密钥密码术(<code>也称为保密密钥密码术</code>)。</p>\n<p>下图，显示了对称密钥密码术的基本思想:</p>\n<blockquote>\n<p>例如 Alice通过一个不安全的通道向Bob发送一则消息，假设一个敌手Eve在通道上简单地偷听，通过加密算法她不能理解消息的内容。<br>从 Alice 到 Bob 的原始消息称为明文，而通过通道发送的消息称为密文，为了从明文创建密文，Alice使用了一个加密算法和一个共享的密钥。<br>然后为了从密文创建明文，Bob使用了一个解密算法和一个相同的密钥，从而将加密数据解密成明文。</p>\n</blockquote>\n<p><img src=\"https://img.weiyigeek.top/2022/10/20230113161115.png\" alt=\"WeiyiGeek.对称密钥密码基本思想图\"></p>\n<p>注意，对称密钥加密对加密和解密使用一个密钥(密钥本身可以是一串数值)。此外， 加密算法和解密算法是互逆的。如果P为明文，C是密文，K是密钥，<code>加密算法Ek(x)从明文建立了密文，而解密算法Dk(x)从密文建立了明文</code>。</p>\n<p>我们推断Ek(x)和Dk(x)是互逆的, 如果对一个输入依次施加<code>Ek(x)和Dk(x)</code>, 它们的作用会相互抵消, 在此处 <code>Dk(Ek(x)) = Ek(Dk(x)) = x</code>。</p>\n<blockquote>\n<p>加密：C=Ek(P)<br>解密：P=Dk(C)</p>\n</blockquote>\n<p>值得注意的是，最好可以将加密和解密算法公开但是把共享密钥保密，此时Alice和Bob需要另外一个(安全的)通道来交换密钥，后面我们会讲解到非对称加密。</p>\n<p>简单的说明，我们可以把加密看作把消息锁进箱子，而解密可以看成打开箱子，在对称密钥加密中，用相同的密钥来锁和打开“箱子”，在下一节中我们会看到非对称密钥加密需要两个密钥，一个用于上锁而另一个则用于开锁。</p>\n<p>当前，我们可以把对称密钥密码分成两大类，即<code>传统对称密钥密码和现代对称密钥密码</code>。</p>\n<ul>\n<li>传统密码, 实现很简单，面向字符的密码对现在的标准而言是不安全的。</li>\n<li>现代密码, 是更为安全的复杂的面向位的密码。</li>\n</ul>\n<hr>\n<p><br/></p>\n<p><strong>1.传统对称密钥密码</strong><br>它是过去时了，但由于它是现代密码的构成要素，所以我们在这里对其进行简要讨论，通常我们把传统密码分为替换密码和移位密码。</p>\n<p><strong>1) 替换密码</strong>：用一个符号替换另一个符号, 如果在明文中的符号是字母表的字符，我们用另一个字符来代替，而替换密码主要可以分成<code>单字母密码</code>和<code>多字母密码</code>。</p>\n<blockquote>\n<p>例如，我们能用字母D代替字母A, 用字母Z代替字母T, 如果符号是数字（0〜9 ）, 我们能用7代替3, 用6代替2。</p>\n</blockquote>\n<ul>\n<li>1.1 单字面密码：此密码模式中，明文中相同的字符（或符号）在密文中用相同的字符（或符号）替换，与该字符在明文中的位置无关，明文和密文中的字符关系是一一对应的（你可以理解为电报机，两边都有密码本）, 最简单的单字母密码就是加法密码（或者移位密码）。<blockquote>\n<p>例如，在密码学中恺撒密码, 尤利乌斯 • 凯撒（Julius Caesar）与他的军官是使用密钥为3的加法密码进行通信的，加密算法可以解释成“向下移位key个字符”，而解密算法可以解释成“向上移位key个字符”，<code>即当偏移量是 3 的时候，所有的字母 A 将被替换成D, B 变成 E。</code>, 因此加法密码有时也称为凯撤密码。</p>\n</blockquote>\n</li>\n</ul>\n<p>下面，我将使用C语言进行凯撤密码代码演示（编程语言学得太多，做的笔记也是各种语言的编程示例）。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ch;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"请输入明文：\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((ch = getchar()) != <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'a'</span> &amp;&amp; ch &lt;= <span class=\"string\">'z'</span>)&#123;</span><br><span class=\"line\">          <span class=\"built_in\">putchar</span>(<span class=\"string\">'a'</span> + (ch - <span class=\"string\">'a'</span> + <span class=\"number\">3</span>) % <span class=\"number\">26</span>);   <span class=\"comment\">//这个是灵魂,利用取余来达到字母偏移，97 = a</span></span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">'A'</span> &amp;&amp; ch &lt;= <span class=\"string\">'Z'</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">putchar</span>(<span class=\"string\">'A'</span> + (ch - <span class=\"string\">'A'</span> + <span class=\"number\">3</span>) % <span class=\"number\">26</span>);  <span class=\"comment\">// 65 = A</span></span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"built_in\">putchar</span>(ch);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2019/1/20191011211531.png\" alt=\"WeiyiGeek.C语言实现的恺撒密码\" title=\"\" class=\"\">\n                <p>WeiyiGeek.C语言实现的恺撒密码</p>\n            </figure></p>\n<p><br/></p>\n<ul>\n<li>1.2 多字母密码: 在多字母密码中，字符的每一次出现都使用不同的替换码, 明文中字符和密文中字符的关系是一对多。<blockquote>\n<p>例如 <code>“a”</code> 既可以在文本开头加密成 <code>“D”</code> ，也可以在中间加密成 <code>“N”</code>多字母密码具有可以隐藏原有语言的字母频率的作用，即使通过单字母频率统计都无法破解密文。<br>为了更好地解释密钥的位置依赖性，我们先讨论一个叫做自动密钥密码的简单多字母密码, 在此密码中，密钥是一个子密流，在这个子密钥流中的每一个子密钥都用来对明文文本中的对应字符进行加密。<br>第一个子密是 Alice 和 Bob 事先同意并密设定的值，<br>第二个子密钥是明文中第一个字符的值(在0~25之间),<br>第三个是第二个明文字符的值以此类推。</p>\n</blockquote>\n</li>\n</ul>\n<p><img src=\"https://img.weiyigeek.top/2022/10/20230113164948.png\" alt=\"WeiyiGeek.多字母密码图\"></p>\n<p><br/></p>\n<p><strong>2) 移位密码</strong><br>移位密码不是用一个符号代替另一个符号，而是改变符号的位置, 明文第一个位置上的符号可能出现在密文的第十个位置上，而明文第八个位置上的符号可能出现在密文的第一个位置上, 简单的说，移位密码就是符号的重新排序。</p>\n<p>假设，Alice 需要向Bob发送消息<code>&quot;Enemy attacks tonight&quot;</code>，其加密解密过程如下图所示，注意我们在消息的末尾加上一个额外的字符(z)这样字符个数就是5的倍数。</p>\n<ul>\n<li>首先，第一张表是Alice通过一行一行写明文创造的，每一列都利用同一个密钥进行变更。</li>\n<li>然后，密文通过一列一列读第二张表得到。</li>\n<li>最后, Bob将这三步操作反向进行来进行解密, 他将密文一列一列写入第一张表格中对每列进行变更，然后一行一行读第二张表</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/10/20230113165757.png\" alt=\"WeiyiGeek.移位密码图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.移位密码图</p>\n            </figure>\n<p>注意，这里用来进行加密和解密的密钥是相同的，但是算法使用密钥的顺序是互逆的。</p>\n<p><br></p>\n<p><strong>3) 流密码&amp;分组密码</strong></p>\n<p>文献中将对称密码分为两大组：流密码和分组密码。</p>\n<ul>\n<li><p>流密码: 加密和解密都是一次只对一个符号（例如一个字符或位）进行，假如，我们有一个明文流 P ，一个密文流 C 和一个密钥流 K。</p>\n<blockquote>\n<p>C1 = Ek1(P1) / C2 = Ek2(P2)</p>\n</blockquote>\n</li>\n<li><p>分组密码: 在分组密码中，一组大小为m (m&gt;1 )的明文符号被加密在一起，创造一组同样大小的密文。</p>\n<blockquote>\n<p>基于定义，在一个分组密码中，整个分组是由一个单独的密钥进行加密，即使这个密钥由多个值构成。<br>在分组密码中，密文的分组取决于整个明文分组。</p>\n</blockquote>\n</li>\n<li><p>组合密码: 在实际操作中，每个明文分组是分别加密的，但是同时密钥流被用来对整个消息按照分组依次加密。</p>\n<blockquote>\n<p>即: 当我们看每一个单独分组时，该密码是分组密码，但是从整个消息来看，这是一个以分组为单位进行加密的流密码。<br>每个分组都使用一个不同的密钥进行加密，这些密钥是在加密进行之前或进行过程中产生的。</p>\n</blockquote>\n</li>\n</ul>\n<p><br/></p>\n<p><strong>2.现代对称密钥密码</strong><br>由于计算机技术发展进步，需要加密的信息已经不限于文本字符串、而有可能是数字、图表、音频或者视频数据。<br>在此种情况下，更方便的方法是把这些类型的数据转换成为比特流后再对其流进行加密，然后发送加密后的流，并且在进行处理时，每个字符会替换为8(或者16)位，这意味着字符数也变成原来的8(或者16)倍大, 将更多的字符混合可以提高安全性。</p>\n<ul>\n<li><p>2.1) 现代分组密码: 对称密钥现代分组密码对大小为 n 位的明文分组进行加密或对同样大小的密文分组进行解密。加密或解密算法使用《位的密钥,解密算法必须是加密算法的逆运算，并且两个操作必须使用相同的密钥，此样 Bob 可以检索到 Alice 发送的消息。</p>\n<blockquote>\n<p>当消息的长度小于n位时，消息后会加上补丁以使消息长度达到一个n位的分组; 如果消息长度超过n位，消息就会被分成几个长度为n 位的分组，如果必要，那么相应的补丁会添加到最后一个分组上, n 的常用数值是 64、128、256 和 512 位。</p>\n</blockquote>\n</li>\n<li><p>2.2) 现代流密码: 除了现代分组密码以外，我们也可以使用现代流密码，其区别类似于我们在之前部分提到的传统的流密码和分组密码之间的差别。</p>\n<blockquote>\n<p>在现代流密码中，加密和解密都是每次对r位进行，我们有一个表示为 P=pn…p2p1的明文流，一个表为C=cn…c2c1的密文流和一个表示为 K=kk 的密钥流在这里p都是长度为r位的词，加密算法是 C=E(k，p) 解密则表现为Pi=(k，c)。<br>所以说流密码比分组密码更快，它的硬件实现也更简单一些，当我们需要对二进制流加密并将加密后的流匀速传输时，流密码是一个更好的选择，其对于传输中发生的损坏也有更好的免疫能力。</p>\n</blockquote>\n</li>\n</ul>\n<p>扩展说明: 最简单也最安全的同步流密码是<code>吉尔伯特·弗纳姆</code>发明并取得专利的一次一密乱码， 一次一密乱码每次加密时使用随机选择的密钥流，加密和解密都使用单一的异或操作，基于异或操作的性质，加密和解密的算法互为逆运算。</p>\n<p><img src=\"https://img.weiyigeek.top/2022/10/20230116104049.png\" alt=\"WeiyiGeek.现代分组、流密码示例图\"></p>\n<p><br></p>\n<h5 id=\"2-非对称密钥密码术\"><a href=\"#2-非对称密钥密码术\" class=\"headerlink\" title=\"(2) 非对称密钥密码术\"></a>(2) 非对称密钥密码术</h5><p>描述: 对称与非对称加密实际上是相互相成，即可以取长补短，又可以相互补充，两者之间的差异:</p>\n<ul>\n<li>对称密钥在双方之间是共享的，而非对称密钥是个人独有(非共享的)。</li>\n<li>对称密钥对字符进行排列或替换，非对称密钥密码对数字进行操作。</li>\n<li>对称密钥对较长的信息加密，而非对称密钥针对少量信息加密（身份验证、数字签名）。</li>\n</ul>\n<p><strong>简单介绍</strong><br>描述: 非对称加密是一种加密方式，它使用一对被称为“公钥”和“私钥”的不同密钥。 公钥用于加密消息，而私钥用于解密消息。<br>此外，一个密钥可以用于加密消息，但却不能用于解密它。 因此只有拥有正确的秘钥（公钥或私钥）才能够解密它。</p>\n<p>简单的说，非对称密钥加密使用两个独立的密钥，即<code>公钥</code>与<code>私钥</code>, 你可将其理解为公钥是进行加密信息的并且是公开的(加锁🔒)，而私钥是解密信息并且是需要保密的(解锁)。</p>\n<p><strong>主要思想</strong><br>描述: 下图中展示了非对称密钥进行加密时的思想，<br>其关键点如下所示:</p>\n<ul>\n<li><p>明文/密文: 与对称密钥密码术不同，在非对称密钥密码术中，明文和密文被当作整数来对待, 在加密之前，消息必须被编码成一个整数（或一组整数），在解密之后整数（或一组整数）必须译码成消息, 非对称密钥密码术通常被用来加密或解密小段信息，例如对称密钥密码术中的密码密钥。</p>\n<blockquote>\n<p>换句话说，非对称性密钥密码术通常起到辅助目标而不是加密消息的作用，即非对称密钥密码术通常用来加密或解密小段信息。</p>\n</blockquote>\n</li>\n<li><p>加密/解密: 在非对称密钥中的加密/解密是作用在表示明文和密文的数字上的数学函数，例如，密文可以被看做C=f(Kpublic*p)，而明文可以看成P=g(Kprivate*c), 其中解密函数f只能用来加密，而解密函数g只能用来解密。</p>\n</li>\n</ul>\n<p><img src=\"https://img.weiyigeek.top/2022/10/20230116144030.png\" alt=\"WeiyiGeek.非对称加密原理思想图\"></p>\n<p><br/></p>\n<p><strong>RSA 非对称密码算法</strong><br>描述：虽然有几种非对称密钥系统，但是最常见的公钥算法之一是 RSA 密钥系统（以发明者 Ron Rivest、Shamir 和 Adleman 命名）。</p>\n<p>RSA 使用两个指数 e 和 d，其中 e 是公钥，d 是私钥。</p>\n<blockquote>\n<p>假设P表示明文、C表示密文，那么Alice使用<code>C = P^e mod n</code>的算法从明文P中得到密文 C ，Bob 通过 <code>P = C^d mod n</code> 来检索 Alice 发送的明文，在密钥生成的过程中创造了一个很大的数作为模数n。</p>\n</blockquote>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/10/20230116153045.png\" alt=\"WeiyiGeek.RSA生成密钥图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.RSA生成密钥图</p>\n            </figure>\n<ul>\n<li>范例1.</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/10/20230116162450.png\" alt=\"WeiyiGeek.RSA范例1图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.RSA范例1图</p>\n            </figure>\n<ul>\n<li>范例2.</li>\n<li><figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/10/20230116162729.png\" alt=\"WeiyiGeek.RSA范例2图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.RSA范例2图</p>\n            </figure>\n</li>\n</ul>\n<p><br/></p>\n<p><strong>RSA 的应用场景</strong><br>描述: 虽然RSA可以用于对实际消息进行加密和解密，但如果消息很长加密的速度会很慢。因此，RSA加密适用于短消息，以及特定用于数字签名以及其他不需要使用对称密钥来对较短信息进行加密的密码，同时RSA也适用于身份验证。</p>\n<p>实践示例.在Linux中生成一个rsa格式的公密钥文件并在主机间进行ssh登录认证。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.生成ras格式的公密钥</span></span><br><span class=\"line\">$ /usr/bin/ssh-keygen -t rsa -P </span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> <span class=\"built_in\">which</span> to save the key (/root/.ssh/id_rsa):    <span class=\"comment\"># 生成路径</span></span><br><span class=\"line\">Enter passphrase (empty <span class=\"keyword\">for</span> no passphrase):  <span class=\"comment\"># 密钥加密密码</span></span><br><span class=\"line\">Enter same passphrase again:                 <span class=\"comment\"># 密钥加密密码</span></span><br><span class=\"line\">Your identification has been saved <span class=\"keyword\">in</span> /root/.ssh/id_rsa.    <span class=\"comment\"># 私钥</span></span><br><span class=\"line\">Your public key has been saved <span class=\"keyword\">in</span> /root/.ssh/id_rsa.pub.    <span class=\"comment\"># 公钥</span></span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">30:f6:d7:2a:ac:56:eb:3f:fa:40:25:8d:90:96:68:cb root@localhost.localdomain</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.查看生成的共密钥文件</span></span><br><span class=\"line\">$ ls ~/.ssh/</span><br><span class=\"line\">id_rsa  id_rsa.pub known_hosts</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.配置A机器使用密钥登录到B机器，此时需要将公钥传到B机器的 authorized_keys 中。</span></span><br><span class=\"line\">$ sftp weiyigeek@10.10.10.250 -P 22</span><br><span class=\"line\">&gt; put /root/.ssh/id_rsa.pub</span><br><span class=\"line\">&gt; <span class=\"built_in\">exit</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ touch /root/.ssh/authorized_keys</span><br><span class=\"line\">$ cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br><span class=\"line\"><span class=\"comment\"># 或者执行如下命令</span></span><br><span class=\"line\">$ ssh-copy-id -i ~/.ssh/id_rsa.pub weiyigeek@10.10.10.250 -p 22</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.然后就可以在A机器上使用密钥进行登录到B机器中</span></span><br><span class=\"line\">$ ssh -i /root/.ssh/id_rsa weiyigeek@10.10.10.250 -p 22</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h4 id=\"16-4-其他安全技术\"><a href=\"#16-4-其他安全技术\" class=\"headerlink\" title=\"16.4 其他安全技术\"></a>16.4 其他安全技术</h4><p>到目前为止我们研究的密码系统提供了机密性，但在现代通信中还需要考虑安全的其他方面，比如完整性、消息和实体验证、不可抵赖性和密钥管理。</p>\n<h5 id=\"1-消息完整性\"><a href=\"#1-消息完整性\" class=\"headerlink\" title=\"(1) 消息完整性\"></a>(1) 消息完整性</h5><p>为了防止消息被篡改，我们在发送端/接收端进行验证信息完整性，通常使用如下方法一是消息和消息摘要，二是散列函数。</p>\n<p><strong>消息和消息摘要</strong></p>\n<blockquote>\n<p>保证文档完整性的一种方法是通过使用指纹，来确保文档没被篡改过。例如，为了保证消息完整性，消息要通过一个称为密码散列函数的算法，生成文件的消息和摘要，接收方验证比对该文件的信息消息和摘要，如果相同则确保信息未被串改过。</p>\n</blockquote>\n<p><br/></p>\n<p><strong>散列函数</strong></p>\n<blockquote>\n<p>将任意长度的消息加密成为固定长度的消息摘要, 所有的散列函数加密都需要从长度不一的消息中创造出长度固定的消息摘要, 建造这样一个功能最好由迭代完成，创造一个有着固定输入值并且可以使用必需的次数的函数，而不是使用输入值大小可变的散列函数。<br>这里的固定输人值函数指的是压缩函数，它将 n 位的一串字符缩并创造成 m 位的字符串，这里的 n 通常大于 m, 该方案被称为选代加密散列函数。</p>\n</blockquote>\n<p>罗恩·李维斯设计的几个列算法被称为<code>MD2、MD4和MD5</code>消息摘要, 当前最新的版本 MD5 是 MD4 的个加强版，它可以将消息分成长度为 512 位的分组并创造大小为 128 位的摘要, 然而事实证明大小为 128 位的消息要太小了以至于不能阻挡攻击（容易被碰撞检测）。</p>\n<p>因此，为了解决 MD 散列算法的不安全性，安全散列算法诞生了，安全散列算法(SHA)是由国家标准与技术研究所(NIST)研制的一个标准。SHA 经过了几个版本, 从 sha1、sha224、sha256、sha384、sha512（当前最新）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># md5 摘要信息</span></span><br><span class=\"line\">$ md5sum weiyigeek.png</span><br><span class=\"line\">51644c3d7174702529c5706ddf8db020 weiyigeek.png</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sha1sum 摘要信息</span></span><br><span class=\"line\">$ sha1sum weiyigeek.png</span><br><span class=\"line\">92ade000aed6c07b501a4c03374c0412bd33c716  weiyigeek.png</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sha256sum 摘要信息</span></span><br><span class=\"line\">$ sha256sum weiyigeek.png</span><br><span class=\"line\">07a041820e1dff2c48901828b2629275a301480adf804f55e63849849227ffb0  weiyigeek.png</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/10/20230116172552.png\" alt=\"WeiyiGeek.摘要信息与散列算法图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.摘要信息与散列算法图</p>\n            </figure>\n<p><br/></p>\n<h5 id=\"2-消息验证\"><a href=\"#2-消息验证\" class=\"headerlink\" title=\"(2) 消息验证\"></a>(2) 消息验证</h5><p>通过前面学习我们知道，消息摘要可以检验消息的完整性，保证消息没被篡改, 然而为了确保消息的完整性以及数据源的身份验证——这消息是真的来自于Alice而不是任何其他的人，我们需要在过程中包括一个Alice和Bob共享的秘密<code>（没有经过Eve）</code>, 我们需要创造一个消息验证码<code>（message authentication code, MAC）</code>。</p>\n<p>即MAC通过散列函数和密钥的组合来保证消息的完整性和消息验证。</p>\n<p><strong>消息验证流程:</strong></p>\n<ul>\n<li>1.Alice使用散列函数从密钥和消息连接中创建了一个MAC,即h(K+M）。</li>\n<li>2.它在不安全的通道上把消息和MAC发送给Bob。</li>\n<li>3.Bob把消息与MAC分开,然后从消息和密钥的连接中建立新的MAC。</li>\n<li>4.Bob比较新建的MAC和收到的MAC, 如果两个MAC匹配，那么消息就得到验证，并没有被敌手篡改过。</li>\n</ul>\n<p>温馨提示: HMAC国家标准与技术研究所(NIST)发布了新一代MAC标准, 通常称为<code>HMAC (散列消息 验证码)</code>, HMAC的实施比简化的MAC更复杂,因此此处不再多做累述。</p>\n<p><img src=\"https://img.weiyigeek.top/2022/10/20230116175204.png\" alt=\"WeiyiGeek.消息验证码图\"></p>\n<p><br></p>\n<h5 id=\"3-数字签名\"><a href=\"#3-数字签名\" class=\"headerlink\" title=\"(3) 数字签名\"></a>(3) 数字签名</h5><p>为了保证消息完整性和消息验证我们还可以使用的另一种方法是<code>数字签名</code>，数字签名使用一组公私钥。</p>\n<p>为了方便大家理解，此处在讲解数字签名前，对签名概念进行描述，当一个人在文档上签名就表示该文档是起源于他或他已同意的，签名对接收者来说是文档来自正确实体的证据。</p>\n<blockquote>\n<p>例如，当客户签了一张支票，银行就需要确信支票是客户签署的，而不是其他人。换言之，文档上的签名是身份验证的标记，它验证通过，文档就可信, 此处签名概念也可以看做是艺术家在画上的签名，艺术上的签名如果得到验证通过，那么这幅画通常也是可验证通过的。</p>\n</blockquote>\n<p><br/></p>\n<p><strong>究竟什么是数字签名?</strong></p>\n<blockquote>\n<p>数字签名是一种在数字环境中实现签名的方法（数字编码），其包含有用户的身份信息以及消息的原始数据，它可以确保发送方的身份，确认消息的完整性和原始性，以及消息的传输的安全性。 </p>\n</blockquote>\n<p><strong>数字签名的功能?</strong></p>\n<blockquote>\n<p>数字签名的功能主要有，保证发送者的身份、确认消息的完整性、确认消息抵达的可靠性、确认消息的原始性和保证消息的传输安全性。<br>简单的说就是, 验证所发送消息的真实性、完整性和可靠性。</p>\n</blockquote>\n<p><strong>那消息验证与数字签名的区别是什么?</strong></p>\n<blockquote>\n<p>MAC通过密钥来保护消息摘要，数字签名则使用一组公私钥.</p>\n</blockquote>\n<p><br/></p>\n<p>当Alice向Bob发送消息时，Bob需要检査发送者的身份，他需要确信消息来自Alice 而不是Eve(其他人), Bob可以要求Alice对信息进行电子签名。 </p>\n<p>换言之，一个电子签名能证明 Alice 作为消息发送者的身份, 我们把这种签名称为数字签名。</p>\n<p><strong>1.对比</strong></p>\n<ul>\n<li><p>(1)包括<br>普通签名是包含在文档里的，是文档的一部分。当我们写支票时，签名就在支票上，而不是一个分开的文档。但是当对文档进行数字签名时，我们把签名作为一个单独的文档来发送。</p>\n</li>\n<li><p>(2) 验证手段<br>两种签名的第二点不同在于签名验证的方法不同。对于普通签名，当接收者接收到一个文档时，他们比较文档上的签名与文件中的签名，如果相同，文档就是可信的。接收者需要有一个文件上签名的副本来作比较。对于数字签名，接收者接收到消息和签名，签名的副本不再保存，接收者需要应用验证技术来组合消息和签名，从而验证发送者的身份。</p>\n</li>\n<li><p>(3) 关系<br>对于普通签名来说，签名和文档之间通常是一对多的关系，一个人使用相同的签名签署许多文档。但是对于数字签名来说，签名和消息之间是一对一的关系。每条消息有它自己的签名。一条消息的数字签名不能用在另一条消息上。如果Bob从Alice处接收到两条消息，一条接着一条，他不能用第一条消息的签名去验证第二条。每条消息都有新的签名。</p>\n</li>\n<li><p>(4) 复制性<br>两种签名的另一点不同是称为复制性的特质。普通签名允许签署文档的副本与文件中的原始件有点不同。对于数字签名，就没有这样的不同，除非在文档上有时间因子(如时间 戳)。例如，假设Alice发送文档，指示Bob给Eve付款，如果Eve截获到文档和签名，她可以随后重复这些文档和签名，再次从Bob处得到钱。</p>\n</li>\n</ul>\n<p><br/></p>\n<p><strong>2.过程</strong><br>下图中显示了签名过程，发送者使用签名算法去签署消息，消息和签名被发送给接收者。接收者收到消息和签名，对收到的内容应用验证算法，如果结果是真，消息被接受，否则消息被拒绝。</p>\n<p>数字签名需要公钥系统，密码系统使用接收者的私钥和公钥，数字签名使用发送者的私钥和公钥，签署者用私钥签署，验证者用签署者的公钥验证。</p>\n<p><img src=\"https://img.weiyigeek.top/2023/1/20230117160220.png\" alt=\"WeiyiGeek.数字签名图\"></p>\n<p>我们能否用一个密钥（对称的）来签署和验证签名？</p>\n<blockquote>\n<p>答案是否定的，有以下几个原因。首先，密钥是只有双方知道的（这个例子中是Alice和Bob）因此如果 Alice 需要签署另一份文档，并发送给Ted, 那她就需要使用另外的密钥。<br>其次，我们将看到，为一个对话创建密钥涉及验证，而验证要使用数字签名, 因此，我们就遇到一个错误的循环。再次，Bob可以使用他和Alice间的密钥签署一个文档，把它发送给Tde,假装这是来自于Alice的。</p>\n</blockquote>\n<p><br/></p>\n<p><strong>3.签署摘要</strong><br>在处理较长消息时，非对称密钥密码系统的效率低下，而在数字签名系统中，消息通常较长，但我们不得不使用非对称密钥模式, 解决方法是签署消息的摘要，该摘要比消息本身要短得多。</p>\n<p>消息摘要与消息具有一对一的关系, 发送者可以签署消息摘要，接收者可以验证消息摘要，两者的效果是相同的。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230117161422.png\" alt=\"WeiyiGeek.签署摘要图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.签署摘要图</p>\n            </figure>\n<p><br></p>\n<p><strong>4.服务</strong><br>此小节讨论几个安全服务，包括消息机密性、消息验证、消息完整性和不可抵赖性。</p>\n<p>(1) 消息验证 ：一个安全的数字签名模式就像一个安全的普通签名(也就是说一个人不容易复制)一样 能提供消息验证，也称为数据源验证。Bob能验证Alice发送过来的信息是因为在验证过程中使用了Alice的公钥。Alice的公钥不能验证用Eve私钥签署的签名。</p>\n<p>(2) 消息完整性 ：如果我们签署消息或消息的摘要，消息的完整性就能被保护，因为如果消息改变了，我们就不能得到相同的摘要。当今的数字签名模式在签署和验证算法中使用了散列函数，这样更好地保护了消息的完整性。</p>\n<p>(3) 不可抵赖性 ：如果Alice签署了一个消息，然后否认它，Bob能否证明Alice实际上是签署了它呢？例如，如果Alice向银行(Bob)发送消息，要求从她的账户转10 000美元到Ted的账户，Alice能否事后否认她发送过这样的消息？使用我们目前为止介绍的模式，Bob可能会有一个问题。Bob必须先保存签名，然后用Alice的公钥去建立原始消息，去证明文件中的信息和新创建的消息是相同的。但这样并不可行，因为Alice这时可能已经更换了私钥或公钥。她也可以声称含有签名的文件是不可信的。</p>\n<p><strong>如何解决不可抵赖性问题?</strong></p>\n<blockquote>\n<p>解决方案是: 可信的第三方, 人们可以在他们之间建立可信中心, 在本章的后面，我们将看到受到信任的第三方可以解决有关安全服务和密钥交换的很多问题。<br>例如: 展示了一个可靠的第三方如何防止Alice抵赖她发过的消息，此时是不是感觉下述流程与网站CA以及服务端、客户端证书的颁发使用原理是一致的</p>\n</blockquote>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230118105104.png\" alt=\"WeiyiGeek.使用可信的第三方来达到不可抵赖性图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.使用可信的第三方来达到不可抵赖性图</p>\n            </figure>\n<p>(4) 机密性<br>数字签名不提供机密通信，如果机密性是需要的，那么消息和签名就要使用对称密钥密码或非对称密钥密码进行加密。</p>\n<p><br></p>\n<h5 id=\"4-实体验证\"><a href=\"#4-实体验证\" class=\"headerlink\" title=\"(4) 实体验证\"></a>(4) 实体验证</h5><p>主要用来使得一方证明另一方标识的一种技术，一个实体可以是<code>一个人、一个过程、一个客户端或一个服务器</code>。</p>\n<p>身份需要证明的实体称为<code>要求者</code>, 试图证明要求者身份的一方称为<code>证明者</code>。</p>\n<p>(1) 实体与消息验证<br>在消息验证（数据源验证）和实体验证间有两点区别：</p>\n<ul>\n<li>1).消息验证（或数据源验证）可能不会发生在实时系统中，而实体验证是会的。在前面的例子中，Alice发送一条消息给Bob。在Bob验证消息的时候，Alice可能在或可能不在通信的过程中。在另一方面，当Alice要求实体验证时，没有实际消息通信被涉及，直到Alice的身份被Bob验证。Alice需要在线参加这个过程。只有她的身份被验证后，消息才能在Alice和Bob间传输。当一则电子邮件从Alice到Bob,这时需要的是数据源验证；当Alice从自动取款机上取现金时，这时需要实体验证。</li>\n<li>2).消息验证简单地验证一则消息，这个过程需对每则新的消息重复。实体验证可在整个会话期间内验证要求者。</li>\n</ul>\n<p>(2) 验证分类<br>在实体验证中要求者必须向证明者标识自己,可以使用下面三种证据中的一种：</p>\n<ul>\n<li>1).所知道的: 只有要求者知道的秘密，证明者可以通过它来检査要求者, 例如：<code>密码、PIN码、密钥和私钥</code>。</li>\n<li>2).所拥有的: 证明要求者的身份, 例如：<code>护照、驾驶证、身份证、信用卡和智能卡</code>。</li>\n<li>3).所固有的: 要求者内在固有的生物特性, 例如：<code>普通签名、指纹、声音、面部特征、视网膜模型和手迹</code>。<br>在这部分我们只讨论第一种验证，所知道的, cu种验证通常用作远程（在线）实体验证。另外两个分类则通常在要求者个人出现时使用。</li>\n</ul>\n<p>(3) 密码认证<br>最简单且最古老的实体身份验证的方法是基于密码的身份验证，密码是要求者知道的一些东西。当用户需要访问系统资源时（登录），他就需要一个密码。每个用户都有一个用户标识，这是公开的；还有一个密码，这是私有的，然而密码在攻击面前很脆弱，密码可能被窃取、截获或猜出（<code>暴力破解</code>）等。</p>\n<p>(4) 挑战回应<br>在密码验证中，要求者通过展示他们知道秘密（密码）来证明他们的身份。但是要求者暴露了这个秘密，就容易受到敌手的截获。在挑战-回应身份验证中，要求者能证明他知道 秘密而不需要暴露它。换言之，要求者没有把秘密发送给证明者，但证明者或者有它，或者 能找到它。<br>在挑战-回应身份验证中，要求者证明他们知道秘密，而不需要把秘密暴露给证 明者。<br>挑战是一个随时间变化的值，如随机数或一个时间戳，它由证明者发送给要求者。要求者对挑战运用一个函数，把结果（称为响应）发送给证明者。响应表明要求者知道秘密。</p>\n<ul>\n<li>1) 使用对称密钥密码<br>有几种方法可以利用对称密钥加密来挑战-回应。这里共享的秘密是要求者和证明者都 知道的共享密钥。使用对称密钥密码的作用是对挑战应用加密算法。虽然达到这个手段有几种方法，我们只给出最简单的一种来给出思想，下图展示了第一种方法。</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230118115237.png\" alt=\"WeiyiGeek.单向对称密钥认证图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.单向对称密钥认证图</p>\n            </figure>\n<p>第一个消息不是挑战-回应的一部分，他只告知证明者要求者想要进行挑战。第二个 消息是挑战。Rb是证明者（Bob）为了挑战要求者随便挑选的随机数（一定数量的缩写）。要求者将随机数通过只有要求者和证明者知道的秘密共享密钥进行加密并将结果发送给证明者。证明者对消息进行解密，如果得到的随机数和证明者发送的相同，Alice就得到许可进入。<br>注意在这个过程中，要求者和证明者需要在过程中对他们使用的对称密钥保密。证明者也必须保存给要求者进行鉴别的随机数值直到返回回应。</p>\n<ul>\n<li>2) 使用非对称密钥密码<br>下图展示了这个方法。我们可以使用非对称密钥密码代替对称密钥密码进行实体验证。在这里秘密必须是要求者的密钥。要求者必须显示她拥有的私钥和所有人都有的公钥相关。也就是说，证明者必须使用要求者的公钥对挑战进行加密；然后要求者使用她的私钥对消息解密，对该挑战的回应就是解密后的消息。</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230118115300.png\" alt=\"WeiyiGeek.单向非对称密钥图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.单向非对称密钥图</p>\n            </figure>\n<ul>\n<li>3) 使用数字签名<br>实体验证也可以通过使用数字签名来达到。当数字签名用在实体验证时，要求者使用她的私钥进行签名。在第一种方法中，如图16-18所示，Bob使用明文挑战，然后Alice签署回应。</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230118115339.png\" alt=\"WeiyiGeek.单向数字签名验证图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.单向数字签名验证图</p>\n            </figure>\n<p><br/></p>\n<h5 id=\"5-密钥管理\"><a href=\"#5-密钥管理\" class=\"headerlink\" title=\"(5) 密钥管理\"></a>(5) 密钥管理</h5><p>此小节将讨论对称密钥密码术中的密钥和非对称密钥密码术中公钥是如何分配和维持的?</p>\n<p><strong>(1) 对称密钥分发</strong><br>在对大量消息进行加密时，对称密钥密码术的效率要比非对称密钥密码高，但是对称密钥密码需要在双方间共享(这是一个风险点)。</p>\n<p>至此，我们需要一种有效的方法来维护和分发密钥。</p>\n<ul>\n<li><p>方法1.密钥分发中心(KDC): 减少密钥的数量，每个人与KDC建立一个共享密钥，一个密钥建立在KDC和每个成员间。</p>\n</li>\n<li><p>方法2.多密钥分发中心: 当使用同一个密钥分发中心的人数增多时，系统就会变得难以管理并导致瓶颈，此时我们可以创建多个密钥分发中心，将其划分区域，并且每个区域有一个或者多个KDC(主备防止故障)</p>\n</li>\n<li><p>方法3.会话密钥: KDC为每个成员创建一个密钥，这个密钥只能在成员和KDC间使用，而不两个成员间，一个双方间的会话对称密钥只能被使用一次。</p>\n</li>\n</ul>\n<p><img src=\"https://img.weiyigeek.top/2023/1/20230118152016.png\" alt=\"WeiyiGeek.KDC创建会话密钥图\"></p>\n<p><br/></p>\n<p><strong>(2) 公钥分发</strong></p>\n<p>在非对称加密中公钥往往是共享的，每个人有权访问每个人的公钥，公钥对公众可用，当然公钥也像密钥一样需要进行分发。</p>\n<ul>\n<li><p>方法1.公开声明：即将公钥放在网站上供需要进行消息通信的客户使用，但是此种方式并不安全容易被伪造。</p>\n</li>\n<li><p>方法2.认证机构: 建立公钥认证，为了解决将公钥给需要的人并且不能假冒其公钥，此时就可以去认证机构(CA), 它是一个把公钥和实体捆绑在一起并处理认证的政府机构。</p>\n<blockquote>\n<p>其流程如下: 首先 CA 中心检查 Bob 的身份，之后 CA 向 Bob 要公钥, 并把它写在证书上, 为了防止证书本身被伪造, CA 用它的私钥签署证书, 然后 Bob 可以上载签署的证书, 任何需要 Bob 公钥的人就可以下载签署的证书, 并使用中心的公钥来抽取出 Bob 的公钥。</p>\n</blockquote>\n</li>\n<li><p>方法3.X509: CA可以解决公钥伪造的问题，但是它每个证书的格式可能都不一样，如果Alice想利用程序来自动下载不同的证书和不同人的消息摘要, 所以为了解决这个问题ITU设计了X.509，它是一个结构化描述证书的方法，它使用叫ASN.1的协议，此协议定义了计算机编程者一些熟悉的领域。</p>\n</li>\n</ul>\n<p><img src=\"https://img.weiyigeek.top/2023/1/20230118161049.png\" alt=\"WeiyiGeek.认证机构图\"></p>\n<p><br/></p>\n<h4 id=\"16-5-硬件防火墙\"><a href=\"#16-5-硬件防火墙\" class=\"headerlink\" title=\"16.5 硬件防火墙\"></a>16.5 硬件防火墙</h4><p>我们知道，在企业互联网边界上一定会有一台防护墙，来防止公网上的常规的一些黑客攻击，过滤有害信息或者说是指令，其是为了推进一些数据包而过滤其他数据包而设计的。</p>\n<p>例如，图中展示了企业中防火墙在网络拓扑中的位置。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230130094001.png\" alt=\"WeiyiGeek.防火墙图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.防火墙图</p>\n            </figure>\n<p>防火墙实现功能很多，可以做NAT转发，也可以过滤所有到来的目标为特定主机或服务器（例如HTTP）的数据包，也可以用来阻拦对组织内特定主机或服务的访问（ACL访问限制），防火墙通常分为<code>包过滤防火墙</code>和<code>代理防火墙</code>。</p>\n<h5 id=\"1-包过滤防火墙\"><a href=\"#1-包过滤防火墙\" class=\"headerlink\" title=\"(1) 包过滤防火墙\"></a>(1) 包过滤防火墙</h5><p>原理: 它可以基于网络层的信息和传输层的头部：源和目标IP地址，源和目标端口地址以及协议的种类（TCP或UDP）来推进或阻拦数据包。</p>\n<p>包过滤防火墙是一个使用过滤表单决定哪些数据包应该丢弃（不推进）的路由器, 如下图所示根据过滤表，以下数据包被过滤：<br>1）来自网络131.34.0.0的数据包被阻拦了（安全预防措施）。注意*号代表“任何”。<br>2）终点为任何国际TELNET服务器（端口23）的外发数据包被阻拦了。<br>3）到来的目标为内部主机194.78.20.8的数据包被阻拦了，该组织希望这个主机只用于内部使用。<br>4）终点为HTTP服务器（端口80）的外发数据包被阻拦了，该组织不希望雇员浏览因特网。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230130094521.png\" alt=\"WeiyiGeek.包过滤防火墙图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.包过滤防火墙图</p>\n            </figure>\n<p>总结:包过滤防火墙是基于网络层的有效信息和传输层头部（IP和TCP/UDP）建立的</p>\n<p><br/></p>\n<h5 id=\"2-代理防火墙\"><a href=\"#2-代理防火墙\" class=\"headerlink\" title=\"(2) 代理防火墙\"></a>(2) 代理防火墙</h5><p>目的：有时我们也需要基于消息自身携带的信息（应用层上）进行过滤，例如通过 VPN 代理访问。</p>\n<p>比如，假设一个组织想对其网页试试以下几条政策, 只有那些之前与本公司建立商业联系的因特网用户可以访问；其他用户必须阻拦。</p>\n<p>在此情况下，数据包过滤防火墙就不可行，因为它无法区分到达TCP端口80 （HTTP）的不同数据包，必须在应用层（通过URL）进行测试。</p>\n<p>一个解决措施是安装代理计算机（有时也称为应用网关），代理计算机位于客户计算机和公司计算机之间。当用户客户进程发送消息时，应用网关运行服务器进程来接收请求。服务器在应用层打开数据包并且查找这个请求是否合法。如果是，那么服务器运行客户端进程并将消息发给公司中真正的服务器，否则这个消息会被丢弃并且错误消息会发给外部用户。通过这个方法，外部用户的请求基于内容在应用层进行筛选。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2023/1/20230130094855.png\" alt=\"WeiyiGeek.代理防火墙图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.代理防火墙图</p>\n            </figure>","comments":true,"excerpt":"[TOC]计算机科学导论学习笔记第 5 部分 数据安全与人工智能此部分包含第15、16、17和18章，包含了计算机中传输的数据压缩(有损与无损)、网络数据在传输过程中如何保证其数据安全, 讨论计算理论，即哪些是可计算的，哪些是不可计算的，最后介绍当前热门的人工智能(AI)的观点，加深我们对计算机数据处理的的认识，为后续学习扩展基础认识。原文地址: ","categories":[{"name":"计算机基础知识","path":"api/categories/计算机基础知识.json"}],"tags":[{"name":"计算机科学导论","path":"api/tags/计算机科学导论.json"}]}