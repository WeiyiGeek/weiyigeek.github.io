{"title":"10.计算机科学导论之软件工程学习笔记","slug":"书籍笔记/计算机科学导论/10.计算机科学导论之软件工程学习笔记","date":"2022-06-07T08:35:30.000Z","updated":"2023-01-03T07:40:42.222Z","url":"2022/6-7-701.html","path":"api/articles/2022/6-7-701.html.json","covers":["https://img.weiyigeek.top/2022/8/image-20221001125936911.png","https://img.weiyigeek.top/2022/8/image-20221001131349980.png","https://img.weiyigeek.top/2022/8/image-20221001132613183.png","https://img.weiyigeek.top/2022/8/image-20221001133742301.png","https://img.weiyigeek.top/2022/8/image-20221001135918017.png","https://img.weiyigeek.top/2022/8/image-20221001142409996.png","https://img.weiyigeek.top/2022/8/image-20221001144106793.png"],"content":"<p>[TOC]</p>\n<h1 id=\"计算机科学导论学习笔记\"><a href=\"#计算机科学导论学习笔记\" class=\"headerlink\" title=\"计算机科学导论学习笔记\"></a>计算机科学导论学习笔记</h1><h2 id=\"第-4-部分-计算机软件与算法\"><a href=\"#第-4-部分-计算机软件与算法\" class=\"headerlink\" title=\"第 4 部分 计算机软件与算法\"></a>第 4 部分 计算机软件与算法</h2><p>此部分包含第<strong>7</strong>、<strong>8</strong>、<strong>9</strong>、<strong>10</strong>章，包含了计算机操作系统、问题求解算法、程序设计语言之旅、软件工程等相关知识，加深我们对开发的认识，为后续开发打下一个基础。</p>\n<a id=\"more\"></a>\n<h3 id=\"第-10-章-软件工程\"><a href=\"#第-10-章-软件工程\" class=\"headerlink\" title=\"第 10 章 软件工程\"></a>第 10 章 软件工程</h3><p>此节介绍软件工程概念以及软件生命周期为起点，以及开发过程中的两个模型（<code>瀑布模型和增量模型</code>）。</p>\n<p>在1969年第一届国际软件工程会议，恰巧是第一台计算机诞生30年之际，定义了软件工程是建立在利用合理的工程方法和原则来获得在真实机器上工作的可靠软件。</p>\n<h4 id=\"10-1-软件生命周期\"><a href=\"#10-1-软件生命周期\" class=\"headerlink\" title=\"10.1 软件生命周期\"></a>10.1 软件生命周期</h4><h5 id=\"1-生命周期概念\"><a href=\"#1-生命周期概念\" class=\"headerlink\" title=\"(1) 生命周期概念\"></a>(1) 生命周期概念</h5><p>描述：软件生命周期是软件工程的基本概念，软件和其他的产品一样，周期性地重复着一些阶段。</p>\n<ul>\n<li><p>开发：由开发者小组根据设计要求开发软件。</p>\n</li>\n<li><p>使用和修改：由于在软件使用中发现错误、设计改变规则或公司本身发生变化。</p>\n</li>\n<li><p>过时：因效率低下、语言过时、 用户需求的重大变化或其他因素而导致软件失去它的有效性。</p>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20221001125936911.png\" alt=\"WeiyiGeek.软件生命周期\" title=\"\" class=\"\">\n                <p>WeiyiGeek.软件生命周期</p>\n            </figure>\n<h5 id=\"2-开发过程模型\"><a href=\"#2-开发过程模型\" class=\"headerlink\" title=\"(2) 开发过程模型\"></a>(2) 开发过程模型</h5><p>在软件生命周期中，开发过程包括4个阶段：<code>分析、设计、实现和测试</code>，并且有多种模型，此处讨论最常见的两种模型，即<code>瀑布模型和增量模型</code>。</p>\n<p><strong>瀑布模型</strong>: 它是一种非常流行的模型，开发过程只有一个方向的流动。意味则前一个阶段结束，才能开始后面一个阶段。</p>\n<blockquote>\n<p>例如，整个工程的分析阶段应该在设计阶段开始前完成，整个设计阶段应该在实现阶段开始前完成。</p>\n<p>优点：在下一个阶段开始前每个阶段已经完成，在测试阶段整个系统整体功能已经完成。</p>\n<p>缺点：问题定位难，如果过程中中有一部分有问题，则必须检查整个过程。</p>\n</blockquote>\n<p><strong>增量模型</strong>：它是企业中最常用的模型，由开发者根据初始需求进行开发，后续在由需求是在进行开发，这就是我们常说的模块化开发。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20221001131349980.png\" alt=\"WeiyiGeek.瀑布模型与增量模型\" title=\"\" class=\"\">\n                <p>WeiyiGeek.瀑布模型与增量模型</p>\n            </figure>\n<h4 id=\"10-2-分析阶段\"><a href=\"#10-2-分析阶段\" class=\"headerlink\" title=\"10.2 分析阶段\"></a>10.2 分析阶段</h4><p>整个开发过程始于分析阶段，此阶段生<code>成规格说明文档</code>，即说明了<code>软件要做什么</code>，它使用两种独立的方法，其依赖于实现阶段是使用 <code>过程编程还是对象编程</code></p>\n<h5 id=\"1-面向过程分析\"><a href=\"#1-面向过程分析\" class=\"headerlink\" title=\"(1) 面向过程分析\"></a>(1) 面向过程分析</h5><p><strong>1) 数据流图</strong>: 显示了系统中数据的流动，使用4种符号来表示。</p>\n<blockquote>\n<p>方形盒: 表示数据源或数据目的<br>带圆角的矩形: 表示过程（数据上的动作）<br>末端开口的矩形: 表示数据存储的地方<br>箭头表示: 数据流</p>\n</blockquote>\n<p><strong>2) 实体图</strong>：实体关系图是分析阶段使用的另一个建模工具，此图主要用于数据库的设计。</p>\n<p><strong>3) 状态图</strong>:  提供了另外一种有用的工具，其通常用于当系统中的实体状态在响应事件时将会改变的情况下。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20221001132613183.png\" alt=\"WeiyiGeek.数据流图与状态图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.数据流图与状态图</p>\n            </figure>\n<h5 id=\"2-面向过程分析\"><a href=\"#2-面向过程分析\" class=\"headerlink\" title=\"(2) 面向过程分析\"></a>(2) 面向过程分析</h5><p><strong>1) 用例图</strong>: 系统用户视图，它显示了用户与系统间的交互，常常使用四种组件表示，即<code>系统、用例、动作者和关系</code>。</p>\n<blockquote>\n<p>系统（用矩形表示）执行功能。<br>系统中的行动（圆角的矩形表示）由用例显示。<br>动作者：是使用系统的某人或某事。<br>关系：使用线条联系动作者与行动，但它们并不需要表示人类。</p>\n</blockquote>\n<p><strong>2) 类图</strong>：经过分析下一步就是创建系统类图，主要是考虑系统涉及的实体。</p>\n<p><strong>3) 状态图</strong>：在类图完成之后，就可以为类图中的每个类准备状态图，其与面向过程分析中的状态图相同。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20221001133742301.png\" alt=\"WeiyiGeek.用例图与类图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.用例图与类图</p>\n            </figure>\n<h4 id=\"10-3-设计阶段\"><a href=\"#10-3-设计阶段\" class=\"headerlink\" title=\"10.3 设计阶段\"></a>10.3 设计阶段</h4><p>设计阶段定义系统如何完成在分析阶段所定义的需求，<code>即到底怎么做</code>，此阶段中系统所有的组成部分都被定义。</p>\n<h5 id=\"1-面向过程设计\"><a href=\"#1-面向过程设计\" class=\"headerlink\" title=\"(1) 面向过程设计\"></a>(1) 面向过程设计</h5><p>在面向过程设计中，即要设计过程也要设计数据，并且整个系统被<code>分解成一组过程或模块</code>。</p>\n<p><strong>1) 结构图</strong>：主要用于说明模块间的关系，例如图中的 10.8。</p>\n<p><strong>2) 模块化</strong>：将大项目分解成较小的部分，以便能够容易理解和处理，即意味着将大程序分解成能互相通信的小程序，通常在代码开发时要求<code>低耦合</code>和<code>高内聚</code>。</p>\n<ul>\n<li><p>(低)耦合：耦合是对两个模块互相绑定紧密程度的度量，通常为了让模块尽可能地独立，我们需要让其松散耦合。</p>\n<blockquote>\n<p>例如，A模块与B模块存在依赖关系，当A模块发生改变时，B模块仍然可以正常工作，那么就认为A与B是低耦合的。</p>\n<p>优点：松散耦合的模块更可能被重用，不容易在相关模块中产生错误，并且在系统需要修改时，允许我们只修改需要改变的模块，而不会影响到其它模块。<br>开发原则：软件系统中模块间的耦合必须最小化。</p>\n</blockquote>\n</li>\n<li><p>(高)内聚：内聚是程序（<code>模块内部</code>）中处理过程相关紧密程度的度量，通常需要尽可能最大化软件系统模块间的内聚。</p>\n<blockquote>\n<p>例如，系统中存在A、B两个模块进行交互，如果修改了A模块，不影响B模块的工作，反之，修改了B模块也不影响A模块工作，即A、B模块都各司其职，那么我们就认为A模块有足够的内聚。</p>\n<p>优点：我认为高内聚的模块是实现低耦合的前提，因为一个模块实现某一个功能不依赖于其他模块，从而提高程序的可靠性。<br>开发原则：软件系统模块间的内聚必须最大化。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"2-面向对象设计\"><a href=\"#2-面向对象设计\" class=\"headerlink\" title=\"(2) 面向对象设计\"></a>(2) 面向对象设计</h5><p>在面向对象设计中设计阶段，通过详细描述类（Class）的细节，例举出其对象的属性以及方法动作的细节。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20221001135918017.png\" alt=\"WeiyiGeek.结构图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.结构图</p>\n            </figure>\n<h4 id=\"10-4-实现阶段\"><a href=\"#10-4-实现阶段\" class=\"headerlink\" title=\"10.4 实现阶段\"></a>10.4 实现阶段</h4><p>此阶段在瀑布模型中，通常是在设计阶段完成之后，其主要为面向过程设计中的模块<code>编写程序</code>或者<code>编写程序单元</code>，换言之，根据需求开始写代码🤓。</p>\n<h5 id=\"1-语言选择\"><a href=\"#1-语言选择\" class=\"headerlink\" title=\"(1) 语言选择\"></a>(1) 语言选择</h5><p>通常在企业中都有相应的技术开发栈，例如 C 系列、Java 系（当前最多）、Go 系（次之）、Python 系，对应不同的开发需求、侧重点选择一种开发语言，使得开发周期变短。</p>\n<h5 id=\"2-软件质量\"><a href=\"#2-软件质量\" class=\"headerlink\" title=\"(2) 软件质量\"></a>(2) 软件质量</h5><p>高质量的软件系统是一个能满足用户需求、符合组织操作标准和能高效运行在为其开发的硬件上的一个软件。</p>\n<p>软件质量能够划分成三个广义的度量∶<code>可操作性、可维护性和可迁移性</code>。</p>\n<ul>\n<li>1) 可操作性：涉及系统的基本操作，具有有多种度量方法<code>准确性、高效性、可靠性、安全、及时性和适用性</code>。</li>\n<li>2) 可维护性：以保持系统正常运行并及时更新为参照，具有有多种度量方法<code>可变性、可修正性、适应性，可测试性</code></li>\n<li>3) 可迁移性：指把数据和（或）系统从一个平台移动到另一个平台并重用代码的能力，有有多种度量方法<code>重用性、互用性、可一移植性</code></li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20221001142409996.png\" alt=\"WeiyiGeek.软件质量\" title=\"\" class=\"\">\n                <p>WeiyiGeek.软件质量</p>\n            </figure>\n<h4 id=\"10-5-测试阶段\"><a href=\"#10-5-测试阶段\" class=\"headerlink\" title=\"10.5 测试阶段\"></a>10.5 测试阶段</h4><p>此阶段主要是在上线前尽可能发现错误，意味着良好的测试策略能发现最多的错误，通常有白盒测试与黑盒测试两种。</p>\n<h5 id=\"1-白盒测试\"><a href=\"#1-白盒测试\" class=\"headerlink\" title=\"(1) 白盒测试\"></a>(1) 白盒测试</h5><p>或叫玻璃盒测试，即内部开发测试人员，知道或者拿到<code>软件分析文档，设计文档，以及有开发的源程序代码</code>, 程序就像玻璃盒子，其中的每件事都是可见的。</p>\n<p>白盒测试需要保证至少满足下面4条标准:</p>\n<ul>\n<li><p>每个模块中的所有独立的路径至少被测试过一次。</p>\n</li>\n<li><p>所有的判断结构（两路的或多路的）每个分支都被测试。</p>\n</li>\n<li><p>每个循环被测试。</p>\n</li>\n<li><p>所有数据结构都被测试。</p>\n</li>\n</ul>\n<p><img src=\"https://img.weiyigeek.top/2022/8/image-20221001144106793.png\" alt=\"WeiyiGeek.软件测试与基本测试示例\"></p>\n<p>白盒测试有多种测试方法，其中最常见是<code>基本路径测试</code>和<code>控制结构测试(逻辑测试)</code>。</p>\n<p><strong>基本路径测试</strong>：由Tom McCabe提出的，它是一种软件中每条语句至少被执行一次的方法。</p>\n<p><strong>控制结构测试</strong>：它比基本路径测试更容易理解并且包含基本路径测试，例如下方不同类的测试。</p>\n<ul>\n<li>条件测试：用来检査是否所有的条件都被正确设置。</li>\n<li>数据流测试：用来检査被用在赋值语句左边的变量的值。</li>\n<li>循环测试：用来检查循环的正确性。</li>\n</ul>\n<h5 id=\"2-黑盒测试\"><a href=\"#2-黑盒测试\" class=\"headerlink\" title=\"(2) 黑盒测试\"></a>(2) 黑盒测试</h5><p>即我们在不知道其程序分析文档、设计文档以及拿不到程序源代码时进行的测试，通常在业务上线前需要进行黑盒的安全渗透测试，换言之，程序就像看不见内部的黑盒。</p>\n<p><strong>穷尽测试</strong>：在输入域（路径、输入、传参出）中的使用所有可能的值去测试软件。</p>\n<p><strong>随机测试</strong>：在输入域的值的子集来测试，子集选择的方式(值在输入域上的分布)是非常重要的。</p>\n<p><strong>边界值测试</strong>：当遇到边界值时错误经常发生，即我们常说的缓冲区溢出，可能会对代码程序致命的错误。</p>\n<h4 id=\"10-6-软件文档\"><a href=\"#10-6-软件文档\" class=\"headerlink\" title=\"10.6 软件文档\"></a>10.6 软件文档</h4><p>企业内部中在开发初始阶段便有许多开发设计文档，随着业务的迭代也有自己的Bug管理文档，所以说软件的正确使用和有效维护离不开文档，所以文档是一个持续过程。</p>\n<p>通常软件有三种独立的文档：<code>用户文档、系统文档和技术文档</code>。</p>\n<p><strong>用户文档</strong>：即用户手册的文档，它告诉用户如何一步步地使用此软件。</p>\n<p><strong>系统文档</strong>：即定义软件本身，其目的是为了让原始开发人员之外的人能够维护和修改软件包（接盘侠 😳）。</p>\n<blockquote>\n<p>在分析阶段，收集的信息应该仔细地用文档记录</p>\n<p>在设计阶段，最终版本中用到的工具必须记录在文档中。</p>\n<p>在实现阶段，代码的每个模块都应记录在文档中。</p>\n<p>在测试阶段，对最终产品使用的每种测试，连同它的结果都要记录在文档中。</p>\n</blockquote>\n<p><strong>技术文档</strong>: 即软件系统的安装部署，通常由专业的技术人员进行参考。</p>\n","comments":true,"excerpt":"[TOC]计算机科学导论学习笔记第 4 部分 计算机软件与算法此部分包含第7、8、9、10章，包含了计算机操作系统、问题求解算法、程序设计语言之旅、软件工程等相关知识，加深我们对开发的认识，为后续开发打下一个基础。","categories":[{"name":"计算机基础知识","path":"api/categories/计算机基础知识.json"}],"tags":[{"name":"计算机科学导论","path":"api/tags/计算机科学导论.json"}]}