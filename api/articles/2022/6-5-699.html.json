{"title":"8.计算机科学导论之数据算法学习笔记","slug":"书籍笔记/计算机科学导论/8.计算机科学导论之数据算法学习笔记","date":"2022-06-05T08:35:30.000Z","updated":"2023-01-03T08:10:22.724Z","url":"2022/6-5-699.html","path":"api/articles/2022/6-5-699.html.json","covers":["https://img.weiyigeek.top/2022/8/image-20220923113535737.png","https://img.weiyigeek.top/2022/8/image-20220923123133836.png","https://img.weiyigeek.top/2022/8/image-20220923141306529.png","https://img.weiyigeek.top/2022/8/image-20220923165004873.png","https://img.weiyigeek.top/2022/8/image-20220926114111960.png","https://img.weiyigeek.top/2022/8/image-20220926151604850.png","https://img.weiyigeek.top/2022/8/bubbleSort.gif","https://img.weiyigeek.top/2022/8/selectionSort.gif","https://img.weiyigeek.top/2022/8/insertionSort.gif","https://img.weiyigeek.top/2022/8/image-20220926153614560.png","https://img.weiyigeek.top/2022/8/image-20220926165843724.png","https://img.weiyigeek.top/2022/8/image-20220926223108015.png","https://img.weiyigeek.top/2022/8/image-20220926170836950.png","https://img.weiyigeek.top/2022/8/image-20220926220100641.png"],"content":"<p>[TOC]</p>\n<h1 id=\"计算机科学导论学习笔记\"><a href=\"#计算机科学导论学习笔记\" class=\"headerlink\" title=\"计算机科学导论学习笔记\"></a>计算机科学导论学习笔记</h1><h2 id=\"第-4-部分-计算机软件与算法\"><a href=\"#第-4-部分-计算机软件与算法\" class=\"headerlink\" title=\"第 4 部分 计算机软件与算法\"></a>第 4 部分 计算机软件与算法</h2><p>此部分包含第<strong>7</strong>、<strong>8</strong>、<strong>9</strong>、<strong>10</strong>章，包含了计算机操作系统、问题求解算法、程序设计语言之旅、软件工程等相关知识，加深我们对开发的认识，为后续开发打下一个基础。</p>\n<a id=\"more\"></a>\n<h3 id=\"第-8-章-数据算法\"><a href=\"#第-8-章-数据算法\" class=\"headerlink\" title=\"第 8 章.数据算法\"></a>第 8 章.数据算法</h3><p>数据算法（<code>分步解决问题的过程</code>）是学习计算机编程开发的核心，只有在了解数据算法的前提下才能，做出更好、更高效的软件，在今后的学习中我会针对《数据结构与算法》进行详细学习，此节先简单的作为一个入门了解。</p>\n<h4 id=\"8-1-算法概念\"><a href=\"#8-1-算法概念\" class=\"headerlink\" title=\"8.1 算法概念\"></a>8.1 算法概念</h4><h5 id=\"1-非标准定义\"><a href=\"#1-非标准定义\" class=\"headerlink\" title=\"(1) 非标准定义\"></a>(1) 非标准定义</h5><p>算法是一种<code>逐步解决问题或完成任务</code>的方法，按照这种定义算法完全独立于计算机系统。</p>\n<p>例如，算法在接收一组输入数据，同时产生一组输出数据。</p>\n<p>例如，使用求最大值算法来求得输入五个数中的最大值。</p>\n<blockquote>\n<p>输入：算法需输入一组5个整数（12 、8、 13、 9、 11）。</p>\n<p>过程：使用在算法中定义的 Largest 变量，依次对比输入的整数，将比对的最大值赋予给它。</p>\n<p>输出：算法执行完毕输出 Largest 值（13）。</p>\n</blockquote>\n<p><img src=\"https://img.weiyigeek.top/2022/8/image-20220923113535737.png\" alt=\"WeiyiGeek.算法定义示例\"></p>\n<p><strong>细化</strong></p>\n<p>为了算法能在所有程序中应用则需要对其进行细化，实际上示例算法细分为两步。</p>\n<ul>\n<li>步骤01.将Lagest遍历初始化为负无穷。</li>\n<li>步骤02.如果第1数值大于Lagest，则将其赋予给Lagest变量。</li>\n<li><p>步骤03.如果第2数值大于Lagest，则将其赋予给Lagest变量。</p>\n</li>\n<li><p>步骤04.如果第3数值大于Lagest，则将其赋予给Lagest变量。</p>\n</li>\n<li><p>步骤05.如果第4数值大于Lagest，则将其赋予给Lagest变量。</p>\n</li>\n<li><p>步骤06.如果第5数值大于Lagest，则将其赋予给Lagest变量。</p>\n</li>\n</ul>\n<p><strong>泛化</strong></p>\n<p>为了算法不仅仅在简单的几个数之间最大值而是从 n 个正数中找到最大值，为了提高效率以及减少编写步骤，我们可以在计算机循环此步骤n次，然后再将求得的最大值输出。</p>\n<p><img src=\"https://img.weiyigeek.top/2022/8/image-20220923123133836.png\" alt=\"WeiyiGeek.细化与泛化\"></p>\n<h5 id=\"2-更正式定义\"><a href=\"#2-更正式定义\" class=\"headerlink\" title=\"(2) 更正式定义\"></a>(2) 更正式定义</h5><p>算法：它是一组明确步骤的有序集合，它产生结果并在有限的时间内终止。</p>\n<p>定义良好：算法必须是一组定义良好且有序的指令集合。</p>\n<p>明确步骤：算法的每一步都必须有清晰、明白的定义，不能出现一个操作符有多重意思。</p>\n<p>产生结果：算法必须产生结果，否则该算法就没有意义。</p>\n<p>在有限时间内终止: 算法必有有终止条件，不能无限循环下去。</p>\n<h4 id=\"8-2-算法结构\"><a href=\"#8-2-算法结构\" class=\"headerlink\" title=\"8.2 算法结构\"></a>8.2 算法结构</h4><p>结构化程序或算法定义了<code>顺序、判断（选择）和循环</code>三种基础结构，仅仅使用这三种结构就可以使程序或算法容易<code>理解、调试或修改</code>。</p>\n<ul>\n<li><p>顺序结构：最简单的指令结构， 算法（<code>最终是程序</code>）都是指令序列，顾名思义按顺序执行。</p>\n</li>\n<li><p>判断(选择)结构: 条件指令结构，当算法程序指令中需要检测一个条件<code>满足时</code>或者<code>不满足时</code>从而分别执行不同的操作。</p>\n</li>\n<li>循环(重复)结构：当有相同指令需要重复执行时，使用循环(重复)结构来解决。</li>\n</ul>\n<hr>\n<h4 id=\"8-3-算法表示\"><a href=\"#8-3-算法表示\" class=\"headerlink\" title=\"8.3 算法表示\"></a>8.3 算法表示</h4><p>当下，常常使用<code>图示、UML以及伪代码</code>等几种表示算法。</p>\n<h5 id=\"1-UML\"><a href=\"#1-UML\" class=\"headerlink\" title=\"(1) UML\"></a>(1) UML</h5><p><strong>统一建模语言（UML）</strong>: 是算法的图形表示法，它使用“大图”的形式掩盖了算法的所有细节，它只显示算法从<code>开始到结束</code>的整个流程。</p>\n<p>例如，使用UML来表示算法的三种基本结构。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220923141306529.png\" alt=\"WeiyiGeek.UML表示三种基本结构\" title=\"\" class=\"\">\n                <p>WeiyiGeek.UML表示三种基本结构</p>\n            </figure>\n<p>温馨提示：UML具有许多灵活性，如果在假的部分没有操作，那么判断结构就能简化</p>\n<h5 id=\"2-伪代码\"><a href=\"#2-伪代码\" class=\"headerlink\" title=\"(2) 伪代码\"></a>(2) 伪代码</h5><p><strong>伪代码（pseudo code）</strong>：是算法的一种类似英语的表示法，当下并没有伪代码的标准，有些人使用得过细，有些人则使用得过粗。有些人用一种很像英语的代码，有些人则用和Pascal编程语言相似的语法。</p>\n<p>我认为只要能简要介绍问题解决的实现即可，至于采用那种由自己水平而定。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220923165004873.png\" alt=\"WeiyiGeek.伪代码表示三种结构\" title=\"\" class=\"\">\n                <p>WeiyiGeek.伪代码表示三种结构</p>\n            </figure>\n<p>例如，使用伪代码来表示算法的三种基本结构。</p>\n<hr>\n<h4 id=\"8-4-基本算法\"><a href=\"#8-4-基本算法\" class=\"headerlink\" title=\"8.4 基本算法\"></a>8.4 基本算法</h4><h5 id=\"1-求和乘积\"><a href=\"#1-求和乘积\" class=\"headerlink\" title=\"(1) 求和乘积\"></a>(1) 求和乘积</h5><p>计算机科学中常用的算计就是求和与乘积。</p>\n<ul>\n<li>求和：实现两个或者多个数值相加。</li>\n<li>乘积：实现讲个或者多个数值相乘。</li>\n</ul>\n<p><img src=\"https://img.weiyigeek.top/2022/8/image-20220926114111960.png\" alt=\"WeiyiGeek.求和与乘积算法\"></p>\n<p>此处以Javascript语言为例进行演示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义</span></span><br><span class=\"line\">var a = 2;</span><br><span class=\"line\">var b = 6;</span><br><span class=\"line\"><span class=\"comment\"># 相加步骤</span></span><br><span class=\"line\">a + b</span><br><span class=\"line\"><span class=\"comment\"># 结果 </span></span><br><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<p>例如，求<code>x^n</code>次方值</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义：</span></span><br><span class=\"line\">var x = 2;</span><br><span class=\"line\">var n = 3;</span><br><span class=\"line\">var result = 1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 阶乘步骤</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ( n &gt; 0 ) &#123;</span><br><span class=\"line\"> result *= x </span><br><span class=\"line\"> n--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-求最值\"><a href=\"#2-求最值\" class=\"headerlink\" title=\"(2) 求最值\"></a>(2) 求最值</h5><p>即通常求得一组数据中的最大值（最小值）算法，即判断两个整数的最大值或者最小值。</p>\n<p>此处以JavaScript语言为例进行演示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义</span></span><br><span class=\"line\">var x = 2;</span><br><span class=\"line\">var y = 3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 最值与最小值步骤</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> max (x,y) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">return</span> x &gt; y ? x:y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> min (x,y) &#123;</span><br><span class=\"line\"> <span class=\"built_in\">return</span> x &lt; y ? x:y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\">max(x,y)</span><br><span class=\"line\">3</span><br><span class=\"line\">min (x,y)</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-排序算法\"><a href=\"#3-排序算法\" class=\"headerlink\" title=\"(3) 排序算法\"></a>(3) 排序算法</h5><p>计算机科学中最普遍的应用是排序，它根据数据的值对其按顺序排列。其中最常用、最简单、效率最低的三种排序算法<code>选择排序、冒泡排序、插入排序</code>，他们也是当今计算机科学中使用快速排序的基础。</p>\n<p>当然除了上述简单的算法外，还有更高级、高效的排序算法，例如<code>快速排序、堆排序、Shell排序、桶排序、合并排序、基排序</code>等，但此章节不做详细讲解，在后续深入学习数据结构与算法时在详细说明。</p>\n<p>当前程序中为了决定哪种算法更适合特定的程序，需要一种叫做算法复杂度的度量，例如冒泡排序的复杂度为<code>O(n)</code>。</p>\n<p>平方阶 (O(n2)) 排序各类简单排序：<code>直接插入、直接选择和冒泡排序</code>。</p>\n<p>线性对数阶 (O(nlog2n)) 排序 : <code>快速排序、堆排序和归并排序</code>；</p>\n<p>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数: <code>希尔排序</code>;</p>\n<p>线性阶 (O(n)) 排序：<code>基数排序，此外还有桶、箱排序</code>。</p>\n<p>稳定的排序算法：<code>冒泡排序、插入排序、归并排序和基数排序</code>。</p>\n<p>不是稳定的排序算法：<code>选择排序、快速排序、希尔排序、堆排序</code>。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220926151604850.png\" alt=\"image-20220926151604850\" title=\"\" class=\"\">\n                <p>image-20220926151604850</p>\n            </figure>\n<p>名词解释：</p>\n<ul>\n<li>n：数据规模.</li>\n<li>k：”桶”的个数.</li>\n<li>In-place：占用常数内存，不占用额外内存.</li>\n<li>Out-place：占用额外内存.</li>\n<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同.</li>\n</ul>\n<hr>\n<p><strong>1.冒泡排序</strong>(Bubble Sort)：其也是使用两重循环，外层循环每迭代一次，内层循环每次迭代则将某一原数置于顶部（头部）。</p>\n<ul>\n<li><p>算法步骤:</p>\n<blockquote>\n<p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>\n<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>\n<p>针对所有的元素重复以上的步骤，除了最后一个。</p>\n<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>\n</blockquote>\n</li>\n<li><p>时间复杂度：O(n)</p>\n</li>\n<li><p>算法稳定性: 是一种稳定排序算法。</p>\n</li>\n<li><p>排序选择：当n值较大时，冒泡排序比选择排序快。</p>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/bubbleSort.gif\" alt=\"WeiyiGeek.冒泡p排序示例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.冒泡p排序示例</p>\n            </figure>\n<ul>\n<li>代码示例：此处以Go语言进行简单演示。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//* 冒泡排序 */</span><br><span class=\"line\">//* 1. 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换 */</span><br><span class=\"line\">//* 2. 对所有元素均重复以上步骤，直至最后一个元素 */</span><br><span class=\"line\">package main</span><br><span class=\"line\">import <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">bubblesort</span></span>() &#123;</span><br><span class=\"line\">    var temp int</span><br><span class=\"line\">  arr := [...]int&#123;21, 9, -18, 196, 88, 68, 1&#125;</span><br><span class=\"line\">  length := len(arr)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"原始数组: %v \\n\"</span>,arr)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := 0 ; i &lt; length - 1; i++ &#123;</span><br><span class=\"line\">      // 每次循环将最大值放在最右边, <span class=\"keyword\">if</span> 条件中 &gt; 则为升序，&lt; 则为降序</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := 0; j &lt; length - 1 - i; j++ &#123;</span><br><span class=\"line\">        // 注意其与选择排序的不同之处，冒泡是直接相邻下标值两两对比、交换</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j+1]) &#123;</span><br><span class=\"line\">        temp = arr[j]</span><br><span class=\"line\">        arr[j] = arr[j+1]</span><br><span class=\"line\">        arr[j+1] = temp </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"第 %d 次循环: %v\\n\"</span>,i+1,arr)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"冒泡排序: %v\"</span>,arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func <span class=\"function\"><span class=\"title\">main</span></span>()&#123;</span><br><span class=\"line\">  bubblesort()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原始数组: [21 9 -18 196 88 68 1] </span><br><span class=\"line\">第 1 次循环: [9 -18 21 88 68 1 196]</span><br><span class=\"line\">第 2 次循环: [-18 9 21 68 1 88 196]</span><br><span class=\"line\">第 3 次循环: [-18 9 21 1 68 88 196]</span><br><span class=\"line\">第 4 次循环: [-18 9 1 21 68 88 196]</span><br><span class=\"line\">第 5 次循环: [-18 1 9 21 68 88 196]</span><br><span class=\"line\">第 6 次循环: [-18 1 9 21 68 88 196]</span><br><span class=\"line\">冒泡排序: [-18 1 9 21 68 88 196]</span><br></pre></td></tr></table></figure>\n<p><br/></p>\n<p><strong>2.选择排序</strong>(Selection sort)：该算法使用两重循环，外层循环每扫描时迭代一次，内层循环则在未排列列表中求得最小元素。</p>\n<ul>\n<li>算法步骤:<blockquote>\n<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>\n<p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>\n<p>重复第二步，直到所有元素均排序完毕。</p>\n</blockquote>\n</li>\n<li>时间复杂度：O(n^2）</li>\n<li>稳定性：是一个不稳定的排序算法。</li>\n<li>排序选择：当n值较小时，选择排序比冒泡排序快。</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/selectionSort.gif\" alt=\"WeiyiGeek.选择排序示例图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.选择排序示例图</p>\n            </figure>\n<ul>\n<li>代码示例：此处以Go语言进行简单演示。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//* 选择排序 */</span></span><br><span class=\"line\"><span class=\"comment\">//* 1. 从当前元素起，记录当前初始循环索引（i），当当前索引值依次与索引值+1进行对比，如后者比前者小，则记录其索引下标，并将其值赋予给初始循环索引*/</span></span><br><span class=\"line\"><span class=\"comment\">//* 2. 对于下次循环则为 外部初始循环索引i++ ，且内部循环索引为初始循环索引 （i）+1，然后再求最小值。</span></span><br><span class=\"line\"><span class=\"comment\">//* 3. 对所有元素均重复以上步骤，直至最后一个元素 */</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">selectionsort</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  arr := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">21</span>, <span class=\"number\">9</span>, <span class=\"number\">-18</span>, <span class=\"number\">196</span> , <span class=\"number\">88</span>, <span class=\"number\">68</span>, <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">  length := <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"原始数组: %v \\n\"</span>,arr)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ; i &lt; length - <span class=\"number\">1</span>; i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次循环时将最小值放在最左边，如 if 条件是 &gt; 则为升序，&lt; 则为降序。</span></span><br><span class=\"line\">        <span class=\"comment\">// 最小数的索引为i</span></span><br><span class=\"line\">        minIndex := i</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := i + <span class=\"number\">1</span>; j &lt; length; j++ &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class=\"line\">        minIndex = j</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 注意其与冒泡排序的不同之处，选择是直接下标交换。</span></span><br><span class=\"line\">        temp := arr[i]</span><br><span class=\"line\">    arr[i] = arr[minIndex]</span><br><span class=\"line\">    arr[minIndex] = temp </span><br><span class=\"line\">        </span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"第 %d 次循环: %v\\n\"</span>,i+<span class=\"number\">1</span>,arr)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"选择排序: %v\"</span>,arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  selectionsort()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原始数组: [21 9 -18 196 88 68 1] </span><br><span class=\"line\">第 1 次循环: [-18 9 21 196 88 68 1]</span><br><span class=\"line\">第 2 次循环: [-18 1 21 196 88 68 9]</span><br><span class=\"line\">第 3 次循环: [-18 1 9 196 88 68 21]</span><br><span class=\"line\">第 4 次循环: [-18 1 9 21 88 68 196]</span><br><span class=\"line\">第 5 次循环: [-18 1 9 21 68 88 196]</span><br><span class=\"line\">第 6 次循环: [-18 1 9 21 68 88 196]</span><br><span class=\"line\">选择排序: [-18 1 9 21 68 88 196]</span><br></pre></td></tr></table></figure>\n<p><br/></p>\n<p><strong>3.插入排序</strong>（Insertion Sort）: 其设计类似于<code>Selection Sort</code>与<code>Bubble Sort</code>排序，其工作方式相似玩扑克牌从大到小插入，外层循环每轮都迭代( <code>0&lt; n &lt;length</code>)，内层循环(<code>外i, 外i &gt; 0,外i--</code>)寻找插入位置。</p>\n<ul>\n<li><p>操作步骤：</p>\n<blockquote>\n<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。</p>\n<p>（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>\n</blockquote>\n</li>\n<li><p>时间复杂度：最好 O(n)，最坏 O (n^2)。</p>\n</li>\n<li><p>空间复杂度：常数阶O(1)。</p>\n</li>\n<li><p>稳定性：是一种稳定排序算法。</p>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/insertionSort.gif\" alt=\"WeiyiGeek.插入排序示例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.插入排序示例</p>\n            </figure>\n<ul>\n<li>排序选择：当n值大于1000的场景下不建议使用插入排序。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//* 插入排序 */</span></span><br><span class=\"line\"><span class=\"comment\">//* 1. 从当前元素起，外层循环下标为0，内层循环下标为 外层循环下标（i）,*/</span></span><br><span class=\"line\"><span class=\"comment\">//* 2. 比较下标[j-1]是否大于下标[j],是则交换其值。</span></span><br><span class=\"line\"><span class=\"comment\">//* 3. 对所有元素均重复以上步骤，直至最后一个元素 */</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertionsort</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  arr := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">21</span>, <span class=\"number\">9</span>, <span class=\"number\">-18</span>, <span class=\"number\">196</span> , <span class=\"number\">88</span>, <span class=\"number\">68</span>, <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">  length := <span class=\"built_in\">len</span>(arr)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"原始数组: %v \\n\"</span>,arr)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ; i &lt; length; i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先假设每次循环时，将 j 次循环的值按从小到大依次排列，如 if 条件是 &gt; 则为升序，&lt; 则为降序。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j := i; j &gt; <span class=\"number\">0</span>; j-- &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j<span class=\"number\">-1</span>] &gt; arr[j]) &#123;</span><br><span class=\"line\">          temp := arr[j]</span><br><span class=\"line\">              arr[j] = arr[j<span class=\"number\">-1</span>]</span><br><span class=\"line\">              arr[j<span class=\"number\">-1</span>] = temp </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">\"第 %d 次循环: %v\\n\"</span>,i+<span class=\"number\">1</span>,arr)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"插入排序: %v\"</span>,arr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  insertionsort()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原始数组: [21 9 -18 196 88 68 1] </span><br><span class=\"line\">第 1 次循环: [21 9 -18 196 88 68 1]</span><br><span class=\"line\">第 2 次循环: [9 21 -18 196 88 68 1]</span><br><span class=\"line\">第 3 次循环: [-18 9 21 196 88 68 1]</span><br><span class=\"line\">第 4 次循环: [-18 9 21 196 88 68 1]</span><br><span class=\"line\">第 5 次循环: [-18 9 21 88 196 68 1]</span><br><span class=\"line\">第 6 次循环: [-18 9 21 68 88 196 1]</span><br><span class=\"line\">第 7 次循环: [-18 1 9 21 68 88 196]</span><br><span class=\"line\">插入排序: [-18 1 9 21 68 88 196]</span><br></pre></td></tr></table></figure>\n<hr>\n<h5 id=\"4-查找算法\"><a href=\"#4-查找算法\" class=\"headerlink\" title=\"(4) 查找算法\"></a>(4) 查找算法</h5><p>在计算机科学里还有一种常用的算法叫做查找，是一种在列表中确定目标所在位置的算法，两种最基本的查找方法为<code>顺序查找和折半查找</code>.</p>\n<p><strong>1.顺序查找</strong>(Sequential search)：用于查找无序列表，通常用于查找较小的列表或者不常用的列表。</p>\n<ul>\n<li><p>查询步骤：</p>\n<blockquote>\n<p>顺序査找是从列表起始处开始查找，当找到目标元素或确信查找目标不在列表中时，查找过程结束。</p>\n</blockquote>\n</li>\n<li><p>图示：</p>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220926153614560.png\" alt=\"WeiyiGeek.顺序查找\" title=\"\" class=\"\">\n                <p>WeiyiGeek.顺序查找</p>\n            </figure>\n<ul>\n<li>代码演示：此处使用Go语言进行演示。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sequentialsearch</span><span class=\"params\">(n <span class=\"keyword\">int</span>,  numbers []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"原始数组: %v \\n\"</span>, numbers)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> numbers &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( n == v ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  searchNumber := <span class=\"number\">196</span></span><br><span class=\"line\">  arr := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">21</span>, <span class=\"number\">9</span>, <span class=\"number\">-18</span>, <span class=\"number\">196</span> , <span class=\"number\">88</span>, <span class=\"number\">68</span>, <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">  index := sequentialsearch(searchNumber, arr[:])</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"元素 %d 在 arrNumber [ %v ] 中的下标为 %v\"</span>,searchNumber,arr,index)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原始数组: [<span class=\"number\">21</span> <span class=\"number\">9</span> <span class=\"number\">-18</span> <span class=\"number\">196</span> <span class=\"number\">88</span> <span class=\"number\">68</span> <span class=\"number\">1</span>] </span><br><span class=\"line\">元素 <span class=\"number\">196</span> 在 arrNumber [ [<span class=\"number\">21</span> <span class=\"number\">9</span> <span class=\"number\">-18</span> <span class=\"number\">196</span> <span class=\"number\">88</span> <span class=\"number\">68</span> <span class=\"number\">1</span>] ] 中的下标为 <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p><strong>2.折半查找</strong>: 通常称为二分法, 用于找寻有序列表中的元素，其效率更高，如果元素是无序的则不能使用该方法。</p>\n<ul>\n<li><p>查询步骤：</p>\n<blockquote>\n<p>折半査找是从一个列表的中间元素来测试的，这将能够判别出目标在列表的前半部分还是后半部分。</p>\n<p>如果在前半部分，就不需要査找后半部分。</p>\n<p>如果在后半部分，就不需要查找前半部分。</p>\n</blockquote>\n</li>\n<li><p>图示：</p>\n</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220926165843724.png\" alt=\"WeiyiGeek.折半查找示例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.折半查找示例</p>\n            </figure>\n<ul>\n<li><p>代码演示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">halfsearch</span><span class=\"params\">(number <span class=\"keyword\">int</span>, numbers []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化 数组、长度、中值变量</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> i,arr_len,mid <span class=\"keyword\">int</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"comment\">// 在arr[i...arr_len]之中查找target</span></span><br><span class=\"line\">  i = <span class=\"number\">0</span></span><br><span class=\"line\">  arr_len = <span class=\"built_in\">len</span>(numbers)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// go 语言没有While关键字所有使用for作为替代，以及使用 break 跳出循环。</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 取数组长度中值(灵魂)</span></span><br><span class=\"line\">    mid = i + (arr_len - i) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"comment\">// 刚好等于则直接返回mid，如果大于number则将其中值减一后赋予arr_len，否则将中值赋予 i + 1。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> numbers[mid] == number &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>  numbers[mid] &gt; number  &#123;</span><br><span class=\"line\">      arr_len = mid - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      i = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 不满足则退出循序，即</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &gt; arr_len &#123;</span><br><span class=\"line\">       <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  searchNumber := <span class=\"number\">88</span></span><br><span class=\"line\">  arr := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">-18</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>,<span class=\"number\">21</span>,<span class=\"number\">68</span>,<span class=\"number\">88</span>,<span class=\"number\">196</span>&#125;</span><br><span class=\"line\">  index := halfsearch(searchNumber, arr[:])</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"[折半查询]\\n元素 %d 在 arrNumber  %v  中的下标为 %v\"</span>,searchNumber,arr,index)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[折半查询]</span><br><span class=\"line\">元素 88 在 arrNumber  [-18 1 9 21 68 88 196]  中的下标为 5</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"5-迭代递归算法\"><a href=\"#5-迭代递归算法\" class=\"headerlink\" title=\"(5) 迭代递归算法\"></a>(5) 迭代递归算法</h5><p>通常为了解决更复杂的问题，我们会使用<code>迭代</code>或使用<code>递归</code>算法。</p>\n<p><strong>迭代:</strong> 其算法的定义不涉及算法本身，则算法的迭代的。例如 阶乘的计算（迭代）。</p>\n<p><strong>递归: </strong>即算法自我调用的过程。例如 斐波那契数列。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220926223108015.png\" alt=\"WeiyiGeek\" title=\"\" class=\"\">\n                <p>WeiyiGeek</p>\n            </figure>\n<p>实际上递归计算花费的时间更长且更加困难，那为何我没还要使用递归呢？</p>\n<blockquote>\n<p>递归对于编程人员和程序阅读者在概念上更容易理解。</p>\n</blockquote>\n<p>分别使用<code>迭代</code>与<code>递归</code>算法进行计算阶乘示例：此处以Go语言为例。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\"><span class=\"comment\">// 使用迭代方式计算阶乘</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">factotial_iteration</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  result,i := <span class=\"number\">1</span>,<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt; n)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result *= i</span><br><span class=\"line\">    i++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用递归方式计算阶乘</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">factotial_recursion</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * factotial_recursion(n<span class=\"number\">-1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  number := <span class=\"number\">6</span></span><br><span class=\"line\">  result := factotial_iteration(number)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"使用迭代计算 %d! 阶乘的结果为 %d \\n\"</span>, number, result)</span><br><span class=\"line\"></span><br><span class=\"line\">  result = factotial_recursion(number)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"使用递归计算 %d! 阶乘的结果为 %d\"</span>, number, result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用迭代计算 6! 阶乘的结果为 720 </span><br><span class=\"line\">使用递归计算 6! 阶乘的结果为 720</span><br></pre></td></tr></table></figure>\n<h5 id=\"6-子算法\"><a href=\"#6-子算法\" class=\"headerlink\" title=\"(6) 子算法\"></a>(6) 子算法</h5><p><strong>定义</strong></p>\n<p>结构化编程的原则要求将算法分成几个单元，称为<code>子算法</code>,  而每个子算法依次又分为更小的子算法，你可将其看做即<code>函数模块</code>。</p>\n<p>在每次迭代中，算法<code>SelectionSort</code>调用子算法<code>FindSmallest</code>。</p>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220926170836950.png\" alt=\"WeiyiGeek.子算法概念示例\" title=\"\" class=\"\">\n                <p>WeiyiGeek.子算法概念示例</p>\n            </figure>\n<p>使用子算法至少有两个优点，即程序更容易理解，子算法可在主算法中不同地方调用。</p>\n<p><br></p>\n<p><strong>结构图</strong></p>\n<p>描述：程序员使用的另一个编程工具就是结构图，它是一个高级设计工具，它显示了算法和子算法之间的关系。</p>\n<p>结构图是面向过程软件设计阶段的主要工具。</p>\n<ul>\n<li>模块符号：每个矩形代表编写一个模块，矩形的名字就是其代表的模块的名字。</li>\n<li>结构图的选择条件：例如表示 <code>条件</code>和<code>异或</code>。</li>\n<li>结构图中的循环条件：例如表示<code>普通循环</code>和<code>条件循环</code>。</li>\n<li>结构图的阅读顺序：从上到下，从左到右阅读。</li>\n</ul>\n<figure class=\"image-box\">\n                <img src=\"https://img.weiyigeek.top/2022/8/image-20220926220100641.png\" alt=\"WeiyiGeek.结构图\" title=\"\" class=\"\">\n                <p>WeiyiGeek.结构图</p>\n            </figure>\n<p>结构图主要规则：</p>\n<ul>\n<li>结构图每个矩形都代表一个模块。</li>\n<li>矩形中的名字就是模块代码的模块名。</li>\n<li>结构图中只包含模块流程，没有任何代码。</li>\n<li>公有模块的矩形一般都在右下角画一条双向影线或一块阴影。</li>\n<li>数据流和标志是可选的，但如果使用则必须命名。</li>\n<li>输入流和标志是显示垂直线的左端，输出流和标志显示在其右端。</li>\n</ul>\n","comments":true,"excerpt":"[TOC]计算机科学导论学习笔记第 4 部分 计算机软件与算法此部分包含第7、8、9、10章，包含了计算机操作系统、问题求解算法、程序设计语言之旅、软件工程等相关知识，加深我们对开发的认识，为后续开发打下一个基础。","categories":[{"name":"计算机基础知识","path":"api/categories/计算机基础知识.json"}],"tags":[{"name":"计算机科学导论","path":"api/tags/计算机科学导论.json"}]}