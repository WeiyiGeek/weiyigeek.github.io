{"title":"Binary程序分析查看类命令","slug":"系统运维/Linux/常用命令/二进制程序类命令/binary程序分析查看类命令","date":"2019-06-03T12:35:30.000Z","updated":"2022-03-29T05:39:06.308Z","url":"2019/6-3-140.html","path":"api/articles/2019/6-3-140.html.json","covers":["https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190604091017.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190604103501.png","https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2020/1/20200606172536.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h4 id=\"0x00-快速入门\"><a href=\"#0x00-快速入门\" class=\"headerlink\" title=\"0x00 快速入门\"></a>0x00 快速入门</h4><p>编程相关缩写<br>缩写 | 全称 | 说明<br>— | — | —<br>cc | C Compiler |<br>gcc | Gnu Compiler Collection | 作为一个软件集被你下载下来编译安装的时候<br>gcc | Gnu C Compiler | 作为一个软件被你调用来编译C程序的时候<br>g++ | Gnu c++ compiler | 其实g++只是调用gcc，然后连接c++的库，并且作相应的一些编译设置而已<br>gcj | Gnu Compiler for Java |<br>gdb | Gnu DeBug |</p>\n<h5 id=\"file命令\"><a href=\"#file命令\" class=\"headerlink\" title=\"file命令\"></a>file命令</h5><p>描述：用来探测给定文件的类型，file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基础语法和参参数</span></span><br><span class=\"line\">file (选项) (参数)   <span class=\"comment\"># parameters-&gt; 文件：要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件</span></span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190604091017.png\" alt=\"WeiyiGeek.参数\" title=\"\" class=\"\">\n                <p>WeiyiGeek.参数</p>\n            </figure></p>\n<p>示例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例1.显示文件类型</span></span><br><span class=\"line\"><span class=\"variable\">$file</span> anaconda-ks.cfg</span><br><span class=\"line\">anaconda-ks.cfg: ASCII text</span><br><span class=\"line\"><span class=\"variable\">$file</span> PentextBox.zip</span><br><span class=\"line\">PentextBox.zip: Zip archive data, at least v2.0 to extract</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$file</span> -b PentextBox.zip    <span class=\"comment\">#不显示文件名称</span></span><br><span class=\"line\">Zip archive data, at least v2.0 to extract</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$file</span> -b -i  PentextBox.zip   <span class=\"comment\">#显示MIME类别</span></span><br><span class=\"line\">application/zip; charset=binary</span><br><span class=\"line\"><span class=\"variable\">$file</span> -b -i  anaconda-ks.cfg</span><br><span class=\"line\">text/plain; charset=us-ascii</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例2.判断当前系统的位数（运行的平台，以及架构和是不是支持裁剪stripped，）</span></span><br><span class=\"line\"><span class=\"variable\">$file</span> /bin/ls</span><br><span class=\"line\">/bin/ls: [关键点]ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class=\"keyword\">for</span> GNU/Linux 2.6.32, BuildID[sha1]=ceaf496f3aec08afced234f4f36330d3d13a657b, stripped</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#示例3.显示符合链接的文件类型以及目录</span></span><br><span class=\"line\"><span class=\"variable\">$file</span> anaconda-ks.ln</span><br><span class=\"line\">anaconda-ks.ln: symbolic link to `anaconda-ks.cfg`</span><br><span class=\"line\"><span class=\"variable\">$file</span> /root/</span><br><span class=\"line\">/root/: directory</span><br></pre></td></tr></table></figure><br><br></p>\n<h5 id=\"size-命令\"><a href=\"#size-命令\" class=\"headerlink\" title=\"size 命令\"></a>size 命令</h5><p>描述：分析Linux程序内存段分布,但它的输出不包括stack和heap的部分，只包括文本段(text), 代码段(data),未初始化数据段(bss)三部分。</p>\n<ul>\n<li>1、文本段：包含程序的指令，它在程序的执行过程中一般不会改变。</li>\n<li>2、数据段：包含了经过初始化的全局变量和静态变量，以及他们的值。</li>\n<li>3、BSS段：包含未经初始化的全局变量和静态变量。</li>\n<li>4、堆栈段：包含了函数内部声明的局部变量。当然上面段的作用不仅于此具体的作用</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#示例1.以C脚本来分析</span></span><br><span class=\"line\">[root@pc201 ccodes]<span class=\"comment\"># cat test.c</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 论1：未初始化的全局变量保存在BSS段   </span><br><span class=\"line\">int g_data;     //4B（由于整型占用了4B）</span><br><span class=\"line\"></span><br><span class=\"line\">//论2：经过初始化的全局变量保存在数据段中 </span><br><span class=\"line\">int gg_data=1;  </span><br><span class=\"line\"></span><br><span class=\"line\">// 论6：const修饰的全局变量保存在文本段</span><br><span class=\"line\">const int g_data=1;</span><br><span class=\"line\"></span><br><span class=\"line\">//论8：字符串常量保存在文本段/数据data段</span><br><span class=\"line\">char *pstr=<span class=\"string\">\"123456789\"</span>;  //文本占用9B，数据data段4B</span><br><span class=\"line\">//char ptrs[10]=<span class=\"string\">\"123456789\"</span>; //这个只增加数据data段</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> //论3：未初始化的静态变量保存在BSS段中</span><br><span class=\"line\"> static int sg_data;</span><br><span class=\"line\">    </span><br><span class=\"line\"> //论4：经过初始化的静态变量保存在数据段中</span><br><span class=\"line\"> static int sgg_data = 2;</span><br><span class=\"line\"></span><br><span class=\"line\"> //结论7：const修饰的局部变量保存在文本段</span><br><span class=\"line\"> const int i_data=1;</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"built_in\">return</span> 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2019/20190604103501.png\" alt=\"WeiyiGeek.案例演示\" title=\"\" class=\"\">\n                <p>WeiyiGeek.案例演示</p>\n            </figure>\n<p><br></p>\n<h4 id=\"0x01-应用依赖查看\"><a href=\"#0x01-应用依赖查看\" class=\"headerlink\" title=\"0x01 应用依赖查看\"></a>0x01 应用依赖查看</h4><h5 id=\"ldd-命令\"><a href=\"#ldd-命令\" class=\"headerlink\" title=\"ldd 命令\"></a>ldd 命令</h5><p>描述:用于打印程序或者库文件所依赖的共享库列表。值得注意的是ldd不是一个可执行程序而只是一个shell脚本： cat <code>whereis ldd | cut -f 2 -d &#39; &#39;</code>,ldd显示可执行模块的dependency(所属)的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现的;</p>\n<p>它能够显示可执行模块的dependency(所属)(所属)，其原理是通过设置一系列的环境变量，如下：<code>LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE</code>等。</p>\n<p>当LD_TRACE_LOADED_OBJECTS环境变量不为空时，任何可执行程序在运行时，它都会只显示模块的dependency(所属)，而程序并不真正执行。<br>例如:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">export</span> LD_TRACE_LOADED_OBJECTS=0</span><br><span class=\"line\">$ ls (实际上命令并未执行)</span><br><span class=\"line\">  linux-vdso.so.1 =&gt;  (0x00007fffcb2ff000)</span><br><span class=\"line\">  libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f236c95d000)</span><br><span class=\"line\">  libcap.so.2 =&gt; /lib64/libcap.so.2 (0x00007f236c758000)</span><br><span class=\"line\">  libacl.so.1 =&gt; /lib64/libacl.so.1 (0x00007f236c54f000)</span><br><span class=\"line\">  libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f236c181000)</span><br><span class=\"line\">  libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f236bf1f000)</span><br><span class=\"line\">  libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f236bd1b000)</span><br><span class=\"line\">  /lib64/ld-linux-x86-64.so.2 (0x00007f236cb84000)</span><br><span class=\"line\">  libattr.so.1 =&gt; /lib64/libattr.so.1 (0x00007f236bb16000)</span><br><span class=\"line\">  libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f236b8fa000)</span><br><span class=\"line\">$ <span class=\"built_in\">unset</span> LD_TRACE_LOADED_OBJECTS</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">aio.h        bits        dlfcn.h</span><br></pre></td></tr></table></figure></p>\n<p><em>Q:那为何会如此?</em><br>我们知道<code>ld-linux.so</code>模块会先于executable模块程序工作，并获得控制权，因此当上述的那些环境变量被设置时ld-linux.so选择了显示可执行模块的dependency(所属)。<br>实际上可以直接执行ld-linux.so模块，如：<code>/lib/ld-linux.so.2 --list program（这相当于ldd program）</code></p>\n<p>基础语法:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldd (选项) (参数-指定可执行程序或者文库)</span><br><span class=\"line\">-v：详细信息模式，打印所有相关信息；</span><br><span class=\"line\">-u：打印未使用的直接依赖；</span><br><span class=\"line\">-d：执行重定位和报告任何丢失的对象；</span><br><span class=\"line\">-r：执行数据对象和函数的重定位，并且报告任何丢失的对象和函数；</span><br></pre></td></tr></table></figure></p>\n<p>基础实例:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#1.显示su应用依赖的动态链接库</span></span><br><span class=\"line\">ldd `whereis sudo|cut -f2 -d <span class=\"string\">' '</span>`</span><br><span class=\"line\">  linux-vdso.so.1 =&gt;  (0x00007ffceeb96000)</span><br><span class=\"line\">  libaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f1b92599000)</span><br><span class=\"line\">  libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f1b92372000)</span><br><span class=\"line\">  libutil.so.1 =&gt; /lib64/libutil.so.1 (0x00007f1b9216f000)</span><br><span class=\"line\">  libsudo_util.so.0 =&gt; /usr/libexec/sudo/libsudo_util.so.0 (0x00007f1b91f5c000)</span><br><span class=\"line\">  libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f1b91d58000)</span><br><span class=\"line\">  libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f1b9198a000)</span><br><span class=\"line\">  libcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f1b91784000)</span><br><span class=\"line\">  libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f1b91522000)</span><br><span class=\"line\">  /lib64/ld-linux-x86-64.so.2 (0x00007f1b929e7000)</span><br><span class=\"line\">  libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f1b91306000)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#2.详细依赖查看</span></span><br><span class=\"line\">$ ldd -v `whereis sudo|cut -f2 -d <span class=\"string\">' '</span>`</span><br><span class=\"line\">  linux-vdso.so.1 =&gt;  (0x00007fff4269e000)</span><br><span class=\"line\">  libaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f7efb74f000)</span><br><span class=\"line\">Version information:</span><br><span class=\"line\">  /usr/bin/sudo:</span><br><span class=\"line\">    libutil.so.1 (GLIBC_2.2.5) =&gt; /lib64/libutil.so.1</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.9) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.3) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.14) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.8) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.4) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.6) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.3.4) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.2.5) =&gt; /lib64/libc.so.6</span><br><span class=\"line\">    libc.so.6 (GLIBC_2.11) =&gt; /lib64/libc.so.6</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#3.当应用报错时候可以采用ldd来查看缺少的so链接库(比如下图)</span></span><br><span class=\"line\"><span class=\"comment\">#解决程式因缺少某个库文件而不能运行的一些问题</span></span><br><span class=\"line\">ln -s /usr/lib/i386-linux-gnu/libpangoxft-1.0.so.0.3800.1 /usr/lib/libpangoxft-1.0.so.0</span><br></pre></td></tr></table></figure><br><figure class=\"image-box\">\n                <img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2020/1/20200606172536.png\" alt=\"WeiyiGeek.\" title=\"\" class=\"\">\n                <p>WeiyiGeek.</p>\n            </figure></p>\n<p>注意事项:</p>\n<ul>\n<li><ol>\n<li>ldd的标准版本和glibc2一起提供, Libc5和老版本以前提供在一些系统中还存在。</li>\n</ol>\n<ul>\n<li>在libc5版本中长选项不支持</li>\n<li>glibc2版本不支持-V选项,只提供等价的–version选项。</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>如果命令行中给定的库名字包含/，这个程式的libc5版本将使用他作为库名字；否则他将在标准位置搜索库；</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>注意ldd不能工作在a.out格式的共享库上，调试异常。</li>\n</ol>\n</li>\n</ul>\n","comments":true,"excerpt":"[TOC]","categories":[{"name":"Linux命令","path":"api/categories/Linux命令.json"}],"tags":[{"name":"二进制","path":"api/tags/二进制.json"}]}