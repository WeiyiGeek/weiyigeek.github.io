{"title":"4.Prometheus监控入门之PromQL表达式语法学习","slug":"虚拟云容/云容器/Kubernetes/功能组件/Prometheus/4.Prometheus监控入门之PromQL表达式语法学习","date":"2021-04-25T09:37:47.000Z","updated":"2022-03-29T05:39:03.674Z","url":"2021/4-25-554.html","path":"api/articles/2021/4-25-554.html.json","covers":["https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210819215356.png"],"content":"<p>[TOC]</p>\n<a id=\"more\"></a>\n<h2 id=\"0x00-PromQL-介绍\"><a href=\"#0x00-PromQL-介绍\" class=\"headerlink\" title=\"0x00 PromQL 介绍\"></a>0x00 PromQL 介绍</h2><h3 id=\"1-基础简述\"><a href=\"#1-基础简述\" class=\"headerlink\" title=\"1.基础简述\"></a>1.基础简述</h3><p><strong>Q: 什么是PromQL?</strong></p>\n<blockquote>\n<p>答: PromQL <code>(Prometheus Query Language)</code> 函数式查询语言 是 Prometheus 自己开发的数据查询 DSL 语言，可以让用户实时选择和聚合时间序列数据。</p>\n</blockquote>\n<p>它类似于 SQL 的语言，但是PromQL表现力非常丰富，并且内置函数很多，在日常数据可视化以及 rule 告警中都会使用到它。</p>\n<p>Tips: 我们把每个查询对象得名字叫做<code>Metrics</code>度量值。</p>\n<p>Tips: 标签是PromQL的关键部分，不仅可以使用它们进行任意聚合，还可以将不同的指标连接在一起，以对其进行算术运算。</p>\n<p><strong>Q: 如果进行Prometheus采集的数据查询?</strong></p>\n<blockquote>\n<p>答: 在<code>Prometheus Server</code>的后台里面输入指标名称(会自动补齐), 如最近一个时间间隔(采集周期)下的值<code>prometheus_prometheus_http_requests_total</code>;</p>\n</blockquote>\n<p><strong>Q: 如何使用 PromQL 语句通过内置表达式浏览器进行查询?</strong></p>\n<ul>\n<li>(1) 使用<code>Prometheus</code>的内置表达式浏览器，利用PromQL语句进行查询我们监控的指标。</li>\n</ul>\n<p>例如: Prometheus 服务器已服务的<code>/metrics</code>请求的总数指标: <code>promhttp_metric_handler_requests_total</code><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求`/metrics`返回`code=200`为条件进行查询</span></span><br><span class=\"line\">promhttp_metric_handler_requests_total&#123;code=<span class=\"string\">\"200\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// promhttp_metric_handler_requests_total&#123;code=\"200\", instance=\"aiserver\", job=\"Prod\"&#125; 80619</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算返回的请求为200的总数指标时间序列总数</span></span><br><span class=\"line\">count(promhttp_metric_handler_requests_total&#123;code=<span class=\"string\">\"200\"</span>&#125;)  <span class=\"comment\">// &#123;&#125; 34</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>(2) 使用<code>Graph</code>选项卡，展示查询到的数据<br>例如，输入以下表达式来绘制在自我抓取的Prometheus中发生的返回状态代码<code>200</code>的每秒HTTP请求率：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rate(promhttp_metric_handler_requests_total&#123;code=<span class=\"string\">\"200\"</span>,job=<span class=\"string\">\"LocalServer\"</span>&#125;[5m])</span><br><span class=\"line\">  <span class=\"comment\"># &#123;code=\"200\", instance=\"localhost:9090\", job=\"LocalServer\"&#125; \t0.016666666666666666</span></span><br></pre></td></tr></table></figure>\n您可以尝试图形范围参数和其他设置。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/WeiyiGeek/blogimage/2021/5/20210819215356.png\" alt=\"WeiyiGeek.Graph\"></p>\n<p><br></p>\n<h3 id=\"2-基础标准\"><a href=\"#2-基础标准\" class=\"headerlink\" title=\"2.基础标准\"></a>2.基础标准</h3><p><strong>2.1 时间单位:</strong><br>描述: Prometheus 中的持续时间被用于 <code>PromQL</code> 和<code>配置文件</code>中，它支持的单位如下:</p>\n<table>\n<thead>\n<tr>\n<th>单位</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ms</td>\n<td>毫秒</td>\n</tr>\n<tr>\n<td>s</td>\n<td>秒, 等于 1000 ms</td>\n</tr>\n<tr>\n<td>m</td>\n<td>分钟, 等于 60 s</td>\n</tr>\n<tr>\n<td>h</td>\n<td>小时, 等于 60 min</td>\n</tr>\n<tr>\n<td>d</td>\n<td>天, 等于 24h</td>\n</tr>\n<tr>\n<td>w</td>\n<td>周, 等于 7d</td>\n</tr>\n<tr>\n<td>y</td>\n<td>年, 等于 365d</td>\n</tr>\n</tbody>\n</table>\n<p>以下是一些有效持续时间的示例：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>h</span><br><span class=\"line\"><span class=\"number\">1</span>h30m</span><br><span class=\"line\"><span class=\"number\">5</span>m</span><br><span class=\"line\"><span class=\"number\">10s</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips : 你可以使用一个整数带一个单位，例如<code>90m</code>是有效的，而<code>1h30m</code>和<code>1.5h</code>不是有效的。<br>Tips : 并且闰年和闰秒都是被忽略的，1y 总是 (<code>60 * 60 * 24 * 365s</code>)</p>\n<p><br></p>\n<p><strong>2.2 文字</strong><br>(1) 字符串文字: 字符串可以在单引号、双引号或反引号中指定为文字。<br>PromQL 遵循与Go相同的转义规则。在单引号或双引号中，反斜杠开始一个转义序列，后面可以跟<code>a, b, f, n, r, t,v或\\</code>。可以使用八进制 (<code>\\nnn</code>) 或十六进制 (<code>\\xnn,\\unnnn和\\Unnnnnnnn</code>)提供特定字符。</p>\n<p>Tips : 非常注意的是与 Go 不同，Prometheus 不会丢弃反引号内的换行符(<code>反引号内不处理转义</code>)。</p>\n<p>例子:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"this is a string\"</span></span><br><span class=\"line\"><span class=\"string\">'these are unescaped: \\n \\\\ \\t'</span></span><br><span class=\"line\"><span class=\"string\">`these are not unescaped: \\n ' \" \\t`</span></span><br></pre></td></tr></table></figure></p>\n<p>(2) 浮动文字: 标量浮点值可以按以下格式写成文字整数或浮点数（仅包含空格以提高可读性）。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[-+]?(</span><br><span class=\"line\">  [0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?</span><br><span class=\"line\">  | 0[xX][0-9a-fA-F]+</span><br><span class=\"line\">  | [nN][aA][nN]</span><br><span class=\"line\">  | [iI][nN][fF]</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>例子：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">23</span><br><span class=\"line\">-2.43</span><br><span class=\"line\">3.4e-9</span><br><span class=\"line\">0x8f</span><br><span class=\"line\">-Inf</span><br><span class=\"line\">NaN</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"3-数据类型\"><a href=\"#3-数据类型\" class=\"headerlink\" title=\"3.数据类型\"></a>3.数据类型</h3><p>描述: 在 Prometheus 的表达式语言中，表达式或子表达式可以计算为以下四种类型之一：</p>\n<h4 id=\"瞬时数据-Instant-vector\"><a href=\"#瞬时数据-Instant-vector\" class=\"headerlink\" title=\"瞬时数据 (Instant vector)\"></a>瞬时数据 (Instant vector)</h4><p><code>即时时向量选择器</code>: 查询评估时间之前返回最近样本的瞬时向量，即零个或者多个时间序列的列表，<code>每个时间序列包含一个样本，所有时间序列都共享相同的时间戳</code>。并且当你使用瞬时向量选择器时，不会返回已过时的时间序列。</p>\n<p><strong>示例说明:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (1) 包含一组时序，每个时序只有一个点，例如：`prometheus_prometheus_http_requests_total`</span></span><br><span class=\"line\">node_timex_status[2m]</span><br><span class=\"line\">  <span class=\"comment\"># node_timex_status&#123;instance=\"aiserver\", job=\"Prod\"&#125; 8193 @1629298587.604</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips: 例如返回即时向量的表达式是唯一可以直接绘制的类型。</p>\n<p><br/></p>\n<h4 id=\"区间数据-Range-vector\"><a href=\"#区间数据-Range-vector\" class=\"headerlink\" title=\"区间数据 (Range vector)\"></a>区间数据 (Range vector)</h4><p><code>范围向量选择器</code>: 与每个时间序列返回一个样本的瞬时向量选择器不同，范围选择器为每个时间序列返回多个样本（<code>包含一组时序，每个时序有多个点</code>）即(包含每个时间序列随时间变化的数据点范围)，并且范围向量总是与<code>rate、avg_over_time</code>函数联合使用。</p>\n<p><strong>示例说明:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (1) 查询执行时间为准按照分钟粒度返回与选择器匹配的所有时间序列</span></span><br><span class=\"line\">process_cpu_seconds_total&#123;instance=<span class=\"string\">\"aiserver\"</span>&#125;[1m]</span><br><span class=\"line\"></span><br><span class=\"line\">                                                                              54969.1 @1629292827.605</span><br><span class=\"line\">                                                                              54969.3 @1629292837.605</span><br><span class=\"line\">process_cpu_seconds_total&#123;instance=<span class=\"string\">\"aiserver\"</span>, job=<span class=\"string\">\"Prod\"</span>&#125; \t                  54969.1 @1629292847.605</span><br><span class=\"line\">                                                                              54969.2 @1629292857.605</span><br><span class=\"line\">                                                                              54969.2 @1629292867.605</span><br><span class=\"line\">                                                                              54969.1 @1629292877.605</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 上述示例结果中每个时间序列的样本恰好相差10s，这与Prometheus配置的抓取时间相关一致，但两个时间序列时间戳不会相互对齐。</p>\n<p><br/></p>\n<h4 id=\"纯量数据-Scalar\"><a href=\"#纯量数据-Scalar\" class=\"headerlink\" title=\"纯量数据 (Scalar)\"></a>纯量数据 (Scalar)</h4><p><code>标量</code>: 纯量只有一个数字，没有时序，例如：<code>count(prometheus_prometheus_http_requests_total)</code>执行结果为:<code>{} 20</code></p>\n<p><strong>示例说明:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (1) 纯量只有一个数字，没有时序</span></span><br><span class=\"line\">prometheus_prometheus_http_requests_total&#123;code=<span class=\"string\">\"200\"</span>,&#125;</span><br><span class=\"line\">  <span class=\"comment\"># prometheus_prometheus_http_requests_total&#123;code=\"200\", handler=\"/metrics\", instance=\"localhost:9090\", job=\"LocalServer\"&#125;  82016</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips : 在采用Graph进行展示时，查询的表达式类型”range vector”是无效可导致执行查询时出错，必须是标量或即时向量。</p>\n<h4 id=\"字符串数据-String\"><a href=\"#字符串数据-String\" class=\"headerlink\" title=\"字符串数据 (String)\"></a>字符串数据 (String)</h4><p>描述: 一个简单的字符串值；目前未使用。</p>\n<p><br></p>\n<h3 id=\"4-选择器-Selector\"><a href=\"#4-选择器-Selector\" class=\"headerlink\" title=\"4.选择器 - (Selector)\"></a>4.选择器 - (<code>Selector</code>)</h3><p>描述：在 Prometheus 浏览器表达式中选择器非常重要，它可以缩小我们查询或者要处理的时间序列范围。通过在花括号 ( {}) 中附加逗号分隔的标签匹配器列表来进一步过滤这些时间序列。</p>\n<p>例如: job=”node” 被称为匹配器，并且你可以在一个选择器利用多个匹配器串在一起。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go_info&#123;BusinessType=<span class=\"string\">\"jszg\"</span>,env=<span class=\"string\">\"prod\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\"># go_info&#123;BusinessType=\"jszg\", instance=\"192.168.1.69:9100\", job=\"Win\", version=\"go1.15.6\"&#125; 1</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"5-匹配器-Matcher\"><a href=\"#5-匹配器-Matcher\" class=\"headerlink\" title=\"5.匹配器 - (Matcher)\"></a>5.匹配器 - (<code>Matcher</code>)</h3><p>描述: 常用的匹配器解析说明。</p>\n<p><code>=</code> (等式匹配器) : 最是常用的匹配器，通过此操作，你可以指定返回的时间系列包含一个具有特定值的标签。</p>\n<ul>\n<li>例如: <code>job=&quot;node&quot;</code>作为一个空值标签和没有该标签一样, 你可以使用 <code>foo=&quot;&quot;</code> 来指定 <code>foo</code> 标签不存在的指标。<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) 查询标签 instance 为 aiserver 以及 不存在 env 标签的 go_info 的目标 go_info 指标项。</span></span><br><span class=\"line\">go_info&#123;env=<span class=\"string\">\"\"</span>,instance=<span class=\"string\">\"aiserver\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// go_info&#123;instance=\"aiserver\", job=\"K8S-Prod\", version=\"go1.15.8\"&#125;\t1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>!=</code>(否定的等式匹配器) : 通过此操作，你可以指定返回的时间系列没有包含特定值的标签。</p>\n<ul>\n<li>例如: <code>job != &quot;node&quot;</code><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) 查询标签 BusinessType 为 zk 以及 version 不等于 go1.15.8 的目标 go_info 指标项。</span></span><br><span class=\"line\">go_info&#123;version!=<span class=\"string\">\"go1.15.8\"</span>,BusinessType=<span class=\"string\">\"zk\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// go_info&#123;env=\"prod\", instance=\"192.168.10.67:9100\", job=\"K8S-Prod\", version=\"go1.15.6\"&#125; 1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>=~</code>(正则表示式匹配器) : 通过此操作，它可以定标签的值与正则表达式相匹配。表达式语法可以在百度中进行查询。</p>\n<ul>\n<li>例如: <code>job =~ &quot;n.*&quot;</code><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) 查询标签 instance 匹配的 \"ai.*\" 正则表达式匹配的目标 go_info 指标项。</span></span><br><span class=\"line\">go_info&#123;instance=~<span class=\"string\">\"ai.*\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// go_info&#123;instance=\"aiserver\", job=\"K8S-Prod\", version=\"go1.15.8\"&#125; 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (2) 注意点，向量选择器必须指定一个名称或至少一个与空字符串不匹配的标签匹配器。</span></span><br><span class=\"line\">&#123;job=~<span class=\"string\">\".*\"</span>&#125; # Bad!</span><br><span class=\"line\"><span class=\"comment\">// 相反，这些表达式是有效的，因为它们都有一个不匹配空标签值的选择器。</span></span><br><span class=\"line\">&#123;job=~<span class=\"string\">\".+\"</span>&#125;              # Good!</span><br><span class=\"line\">&#123;job=~<span class=\"string\">\".*\"</span>,method=<span class=\"string\">\"get\"</span>&#125; # Good!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (3) 例如，标签匹配器也可以通过与内部__name__标签匹配来应用于度量名称, 表达式 prometheus_http_requests_total 等效于 &#123;__name__=\"prometheus_http_requests_total\"&#125;。</span></span><br><span class=\"line\">&#123;__name__=~<span class=\"string\">\"job:.*\"</span>&#125;  <span class=\"comment\">// 选择名称以job开头的所有指标</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>!~</code>(正则表示式反匹配器) : 通过此操作, 它可以定标签的值与正则表达式不相匹配。</p>\n<ul>\n<li>例如: <code>job !~ &quot;n.*&quot;</code><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) 查询标签 env 不匹配的 \"p.*\" 为值的目标 go_info 指标项。</span></span><br><span class=\"line\">go_info&#123;env!~<span class=\"string\">\"p.*\"</span>,instance=<span class=\"string\">\"aiserver\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// go_info&#123;instance=\"aiserver\", job=\"K8S-Prod\", version=\"go1.15.8\"&#125; 1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Tips : Prometheus 中的所有正则表达式都使用RE2 语法（<a href=\"https://github.com/google/re2/wiki/Syntax）。\" target=\"_blank\" rel=\"noopener\">https://github.com/google/re2/wiki/Syntax）。</a></p>\n<p><br/></p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (1) 在选择器中使用具有相同标签名称的多个匹配器，查找 job 为 Linux, 标签 device 不为 `tmpfs|shm`, 标签 mountpoint 为 / 根的所以文件系统的大小。</span></span><br><span class=\"line\">node_filesystem_size_bytes&#123;job=~<span class=\"string\">\"L.*\"</span>, device!~<span class=\"string\">\"tmpfs|shm\"</span>,mountpoint=~<span class=\"string\">\"/$\"</span>&#125; / 1024^3</span><br><span class=\"line\">  <span class=\"comment\"># &#123; device=\"/dev/mapper/ubuntu--vg-lv--0\", fstype=\"ext4\", instance=\"192.168.1.12:9100\", job=\"Linux\", mountpoint=\"/\"&#125; \t96.94237518310547</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2) 在选择器中至少一个匹配器的值不能与空字符串相匹配。如 &#123;foo=\"\", foo!=\"\"&#125; 和 &#123;foo =~ \".*\"&#125; 将返回错误，而&#123;foo=\"\", bar=\"x\"&#125; 或 &#123;foo=~\".+\"&#125; 是正常的。</span></span><br><span class=\"line\">node_filesystem_size_bytes&#123;job=~<span class=\"string\">\"Linux\"</span>, mountpoint=~<span class=\"string\">\"/$\"</span>&#125; / 1024^3</span><br><span class=\"line\">  <span class=\"comment\"># &#123; device=\"/dev/mapper/ubuntu--vg-lv--0\", fstype=\"ext4\", instance=\"192.168.1.12:9100\", job=\"Linux\", mountpoint=\"/\"&#125;   96.94237518310547</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (3) 此选择所有prometheus_http_requests_total的时间序列staging， testing以及development环境和HTTP除开GET的其他方法。</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"6-偏移修改器-Offset\"><a href=\"#6-偏移修改器-Offset\" class=\"headerlink\" title=\"6.偏移修改器 - (Offset)\"></a>6.偏移修改器 - (<code>Offset</code>)</h3><p>描述: 该修饰符可以适用于任意类型的向量选择器，它可以让你获取查询执行时间，并在每个选择器的当前基础上将其回退到过去的这个时间上, 即可以改变时间为查询中的个别时刻和范围矢量偏移。。</p>\n<p>Tips: 请注意 <code>offset 修饰符</code>总是需要立即跟随选择器</p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如，以下表达式返回 prometheus_http_requests_total过去 5 分钟相对于当前查询评估时间的值：</span></span><br><span class=\"line\">prometheus_http_requests_total offset <span class=\"number\">5</span>m</span><br><span class=\"line\">sum(prometheus_http_requests_total&#123;method=<span class=\"string\">\"GET\"</span>&#125; offset <span class=\"number\">5</span>m) <span class=\"comment\">// GOOD.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询 localhost:9090 执行的内存使用情况</span></span><br><span class=\"line\">process_resident_memory_bytes&#123;instance=<span class=\"string\">\"localhost:9090\"</span>&#125;  <span class=\"comment\">// 731750400</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询 localhost:9090 执行时间前一个小时的内存使用情况</span></span><br><span class=\"line\">process_resident_memory_bytes&#123;instance=<span class=\"string\">\"localhost:9090\"</span>&#125; offset <span class=\"number\">1</span>h <span class=\"comment\">// 748228608</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如，同样适用于范围向量, 查询在过去的1h内导出器暴露使用的cpu变化请求（适用于范围变量）</span></span><br><span class=\"line\">rate(process_cpu_seconds_total&#123;instance=<span class=\"string\">\"localhost:9090\"</span>&#125;[<span class=\"number\">5</span>m]) </span><br><span class=\"line\">- </span><br><span class=\"line\">rate(process_cpu_seconds_total&#123;instance=<span class=\"string\">\"localhost:9090\"</span>&#125;[<span class=\"number\">5</span>m] offset <span class=\"number\">1</span>h)  <span class=\"comment\">// \t-0.006089652962922479</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"7-修饰符\"><a href=\"#7-修饰符\" class=\"headerlink\" title=\"7.修饰符 - @\"></a>7.修饰符 - <code>@</code></h3><p>描述: 所述@改性剂允许改变评价时间为查询中的个别时刻和范围的载体。提供给@修饰符的时间是一个 unix 时间戳并用浮点文字描述。</p>\n<p>Tips : 请注意，@修饰符总是需要立即跟随选择器。<br>Tips : 默认情况下禁用此修饰符, 此功能通过设置 <code>--enable-feature=promql-at-modifier</code> 标志启用。</p>\n<p><br></p>\n<p><strong>示例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如，以下表达式返回 prometheus_prometheus_http_requests_total的值 2021-01-04T07:40:00+00:00：</span></span><br><span class=\"line\">prometheus_prometheus_http_requests_total&#123;handler=<span class=\"string\">\"/metrics\"</span>&#125; @ <span class=\"number\">1609746000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如，@修饰符总是需要立即跟随选择器</span></span><br><span class=\"line\">sum(prometheus_prometheus_http_requests_total&#123;handler=<span class=\"string\">\"/metrics\"</span>&#125; @ <span class=\"number\">1609746000</span>) <span class=\"comment\">// GOOD.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如，适用于范围向量，将返回5分钟的速度 prometheus_prometheus_http_requests_total 曾在2021-01-04T07:40:00+00:00：</span></span><br><span class=\"line\">rate(prometheus_prometheus_http_requests_total&#123;handler=<span class=\"string\">\"/metrics\"</span>&#125;[<span class=\"number\">5</span>m] @ <span class=\"number\">1609746000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如，@修饰符与offset修改器一起使用，其中偏移是相对于 @ 修改器时间应用的，而不管哪个修改器首先被写入</span></span><br><span class=\"line\"># offset after @</span><br><span class=\"line\">prometheus_prometheus_http_requests_total @ <span class=\"number\">1609746000</span> offset <span class=\"number\">5</span>m</span><br><span class=\"line\"># offset before @</span><br><span class=\"line\">prometheus_prometheus_http_requests_total offset <span class=\"number\">5</span>m @ <span class=\"number\">1609746000</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips : <code>start()</code> 并且 <code>end()</code> 还可以用作值@修正为特殊值, </p>\n<ul>\n<li>对于即时查询，start() 与 end() 都有的评估时间。</li>\n<li>对于范围查询, 它们分别解析为范围查询的开始和结束，并在所有步骤中保持不变。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prometheus_prometheus_http_requests_total @ start()</span><br><span class=\"line\">rate(prometheus_prometheus_http_requests_total[5m] @ end())</span><br></pre></td></tr></table></figure>\nmethod:prometheus_prometheus_http_requests_total:rate5m{method=”get”} </li>\n</ul>\n<p><br/></p>\n<h3 id=\"8-子查询\"><a href=\"#8-子查询\" class=\"headerlink\" title=\"8.子查询\"></a>8.子查询</h3><p>描述: 子查询允许您对给定的范围和分辨率运行即时查询。</p>\n<p>Tips : 子查询的结果是一个范围向量</p>\n<p>格式定义:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &lt;resolution&gt;是可选的。默认为全局评估区间。</span></span><br><span class=\"line\">&lt;instant_query&gt; <span class=\"string\">'['</span> &lt;<span class=\"keyword\">range</span>&gt; <span class=\"string\">':'</span> [&lt;resolution&gt;] <span class=\"string\">']'</span> [ @ &lt;float_literal&gt; ] [ offset &lt;duration&gt; ]</span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"9-查询类型\"><a href=\"#9-查询类型\" class=\"headerlink\" title=\"9.查询类型\"></a>9.查询类型</h3><h4 id=\"Counter-类型\"><a href=\"#Counter-类型\" class=\"headerlink\" title=\"Counter 类型\"></a>Counter 类型</h4><p>描述: 它是使用最频繁的数据类型，其记录的是事件的数量或者大小，通常用来跟踪某个特定代码路径被执行的频率，此类型其根本的的意义是计数器随着时间的推移而增加的速度。</p>\n<p>Tips : 对于PromQL而言必须确保Counter变量是递增的，只有这样才能保证rate或者其它函数不会把counter的减少误当做应用重启后Counter置零操作。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (1) 计算每秒接收的网络流量</span></span><br><span class=\"line\">rate(node_network_receive_bytes_total&#123;job=<span class=\"string\">\"Linux\"</span>&#125;[5m])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2) [5m]表示平均5min数据的比率其返回值将过去5min的每秒平均值。</span></span><br><span class=\"line\">sum without(device)(rate(node_network_receive_bytes_total&#123;job=<span class=\"string\">\"Linux\"</span>&#125;[5m]))</span><br><span class=\"line\">  <span class=\"comment\"># &#123; instance=\"192.168.1.12:9100\", job=\"Linux\"&#125;  575.2595748148149</span></span><br></pre></td></tr></table></figure>\n<p>Tips : 标签没有顺序或层次结构，允许你可以根据需求聚合尽可能多的标签。</p>\n<p><br/></p>\n<h4 id=\"Gauge-类型\"><a href=\"#Gauge-类型\" class=\"headerlink\" title=\"Gauge 类型\"></a>Gauge 类型</h4><p>描述: 存储的是当前状态的快照，其关心的是数值本身，因此此类型的数据类型的值可升可降。例如: 使用Gauge数据类型的例子包括队列中元素个数、缓存的内存使用率，活跃的线程数，最后一分钟时间里没秒的平均请求数。</p>\n<p>Tips : Gauge 提供三种主要的方法供你使用<code>inc(增加)、dec(减少)或者set方法</code>，并且可以将负值传递给Gauge类型的inc方法。</p>\n<ul>\n<li><p>查询计算每台计算机上文件系统的总大小。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum without(device,fstype,mountpoint)(node_filesystem_size_bytes&#123;job=<span class=\"string\">\"weiyigeek-Linux\"</span>&#125;) / 1024^3</span><br><span class=\"line\">  <span class=\"comment\"># &#123;env=\"prod\",instance=\"192.168.1.12:9100\", job=\"weiyigeek-Linux\"&#125; 201.34028244018555</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询每台机器上最大的挂载文件系统的大小。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">max without(device,fstype,mountpoint)(node_filesystem_size_bytes&#123;job=<span class=\"string\">\"weiyigeek-Linux\"</span>&#125;) / 1024^3</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># &#123;env=\"prod\", instance=\"192.168.1.12:9100\", job=\"weiyigeek-Linux\"&#125; \t100</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查询每台机器上挂载点平均的文件系统的大小。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">avg without(device,fstype,mountpoint)(node_filesystem_size_bytes&#123;job=<span class=\"string\">\"weiyigeek-Linux\"</span>&#125;) / 1024^3</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># &#123;env=\"prod\", instance=\"192.168.1.12:9100\", job=\"weiyigeek-Linux\"&#125; 18.303662040016867</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h4 id=\"Summary-类型\"><a href=\"#Summary-类型\" class=\"headerlink\" title=\"Summary 类型\"></a>Summary 类型</h4><p>描述: 该数据类型最常用的方法是observe可以通过该方法传递事件的大小<code>(注意必须是非负数)</code>即跟踪延迟。</p>\n<p>Tips: 该类型也可能包括了分为数,此外就CPU使用率而言，客户端分位数与其它测控相比是代价昂贵的(慢一百倍也不罕见)。</p>\n<p>例如: 利用 prometheus_http_response_size_bytes_count 指标 可以 跟踪API请求的数量。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (1) 查询并返回提供每秒的总请求数</span></span><br><span class=\"line\">sum without(handler)(rate(prometheus_http_response_size_bytes_count[5m]))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"LocalServer\"&#125; 0.015740740740740743</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2)查询并返回每个Handler返回的字节数</span></span><br><span class=\"line\">sum without(handler)(rate(prometheus_http_response_size_bytes_sum[5m]))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"LocalServer\"&#125; 156.97563272222223</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (3) 你将_sum 除以 _count(在执行rate后)来获得一段时间内的平均值，例如下面过去 5min 的平均响应大小为值。</span></span><br><span class=\"line\">sum without(handler)(rate(prometheus_http_response_size_bytes_sum[5m]))</span><br><span class=\"line\">/ </span><br><span class=\"line\">sum without(handler)(rate(prometheus_http_response_size_bytes_count[5m]))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"LocalServer\"&#125; 13236</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (4) 如果要获得一个任务的所有实例平均响应字节大小</span></span><br><span class=\"line\">sum without(instance) (</span><br><span class=\"line\">  sum without(handler)(rate(prometheus_http_response_size_bytes_sum[5m]))</span><br><span class=\"line\">)</span><br><span class=\"line\">/ </span><br><span class=\"line\">sum without(instance) (</span><br><span class=\"line\">  sum without(handler)(rate(prometheus_http_response_size_bytes_count[5m]))</span><br><span class=\"line\">)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"LocalServer\"&#125; 13236</span></span><br></pre></td></tr></table></figure>\n<p><br/></p>\n<h4 id=\"Histogram-类型\"><a href=\"#Histogram-类型\" class=\"headerlink\" title=\"Histogram 类型\"></a>Histogram 类型</h4><p>描述: 该类型指标允许你跟踪事件大小的分布（<code>提供平均延迟数据</code>），允许你用它们来计算分位数，分位数可以告诉你低于某个值的事件个数，例如: <code>0.95分位数为300ms</code>则代表95%的请求耗时小于300ms。</p>\n<p>Tips : 分位数和百分位我们说的95%是0.95分位数，由于更喜欢基本单位所以通常使用分位数，而在比例的时候优先使用百分位。</p>\n<p>Tips : Histogram 类型是有标签的。</p>\n<p><strong>桶(Buckets)说明</strong><br>描述: 默认的涵盖从1ms~10s范围内的延迟，我们可以定义指标的时候覆盖他们并提供自己的桶。建议保持在10个左右才能保证足够的准确率，该数字看起来很小的数字，但是存储桶是需要成本，并且每个桶都是一个额外的时序存储。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用于跟踪时序数据库压缩所需的秒数 : prometheus_tsdb_compaction_duration_seconds</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (1) 在0.90分位数将用于跟踪时序数据库压缩所需的秒数, 表明压缩的第90个百分位延约为 3.2s。</span></span><br><span class=\"line\">histogram_quantile(</span><br><span class=\"line\">  0.90,</span><br><span class=\"line\">  sum without(instance)(rate(prometheus_tsdb_compaction_duration_seconds_bucket[1d]))</span><br><span class=\"line\">)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;job=\"LocalServer\"&#125; 3.2 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2) 计算事件平均大小例如压缩平均持续时间。</span></span><br><span class=\"line\">sum without(instance)(rate(prometheus_tsdb_compaction_duration_seconds_sum[1d])) </span><br><span class=\"line\">/ </span><br><span class=\"line\">sum without(instance)(rate(prometheus_tsdb_compaction_duration_seconds_count[1d]))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;job=\"LocalServer\"&#125; 2.317425352000015</span></span><br></pre></td></tr></table></figure>\n<p>Tips : 通常使用<code>5~10 min</code>的间隔来进行直方图 <code>rate</code> 函数计算，所有桶中的时间序列将根据任何标签进行结合，并且rate范围越长，就会有更多的数据样本需要处理，所以我们要警惕使用<code>小时(hour)</code>或者<code>天数(Days)</code>范围的PromQL表达式, 因此它们的计算成本相对较高。</p>\n<p><br/></p>\n<h3 id=\"10-API查询指标数据\"><a href=\"#10-API查询指标数据\" class=\"headerlink\" title=\"10.API查询指标数据\"></a>10.API查询指标数据</h3><p>描述: Prometheus 提供了许多HTTP API, 它们允许你输入PromQL语句，并返回数据使得可以用在仪表板工具或自定义报告脚本中。</p>\n<h4 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h4><p>描述: 在给定的时间执行PromQL表达式并返回结果，注意其支持带入标签进行查询过滤的。</p>\n<p><strong>示例1：使用当前时间进行指标查询</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.0.0.107:30090/api/v1/query?query=go_info&#123;job=<span class=\"string\">\"Server\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#// 返回结果:</span></span><br><span class=\"line\">&#123;<span class=\"string\">\"status\"</span>:<span class=\"string\">\"success\"</span>,<span class=\"string\">\"data\"</span>:&#123;<span class=\"string\">\"resultType\"</span>:<span class=\"string\">\"vector\"</span>,<span class=\"string\">\"result\"</span>:[&#123;<span class=\"string\">\"metric\"</span>:&#123;<span class=\"string\">\"__name__\"</span>:<span class=\"string\">\"go_info\"</span>,<span class=\"string\">\"instance\"</span>:<span class=\"string\">\"localhost:9090\"</span>,<span class=\"string\">\"job\"</span>:<span class=\"string\">\"Server\"</span>,<span class=\"string\">\"version\"</span>:<span class=\"string\">\"go1.16.2\"</span>&#125;,<span class=\"string\">\"value\"</span>:[1629539549.827,<span class=\"string\">\"1\"</span>]&#125;]&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#// 结果说明:</span></span><br><span class=\"line\">status 字段 : success (查询有效) | error (查询有误)。</span><br><span class=\"line\">resultType 字段 : 结果类型是一个是个瞬时向量。</span><br><span class=\"line\">metric 字段 : 存放该指标的相关关联标签。</span><br><span class=\"line\">value 字段 : 第一个值为样本时间戳，第二个为其值</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>示例2:指定时间进行查询指标</strong><br>描述: 我们可以传入Unix格式的时间或者<code>RFC 3339</code>标准的时间<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.0.0.107:30090/api/v1/query?query=node_memory_Active_bytes&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;&amp;time=1629539549  <span class=\"comment\"># 2021-08-21 17:52:29</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回结果:</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"status\"</span>: <span class=\"string\">\"success\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"resultType\"</span>: <span class=\"string\">\"vector\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"result\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"metric\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"__name__\"</span>: <span class=\"string\">\"node_memory_Active_bytes\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"env\"</span>: <span class=\"string\">\"prod\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"instance\"</span>: <span class=\"string\">\"10.0.0.107:9100\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"job\"</span>: <span class=\"string\">\"linux_exporter\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"nodeType\"</span>: <span class=\"string\">\"master\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"value\"</span>: [</span><br><span class=\"line\">          1629539549,</span><br><span class=\"line\">          <span class=\"string\">\"5097132032\"</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>示例3: 支持范围向量进行查询（但一般都采用query_range 而非 query）</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.0.0.107:30090/api/v1/query?query=prometheus_http_requests_total&#123;handler=<span class=\"string\">\"/metrics\"</span>,instance=<span class=\"string\">\"localhost:9090\"</span>&#125;[5m]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回结果:</span></span><br><span class=\"line\">&#123;<span class=\"string\">\"status\"</span>:<span class=\"string\">\"success\"</span>,<span class=\"string\">\"data\"</span>:&#123;<span class=\"string\">\"resultType\"</span>:<span class=\"string\">\"matrix\"</span>,<span class=\"string\">\"result\"</span>:[&#123;<span class=\"string\">\"metric\"</span>:&#123;<span class=\"string\">\"__name__\"</span>:<span class=\"string\">\"prometheus_http_requests_total\"</span>,<span class=\"string\">\"code\"</span>:<span class=\"string\">\"200\"</span>,<span class=\"string\">\"handler\"</span>:<span class=\"string\">\"/metrics\"</span>,<span class=\"string\">\"instance\"</span>:<span class=\"string\">\"localhost:9090\"</span>,<span class=\"string\">\"job\"</span>:<span class=\"string\">\"Server\"</span>&#125;,<span class=\"string\">\"values\"</span>:[[1629540385.147,<span class=\"string\">\"8\"</span>],[1629540505.147,<span class=\"string\">\"9\"</span>]]&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>示例4.利用标量进行查询，其没有标签只是数字</strong><br>描述: 与 {} 不同，后者是一个没标签的时间序列标识符。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.0.0.107:30090/api/v1/query?query=1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 执行结果</span></span><br><span class=\"line\">&#123;<span class=\"string\">\"status\"</span>:<span class=\"string\">\"success\"</span>,<span class=\"string\">\"data\"</span>:&#123;<span class=\"string\">\"resultType\"</span>:<span class=\"string\">\"scalar\"</span>,<span class=\"string\">\"result\"</span>:[1629540849.286,<span class=\"string\">\"1\"</span>]&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"Query-range\"><a href=\"#Query-range\" class=\"headerlink\" title=\"Query_range\"></a>Query_range</h4><p>描述: 主要采用其api进行查询查询并返回范围向量的指标结果，其除了查询指标参数外，还有提供start、end、step参数。</p>\n<p>Tips : 将来自不同执行的所有瞬时向量组合成范围向量并返回。</p>\n<p>例如: 查询前15分钟内请求prometheus的/metric次数。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># start [2021-08-21 18:00:00 ==&gt; 1629540000]</span></span><br><span class=\"line\"><span class=\"comment\"># end [2021-08-21 18:15:00 ==&gt; 1629540900]</span></span><br><span class=\"line\"><span class=\"comment\"># step 60</span></span><br><span class=\"line\"></span><br><span class=\"line\">curl http://10.0.0.107:30090/api/v1/query?query=prometheus_http_requests_total&#123;handler=%22/metrics%22,instance=%22localhost:9090%22&#125;[5m]&amp;start=1629540000&amp;end=1629541800&amp;step=60</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 返回结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"status\"</span>: <span class=\"string\">\"success\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"resultType\"</span>: <span class=\"string\">\"matrix\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"result\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"metric\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"__name__\"</span>: <span class=\"string\">\"prometheus_http_requests_total\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"code\"</span>: <span class=\"string\">\"200\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"handler\"</span>: <span class=\"string\">\"/metrics\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"instance\"</span>: <span class=\"string\">\"localhost:9090\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"job\"</span>: <span class=\"string\">\"Server\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"values\"</span>: [</span><br><span class=\"line\">          [1629541465.147,<span class=\"string\">\"17\"</span>],</span><br><span class=\"line\">          [1629541585.147,<span class=\"string\">\"18\"</span>]</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"0x01-表达式语言运算符\"><a href=\"#0x01-表达式语言运算符\" class=\"headerlink\" title=\"0x01 表达式语言运算符\"></a>0x01 表达式语言运算符</h2><p>描述: Prometheus 支持许多二元和聚合运算符。</p>\n<p><br/></p>\n<h3 id=\"1-二元运算符\"><a href=\"#1-二元运算符\" class=\"headerlink\" title=\"1.二元运算符\"></a>1.二元运算符</h3><p>描述: Prometheus 的查询语言支持基本的逻辑和算术运算符。对于两个瞬时向量之间的操作，可以修改匹配行为。</p>\n<ul>\n<li><strong>1.1 二元算术运算符</strong><br>描述: 二元算术运算符定义在<code>标量/标量</code>、<code>向量/标量</code>和<code>向量/向量</code>值对之间。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+，-，*，/，%（模数），^（幂/幂）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 简单示例:</span></span><br><span class=\"line\">5 % 1.5  <span class=\"comment\"># ==&gt; scalar\t0.5</span></span><br><span class=\"line\">5 ^ 2    <span class=\"comment\"># ==&gt; scalar\t25</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Tips : 描述: 标量是没有维度的单个数字，是除了瞬时与范围向量之外，被称为标量类型的值。<br>例如, 0 是标量它的值为零。<br>例如, {} 0 是包含单个样本且没有标签且值为零的瞬时向量。</p>\n<p><br></p>\n<ul>\n<li><strong>1.2 比较二元运算符</strong><br>描述:在PromQL中比较运算符是过滤的<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 比较判断</span></span><br><span class=\"line\">==，!=，&gt;，&lt;，&gt;=，&lt;=, </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 正则匹配 以及 正则不匹配 的情况下</span></span><br><span class=\"line\">=~ , !~ </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 简单示例:</span></span><br><span class=\"line\"><span class=\"comment\"># 1.打开的文件描述符数量大于10的时间序列</span></span><br><span class=\"line\">process_open_fds &gt; 10 </span><br><span class=\"line\">10 &lt; process_open_fds  <span class=\"comment\"># 当比较标量和瞬时向量时，哪个在那一侧并不重要。</span></span><br><span class=\"line\">  <span class=\"comment\"># process_open_fds&#123;instance=\"localhost:9090\", job=\"Server\"&#125;\t49</span></span><br><span class=\"line\">  <span class=\"comment\"># process_open_fds&#123;app_kubernetes_io_name=\"kube-state-metrics\", app_kubernetes_io_version=\"2.0.0\", instance=\"172.16.182.233:8081\", job=\"k8s-endpoint-discover\", kubernetes_namespace=\"monitor\", service_name=\"kube-state-metrics\"&#125; 11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1.打开的文件描述符数量大于10且小于48的时间序列</span></span><br><span class=\"line\">10 &lt; process_open_fds  &lt; 48 </span><br><span class=\"line\">process_open_fds  &lt; 48 &gt; 10</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<ul>\n<li><strong>1.3 Bool 修饰符</strong><br>描述: 过滤主要用于告警规则，而bool是进行比较的一些方法而不是过滤。</li>\n</ul>\n<p>示例演示:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.该修饰符是比较标量的唯一方法</span></span><br><span class=\"line\"><span class=\"comment\"># 1024 &gt;= 42  会报如下: Error executing query: invalid parameter \"query\": 1:6: parse error: comparisons between scalars must use BOOL modifier 错误</span></span><br><span class=\"line\">1024 &gt;= bool 42   <span class=\"comment\"># scalar\t1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.获得打开十个以上文件描述符的每个任务的进程数</span></span><br><span class=\"line\">sort_desc(sum without(instance)(process_open_fds &gt;= bool 10))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;job=\"Server\"&#125; \t1       # 该 job 主机满足</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;job=\"linux_exporter\"&#125;\t0     # 该 job 主机无满足</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.查找具有四个以上的磁盘设备计算机的比例</span></span><br><span class=\"line\">avg without(instance)(count without(device)(node_disk_io_now) &gt; bool 4)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;job=\"linux_exporter\"&#125;\t0</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;job=\"linux_exporter\", nodeType=\"work\"&#125; \t0.6666666666666667</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<ul>\n<li><strong>1.4 逻辑二元运算符</strong><br>描述: 逻辑/集合二元运算符仅在即时向量之间定义<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">and , or, unless </span><br><span class=\"line\"></span><br><span class=\"line\">- or 操作符：每组左侧的组如都有样本则返回他们，否则返回右侧组中的样本。</span><br><span class=\"line\">- unless 操作符：根据右和左操作数中是否为空进行判断，除非右侧有成员，否则unless运算符返回左侧组。</span><br><span class=\"line\">- and 操作符: 与unless相反，仅当匹配的右侧有样本时，它才从左侧操作符返回一个组，否则他不返回该匹配的样本。你可将其视为<span class=\"keyword\">if</span>运算符。</span><br><span class=\"line\"><span class=\"comment\"># 说明:</span></span><br><span class=\"line\">vector1 unless vector2 : 产生一个向量，该向量 vector1 不匹配 vector2 完全匹配标签集的元素组成。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例演示:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># or 操作符示例</span></span><br><span class=\"line\"><span class=\"comment\"># 1.每组左侧的组都有样本然后返回他们，否则返回右侧组中的样本。</span></span><br><span class=\"line\">node_hwmon_temp_celsius or ignoring(label) (node_hwmon_sensor_label * 0 + 1)</span><br><span class=\"line\">  <span class=\"comment\"># node_hwmon_temp_celsius&#123;chip=\"platform_coretemp_0\", instance=\"10.0.0.223:9100\", job=\"linux_exporter\", sensor=\"temp10\"&#125; 30</span></span><br><span class=\"line\">node_hwmon_temp_celsius * ignoring(label) group_left(label) (node_hwmon_sensor_celsius  or ignoring(lable)(node_hwmon_temp_celsius * 0 + 1))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;chip=\"platform_coretemp_0\", instance=\"10.0.0.223:9100\", job=\"linux_exporter\",sensor=\"temp10\"&#125; \t28</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.将两者的指标都输出，但针对于up指标的值全部设置为0</span></span><br><span class=\"line\">node_uname_info or up&#123;job=<span class=\"string\">\"Server\"</span>&#125; * 0</span><br><span class=\"line\">  <span class=\"comment\"># node_uname_info&#123; instance=\"10.0.0.225:9100\", job=\"linux_exporter\", machine=\"x86_64\", nodename=\"weiyigeek-255\", release=\"5.4.0-42-generic\", sysname=\"Linux\", version=\"#46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020\"&#125; \t1</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># unless 操作符示例</span></span><br><span class=\"line\"><span class=\"comment\"># 1.除了使用少于100MB驻留内存进程外的其他进程平均CPU使用率，可以使用以下表达式。</span></span><br><span class=\"line\">rate(process_cpu_seconds_total[5m]) unless process_resident_memory_bytes &lt; 1024^2 * 100</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125; \t0.0016149975000000613</span></span><br><span class=\"line\"><span class=\"comment\"># 2.用于发现目标中缺少的指标。</span></span><br><span class=\"line\">up&#123;instance=<span class=\"string\">\"localhost:9090\"</span>&#125; == 1 unless node_custom</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.及时组的右操作数有多个样本，unless也可以在多对多匹配中使用。</span></span><br><span class=\"line\">up == 1 unless on (job,instance) node_custom</span><br><span class=\"line\">  <span class=\"comment\"># up&#123;instance=\"localhost:9090\", job=\"Server\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># and 操作符示例</span></span><br><span class=\"line\"><span class=\"comment\"># 1.希望在延迟时间很长并且用户请求较多时返回。处理程序超过一秒，并且每秒只有一个请求。</span></span><br><span class=\"line\">(rate(prometheus_http_request_duration_seconds_sum[5m]) </span><br><span class=\"line\"> /  </span><br><span class=\"line\">rate(prometheus_http_request_duration_seconds_count[5m])) </span><br><span class=\"line\"> &gt; 10^6 </span><br><span class=\"line\">and rate(prometheus_http_request_duration_seconds_count[5m]) &gt; 1</span><br><span class=\"line\">and on() hour() &gt; 9 &lt; 17</span><br></pre></td></tr></table></figure></p>\n<p>Tips : x * 0 + 1会将瞬时向量的所有值都更改为1。</p>\n<p><br/></p>\n<h3 id=\"2-修饰运算符\"><a href=\"#2-修饰运算符\" class=\"headerlink\" title=\"2.修饰运算符\"></a>2.修饰运算符</h3><p>描述: 向量之间的操作尝试为左侧的每个条目在右侧向量中找到匹配元素。</p>\n<p>Tips : 向量匹配是将两个瞬时向量之间使用运算符进行过滤或者查询。</p>\n<p>Tips : 向量匹配行为有两种基本类型<code>一对一</code>和<code>多对一</code>/<code>一对多</code>。</p>\n<ul>\n<li><strong>2.1 一对一向量匹配</strong><br>描述: 一对一从操作的每一侧找到一对唯一的条目。如果两个条目具有完全相同的一组标签和相应的值，则它们匹配.<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法</span></span><br><span class=\"line\">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) &lt;vector expr&gt; </span><br><span class=\"line\">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 语法示例：返回一个结果向量，其中包含在过去 5 分钟内测量的每种方法的状态代码为 500 的 HTTP 请求的比例</span></span><br><span class=\"line\">method_code:http_errors:rate5m&#123;code=<span class=\"string\">\"500\"</span>&#125; / ignoring(code) method:http_requests:rate5m</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>具体示例:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.查询目标机器已使用的进程打开的文件标识符占比(在两个时间序列标签匹配时)</span></span><br><span class=\"line\">process_open_fds&#123;instance=<span class=\"string\">\"localhost:9090\"</span>&#125; / process_max_fds&#123;instance=<span class=\"string\">\"localhost:9090\"</span>&#125; </span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"localhost:9090\", job=\"Server\"&#125; 0.00004863739013671875</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.匹配两个标签不完美匹配的瞬时变量。</span></span><br><span class=\"line\"><span class=\"comment\">// 每个实例CPU在idle模式下所占用的时间比例，使用ignoring(mode)时，将向量在分组时node标签将被丢弃，并匹配成功。</span></span><br><span class=\"line\">sum without(cpu) (rate(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;[<span class=\"number\">5</span>m])) /ignoring(mode) sum without(mode,cpu) (rate(node_cpu_seconds_total[<span class=\"number\">5</span>m]))</span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.107:9100\", job=\"linux_exporter\"&#125; 0.9783266498445258</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.108:9100\", job=\"linux_exporter\"&#125; 0.9760616305723038</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.109:9100\", job=\"linux_exporter\"&#125; 0.9807213018617855</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.指定保留标签的时间序列进行操作（示例中这样使用比较多余）</span></span><br><span class=\"line\">sum by(cpu) (rate(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;[<span class=\"number\">5</span>m])) / on(mode) sum by(mode,cpu) (rate(node_cpu_seconds_total[<span class=\"number\">5</span>m]))</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 当具有完全相同标签的样本将被匹配(组合)在一起。<br>Tips : 如果期望结果时返回为空的瞬时向量，则可能因为操作数的样本标签不匹配。</p>\n<p><br/></p>\n<ul>\n<li><strong>2.2 多对一和一对多向量匹配</strong><br>描述: 多对一和一对多匹配是指“一”端的每个向量元素可以与“多”端的多个元素匹配的情况。必须使用<code>group_left or group_right</code>修饰符明确请求，其中<code>左/右</code>确定哪个向量具有更高的基数。<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 语法格式</span></span><br><span class=\"line\">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class=\"line\">&lt;vector expr&gt; &lt;bin-op&gt; ignoring(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class=\"line\">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_left(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class=\"line\">&lt;vector expr&gt; &lt;bin-op&gt; on(&lt;label list&gt;) group_right(&lt;label list&gt;) &lt;vector expr&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例查询：分组修饰符只能用于 比较和 算术。默认情况下and，操作 asunless和 or操作与正确向量中的所有可能条目匹配。</span></span><br><span class=\"line\">method_code:http_errors:rate5m / ignoring(code) group_left method:http_requests:rate5m</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实际案例:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// # 1.允许你指定左侧操作数组中可以有多个匹配样本。（多对n-1）</span></span><br><span class=\"line\">sum without(cpu)(rate(node_cpu_seconds_total[<span class=\"number\">5</span>m])) / ignoring(mode) group_left sum without(mode,cpu)(rate(node_cpu_seconds_total[<span class=\"number\">5</span>m])) </span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.225:9100\", job=\"linux_exporter\", mode=\"user\"&#125;\t0.015867011327565222</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123; instance=\"10.0.0.225:9100\", job=\"linux_exporter\", mode=\"system\"&#125;\t0.0027793624511104906</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// # 2.允许你指定右侧操作数组中可以有多个匹配样本。（多对n-1）</span></span><br><span class=\"line\"> sum without(mode,cpu)(rate(node_cpu_seconds_total[<span class=\"number\">5</span>m])) / ignoring(mode) group_right sum without(cpu)(rate(node_cpu_seconds_total[<span class=\"number\">5</span>m]))</span><br></pre></td></tr></table></figure></p>\n<p>Tips : <code>多对一和一对多</code>匹配是应该仔细考虑的高级用例。通常正确可使用<code>ignoring(&lt;labels&gt;)</code>提供所需的结果。</p>\n<p><br></p>\n<h4 id=\"ignoring-修饰符\"><a href=\"#ignoring-修饰符\" class=\"headerlink\" title=\"ignoring 修饰符\"></a>ignoring 修饰符</h4><p>描述: 在匹配时忽略某些标签（类似于聚合操作中的without方式</p>\n<h4 id=\"on-修饰符\"><a href=\"#on-修饰符\" class=\"headerlink\" title=\"on 修饰符\"></a>on 修饰符</h4><p>描述: 在匹配时允许减少该组被认为标签来提供的列表（类似于聚合操作中的by方式）</p>\n<h4 id=\"group-left-修饰符\"><a href=\"#group-left-修饰符\" class=\"headerlink\" title=\"group_left 修饰符\"></a>group_left 修饰符</h4><p>描述: 该修饰符有两个功能，一是指定左侧操作数组中可以有多个匹配样本（<code>始终从左侧操作数的样本中获取所有标签</code>）确保保留左侧需要进行多对一向量匹配的额外标签，二是将信息指标中的标签添加到一个目标的其它指标中。</p>\n<p>简单示例:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># (1) 说明: 将Python_info中的version标签添加到up表达式匹配到所有的指标内。</span></span><br><span class=\"line\"><span class=\"comment\"># 即我们可以通过乘法运算符或者group_left修饰符连接到其它任何指标。</span></span><br><span class=\"line\">up * on (instance,job) group_left (version) python_info</span><br><span class=\"line\">  <span class=\"comment\"># 输出结果</span></span><br><span class=\"line\">  &#123;instance=<span class=\"string\">\"10.20.172.103:8000\"</span>, job=<span class=\"string\">\"control\"</span>, version=<span class=\"string\">\"3.7.3\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># (2) 目标设备的温度传感器</span></span><br><span class=\"line\">node_hwmon_temp_celsius * ignoring(label) group_left(label) node_hwmon_sensor_label</span><br><span class=\"line\">  <span class=\"comment\"># &#123;env=\"prod\", instance=\"10.0.0.224:9100\", job=\"linux_exporter\", label=\"package_id_0\", sensor=\"temp1\"&#125; 33</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips: 可使用任何运算符来连接指标，当信息指标的值为1时时候，乘法不会更改其他指标的值。</p>\n<h4 id=\"group-right-修饰符\"><a href=\"#group-right-修饰符\" class=\"headerlink\" title=\"group_right 修饰符\"></a>group_right 修饰符</h4><p>描述:  其工作方式与group_left相同，只是将操作对象从左换到右，但是通常使用group_left因为任何标签都是从左向右复制的，为了保证一致性以及方便人员理解所以推荐。</p>\n<p>简单示例:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.将左侧prometheus_build_info指标中的version,revision标签复制到右侧up指标中进行展示。</span></span><br><span class=\"line\">prometheus_build_info * on (instance) group_right(version,revision) up</span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"localhost:9090\", job=\"Server\", revision=\"3cafc58827d1ebd1a67749f88be4218f0bab3d8d\", version=\"2.26.0\"&#125; 1</span></span><br></pre></td></tr></table></figure></p>\n<p><br/></p>\n<h3 id=\"3-聚合运算符\"><a href=\"#3-聚合运算符\" class=\"headerlink\" title=\"3.聚合运算符\"></a>3.聚合运算符</h3><p>描述: Prometheus 支持以下内置聚合运算符，可用于聚合单个即时向量的元素，从而生成具有聚合值的更少元素的新向量。</p>\n<h4 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h4><p>描述: 在学习聚合运算符之前，需要了解实践序列的分组方式。</p>\n<p><strong>(1) Without 指定要删除的标签</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.将指标的device,mountpoint标签取消，并进行其它不同标签分组并求值只和</span></span><br><span class=\"line\">sum without(device,mountpoint)(node_filesystem_size_bytes&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;fstype=\"ext4\", instance=\"10.0.0.107:9100\", job=\"linux_exporter\"&#125;  105114386432</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;fstype=\"nfs\", instance=\"10.0.0.107:9100\", job=\"linux_exporter\"&#125;  2998958817280</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;fstype=\"tmpfs\", instance=\"10.0.0.107:9100\", job=\"linux_exporter\"&#125;   52056260608</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.当不为 without 提供标签时，输出效果与 node_filesystem_size_bytes 一致</span></span><br><span class=\"line\">sum without()(node_filesystem_size_bytes&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<p><strong>(2) By 指定要保留的标签</strong></p>\n<p>Tips : 何时用Without ，何时用By?<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下述两种情况使用By可能更有用。</span></span><br><span class=\"line\"><span class=\"comment\"># 1.与without不同的是它不会自动删除`__name__`标签</span></span><br><span class=\"line\">sort_desc(count by(__name__)(&#123;__name__=~<span class=\"string\">\"node_filesystem.+\"</span>&#125;))</span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_files&#123;&#125; \t116</span></span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_files_free&#123;&#125; \t116</span></span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_free_bytes&#123;&#125;  116</span></span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_readonly&#123;&#125;   \t116</span></span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_size_bytes&#123;&#125;  116</span></span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_avail_bytes&#123;&#125; 116</span></span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_device_error&#123;&#125; 116</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.删除任何你不知道的标签。</span></span><br><span class=\"line\">count by(release)(node_uname_info)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;release=\"5.4.0-70-generic\"&#125; \t1</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;release=\"5.4.0-60-generic\"&#125; \t2</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;release=\"5.4.0-42-generic\"&#125; \t3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.可以使用sum和一个空的by，甚至可以忽略by，例如</span></span><br><span class=\"line\">sum by()(node_uname_info) <span class=\"comment\"># ==&gt;&gt; sum(node_uname_info)</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;&#125; \t6  # 单一时间序列，该时间序列没有标签。</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h4><p>描述: 聚合运算符寄仅适用于瞬时向量，也输出瞬时向量。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 聚合运算符列表</span></span><br><span class=\"line\">sum （计算维度的总和）</span><br><span class=\"line\">min （选择最小尺寸）</span><br><span class=\"line\">max （选择最大尺寸）</span><br><span class=\"line\">avg （计算维度上的平均值）</span><br><span class=\"line\">group （结果向量中的所有值都是 1）</span><br><span class=\"line\">stddev （计算维度上的总体标准偏差）</span><br><span class=\"line\">stdvar （计算维度上的总体标准方差）</span><br><span class=\"line\">count （计算向量中元素的数量）</span><br><span class=\"line\">count_values （计算具有相同值的元素数）</span><br><span class=\"line\">bottomk （样本值的最小 k 个元素）</span><br><span class=\"line\">topk （样本值最大的 k 个元素）</span><br><span class=\"line\">quantile （在维度上计算 φ-分位数 (0 ≤ φ ≤ 1)）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 语法格式:</span></span><br><span class=\"line\">&lt;aggr-op&gt; [without|by (&lt;label list&gt;)] ([parameter,] &lt;vector expression&gt;)</span><br><span class=\"line\">&lt;aggr-op&gt;([parameter,] &lt;vector expression&gt;) [without|by (&lt;label list&gt;)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 参数说明:</span></span><br><span class=\"line\">- &lt;label list&gt; : 是加引号的标签，可以包括后面的逗号.</span><br><span class=\"line\">- without : 从结果向量中删除列出的标签，而所有其他标签都保留在输出中.</span><br><span class=\"line\">- by : 执行相反的操作并删除by子句中未列出的标签，即使它们的标签值在向量的所有元素之间都相同。</span><br><span class=\"line\">- parameter : 取值 count_values，quantile，topk和 bottomk。</span><br></pre></td></tr></table></figure></p>\n<p><strong>实例演示:</strong><br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.通过以下方式计算每个应用程序和组在所有实例上看到的 HTTP 请求总数</span></span><br><span class=\"line\">sum without (instance) (prometheus_prometheus_http_requests_total)</span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/alerts\", job=\"LocalServer\"&#125;\t10</span></span><br><span class=\"line\">sum by (code, handler) (prometheus_prometheus_http_requests_total)</span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/metrics\"&#125; 83458</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.计算运行每个构建版本的二进制文件的数量，</span></span><br><span class=\"line\">count_values(<span class=\"string\">\"version\"</span>, go_info) <span class=\"comment\">//&#123;version=\"1\"&#125; 62</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.要在所有实例中获得 5 个最大的 HTTP 请求数，</span></span><br><span class=\"line\">topk(<span class=\"number\">5</span>, prometheus_prometheus_http_requests_total)</span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/metrics\", instance=\"localhost:9090\", job=\"LocalServer\"&#125; 83467</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/api/v1/query_range\", instance=\"localhost:9090\", job=\"LocalServer\"&#125; 6283</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/api/v1/query\", instance=\"localhost:9090\", job=\"LocalServer\"&#125; \t5095</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/api/v1/series\", instance=\"localhost:9090\", job=\"LocalServer\"&#125; \t460</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/api/v1/label/:name/values\", instance=\"localhost:9090\", job=\"LocalServer\"&#125; \t186</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips ：运算符既可用于聚合所有标签维度，也可通过包含withoutorby子句来保留不同的维度</p>\n<p><br></p>\n<h3 id=\"4-运算符优先级\"><a href=\"#4-运算符优先级\" class=\"headerlink\" title=\"4.运算符优先级\"></a>4.运算符优先级</h3><p>描述：下面的列表显示了 Prometheus 中二元运算符的优先级，从高到低。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">^</span><br><span class=\"line\">*, /,%</span><br><span class=\"line\">+, -</span><br><span class=\"line\">==, !=, &lt;=, &lt;, &gt;=,&gt;</span><br><span class=\"line\">and, unless</span><br><span class=\"line\">or</span><br></pre></td></tr></table></figure></p>\n<p>Tips :相同优先级的运算符是左结合的。例如<code>2 * 3 % 2</code>相当于<code>(2 * 3) % 2</code>, 然而^是右结合的，所以 <code>2 ^ 3 ^ 2</code>等价于<code>2 ^ (3 ^ 2)</code>。</p>\n<hr>\n<h2 id=\"0x02-PromQL-内置函数介绍\"><a href=\"#0x02-PromQL-内置函数介绍\" class=\"headerlink\" title=\"0x02 PromQL 内置函数介绍\"></a>0x02 PromQL 内置函数介绍</h2><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：<code>year(v=vector(time()) instant-vector)</code>。其中参数 v 是一个瞬时向量，如果不提供该参数，将使用默认值 <code>vector(time())</code>, <code>instant-vector 表示参数类型 {} : 1626661808.684</code>。</p>\n<p>官方参考: <a href=\"https://prometheus.io/docs/prometheus/latest/querying/functions/\" target=\"_blank\" rel=\"noopener\">https://prometheus.io/docs/prometheus/latest/querying/functions/</a></p>\n<p><br></p>\n<h3 id=\"1-聚合函数\"><a href=\"#1-聚合函数\" class=\"headerlink\" title=\"1.聚合函数\"></a>1.聚合函数</h3><h4 id=\"sum-函数\"><a href=\"#sum-函数\" class=\"headerlink\" title=\"sum 函数\"></a>sum 函数</h4><p>描述: 我们可以根据path标签进行聚合操作，sum函数可以对样本进行做求和操作。</p>\n<p><strong>分组:</strong></p>\n<ul>\n<li>without 字句: 表示要移除的标签。</li>\n<li><p>by 字句: 表示只显示的标签。</p>\n</li>\n<li><p>1) PromQL: <code>sum by(path)(rate(http_requested_total[2m]))</code>, 说明: 聚合求和操作只显示指定标签的键、值</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path=<span class=\"string\">\"/\"</span>&#125; 0</span><br><span class=\"line\">&#123;path=<span class=\"string\">\"/api/\"</span>&#125; 0.03333333333333333</span><br><span class=\"line\">&#123;path=<span class=\"string\">\"/favicon.ico\"</span>&#125; 0.04444444444444444</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2) PromQL: <code>sum without(path)(rate(http_requested_total[2m]))</code>, 说明: 聚合求和操作除了指定标签的包括其它标签的键、值。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;instance=<span class=\"string\">\"10.20.172.103:8000\"</span>, job=<span class=\"string\">\"control\"</span>, method=<span class=\"string\">\"GET\"</span>&#125; 0.040740740740740744</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h4 id=\"avg-函数\"><a href=\"#avg-函数\" class=\"headerlink\" title=\"avg() 函数\"></a>avg() 函数</h4><p>描述: 将返回组中时间序列所以值的平均数来作为组的值。</p>\n<p>示例演示:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) 返回每个节点实例每种CPU模式的平均使用情况</span></span><br><span class=\"line\">avg without(cpu)(node_cpu_seconds_total&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;)</span><br><span class=\"line\">  <span class=\"comment\">// 与下面效果一致 </span></span><br><span class=\"line\">  <span class=\"comment\">// sum without(cpu)(node_cpu_seconds_total&#123;instance=\"10.0.0.107:9100\"&#125;) </span></span><br><span class=\"line\">  <span class=\"comment\">// / </span></span><br><span class=\"line\">  <span class=\"comment\">// count without(cpu)(node_cpu_seconds_total&#123;instance=\"10.0.0.107:9100\"&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"steal\"</span>&#125;\t<span class=\"number\">0</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"system\"</span>&#125;\t<span class=\"number\">80513.27249999999</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"user\"</span>&#125;\t<span class=\"number\">162807.48375</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"idle\"</span>&#125;\t<span class=\"number\">12163467.506250001</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"iowait\"</span>&#125;\t<span class=\"number\">8603.5525</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"irq\"</span>&#125;\t<span class=\"number\">0</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"nice\"</span>&#125;\t<span class=\"number\">212.6525</span></span><br><span class=\"line\">&#123; instance=<span class=\"string\">\"10.0.0.107:9100\"</span>, job=<span class=\"string\">\"linux_exporter\"</span>, mode=<span class=\"string\">\"softirq\"</span>&#125;\t<span class=\"number\">4911.07375</span></span><br></pre></td></tr></table></figure></p>\n<p>TIPS : 有时你会发现输入中存在NaN时都会导致整个结果变为NaN(任何涉及NaN的浮点数运算都会产生NaN)，并且 1 / 0 时也会输出NaN。</p>\n<p><br></p>\n<h4 id=\"count-函数\"><a href=\"#count-函数\" class=\"headerlink\" title=\"count() 函数\"></a>count() 函数</h4><p>描述: count 集合将计算并返回分组中的时间序列数。</p>\n<p>示例演示:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.返回机器包含的磁盘设备数量</span></span><br><span class=\"line\">count without(device)(node_disk_read_bytes_total&#123;device=~<span class=\"string\">\"sd.+\"</span>,instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;)</span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.107:9100\", job=\"linux_exporter\"&#125; 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.计数标签有多少个不同的值例如返回该目标的实例的CPU数量</span></span><br><span class=\"line\">count without(cpu)(count without(mode)(node_cpu_seconds_total&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;))</span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.107:9100\", job=\"linux_exporter\"&#125;\t8 // 8 核</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.生成没有标签的单个样本。</span></span><br><span class=\"line\">count(count without(cpu)(node_cpu_seconds_total&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;))</span><br><span class=\"line\">  <span class=\"comment\">// &#123;&#125; 8</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"count-values-函数\"><a href=\"#count-values-函数\" class=\"headerlink\" title=\"count_values() 函数\"></a>count_values() 函数</h4><p>描述: 该函数可以从一个组中返回多个时间序列。并按照组中的时间序列值建立频率直方图，每个值的计数作为输出时间序列的值，原始值作为新标签。</p>\n<p>示例演示:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.查询目标系统中有几个的内核版本数</span></span><br><span class=\"line\">count_values(<span class=\"string\">\"kernelVersion\"</span>,count without(instance,version,nodename,nodeType)(node_uname_info))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;kernelVersion=\"1\"&#125;\t1</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;kernelVersion=\"2\"&#125;\t1</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;kernelVersion=\"3\"&#125;\t1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.查询机器数和磁盘设备数</span></span><br><span class=\"line\">count_values without(instance)(<span class=\"string\">\"devices\"</span>,count without(device)(node_disk_io_now))</span><br><span class=\"line\">count_values without(instance)(<span class=\"string\">\"devices\"</span>,count without(device)(node_disk_io_now&#123;device=~<span class=\"string\">\"sd.+\"</span>&#125;))</span><br><span class=\"line\">  <span class=\"comment\"># 表示有三台机器只有一块物理硬盘</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;devices=\"1\", env=\"prod\", job=\"linux_exporter\"&#125;\t3</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips: count_values 可与count 结合使用，来计算给定的聚合组的唯一值的数量。</p>\n<p><br></p>\n<h4 id=\"min-函数\"><a href=\"#min-函数\" class=\"headerlink\" title=\"min() 函数\"></a>min() 函数</h4><h4 id=\"max-函数\"><a href=\"#max-函数\" class=\"headerlink\" title=\"max() 函数\"></a>max() 函数</h4><p>描述: 两个聚合函数分别求取组内最小或最大值作为组的返回值。</p>\n<p>示例演示:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min without(device,fstype,mountpoint)(node_filesystem_size_bytes)</span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.224:9100\", job=\"linux_exporter\"&#125; \t5242880</span></span><br><span class=\"line\"></span><br><span class=\"line\">max without(device,fstype,mountpoint)(node_filesystem_size_bytes)</span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.223:9100\", job=\"linux_exporter\"&#125;\t2998958817280</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips : 如果组中的值存在是NaN，则结果也仅仅返回NaN</p>\n<p><br></p>\n<h4 id=\"stddev-函数\"><a href=\"#stddev-函数\" class=\"headerlink\" title=\"stddev() 函数\"></a>stddev() 函数</h4><h4 id=\"stdvar-函数\"><a href=\"#stdvar-函数\" class=\"headerlink\" title=\"stdvar() 函数\"></a>stdvar() 函数</h4><p>描述: 标准差是对一组数字的离散程度进行统计测量。在监控中标准差的主要用于检测异常值。<br>例如, 你有数字{2,4,6}和{3，4，5}其平均值都是4，前者的标准差为 1.633，后者标准差为0.816</p>\n<p>例如，两组数的集合{0,5,9,14}和{5,6,8,9}其平均值都是7，但第二个集合具有较小的标准差。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">平均数: 0 + 5 + 9 + 14 / 4 = 7</span><br><span class=\"line\"><span class=\"comment\"># 此处样本数量较少所以直接采用 n (样本个数)</span></span><br><span class=\"line\">方差: ((0-7)^2 + (5-7)^2 + (9-7)^2 + (14-7)^2) / 4 = (49 + 4 + 4 + 49) / 4  = 106 / 4 = 26.5</span><br><span class=\"line\">标准差: sqrt(方差) = sqrt(26.5) = 5.1478150704935</span><br><span class=\"line\">  <span class=\"comment\"># go 语言中</span></span><br><span class=\"line\">  <span class=\"comment\"># fmt.Println(float64(106) / float64(4))</span></span><br><span class=\"line\">  <span class=\"comment\"># fmt.Println(math.Sqrt(float64(106) / float64(4)))</span></span><br></pre></td></tr></table></figure></p>\n<p>示例演示:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例如，可以使用以下表达式找到比平均值至少高出2两个标准差的实例</span></span><br><span class=\"line\">some_gauge_metrics &gt; ingnoring (instance)(some_gauge_metrics)</span><br><span class=\"line\">(</span><br><span class=\"line\">  avg without (instance) (some_gauge_metrics)</span><br><span class=\"line\">  +</span><br><span class=\"line\">  2 * stddev without (instance) (some_gauge_metrics)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 标准方差是标准差的平方。<br>Tips: 因为有两个定义,用在不同的场合<code>如是总体,标准差公式根号内除以n,如是样本,标准差公式根号内除以（n-1)</code>,因为我们大量接触的是样本,所以<code>普遍使用根号内除以（n-1)</code>,</p>\n<p><br></p>\n<h4 id=\"topk-函数\"><a href=\"#topk-函数\" class=\"headerlink\" title=\"topk() 函数\"></a>topk() 函数</h4><h4 id=\"bottomk-函数\"><a href=\"#bottomk-函数\" class=\"headerlink\" title=\"bottomk() 函数\"></a>bottomk() 函数</h4><p>描述: 该函数与其它聚合函数三个不同的地方，第一，它们返回的是时间序列的标签而非分组标签，第二，每组可以返回多个时间序列，第三，它们采用额外的参数。</p>\n<ul>\n<li>topk() 函数: 返回分组中最大的k个时间序列。</li>\n<li>tottomk() 函数: 返回分组中最小的k个时间序列。</li>\n</ul>\n<p>示例演示:<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) 返回值最大的2个时间序列，并且每组最多返回两个时间序列。</span></span><br><span class=\"line\">topk without(device,fstype,mountpoint)(<span class=\"number\">2</span>,node_filesystem_size_bytes&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;) </span><br><span class=\"line\">  <span class=\"comment\">// node_filesystem_size_bytes&#123; device=\"192.168.1.3:/nask8sapp\", fstype=\"nfs\", instance=\"10.0.0.107:9100\", job=\"linux_exporter\", mountpoint=\"/nfsdisk-31\"&#125; 2998958817280</span></span><br><span class=\"line\">  <span class=\"comment\">// node_filesystem_size_bytes&#123; device=\"/dev/mapper/ubuntu--vg-lv--0\", fstype=\"ext4\", instance=\"10.0.0.107:9100\", job=\"linux_exporter\", mountpoint=\"/\"&#125; 104091082752</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (2) 返回值最小的2个时间序列，并且每组最多返回两个时间序列。</span></span><br><span class=\"line\">bottomk without(device,fstype,mountpoint)(<span class=\"number\">2</span>,node_filesystem_size_bytes&#123;instance=<span class=\"string\">\"10.0.0.107:9100\"</span>&#125;) / <span class=\"number\">1024</span>^<span class=\"number\">3</span>  <span class=\"comment\">// 使用运算符时会删除__name__标签。</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;device=\"tmpfs\", fstype=\"tmpfs\", instance=\"10.0.0.107:9100\", job=\"linux_exporter\", mountpoint=\"/run/lock\"&#125; 0.0048828125</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;device=\"/dev/sda2\", fstype=\"ext4\", instance=\"10.0.0.107:9100\", job=\"linux_exporter\", mountpoint=\"/boot\"&#125; 0.9530258178710938</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (3) 计算过去一个小时内的最大时间序列返回前5</span></span><br><span class=\"line\">topk(<span class=\"number\">5</span>,avg_over_time(prometheus_http_requests_total[<span class=\"number\">1</span>h])) </span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/metrics\", instance=\"localhost:9090\", job=\"Server\"&#125;\t518.5</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/api/v1/query\", instance=\"localhost:9090\", job=\"Server\"&#125;\t69.30000000000001</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/static/*filepath\", instance=\"localhost:9090\", job=\"Server\"&#125;\t6</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"400\", handler=\"/api/v1/query\", instance=\"localhost:9090\", job=\"Server\"&#125;\t3.933333333333333</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;code=\"200\", handler=\"/api/v1/label/:name/values\", instance=\"localhost:9090\", job=\"Server\"&#125;\t3</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips: 该topk聚合函数不会删除<code>__name__</code>标签，但是如果<code>针对其数据进行运算时或者包含其它函数时</code>会删除<code>__name__</code>标签（看上述两个示例），它们会在结果中展示。</p>\n<p><br></p>\n<h4 id=\"quantile-函数\"><a href=\"#quantile-函数\" class=\"headerlink\" title=\"quantile() 函数\"></a>quantile() 函数</h4><p>描述: 该聚合函数指定分位数的值作为组的返回值，适用于对瞬时向量做跨聚合组查询,并且与topk类似分位数使用一个参数。</p>\n<ul>\n<li><p>例如1, 查询不同目标机器中CPU系统模式使用率的第90百分位是多少。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 意味着在90%的CPU每秒至少有0.007秒处于系统模式。</span></span><br><span class=\"line\">quantile without(cpu) (<span class=\"number\">0.9</span>,rate(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"system\"</span>&#125;[<span class=\"number\">5</span>m]))</span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.224:9100\", job=\"linux_exporter\", mode=\"system\"&#125; \t0.007323449333398858</span></span><br><span class=\"line\">  <span class=\"comment\">// &#123;instance=\"10.0.0.225:9100\", job=\"linux_exporter\", mode=\"system\"&#125;   0.0032833333333352737</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>例如2,使用分位数来显示图表中的中位数，第25百分位数和第75百分位数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">quantile without(instance) (<span class=\"number\">0.75</span>,rate(process_cpu_seconds_total[<span class=\"number\">5</span>m]))</span><br><span class=\"line\">  <span class=\"comment\">// &#123;job=\"Server\"&#125; 0.0024166666666666004</span></span><br><span class=\"line\"></span><br><span class=\"line\">quantile without(instance) (<span class=\"number\">0.25</span>,rate(process_cpu_seconds_total[<span class=\"number\">5</span>m]))</span><br><span class=\"line\">  <span class=\"comment\">// &#123;job=\"Server\"&#125; 0.0024166666666666004</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br/></p>\n<h3 id=\"2-类型函数\"><a href=\"#2-类型函数\" class=\"headerlink\" title=\"2.类型函数\"></a>2.类型函数</h3><h4 id=\"vector-函数\"><a href=\"#vector-函数\" class=\"headerlink\" title=\"vector() 函数\"></a>vector() 函数</h4><p>描述: <code>vector(s scalar)</code> 函数将标量 s 作为没有标签的向量返回，<code>即返回结果为：key: value= {}, s</code>, 将其转换为一个无标签的瞬时向量的样本并给予定值。</p>\n<p>例如，vector(1024) 返回 <code>{} 1024</code><br>例如, sum(node_not_metrics) or vector(1024) 返回 <code>{} 1024</code>, 不存在的指标也始终返回一个样本。</p>\n<p><br></p>\n<h4 id=\"scalar-函数\"><a href=\"#scalar-函数\" class=\"headerlink\" title=\"scalar() 函数\"></a>scalar() 函数</h4><p>描述: <code>scalar(v instant-vector)</code> 函数的参数是一个单元素的瞬时向量, 它返回其唯一的时间序列的值作为一个标量。</p>\n<p>Tips：如果度量指标的样本数量大于 1 或者等于 0, 则返回 NaN，它在处理标量常量时非常有用。</p>\n<p>示例演示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.处理标量常量且仅仅适用于瞬时向量的数学函数</span></span><br><span class=\"line\">scalar(sqrt(vector(4)))  <span class=\"comment\"># &gt;&gt; scalar\t2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.与时间函数连用</span></span><br><span class=\"line\">scalar(year())  <span class=\"comment\"># &gt;&gt; scalar\t2021</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.为你提供计算机CPU非空闲的时间比例(使用scalar会丢失所有的标签)</span></span><br><span class=\"line\">  sum(rate(node_cpu_seconds_total&#123;mode!=<span class=\"string\">\"idle\"</span>&#125;[5m])) / scalar(count(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;)) <span class=\"comment\"># &#123;&#125; 0.017490234375018142</span></span><br></pre></td></tr></table></figure><br><br/></p>\n<h3 id=\"3-数学函数\"><a href=\"#3-数学函数\" class=\"headerlink\" title=\"3.数学函数\"></a>3.数学函数</h3><p>描述: 数学函数对瞬时向量执行标准数学计算。并且瞬时向量中的每个样本都独立处理，返回值将删除指标名称。</p>\n<h4 id=\"abs-函数\"><a href=\"#abs-函数\" class=\"headerlink\" title=\"abs() 函数\"></a>abs() 函数</h4><p>描述: <code>abs(v instant-vector)</code> 返回输入向量的所有样本的绝对值。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abs(vector(time()))  <span class=\"comment\"># &#123;&#125; 1626662058.627</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"ln-函数\"><a href=\"#ln-函数\" class=\"headerlink\" title=\"ln() 函数\"></a>ln() 函数</h4><p>描述: ln(v instant-vector) 计算瞬时向量 v 中所有样本数据的自然对数。特殊情况：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln(+Inf) = +Inf</span><br><span class=\"line\">ln(0) = -Inf</span><br><span class=\"line\">ln(x &lt; 0) = NaN</span><br><span class=\"line\">ln(NaN) = NaN</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"log2-函数\"><a href=\"#log2-函数\" class=\"headerlink\" title=\"log2() 函数\"></a>log2() 函数</h4><p>描述: <code>log2(v instant-vector)</code> 函数计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况同上。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log2(vector(2)) <span class=\"comment\"># &#123;&#125;\t1</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"log10-函数\"><a href=\"#log10-函数\" class=\"headerlink\" title=\"log10() 函数\"></a>log10() 函数</h4><p>描述: <code>log10(v instant-vector)</code> 计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况同上。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log2(vector(10)) <span class=\"comment\"># &#123;&#125;\t1</span></span><br></pre></td></tr></table></figure><br><br></p>\n<h4 id=\"exp-函数\"><a href=\"#exp-函数\" class=\"headerlink\" title=\"exp() 函数\"></a>exp() 函数</h4><p>描述: <code>exp(v instant-vector)</code> 函数，输入一个瞬时向量，返回各个样本值的 e 的指数值，即 e 的 N 次方。当 N 的值足够大时会返回 +Inf。</p>\n<p>Tips ： exp 函数提供自然对数，与ln函数相反。</p>\n<p>特殊情况为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exp(+Inf) = +Inf</span><br><span class=\"line\">Exp(NaN) = NaN</span><br><span class=\"line\">exp(vector(1))  <span class=\"comment\"># &#123;&#125; \t2.718281828459045 欧拉数字e</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"sqrt-函数\"><a href=\"#sqrt-函数\" class=\"headerlink\" title=\"sqrt() 函数\"></a>sqrt() 函数</h4><p>描述: <code>sqrt(v instant-vector)</code> 函数计算向量 v 中所有元素的平方根。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sqrt(vector(9)) <span class=\"comment\"># &#123;&#125; 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># sqrt 早于指数运算符^，例如</span></span><br><span class=\"line\">vector(9) ^ 0.5   <span class=\"comment\"># &#123;&#125; 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同样如果你需要其它方根，例如</span></span><br><span class=\"line\">vector(9) ^ (1/3)  <span class=\"comment\"># &#123;&#125; \t2.080083823051904</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h4 id=\"ceil-函数\"><a href=\"#ceil-函数\" class=\"headerlink\" title=\"ceil() 函数\"></a>ceil() 函数</h4><p>描述: <code>ceil (v instant-vector)</code>将 v 中所有元素的样本值<code>向上四舍五入</code>到最接近的整数。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_load5&#123;instance=<span class=\"string\">\"192.168.1.75:9100\"</span>&#125;       <span class=\"comment\"># 结果为 2.79</span></span><br><span class=\"line\">ceil(node_load5&#123;instance=<span class=\"string\">\"192.168.1.75:9100\"</span>&#125;) <span class=\"comment\"># 结果为 3</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"floor-函数\"><a href=\"#floor-函数\" class=\"headerlink\" title=\"floor() 函数\"></a>floor() 函数</h4><p>描述: <code>floor(v instant-vector)</code> 函数与 ceil() 函数相反，将 v 中所有元素的样本值<code>向下四舍五入</code>到最接近的整数。</p>\n<p><br></p>\n<h4 id=\"round-函数\"><a href=\"#round-函数\" class=\"headerlink\" title=\"round() 函数\"></a>round() 函数</h4><p>描述: <code>round(v instant-vector, to_nearest=1 scalar)</code> 函数与 ceil 和 floor 函数类似，返回向量中所有样本值的最接近的整数。to_nearest 参数是可选的, 默认为 1 表示样本返回的是最接近 1 的整数倍的值。你也可以将该参数指定为任意值（也可以是小数），表示样本返回的是最接近它的整数倍的值。</p>\n<p>实例演示:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ceil(vector(6.5))  <span class=\"comment\"># 7</span></span><br><span class=\"line\"></span><br><span class=\"line\">floor(vector(6.5)) <span class=\"comment\"># 6</span></span><br><span class=\"line\"></span><br><span class=\"line\">round(vector(6.5)) <span class=\"comment\"># 7</span></span><br><span class=\"line\">round(vector(6.4)) <span class=\"comment\"># 6</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"clamp-函数\"><a href=\"#clamp-函数\" class=\"headerlink\" title=\"clamp() 函数\"></a>clamp() 函数</h4><p>描述: <code>clamp(v instant-vector, min scalar, max scalar)</code> 将所有元素的样本值钳制在<code>v</code>下限为<code>min</code>和上限为<code>max</code>。</p>\n<p>特殊情况： - 返回空向量 if <code>min &gt; max</code> - 返回<code>NaN</code>if<code>min</code>或<code>max</code>is<code>NaN</code></p>\n<p><br></p>\n<h4 id=\"clamp-max-函数\"><a href=\"#clamp-max-函数\" class=\"headerlink\" title=\"clamp_max() 函数\"></a>clamp_max() 函数</h4><p>描述: <code>clamp_max(v instant-vector, max scalar)</code>函数，输入一个瞬时向量和最大值，样本数据值若大于 max，则改为 max，否则不变。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_load5&#123;instance=<span class=\"string\">\"192.168.1.75:9100\"</span>&#125;               <span class=\"comment\"># 结果为 2.79</span></span><br><span class=\"line\">clamp_max(node_load5&#123;instance=<span class=\"string\">\"192.168.1.75:9100\"</span>&#125;, 2) <span class=\"comment\"># 结果为 2</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"clamp-min-函数\"><a href=\"#clamp-min-函数\" class=\"headerlink\" title=\"clamp_min() 函数\"></a>clamp_min() 函数</h4><p>描述: <code>clamp_min(v instant-vector, min scalar)</code> 函数，输入一个瞬时向量和最小值，样本数据值若小于 min，则改为 min 否则不变。</p>\n<p>例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_load5&#123;instance=<span class=\"string\">\"192.168.1.75:9100\"</span>&#125; <span class=\"comment\"># 结果为 2.79</span></span><br><span class=\"line\">clamp_min(node_load5&#123;instance=<span class=\"string\">\"192.168.1.75:9100\"</span>&#125;, 3) <span class=\"comment\"># 结果为 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 那些目标进程使用最少是10个打开文件描述符(min &lt; 值 &lt; max)</span></span><br><span class=\"line\">clamp_min(process_open_fds,10)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"192.168.1.225:9100\", job=\"linux_exporter\"&#125;\t9</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125;\t10</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"4-时间函数\"><a href=\"#4-时间函数\" class=\"headerlink\" title=\"4.时间函数\"></a>4.时间函数</h3><p>描述: Prometheus提供几个处理时间的函数，注意其完全使用UTC并没有时区的概念。</p>\n<h4 id=\"time-函数\"><a href=\"#time-函数\" class=\"headerlink\" title=\"time() 函数\"></a>time() 函数</h4><p>描述: time() 函数返回从 <code>1970-01-01</code> 到现在的秒数。注意：它不是直接返回当前时间而是时间戳.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回当前时间UTC格式</span></span><br><span class=\"line\">time()  <span class=\"comment\"># scalar 1626675614.185</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 节点开机时间</span></span><br><span class=\"line\">time() - process_start_time_seconds <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125;\t243129.00699996948</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"minute-函数\"><a href=\"#minute-函数\" class=\"headerlink\" title=\"minute() 函数\"></a>minute() 函数</h4><p>描述: <code>minute(v=vector(time()) instant-vector)</code> 函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minute(vector(time()))  <span class=\"comment\">#  50 分钟</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"hour-函数\"><a href=\"#hour-函数\" class=\"headerlink\" title=\"hour()  函数\"></a>hour()  函数</h4><p><code>hour(v=vector(time()) instant-vector)</code>以 UTC 格式返回每个给定时间的一天中的小时。返回值从 0 到 23。</p>\n<p><br></p>\n<h4 id=\"month-函数\"><a href=\"#month-函数\" class=\"headerlink\" title=\"month() 函数\"></a>month() 函数</h4><p>描述: <code>month(v=vector(time()) instant-vector)</code> 函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">month(vector(time()))   <span class=\"comment\"># 7 分钟</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"year-函数\"><a href=\"#year-函数\" class=\"headerlink\" title=\"year() 函数\"></a>year() 函数</h4><p>描述: <code>year(v=vector(time()) instant-vector)</code> 函数返回被给定 UTC 时间的当前年份。</p>\n<p>注意: 即使区间向量内的值分布不均匀，它们在聚合时的权重也是相同的。</p>\n<p>实例演示:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.查看进程是哪一年开始运行</span></span><br><span class=\"line\">year(process_start_time_seconds)  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125; 2021</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.计算本月启动的进程的时间序列</span></span><br><span class=\"line\">year(process_start_time_seconds) == bool scalar(year())  * (month(process_start_time_seconds) == bool scalar(month()))</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125; 1</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"192.168.1.225:9100\", job=\"linux_exporter\"&#125; 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.计算本月启动的进程的时间序列个数 </span></span><br><span class=\"line\">sum(year(process_start_time_seconds) == bool scalar(year())  * (month(process_start_time_seconds) == bool scalar(month())))  <span class=\"comment\"># &#123;&#125; 1</span></span><br></pre></td></tr></table></figure></p>\n<p>Tips : 乘法运算符在布尔值使用时就像<code>和</code>运算符一样值1表示真，否则为假。</p>\n<p><br></p>\n<h4 id=\"day-of-month-函数\"><a href=\"#day-of-month-函数\" class=\"headerlink\" title=\"day_of_month() 函数\"></a>day_of_month() 函数</h4><p>描述: <code>day_of_month(v=vector(time()) instant-vector)</code> 函数，返回被给定 UTC 时间所在月的第几天。返回值范围：1~31。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">day_of_month(vector(time())) <span class=\"comment\"># 19 号</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"day-of-week-函数\"><a href=\"#day-of-week-函数\" class=\"headerlink\" title=\"day_of_week() 函数\"></a>day_of_week() 函数</h4><p>描述: <code>day_of_week(v=vector(time()) instant-vector)</code> 函数，返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">day_of_week(vector(time())) <span class=\"comment\"># 1 星期天</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"days-in-month-函数\"><a href=\"#days-in-month-函数\" class=\"headerlink\" title=\"days_in_month() 函数\"></a>days_in_month() 函数</h4><p>描述: <code>days_in_month(v=vector(time()) instant-vector)</code> 函数，返回当月一共有多少天。返回值范围：28~31。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">days_in_month(vector(time())) <span class=\"comment\"># 31 当月31天</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"timestamp-函数\"><a href=\"#timestamp-函数\" class=\"headerlink\" title=\"timestamp() 函数\"></a>timestamp() 函数</h4><p>描述：<code>timestamp(v instant-vector)</code> 函数返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。</p>\n<p>该函数从 Prometheus 2.0 版本开始引入, 与其它时间函数不同的是，它查看瞬时向量中的样本的时间戳而不是值。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实例1.</span></span><br><span class=\"line\">timestamp(vector(time()))  <span class=\"comment\"># &#123;&#125; \t1629783662.714</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实例2.可以看到每个目标的最后异常抓取的开始时间。</span></span><br><span class=\"line\">timestamp(up) <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125; 1629783745.147</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实例3.返回Prometheus启动节点导出器抓取时间与节点导出器认为的当前实践的差值。</span></span><br><span class=\"line\">node_time_seconds - timestamp(node_time_seconds)  <span class=\"comment\"># &#123;instance=\"192.168.1.107:9100\", job=\"linux_exporter\"&#125; 0.0025420188903808594</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"5-标签函数\"><a href=\"#5-标签函数\" class=\"headerlink\" title=\"5.标签函数\"></a>5.标签函数</h3><h4 id=\"label-join-函数\"><a href=\"#label-join-函数\" class=\"headerlink\" title=\"label_join() 函数\"></a>label_join() 函数</h4><p>描述: 该函数允许你将标签纸连接在用，类似于在重新标记时处理souce_lables方法，同样该函数也不会删除指标名称。</p>\n<p>语法格式: <code>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</code></p>\n<p>Tips: 该函数可以将时间序列 v 中多个标签 src_label 的值，<code>通过 separator 作为连接符写入到一个新的标签 dst_label 中</code>,注意可以有多个 src_label 标签。</p>\n<p>例如，以下表达式返回的时间序列多了一个 foo 标签，标签值为 <code>etcd,etcd-k8s</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">up&#123;instance=<span class=\"string\">\"192.168.1.8:2379\"</span>,job=<span class=\"string\">\"etcd\"</span>,service=<span class=\"string\">\"etcd-k8s\"</span>&#125; =&gt; </span><br><span class=\"line\">  <span class=\"comment\"># up&#123;endpoint=\"api\",instance=\"192.168.1.8:2379\",job=\"etcd\",service=\"etcd-k8s\"&#125;  1</span></span><br><span class=\"line\">label_join(up&#123;instance=<span class=\"string\">\"192.168.1.8:2379\"</span>,job=<span class=\"string\">\"etcd\"</span>,service=<span class=\"string\">\"etcd-k8s\"</span>&#125;, <span class=\"string\">\"foo\"</span>, <span class=\"string\">\",\"</span>, <span class=\"string\">\"job\"</span>, <span class=\"string\">\"service\"</span>) =&gt; </span><br><span class=\"line\">  <span class=\"comment\"># up&#123;endpoint=\"api\",foo=\"etcd,etcd-k8s\",instance=\"192.168.13.248:2379\",job=\"etcd\",namespace=\"monitoring\",service=\"etcd-k8s\"&#125;  1</span></span><br></pre></td></tr></table></figure></p>\n<p>例如, 一个简单例子<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go_info&#123;job=<span class=\"string\">\"LocalServer\"</span>&#125;  </span><br><span class=\"line\">  <span class=\"comment\"># ==&gt; go_info&#123;instance=\"localhost:9090\", job=\"LocalServer\", version=\"go1.16.4\"&#125; 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">label_join(go_info&#123;job=<span class=\"string\">\"LocalServer\"</span>&#125;,<span class=\"string\">\"newlable\"</span>,<span class=\"string\">'|'</span>,<span class=\"string\">\"job\"</span>,<span class=\"string\">\"version\"</span>)</span><br><span class=\"line\">  <span class=\"comment\"># ==&gt; go_info&#123;instance=\"localhost:9090\", job=\"LocalServer\", newlable=\"LocalServer|go1.16.4\", version=\"go1.16.4\"&#125; 1</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"label-replace-函数\"><a href=\"#label-replace-函数\" class=\"headerlink\" title=\"label_replace() 函数\"></a>label_replace() 函数</h4><p>描述: 该函数允许你对标签值进行正则表达式替换。与大多数函数不同的是，该函数不会删除指标名称。</p>\n<p>Tips: 为了能够让客户端的图标更具有可读性，可以通过 label_replace 函数为时间序列添加额外的标签。</p>\n<p>label_replace 的具体格式参数：<code>label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)</code></p>\n<p>例如: 该函数会依次对 v 中的每一条时间序列进行处理，通过 regex 匹配 src_label 的值，并将匹配部分 relacement 写入到 dst_label 标签中。如下所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label_replace(up, <span class=\"string\">\"host\"</span>, <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>, <span class=\"string\">\"instance\"</span>,  <span class=\"string\">\"(.*):.*\"</span>)</span><br><span class=\"line\">label_replace(up&#123;job=<span class=\"string\">\"api-server\"</span>,service=<span class=\"string\">\"a:c\"</span>&#125;, <span class=\"string\">\"foo\"</span>, <span class=\"string\">\"<span class=\"variable\">$1</span>\"</span>, <span class=\"string\">\"service\"</span>, <span class=\"string\">\"(.*):.*\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>函数处理后，时间序列将包含一个 host 标签，host 标签的值为 Exporter 实例的 IP 地址：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">up&#123;host=<span class=\"string\">\"localhost\"</span>,instance=<span class=\"string\">\"localhost:8080\"</span>,job=<span class=\"string\">\"cadvisor\"</span>&#125;   1</span><br><span class=\"line\">up&#123;host=<span class=\"string\">\"localhost\"</span>,instance=<span class=\"string\">\"localhost:9090\"</span>,job=<span class=\"string\">\"prometheus\"</span>&#125;   1</span><br><span class=\"line\">up&#123;host=<span class=\"string\">\"localhost\"</span>,instance=<span class=\"string\">\"localhost:9100\"</span>,job=<span class=\"string\">\"node\"</span>&#125;   1</span><br></pre></td></tr></table></figure></p>\n<p>例如: 更简单的例子<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">up&#123;job=<span class=\"string\">\"LocalServer\"</span>&#125; </span><br><span class=\"line\"><span class=\"comment\"># ==&gt; up&#123;instance=\"localhost:9090\", job=\"LocalServer\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">label_replace(up&#123;job=<span class=\"string\">\"LocalServer\"</span>&#125;, <span class=\"string\">\"instance\"</span>, <span class=\"string\">\"<span class=\"variable\">$1</span>:9200\"</span>, <span class=\"string\">\"job\"</span>,  <span class=\"string\">\"(.*)\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># ==&gt; up&#123;instance=\"LocalServer:9200\", job=\"LocalServer\"&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"6-缺失与排序函数\"><a href=\"#6-缺失与排序函数\" class=\"headerlink\" title=\"6.缺失与排序函数\"></a>6.缺失与排序函数</h3><h4 id=\"absent-函数\"><a href=\"#absent-函数\" class=\"headerlink\" title=\"absent() 函数\"></a>absent() 函数</h4><p>描述: <code>absent(v instant-vector)</code> 该函数在多对多逻辑运算符中所述，该函数扮演not运算符的角色。</p>\n<p>即如果传递给它的向量参数具有样本数据，则返回空向量；如果传递的向量参数没有样本数据，则返回不带度量指标名称且带有标签的时间序列且样本值为1。</p>\n<p>Tips: 当监控度量指标时, 如果获取到的样本数据是空的, 使用 absent 方法对告警是非常有用的。例如：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 0.如果参数是瞬时向量选择器，它使用来自任何相等匹配器的标签。</span></span><br><span class=\"line\">absent(up)  <span class=\"comment\"># 空的瞬时矢量</span></span><br><span class=\"line\">absent(up_not_existent) <span class=\"comment\"># &#123;&#125; 1</span></span><br><span class=\"line\">absent(up_not_existent) <span class=\"comment\"># &#123;&#125; 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1.提供的向量样本数据演示</span></span><br><span class=\"line\">go_gc_duration_seconds_sum&#123;job=<span class=\"string\">\"LocalServer\"</span>&#125;         ==&gt;&gt; \t4.2270563150000005</span><br><span class=\"line\">absent(go_gc_duration_seconds_sum&#123;job=<span class=\"string\">\"LocalServer\"</span>&#125;) ==&gt;&gt;  Empty query result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.提供的向量无样本数据演示</span></span><br><span class=\"line\">prometheus_http_requests_total&#123;method=<span class=\"string\">\"get\"</span>&#125; <span class=\"comment\"># Empty query result</span></span><br><span class=\"line\">absent(prometheus_http_requests_total&#123;method=<span class=\"string\">\"get\"</span>&#125;)       =&gt; 1  <span class=\"comment\"># 返回不带度量指标名称</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.由于不存在度量指标 nonexistent，所以返回不带度量指标名称且带有标签的时间序列，且样本值为1</span></span><br><span class=\"line\">absent(nonexistent&#123;job=<span class=\"string\">\"myjob\"</span>&#125;)  =&gt; &#123;job=<span class=\"string\">\"myjob\"</span>&#125;                =&gt; 1 </span><br><span class=\"line\"><span class=\"comment\"># 正则匹配的 instance 不作为返回 labels 中的一部分</span></span><br><span class=\"line\">absent(nonexistent&#123;job=<span class=\"string\">\"myjob\"</span>,instance=~<span class=\"string\">\".*\"</span>&#125;) =&gt; &#123;job=<span class=\"string\">\"myjob\"</span>&#125; =&gt; 1</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.sum函数返回的时间序列不带有标签且没有样本数据</span></span><br><span class=\"line\">absent(sum(nonexistent&#123;job=<span class=\"string\">\"myjob\"</span>&#125;))  =&gt; &#123;&#125;  =&gt; 1</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 对于检测整个任务是从服务发现丢失中是有效的。</p>\n<p><br></p>\n<h4 id=\"histogram-quantile-函数\"><a href=\"#histogram-quantile-函数\" class=\"headerlink\" title=\"histogram_quantile() 函数\"></a>histogram_quantile() 函数</h4><p>描述: <code>histogram_quantile(φ float, b instant-vector)</code> 从 bucket 类型的向量 b 中计算 <code>φ (0 ≤ φ ≤ 1)</code> 分位数（百分位数的一般形式）的样本的最大值。该函数适用于在瞬时向量中针对单个histogram类型子项的不同桶进行查询。</p>\n<p>Tips :（有关 φ 分位数的详细说明以及直方图指标类型的使用，请参阅直方图和摘要）。向量 b 中的样本是每个 bucket 的采样点数量。每个样本的 labels 中必须要有 le 这个 label 来表示每个 bucket 的上边界，没有 le 标签的样本会被忽略。直方图指标类型自动提供带有 _bucket 后缀和相应标签的时间序列。</p>\n<ul>\n<li>例如，一个直方图指标名称为 employee_age_bucket_bucket，要计算过去 10 分钟内 第 90 个百分位数，请使用以下表达式：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">histogram_quantile(0.9, rate(employee_age_bucket_bucket[10m]))</span><br><span class=\"line\"><span class=\"comment\"># 返回：</span></span><br><span class=\"line\"><span class=\"comment\"># &#123;instance=\"10.0.86.71:8080\",job=\"prometheus\"&#125; 35.714285714285715</span></span><br></pre></td></tr></table></figure>\n这表示最近 10 分钟之内 90% 的样本的最大值为 35.714285714285715。</li>\n</ul>\n<p>Tips : 这个计算结果是每组标签组合成一个时间序列。我们可能不会对所有这些维度<code>（如 job、instance 和 method）</code>感兴趣，并希望将其中的一些维度进行聚合，则可以使用 sum() 函数</p>\n<ul>\n<li>例如，以下表达式根据 job 标签来对第 90 个百分位数进行聚合：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># histogram_quantile() 函数必须包含 le 标签</span></span><br><span class=\"line\">histogram_quantile(0.9, sum(rate(employee_age_bucket_bucket[10m])) by (job, le))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果要聚合所有的标签，则使用如下表达式：</span></span><br><span class=\"line\">histogram_quantile(0.9,sum(rate(employee_age_bucket_bucket[10m])) by (le))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Tips: 可以使用 rate() 函数来指定分位数计算的时间窗口。</p>\n<p>注意: <code>histogram_quantile</code> 这个函数是根据假定每个区间内的样本分布是线性分布来计算结果值的(也就是说它的结果未必准确)，最高的 bucket 必须是 <code>le=&quot;+Inf&quot;</code> (否则就返回 NaN)。如果分位数位于最高的 <code>bucket（+Inf）</code> 中，则返回第二个最高的 bucket 的上边界。如果该 bucket 的上边界大于 0，则假设最低的 bucket 的的下边界为 0，这种情况下在该 bucket 内使用常规的线性插值。如果分位数位于最低的 bucket 中，则返回最低 bucket 的上边界。</p>\n<p>注意: 如果 b 含有少于 2 个 buckets，那么会返回 NaN，如果 φ &lt; 0 会返回 -Inf，如果 φ &gt; 1 会返回 +Inf。</p>\n<p><br></p>\n<h4 id=\"sort-函数\"><a href=\"#sort-函数\" class=\"headerlink\" title=\"sort() 函数\"></a>sort() 函数</h4><p>描述: <code>sort(v instant-vector)</code> 函数对向量按元素的值进行升序排序，返回结果：<code>key: value = 度量指标：样本值[升序排列]</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort(node_load5&#123;&#125;)      <span class=\"comment\"># 正序</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h4 id=\"sort-desc-函数\"><a href=\"#sort-desc-函数\" class=\"headerlink\" title=\"sort_desc() 函数\"></a>sort_desc() 函数</h4><p>描述: <code>sort(v instant-vector)</code> 函数对向量按元素的值进行降序排序，返回结果：<code>key: value = 度量指标：样本值[降序排列]</code>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort_desc(node_load5&#123;&#125;) <span class=\"comment\"># 反序</span></span><br></pre></td></tr></table></figure>\n<p><br/></p>\n<h3 id=\"7-计数器\"><a href=\"#7-计数器\" class=\"headerlink\" title=\"7.计数器\"></a>7.计数器</h3><p>描述: 计数器包括 counter 类型、summary 类型和histogram类型指定中的_sum,_count,_bucket的时间序列。</p>\n<p>Tips: 计数器的值只升不降，当应用重新启动后，计数器初始化为0.</p>\n<h4 id=\"rate-函数\"><a href=\"#rate-函数\" class=\"headerlink\" title=\"rate 函数\"></a>rate 函数</h4><p>描述: <code>rate(v range-vector)</code> 函数可以直接计算区间向量 v 在时间窗口内平均增长速率，即<code>返回计数器在传入给它的范围向量中的每个时间序列每秒增加速率</code>。它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。</p>\n<p>Tips: </p>\n<ul>\n<li>1.该函数的返回结果不带有度量指标，只有标签列表。</li>\n<li>2.该函数可求得某一时间内的<code>平均率( 次数 / 指定时间秒 )</code>，而且自动处理由进程重启导致得计数器重置对其得问题。</li>\n<li>3.建议使用的范围向量的范围至少是抓取间隔的四倍，例如对于1min的抓取间隔，你可以使用4min的rate，但是通常会使用5min，rate(x_total[5m])。</li>\n</ul>\n<p><br></p>\n<p><strong>示例演示:</strong></p>\n<ul>\n<li><p>1) PromQL: <code>rate(http_requested_total[5m])</code>, 说明: 求得最后5分钟的平均每秒的请求率。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;instance=\"10.20.172.103:8000\", job=\"control\", method=\"GET\", path=\"/\"&#125;  0.003508771929824561</span><br><span class=\"line\">&#123;instance=\"10.20.172.103:8000\", job=\"control\", method=\"GET\", path=\"/api/\"&#125; 0.021052631578947368</span><br><span class=\"line\">&#123;instance=\"10.20.172.103:8000\", job=\"control\", method=\"GET\", path=\"/favicon.ico\"&#125; 0.03508771929824561</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>2) PromQL: <code>rate(prometheus_http_requests_total[5m])</code>, 例如以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的每秒增长率：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;code=\"200\",handler=\"label_values\",instance=\"120.77.65.193:9090\",job=\"prometheus\",method=\"get\"&#125; 0</span><br><span class=\"line\">&#123;code=\"200\",handler=\"query_range\",instance=\"120.77.65.193:9090\",job=\"prometheus\",method=\"get\"&#125;  0</span><br><span class=\"line\">&#123;code=\"200\",handler=\"prometheus\",instance=\"120.77.65.193:9090\",job=\"prometheus\",method=\"get\"&#125;   0.2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Tips : rate() 函数返回值类型只能用计数器，在长期趋势分析或者告警中推荐使用这个函数。</p>\n<p>注意: 当将 rate() 函数与聚合运算符（例如 sum()）或随时间聚合的函数（任何以 _over_time 结尾的函数）一起使用时，<code>必须先执行 rate 函数，然后再进行sum聚合操作</code>，否则当采样目标重新启动时 rate() 无法检测到计数器是否被重置。</p>\n<p><br></p>\n<h4 id=\"increase-函数\"><a href=\"#increase-函数\" class=\"headerlink\" title=\"increase() 函数\"></a>increase() 函数</h4><p>描述: <code>increase(v range-vector)</code> 函数是rate函数上的语法糖，例如 <code>increase(x_total[5m])</code> 等同于 <code>rate(x_total[5m] * 300)</code> 的结果乘以范围向量的时间范围其它逻辑相同。</p>\n<p>Tips: 该函数获取区间向量中的第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.该函数的鲁棒性表现之一是它们在给定整数输入时可以返回非整数结果，</span></span><br><span class=\"line\">increase(x_total[15s]) <span class=\"comment\"># 10s 为 3，但是从 10s 数据推导到15s ，在increase会产生的结构是4.5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的增长数：</span></span><br><span class=\"line\">increase(prometheus_http_requests_total&#123;job=<span class=\"string\">\"apiserver\"</span>&#125;[5m])</span><br></pre></td></tr></table></figure>\n<p>Tips: increase 的返回值类型只能是计数器类型，主要作用是增加图表和数据的可读性, 使用 rate 函数记录规则的使用率，以便持续跟踪数据样本值的变化。</p>\n<p><br></p>\n<h4 id=\"irate-函数\"><a href=\"#irate-函数\" class=\"headerlink\" title=\"irate() 函数\"></a>irate() 函数</h4><p>描述：<code>irate(v range-vector)</code> 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率（即返回一个计数器正在增加的每秒速率），多用于图形展示。</p>\n<p>Tips: irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p>\n<p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">irate(prometheus_http_requests_total&#123;job=<span class=\"string\">\"api-server\"</span>&#125;[5m])</span><br></pre></td></tr></table></figure></p>\n<p>Tips: 该函数只能用于绘制快速变化的计数器，在长期趋势分析或者告警中更推荐使用 rate 函数。因为使用 irate 函数时，速率的简短变化会重置 FOR 语句，形成的图形有很多波峰，难以阅读。</p>\n<p>Tips: 如果query_range 的步长大于抓取时间间隔，则使用irate时将跳过数据。</p>\n<p>注意: 当将<code>irate()</code>函数与<code>聚合运算符</code>（例如 sum()）或随时间聚合的函数（任何以 _over_time 结尾的函数）一起使用时，必须先执行 irate 函数，然后再进行聚合操作，否则当采样目标重新启动时 irate() 无法检测到计数器是否被重置。</p>\n<p><br></p>\n<h4 id=\"resets-函数\"><a href=\"#resets-函数\" class=\"headerlink\" title=\"resets() 函数\"></a>resets() 函数</h4><p>描述: <code>resets(v range-vector)</code> 的参数是一个区间向量（<code>返回范围向量中的每个时间序列重置次数</code>）。对于每个时间序列它都返回一个计数器重置的次数。两个连续样本之间的值的减少被认为是一次计数器重置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.显示进程的CPU时间在过去一个小时重置的次数。</span></span><br><span class=\"line\">resets(process_cpu_seconds_total[1h])</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"prom-Server\"&#125;\t0</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"8-Gauge类型处理函数\"><a href=\"#8-Gauge类型处理函数\" class=\"headerlink\" title=\"8.Gauge类型处理函数\"></a>8.Gauge类型处理函数</h3><h4 id=\"changes-函数\"><a href=\"#changes-函数\" class=\"headerlink\" title=\"changes() 函数\"></a>changes() 函数</h4><p>描述: <code>changes (v range-vector)</code>输入一个区间向量返回这个区间向量内Gauge类型每个样本数据值变化的次数<code>（瞬时向量）</code>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 例如，如果样本数据值没有发生变化则返回结果为 1</span></span><br><span class=\"line\">changes(node_load5&#123;instance=<span class=\"string\">\"192.168.1.75:9100\"</span>&#125;[1m])  <span class=\"comment\"># 结果为 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如，计算进程重启次数。</span></span><br><span class=\"line\">changes(process_start_time_seconds[1h])  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125; 0</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"deriv-函数\"><a href=\"#deriv-函数\" class=\"headerlink\" title=\"deriv() 函数\"></a>deriv() 函数</h4><p>描述: <code>deriv(v range-vector)</code> 函数用于返回<code>GuaGue</code>值的变化速度，其参数是一个区间向量返回一个瞬时向量。</p>\n<p>Tips: 它使用简单的线性回归计算区间向量 v 中各个时间序列的导数, 使用最小二乘法回归来估计范围向量中的每个时间序列的斜率。</p>\n<p>Tips: 这个函数一般只用在 Gauge 类型的时间序列上。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.根据过去一小时的样本计算每秒驻留内存的变化速度。</span></span><br><span class=\"line\">deriv(process_resident_memory_bytes[1h])  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125; 1195.152658509455</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"predict-linear-函数\"><a href=\"#predict-linear-函数\" class=\"headerlink\" title=\"predict_linear() 函数\"></a>predict_linear() 函数</h4><p>描述: <code>predict_linear(v range-vector, t scalar)</code> 函数可以预测时间序列 v 在 t 秒后的值。根据所提供范围内的数据预测未来Gauge的值。</p>\n<p>Tips: 它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。该函数的返回结果不带有度量指标，只有标签列表。</p>\n<p>例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用如下表达式：<code>predict_linear(node_filesystem_free{job=&quot;node&quot;}[2h], 4 * 3600) &lt; 0</code> 通过下面的例子来观察返回值：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">predict_linear(prometheus_http_requests_total&#123;code=<span class=\"string\">\"200\"</span>,instance=<span class=\"string\">\"120.77.65.193:9090\"</span>,job=<span class=\"string\">\"prometheus\"</span>,method=<span class=\"string\">\"get\"</span>&#125;[5m], 5)</span><br><span class=\"line\">  <span class=\"comment\"># 结果：</span></span><br><span class=\"line\">  &#123;code=<span class=\"string\">\"200\"</span>,handler=<span class=\"string\">\"query_range\"</span>,instance=<span class=\"string\">\"120.77.65.193:9090\"</span>,job=<span class=\"string\">\"prometheus\"</span>,method=<span class=\"string\">\"get\"</span>&#125;  1</span><br><span class=\"line\">  &#123;code=<span class=\"string\">\"200\"</span>,handler=<span class=\"string\">\"prometheus\"</span>,instance=<span class=\"string\">\"120.77.65.193:9090\"</span>,job=<span class=\"string\">\"prometheus\"</span>,method=<span class=\"string\">\"get\"</span>&#125;   4283.449995397104</span><br><span class=\"line\">  &#123;code=<span class=\"string\">\"200\"</span>,handler=<span class=\"string\">\"static\"</span>,instance=<span class=\"string\">\"120.77.65.193:9090\"</span>,job=<span class=\"string\">\"prometheus\"</span>,method=<span class=\"string\">\"get\"</span>&#125;   22.99999999999999</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure></p>\n<p>例如, 预测四个小时内每个文件系统剩余的可用空间量。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">predict_linear(node_filesystem_free_bytes&#123;instance=<span class=\"string\">\"192.168.1.107:9100\"</span>&#125;[1h],4 * 3600)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;device=\"/dev/mapper/ubuntu--vg-lv--0\",fstype=\"ext4\", instance=\"192.168.1.107:9100\", job=\"linux_exporter\", mountpoint=\"/\"&#125;</span></span><br><span class=\"line\">    81532763513.3</span><br><span class=\"line\"><span class=\"comment\"># 等同于</span></span><br><span class=\"line\">deriv(node_filesystem_free_bytes&#123;instance=<span class=\"string\">\"192.168.1.107:9100\"</span>&#125;[1h] * 4 * 3600) + node_filesystem_free_bytes&#123;instance=<span class=\"string\">\"192.168.1.107:9100\"</span>&#125;[1h]</span><br></pre></td></tr></table></figure></p>\n<p>这个函数一般只用在 Gauge 类型的时间序列上。</p>\n<p><br></p>\n<h4 id=\"delta-函数\"><a href=\"#delta-函数\" class=\"headerlink\" title=\"delta() 函数\"></a>delta() 函数</h4><p>描述: <code>delta(v range-vector)</code>值，其参数是一个区间向量，返回一个瞬时向量。它计算一个区间向量 v 的第一个元素和最后一个元素之间的差值。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。</p>\n<p>例如，下面的例子返回过去两小时的 CPU 温度差：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delta(node_hwmon_temp_celsius&#123;instance=<span class=\"string\">\"aiserver\"</span>&#125;[1h])</span><br><span class=\"line\">  <span class=\"comment\"># &#123;chip=\"platform_coretemp_0\", instance=\"aiserver\", job=\"K8S-weiyigeek-Prod\", sensor=\"temp1\"&#125;</span></span><br><span class=\"line\">  <span class=\"comment\"># \t-2.0338977305373644</span></span><br><span class=\"line\">  <span class=\"comment\"># &#123;chip=\"platform_coretemp_0\", instance=\"aiserver\", job=\"K8S-weiyigeek-Prod\", sensor=\"temp10\"&#125;</span></span><br><span class=\"line\">  <span class=\"comment\"># \t-2.0338977305373644</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h4 id=\"idelta-函数\"><a href=\"#idelta-函数\" class=\"headerlink\" title=\"idelta() 函数\"></a>idelta() 函数</h4><p>描述: <code>idelta(v range-vector)</code> 的参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。<br>即采用时间范围中的最后两个样本并返回它们的差异。</p>\n<p><br></p>\n<h4 id=\"holt-winters-函数\"><a href=\"#holt-winters-函数\" class=\"headerlink\" title=\"holt_winters() 函数\"></a>holt_winters() 函数</h4><p>描述: <code>holt_winters(v range-vector, sf scalar, tf scalar) 函数</code>基于区间向量 v，生成时间序列数据平滑值。平滑因子 sf 越低, 对旧数据的重视程度越高。趋势因子 tf 越高，对数据的趋势的考虑就越多。其中<code>0&lt; sf, tf &lt;=1</code>并且它只能与仪表一起使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.平滑内存使用量，平滑因子为0.1，趋势因子为0.5,该两个因数必须介于（0~1）之间。</span></span><br><span class=\"line\">holt_winters(process_resident_memory_bytes[1h],0.1,0.5)</span><br><span class=\"line\">  <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"Server\"&#125; \t167181065.43937477</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"9-lt-aggregation-gt-over-time-随时间聚合函数\"><a href=\"#9-lt-aggregation-gt-over-time-随时间聚合函数\" class=\"headerlink\" title=\"9.&lt;aggregation&gt;_over_time() 随时间聚合函数\"></a>9.<code>&lt;aggregation&gt;</code>_over_time() 随时间聚合函数</h3><p>描述: 下面的函数列表允许传入一个区间向量，它们会聚合每个时间序列的范围，并返回一个瞬时向量：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* avg_over_time(range-vector) : 区间向量内每个度量指标的平均值。</span><br><span class=\"line\">* min_over_time(range-vector) : 区间向量内每个度量指标的最小值。</span><br><span class=\"line\">* max_over_time(range-vector) : 区间向量内每个度量指标的最大值。</span><br><span class=\"line\">* sum_over_time(range-vector) : 区间向量内每个度量指标的求和。</span><br><span class=\"line\">* stddev_over_time(range-vector) : 区间向量内每个度量指标的总体标准差。</span><br><span class=\"line\">* stdvar_over_time(range-vector) : 区间向量内每个度量指标的总体标准方差。</span><br><span class=\"line\">* count_over_time(range-vector)  : 区间向量内每个度量指标的样本数据个数。</span><br><span class=\"line\">* quantile_over_time(scalar, range-vector) : 区间向量内每个度量指标的样本数据值分位数，φ-quantile (0 ≤ φ ≤ 1)，该函数适用于在范围向量中跨单个时序数据查询。</span><br></pre></td></tr></table></figure></p>\n<p>Tips : 请注意，指定间隔中的所有值在聚合中都具有相同的权重，即使这些值在整个间隔中的间隔不等。</p>\n<p><br></p>\n<h4 id=\"absent-over-time-函数\"><a href=\"#absent-over-time-函数\" class=\"headerlink\" title=\"absent_over_time() 函数\"></a>absent_over_time() 函数</h4><p>描述: <code>absent_over_time(v range-vector)</code> 如果传递给它的范围向量有任何元素则返回一个空向量，如果传递给它的范围向量没有元素，则返回一个值为 1 的 1 元素向量。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">absent_over_time(nonexistent&#123;job=<span class=\"string\">\"myjob\"</span>&#125;[1h])</span><br><span class=\"line\"><span class=\"comment\"># =&gt; &#123;job=\"myjob\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">absent_over_time(nonexistent&#123;job=<span class=\"string\">\"myjob\"</span>,instance=~<span class=\"string\">\".*\"</span>&#125;[1h])</span><br><span class=\"line\"><span class=\"comment\"># =&gt; &#123;job=\"myjob\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">absent_over_time(sum(nonexistent&#123;job=<span class=\"string\">\"myjob\"</span>&#125;)[1h:])</span><br><span class=\"line\"><span class=\"comment\"># =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><br>Tips : 在给定的指标名称和标签组合在一定时间内不存在时间序列时发出警报非常有用。</p>\n<p><br></p>\n<h4 id=\"示例演示\"><a href=\"#示例演示\" class=\"headerlink\" title=\"示例演示\"></a>示例演示</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.查看一个进程内存峰值使用量</span></span><br><span class=\"line\">max_over_time(process_resident_memory_bytes[1h]) <span class=\"comment\"># &#123;instance=\"localhost:9090\", job=\"prom-Server\"&#125; \t219848704</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.更近一步计算整个应用程序。</span></span><br><span class=\"line\">max without(instance)(max_over_time(process_resident_memory_bytes[1h]))</span><br></pre></td></tr></table></figure>\n<p>Tips: 不要在rate上使用<code>avg_over_time</code>,因为该函数返回的是瞬时而不是范围向量。</p>\n<hr>\n<h2 id=\"0x03-实际案例\"><a href=\"#0x03-实际案例\" class=\"headerlink\" title=\"0x03 实际案例\"></a>0x03 实际案例</h2><p>描述: 实际案例将会持续更新。<br><strong>基础示例:</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.显示所有节点的多个挂载点的文件系统空间大小</span></span><br><span class=\"line\">node_filesystem_size_bytes</span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_size_bytes&#123;device=\"/dev/mapper/ubuntu--vg-lv--0\", fstype=\"ext4\", instance=\"192.168.1.107:9100\", job=\"linux_exporter\", mountpoint=\"/\"&#125;  104091082752</span></span><br><span class=\"line\">  <span class=\"comment\"># node_filesystem_size_bytes&#123;device=\"/dev/sda4\", fstype=\"ext4\", instance=\"192.168.1.223:9100\", job=\"linux_exporter\", mountpoint=\"/\"&#125; 284151599104</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.指定label的name查询</span></span><br><span class=\"line\">prometheus_prometheus_http_requests_total&#123;code=<span class=\"string\">\"200\"</span>&#125;</span><br><span class=\"line\">prometheus_prometheus_http_requests_total&#123;code=<span class=\"string\">\"200\"</span>,job=<span class=\"string\">\"prometheus\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.查询指定标签的节点文件系统空间大小</span></span><br><span class=\"line\">node_filesystem_size_bytes &#123;env=<span class=\"string\">\"prod\"</span>, fstype=<span class=\"string\">\"ext4\"</span>, instance=<span class=\"string\">\"192.168.1.107:9100\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4.采用正则表达式进行匹配</span></span><br><span class=\"line\"><span class=\"comment\"># - prometheus 请求响应码在2.x和3.x以及访问路径不为/alert.*匹配到的。</span></span><br><span class=\"line\">prometheus_prometheus_http_requests_total&#123;code =~ <span class=\"string\">\"2.*|3.*\"</span>,handler !~ <span class=\"string\">\"/alert.*\"</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\"># prometheus_prometheus_http_requests_total&#123;code=\"200\", handler=\"/api/v1/label/:name/values\", instance=\"localhost:9090\", job=\"Server\"&#125; 40</span></span><br><span class=\"line\">  <span class=\"comment\"># prometheus_prometheus_http_requests_total&#123;code=\"200\", handler=\"/api/v1/labels\", instance=\"localhost:9090\", job=\"Server\"&#125; 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5.通过`[time]`来实现时间范围</span></span><br><span class=\"line\">prometheus_prometheus_http_requests_total&#123;code =~ <span class=\"string\">\"2.*|3.*\"</span>,handler=~ <span class=\"string\">\"/alert.*\"</span> ,job=<span class=\"string\">\"prometheus\"</span>&#125;[5m]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6.五分钟的cpu平均使用率</span></span><br><span class=\"line\">100 - (avg(irate(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;[5m])) * 100)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 7.可用的内存百分比</span></span><br><span class=\"line\">(node_memory_MemAvailable_bytes / (node_memory_MemTotal_bytes))* 100 </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 8.磁盘一分钟读的速率</span></span><br><span class=\"line\">irate(node_disk_reads_completed_total&#123;&#125;[1m])  </span><br><span class=\"line\">rate(prometheus_tsdb_head_samples_appended_total[5m]) <span class=\"comment\"># - 计算出 Prometheus 一分钟内每秒的平均采集数。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 9.网络五分钟的接收速率（网络流量）</span></span><br><span class=\"line\">irate(node_network_receive_bytes_total&#123;device!~<span class=\"string\">'tap.*|veth.*|br.*|docker.*|virbr*|lo*'</span>&#125;[5m])* 8</span><br><span class=\"line\">  <span class=\"comment\"># &#123;cluster=\"weiyigeek-lb-vip.k8s\", device=\"cali05e09d75aa7\", instance=\"192.168.1.225:9100\", job=\"linux_exporter\"&#125; 5476.866666666667</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"promtheus\"><a href=\"#promtheus\" class=\"headerlink\" title=\"promtheus\"></a>promtheus</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 监控实例是否正常</span></span><br><span class=\"line\">avg without()(up) &lt; 1</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"node-exporter\"><a href=\"#node-exporter\" class=\"headerlink\" title=\"node_exporter\"></a>node_exporter</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CPU 指标 # </span></span><br><span class=\"line\"><span class=\"comment\"># CPU 核心数统计</span></span><br><span class=\"line\">count without(cpu)(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\"># CPU 使用率大于90%</span></span><br><span class=\"line\">(node_load5 /ignoring(mode)  count without(cpu)(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;) * 100) &gt; 90</span><br><span class=\"line\">round(100 - ((avg by (instance,job,env)(irate(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;[5m]))) * 100)) &gt; 90</span><br><span class=\"line\"><span class=\"comment\"># 系统每个CPU模式的平均消耗</span></span><br><span class=\"line\">avg without(cpu)(rate(node_cpu_seconds_total[5m]))</span><br><span class=\"line\"><span class=\"comment\"># 所有CPU的空闲模式的时间比例</span></span><br><span class=\"line\">avg without(cpu, mode)(rate(node_cpu_seconds_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;[5m]))</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"Windows-win-exporter\"><a href=\"#Windows-win-exporter\" class=\"headerlink\" title=\"Windows (win_exporter)\"></a>Windows (win_exporter)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Windows CPU 核心数</span></span><br><span class=\"line\">count without(core)(windows_cpu_time_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Windows CPU 平均使用率大于90%</span></span><br><span class=\"line\">round (100 - ((avg without(core,mode)(irate(windows_cpu_time_total&#123;mode=<span class=\"string\">\"idle\"</span>&#125;[5m]))) * 100)) &gt; 90</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Windows Mem 平均使用率大于90%</span></span><br><span class=\"line\">round((1 - (windows_os_physical_memory_free_bytes / windows_cs_physical_memory_bytes)) * 100) &gt; 90</span><br></pre></td></tr></table></figure>","comments":true,"excerpt":"[TOC]","categories":[{"name":"monitor","path":"api/categories/monitor.json"},{"name":"kubernetes","path":"api/categories/kubernetes.json"},{"name":"OperationTools","path":"api/categories/OperationTools.json"}],"tags":[{"name":"Prometheus","path":"api/tags/Prometheus.json"}]}